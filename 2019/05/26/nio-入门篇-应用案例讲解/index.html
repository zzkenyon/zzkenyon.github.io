<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>nio-入门篇-应用案例讲解 | 黑风雅过吟</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/zzkenyon.github.io/css/style.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/zzkenyon.github.io/css/highlight.css?v=2.0.3"><link rel="Shortcut Icon" href="/zzkenyon.github.io/favicon.ico"><link rel="bookmark" href="/zzkenyon.github.io/favicon.ico"><link rel="apple-touch-icon" href="/zzkenyon.github.io/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/zzkenyon.github.io/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/zzkenyon.github.io/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">nio-入门篇-应用案例讲解</h1><a id="logo" href="/zzkenyon.github.io/.">黑风雅过吟</a><p class="description">不积跬步无以至千里</p></div><div id="nav-menu"><a href="/zzkenyon.github.io/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/zzkenyon.github.io/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/zzkenyon.github.io/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">nio-入门篇-应用案例讲解</h1><div class="post-meta"><a href="/zzkenyon.github.io/2019/05/26/nio-入门篇-应用案例讲解/#comments" class="comment-count"></a><p><span class="date">May 26, 2019</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h3 id="1-Buffer"><a href="#1-Buffer" class="headerlink" title="1. Buffer"></a>1. Buffer</h3><p>在channel中传输的是buffer中的数据，而不是buffer对象。</p>
<p>使用Buffer读写数据一般遵循以下四个步骤（buffer为读写主体）：</p>
<ol>
<li>写入数据到Buffer</li>
<li>调用flip()方法</li>
<li>从Buffer中读取数据</li>
<li>调用clear()方法或者compact()方法  </li>
</ol>
<p>说明：</p>
<ul>
<li>当向buffer写入数据时，buffer会记录下写了多少数据。一旦要读取数据，需要通过flip()方法将Buffer从写模式切换到读模式。在读模式下，可以读取之前写入到buffer的所有数据。</li>
<li>一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用clear()或compact()方法。clear()方法会清空整个缓冲区。compact()方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。<h4 id="1-1-Buffer抽象类"><a href="#1-1-Buffer抽象类" class="headerlink" title="1.1 Buffer抽象类"></a>1.1 Buffer抽象类</h4>Buffer抽象类中定义的常用方法：</li>
<li><strong>Buffer flip()</strong> flip方法将Buffer从写模式切换到读模式。调用flip()方法会将position设回0，并将limit设置成之前position的值。</li>
<li><strong>Buffer rewind()</strong> 将position设回0，所以你可以重读Buffer中的所有数据。limit保持不变，仍然表示能从Buffer中读取多少个元素（byte、char等）</li>
<li><strong>int remaining()</strong> 返回position到limit之间的元素个数（未读出元素个数）</li>
<li><strong>boolean hasRemaining()</strong> 返回是否还有未读出的数据</li>
<li><strong>boolean isReadOnly()</strong> 是否此buffer只能读出</li>
<li><strong>Buffer mark()</strong> 可以标记Buffer中的一个特定position，之后可以通过调用Buffer.reset()方法恢复到这个position。</li>
<li><strong>Buffer reset()</strong> 恢复到mark()标记的状态</li>
<li><strong>Buffer clear()</strong> 重置position、limit、capacity和mark，从读模式转换成写模式 </li>
</ul>
<p>此外Buffer还声明了几个抽象方法如下，这些方法都是在Buffer的子类中定义的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boolean hasArray();</span><br><span class="line">boolean isReadOnly();</span><br><span class="line">Object array();</span><br><span class="line">int arrayOffset();</span><br><span class="line">boolean isDirect();</span><br></pre></td></tr></table></figure></p>
<h4 id="1-2-Buffer的类型"><a href="#1-2-Buffer的类型" class="headerlink" title="1.2 Buffer的类型"></a>1.2 Buffer的类型</h4><p>Java NIO 有以下Buffer类型：</p>
<ul>
<li>ByteBuffer</li>
<li>MappedByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer </li>
</ul>
<p>这些类都是Buffer的子类，其实也是抽象类，它们在Buffer抽象类的基础上扩展了与数据类型相关的功能，下面以ByteBuffer为例介绍</p>
<p>扩展的常用方法：</p>
<ul>
<li><strong>ByteBuffer compact()</strong> 将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样，设置成capacity。</li>
<li><strong>byte get()</strong> 获取position所指的byte，并且position加1</li>
<li><strong>byte get(int index)</strong> 获取指定位置的byte</li>
<li><strong>ByteBuffer put(byte b)</strong> 将指定的byte写入buffer</li>
<li><strong>ByteBuffer put(int index,byte b)</strong> 将指定的byte写入buffer的指定位置</li>
<li>…许多的不同类型的get/put操作</li>
</ul>
<h3 id="2-Channel"><a href="#2-Channel" class="headerlink" title="2. Channel"></a>2. Channel</h3><p>Java NIO的通道类似流，但又有些不同：</p>
<ul>
<li>既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。</li>
<li>通道可以异步地读写。</li>
<li>通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入。</li>
</ul>
<p>常见的channel：</p>
<ol>
<li>FileChannel 从文件中读写数据。</li>
<li>DatagramChannel 能通过UDP读写网络中的数据。</li>
<li>SocketChannel 能通过TCP读写网络中的数据。</li>
<li>ServerSocketChannel可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。</li>
</ol>
<p>本文暂不分析具体的Channel类型，将在下一篇博文中具体阐述。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reads a sequence of bytes from this channel into the given buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Writes a sequence of bytes to this channel from the given buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure></p>
<p>注意对Channel的read和write的理解容易让人懵圈：   </p>
<ul>
<li>channel.read(buffer) 意思是Read from this channel to buffer  </li>
<li>channel.write(buffer) 意思是Write to this channel from buffer</li>
</ul>
<h3 id="3-Selector"><a href="#3-Selector" class="headerlink" title="3. Selector"></a>3. Selector</h3><ol>
<li>创建：调用Selector类的静态方法open()创建selector对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>注册通道：调用Channel的实例方法将通道注册到selector上<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key = channel.register(selector,Selectionkey.OP_READ);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>与Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。</p>
<p>register()方法的第二个参数是一个“interest集合”，意思是在Selector监听该Channel时对什么事件感兴趣。可以监听四种不同类型的事件：</p>
<ul>
<li>connect </li>
<li>accept</li>
<li>read</li>
<li>write</li>
</ul>
<p>当以上四种事件就绪的时候，会触发对应的通道事件，通道事件会被selector发现。所以，某个channel成功连接到另一个服务器称为“连接就绪”。一个server socket channel准备好接收新进入的连接称为“接收就绪”。一个有数据可读的通道可以说是“读就绪”。通道等待写数据可以说是“写就绪”。</p>
<p>这四种事件用SelectionKey的四个常量来表示：</p>
<ul>
<li>SelectionKey.OP_CONNECT</li>
<li>SelectionKey.OP_ACCEPT</li>
<li>SelectionKey.OP_READ</li>
<li>SelectionKey.OP_WRITE</li>
</ul>
<p>如果对不止一种事件感兴趣，那么可以用“位或”操作符将常量连接起来，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-1-SelectionKey"><a href="#3-1-SelectionKey" class="headerlink" title="3.1 SelectionKey"></a>3.1 SelectionKey</h4><p>当向Selector注册Channel时，register()方法会返回一个SelectionKey对象。这个对象包含了一些有用的属性：</p>
<ul>
<li>interest集合</li>
<li>ready集合</li>
<li>Channel</li>
<li>Selector</li>
<li>附件对象（可选）</li>
</ul>
<p><strong>interest集合</strong><br>可以通过SelectionKey读写interest集合，像这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = selectionKey.interestOps();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isInterestedInAccept  = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT；</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInRead    = interestSet &amp; SelectionKey.OP_READ;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInWrite   = interestSet &amp; SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，用“位与”操作interest 集合和给定的SelectionKey常量，可以确定某个确定的事件是否在interest 集合中。</p>
<p><strong>ready集合</strong><br>ready 集合是通道已经准备就绪的操作的集合，是四个常量通过‘或’运算生成的。在一次选择(Selection)之后，你会首先访问这个ready set。Selection将在下一小节进行解释。可以这样访问ready集合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int readySet = selectionKey.readyOps();</span><br></pre></td></tr></table></figure></p>
<p>可以用像检测interest集合那样的方法，来检测channel中什么事件或操作已经就绪。但是，也可以使用以下四个方法，它们都会返回一个布尔类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.isAcceptable();</span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure>
<p><strong>Channel &amp; Selector</strong><br>从SelectionKey访问Channel和Selector很简单。如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Channel  channel  = selectionKey.channel();</span><br><span class="line">Selector selector = selectionKey.selector();</span><br></pre></td></tr></table></figure></p>
<p>在程序中需要对返回的channel做类型转换  </p>
<p><strong>附件对象</strong><br>可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个给定的通道。例如，可以附加 与通道一起使用的Buffer，或是包含聚集数据的某个对象。使用方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.attach(theObject);</span><br><span class="line">Object attachedObj = selectionKey.attachment();</span><br></pre></td></tr></table></figure></p>
<p>还可以在用register()方法向Selector注册Channel的时候附加对象。如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);</span><br></pre></td></tr></table></figure></p>
<h4 id="3-2-Selector选择通道"><a href="#3-2-Selector选择通道" class="headerlink" title="3.2 Selector选择通道"></a>3.2 Selector选择通道</h4><p><strong>select()</strong></p>
<p>一旦向Selector注册了一或多个通道，就可以调用几个重载的select()方法。这些方法返回你所感兴趣的事件（如连接、接受、读或写）已经准备就绪的那些通道。换句话说，如果你对“读就绪”的通道感兴趣，select()方法会返回读事件已经就绪的那些通道。</p>
<p>三种select：</p>
<ul>
<li>int select() 阻塞方法，阻塞到至少有一个通道在注册的事件上就绪。</li>
<li>int select(long timeout) 超时返回的阻塞方法</li>
<li>int selectNow() 非阻塞方法，不管是否有通道就绪，立即返回。如果自上次select之后没有通道就绪，直接返回0</li>
</ul>
<p>方法返回的int值表示有多少通道已经就绪。亦即，自上次调用select()方法后有多少通道变成就绪状态。例如第一次调用select()方法，有一个通道变成就绪状态，返回了1，若再次调用select()方法，如果另一个通道就绪了，它会再次返回1，即使对第一个就绪的channel没有做任何操作，现在有两个就绪的通道。</p>
<p><strong>selectedKeys()</strong></p>
<p>一旦调用了select()方法，并且返回值表明有一个或更多个通道就绪了，然后可以通过调用selector的selectedKeys()方法，访问“已选择键集（selected key set）”中的就绪通道。如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br></pre></td></tr></table></figure></p>
<p>可以遍历这个已选择的键集合来访问就绪通道，像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">    SelectionKey key = iter.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">        handleAccept(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">        handleRead(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(key.isWritable() &amp;&amp; key.isValid())&#123;</span><br><span class="line">        handleWrite(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(key.isConnectable())&#123;</span><br><span class="line">        System.out.println(<span class="string">"isConnectable = true"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    iter.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意每次迭代末尾需要调用remove()。Selector不会自己从已选择键集中移除SelectionKey实例，必须在处理完通道时自己移除。下次该通道变成就绪时，Selector会再次将其放入已选择键集中。</p>
<p><strong>wakeUp()</strong></p>
<p>某个线程调用select()方法后阻塞了，即使没有通道已经就绪，也有办法让其从select()方法返回。只要让其它线程在第一个线程调用select()方法的那个对象上调用Selector.wakeup()方法即可。阻塞在select()方法上的线程会立马返回。</p>
<p>如果有其它线程调用了wakeup()方法，但当前没有线程阻塞在select()方法上，下个调用select()方法的线程会立即“醒来（wake up）”。</p>
<p><strong>close()</strong></p>
<p>用完Selector后调用其close()方法会关闭该Selector，该方法使注册到该Selector上的所有SelectionKey实例无效，通道本身并不会关闭。</p>
<h3 id="4-一个完整的案例"><a href="#4-一个完整的案例" class="headerlink" title="4. 一个完整的案例"></a>4. 一个完整的案例</h3><p>客户端程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketChannelClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        client();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">client</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        SocketChannel socketChannel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            socketChannel = SocketChannel.open();</span><br><span class="line">            socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>,<span class="number">8080</span>));</span><br><span class="line">            <span class="keyword">if</span>(socketChannel.finishConnect()) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    String info = <span class="string">"I'm "</span> + i++ + <span class="string">"-th information from client"</span>;</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                    buffer.put(info.getBytes());</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                        System.out.println(buffer);</span><br><span class="line">                        socketChannel.write(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException | InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(socketChannel!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    socketChannel.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>服务器端程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOSocketServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUF_SIZE=<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">8080</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIMEOUT = <span class="number">3000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        selector();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Selector selector = <span class="keyword">null</span>;</span><br><span class="line">        ServerSocketChannel ssc = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            ssc= ServerSocketChannel.open();</span><br><span class="line">            ssc.socket().bind(<span class="keyword">new</span> InetSocketAddress(PORT));</span><br><span class="line">            ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(selector.select(TIMEOUT) == <span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"=="</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">                    SelectionKey key = iter.next();</span><br><span class="line">                    <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                        handleAccept(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                        handleRead(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(key.isWritable() &amp;&amp; key.isValid())&#123;</span><br><span class="line">                        handleWrite(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(key.isConnectable())&#123;</span><br><span class="line">                        System.out.println(<span class="string">"isConnectable = true"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    iter.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(selector!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    selector.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ssc!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    ssc.close();<span class="comment">//关闭ServerSocketChannel</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleAccept</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel ssChannel = (ServerSocketChannel)key.channel();</span><br><span class="line">        SocketChannel sc = ssChannel.accept();</span><br><span class="line">        sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        sc.register(key.selector(), SelectionKey.OP_READ, ByteBuffer.allocateDirect(BUF_SIZE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleRead</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        SocketChannel sc = (SocketChannel)key.channel();</span><br><span class="line">        ByteBuffer buf = (ByteBuffer)key.attachment();</span><br><span class="line">        <span class="keyword">long</span> bytesRead = sc.read(buf);</span><br><span class="line">        <span class="keyword">while</span>(bytesRead&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            buf.flip();</span><br><span class="line">            <span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>)buf.get());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            buf.clear();</span><br><span class="line">            bytesRead = sc.read(buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(bytesRead == -<span class="number">1</span>)&#123;</span><br><span class="line">            sc.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleWrite</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        ByteBuffer buf = (ByteBuffer)key.attachment();</span><br><span class="line">        buf.flip();</span><br><span class="line">        SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">        <span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">            sc.write(buf);</span><br><span class="line">        &#125;</span><br><span class="line">        buf.compact();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="post-copyright"><blockquote><p>原文作者: Zhao Zhengkang</p><p>原文链接: <a href="http://yoursite.com/child/2019/05/26/nio-入门篇-应用案例讲解/">http://yoursite.com/child/2019/05/26/nio-入门篇-应用案例讲解/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/zzkenyon.github.io/tags/nio/">nio</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/zzkenyon.github.io/2019/07/31/数据库-centos安装配置MySql8.0/" class="pre">数据库-centos安装配置MySql8.0</a><a href="/zzkenyon.github.io/2019/05/20/nio-IO模型/" class="next">nio-I/O模型</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Buffer"><span class="toc-text">1. Buffer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-Buffer抽象类"><span class="toc-text">1.1 Buffer抽象类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-Buffer的类型"><span class="toc-text">1.2 Buffer的类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Channel"><span class="toc-text">2. Channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Selector"><span class="toc-text">3. Selector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-SelectionKey"><span class="toc-text">3.1 SelectionKey</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-Selector选择通道"><span class="toc-text">3.2 Selector选择通道</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-一个完整的案例"><span class="toc-text">4. 一个完整的案例</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/zzkenyon.github.io/2019/09/02/reids-总结精讲/">redis-总结精讲</a></li><li class="post-list-item"><a class="post-list-link" href="/zzkenyon.github.io/2019/09/02/redis-缓存数据库双写一致性/">redis-缓存数据库双写一致性方案解析</a></li><li class="post-list-item"><a class="post-list-link" href="/zzkenyon.github.io/2019/08/02/redis-键空间通知/">redis-键空间通知</a></li><li class="post-list-item"><a class="post-list-link" href="/zzkenyon.github.io/2019/08/01/redis-数据持久化配置/">redis-数据持久化配置</a></li><li class="post-list-item"><a class="post-list-link" href="/zzkenyon.github.io/2019/07/31/数据库-centos安装配置MySql8.0/">数据库-centos安装配置MySql8.0</a></li><li class="post-list-item"><a class="post-list-link" href="/zzkenyon.github.io/2019/05/26/nio-入门篇-应用案例讲解/">nio-入门篇-应用案例讲解</a></li><li class="post-list-item"><a class="post-list-link" href="/zzkenyon.github.io/2019/05/20/nio-IO模型/">nio-I/O模型</a></li><li class="post-list-item"><a class="post-list-link" href="/zzkenyon.github.io/2018/08/02/微信支付-异步回调通知/">微信支付异步回调通知</a></li><li class="post-list-item"><a class="post-list-link" href="/zzkenyon.github.io/2018/07/21/源码分析-会用HashMap/">源码分析-会用HashMap</a></li><li class="post-list-item"><a class="post-list-link" href="/zzkenyon.github.io/2018/05/26/并发编程-CopyOnWrite容器/">并发编程-并发容器CopyOnWriteArrayList</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/zzkenyon.github.io/tags/java编程/" style="font-size: 15px;">java编程</a> <a href="/zzkenyon.github.io/tags/linux命令/" style="font-size: 15px;">linux命令</a> <a href="/zzkenyon.github.io/tags/redis/" style="font-size: 15px;">redis</a> <a href="/zzkenyon.github.io/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/zzkenyon.github.io/tags/并发编程/" style="font-size: 15px;">并发编程</a> <a href="/zzkenyon.github.io/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/zzkenyon.github.io/tags/框架/" style="font-size: 15px;">框架</a> <a href="/zzkenyon.github.io/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/zzkenyon.github.io/tags/nio/" style="font-size: 15px;">nio</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2016/05/">五月 2016</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/zzkenyon.github.io/baidusitemap.xml">网站地图</a> |  <a href="/zzkenyon.github.io/atom.xml">订阅本站</a> |  <a href="/zzkenyon.github.io/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/zzkenyon.github.io/." rel="nofollow">Zhao Zhengkang.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/zzkenyon.github.io/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/zzkenyon.github.io/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/zzkenyon.github.io/share/css/share.css"><script type="text/javascript" src="/zzkenyon.github.io/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/zzkenyon.github.io/share/js/qrcode.js" charset="utf-8"></script></body></html>