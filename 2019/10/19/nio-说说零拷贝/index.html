<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>nio-说说零拷贝 | 黑风雅过吟</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/zzkenyon.github.io/css/style.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/zzkenyon.github.io/css/highlight.css?v=2.0.3"><link rel="Shortcut Icon" href="/zzkenyon.github.io/favicon.ico"><link rel="bookmark" href="/zzkenyon.github.io/favicon.ico"><link rel="apple-touch-icon" href="/zzkenyon.github.io/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/zzkenyon.github.io/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/zzkenyon.github.io/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">nio-说说零拷贝</h1><a id="logo" href="/zzkenyon.github.io/.">黑风雅过吟</a><p class="description">不积跬步无以至千里</p></div><div id="nav-menu"><a href="/zzkenyon.github.io/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/zzkenyon.github.io/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/zzkenyon.github.io/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">nio-说说零拷贝</h1><div class="post-meta"><a href="/zzkenyon.github.io/2019/10/19/nio-说说零拷贝/#comments" class="comment-count"></a><p><span class="date">Oct 19, 2019</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>从一个业务场景开始：从本地磁盘读取一个文件通过socket发送出去。</p>
<p>传统的I/O接口处理流程如下：读文件到应用-&gt;应用打包文件到socket-&gt;发送</p>
<ol>
<li>应用发起系统调用sys_read()（或等价的方法）请求读磁盘文件</li>
<li>系统切换到内核态，读磁盘数据到内核读缓冲区（DMA方式）</li>
<li>系统将内核读缓冲区数据拷贝到应用缓冲区（CPU拷贝），read方法返回，系统切换到用户态。</li>
<li>应用包装好数据后发起send() 系统调用</li>
<li>系统切换到内核态，将数据写入到socket缓冲区（CPU拷贝）</li>
<li>将socket缓冲区的数据发送给网络接口卡（DMA方式），网卡发出</li>
<li>send() 返回，系统切换到用户态回到应用。</li>
</ol>
<p>整个过程将经历4次上下文切换，2次CPU拷贝。</p>
<p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/java%E7%BC%96%E7%A8%8B/nio/%E8%AF%B4%E8%AF%B4%E9%9B%B6%E6%8B%B7%E8%B4%9D-%E4%BC%A0%E7%BB%9FIO%E8%BF%87%E7%A8%8B.jpg" alt="I/O过程"></p>
<h3 id="1-NIO的零拷贝"><a href="#1-NIO的零拷贝" class="headerlink" title="1. NIO的零拷贝"></a>1. NIO的零拷贝</h3><p>java.nio包中有一个TransferTo接口，专门用来发送数据，我们来看看它是怎么做的。</p>
<p>TransferTo接口调用了本地TransferTo方法，在Linux平台上将发起<strong>sendfile</strong>系统调用，执行过程如下：</p>
<ol>
<li>应用发起sendfile系统调用请求发送文件</li>
<li>系统切换到内核态，读磁盘数据到内核读缓冲区（DMA方式）</li>
<li>将内核读缓冲区的数据直接拷贝到socket缓冲区（CPU拷贝）</li>
<li>将socket缓冲区的数据发送给网络接口卡（DMA方式），网卡发出</li>
<li>系统切换到用户态回到应用</li>
</ol>
<p>整个过程经历2次上下文切换和1次CPU拷贝。</p>
<p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/java%E7%BC%96%E7%A8%8B/nio/%E8%AF%B4%E8%AF%B4%E9%9B%B6%E6%8B%B7%E8%B4%9D-nio%E8%BF%87%E7%A8%8B.jpg" alt></p>
<p>如果底层NIC（网络接口卡）支持gather操作，可以进一步减少内核中的数据拷贝。在Linux 2.4以及更高版本的内核中，socket缓冲区描述符已被修改用来适应这个需求。这种方式不但减少上下文切换，同时消除了需要CPU参与的重复的数据拷贝。</p>
<p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/java%E7%BC%96%E7%A8%8B/nio/%E8%AF%B4%E8%AF%B4%E9%9B%B6%E6%8B%B7%E8%B4%9D-nio%E8%BF%87%E7%A8%8B2.jpg" alt></p>
<p>用户这边的使用方式不变，依旧通过transferTo方法，但是方法的内部实现发生了变化：</p>
<ol>
<li><p>transferTo方法调用触发DMA引擎将文件上下文信息拷贝到内核缓冲区</p>
</li>
<li><p>数据不会被拷贝到套接字缓冲区，只有数据的描述符（包括数据位置和长度）被拷贝到套接字缓冲区。DMA 引擎直接将数据从内核缓冲区拷贝到协议引擎，这样减少了最后一次需要消耗CPU的拷贝操作。</p>
</li>
</ol>
<p>将一个文件拷贝到另一个目录，使用nio方式性能提升100%，<a href="https://github.com/zzkenyon/thinking/blob/master/nio/src/main/java/zerocopy/TransferToTest.java" target="_blank" rel="noopener">对比代码</a></p>
<h3 id="2-直接内存"><a href="#2-直接内存" class="headerlink" title="2. 直接内存"></a>2. 直接内存</h3><p>在不需要进行数据文件操作时，可以使用NIO的零拷贝。但如果既需要IO速度，又需要进行数据操作，则需要使用NIO的直接内存映射。</p>
<p>Linux提供的<strong>mmap</strong>系统调用, 它可以将一段用户空间内存映射到内核空间, 当映射成功后, 用户对这段内存区域的修改可以直接反映到内核空间；同样地， 内核空间对这段区域的修改也直接反映用户空间。正因为有这样的映射关系, 就不需要在用户态(User-space)与内核态(Kernel-space) 之间拷贝数据， 提高了数据传输的效率，这就是以内存直接映射为基础的零拷贝技术。</p>
<h4 id="2-1-直接内存的创建"><a href="#2-1-直接内存的创建" class="headerlink" title="2.1 直接内存的创建"></a>2.1 直接内存的创建</h4><p>在ByteBuffer有两个子类，HeapByteBuffer和DirectByteBuffer。前者是存在于JVM堆中的，后者是存在于Native堆中的。</p>
<p>申请堆内存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(capacity, capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>申请直接内存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="为什么使用直接内存"><a href="#为什么使用直接内存" class="headerlink" title="为什么使用直接内存"></a>为什么使用直接内存</h4><ul>
<li>对垃圾回收停顿的改善。因为full gc时，垃圾收集器会对所有分配的堆内内存进行扫描，垃圾收集对Java应用造成的影响，跟堆的大小是成正比的。过大的堆会影响Java应用的性能。如果使用堆外内存的话，堆外内存是直接受操作系统管理。这样做的结果就是能保持一个较小的JVM堆内存，以减少垃圾收集对应用的影响。full gc会回收空闲的直接内存。）</li>
<li>减少了数据从JVM拷贝到native内存的次数，在某些场景下可以提升程序I/O的性能。</li>
<li>可以突破JVM内存限制，操作更多的物理内存。</li>
</ul>
<h4 id="使用直接内存注意事项"><a href="#使用直接内存注意事项" class="headerlink" title="使用直接内存注意事项"></a>使用直接内存注意事项</h4><ul>
<li>与堆内存相比直接内存读数据快、申请慢，所以适合申请次数少，访问频繁的场合。</li>
<li>堆外内存只能通过序列化和反序列化来存储，保存对象速度比堆内存慢，不适合存储很复杂的对象。一般简单的对象或者扁平化的比较适合。</li>
<li>当直接内存不足时会触发full gc，排查full gc的时候，一定要考虑。</li>
<li>堆外内存难以控制，如果内存泄漏，那么很难排查</li>
</ul>
<h4 id="NIO的直接内存映射"><a href="#NIO的直接内存映射" class="headerlink" title="NIO的直接内存映射"></a>NIO的直接内存映射</h4><p>NIO中一个重要的类：MappedByteBuffer——java nio引入的文件内存映射方案，读写性能极高。MappedByteBuffer将文件直接映射到内存。可以映射整个文件，如果文件比较大的话可以考虑分段进行映射，只要指定文件的感兴趣部分就可以。</p>
<p>由于MappedByteBuffer申请的是直接内存，因此不受Minor GC控制，只能在发生Full GC时才能被回收，因此Java提供了DirectByteBuffer类来改善这一情况。它是MappedByteBuffer类的子类，同时它实现了DirectBuffer接口，维护一个Cleaner对象来完成内存回收。因此它既可以通过Full GC来回收内存，也可以调用clean()方法来进行回收</p>
<h4 id="NIO的直接内存映射的函数调用"><a href="#NIO的直接内存映射的函数调用" class="headerlink" title="NIO的直接内存映射的函数调用"></a>NIO的直接内存映射的函数调用</h4><p>FileChannel提供了map方法来把文件映射为内存对象：</p>
<p>MappedByteBuffer map(int mode,long position,long size);<br>可以把文件的从position开始的size大小的区域映射为内存对象，mode指出了 可访问该内存映像文件的方式</p>
<p>READ_ONLY,（只读）： 试图修改得到的缓冲区将导致抛出 ReadOnlyBufferException.(MapMode.READ_ONLY)</p>
<p>READ_WRITE（读/写）： 对得到的缓冲区的更改最终将传播到文件；该更改对映射到同一文件的其他程序不一定是可见的。 (MapMode.READ_WRITE)</p>
<p>PRIVATE（专用）： 对得到的缓冲区的更改不会传播到文件，并且该更改对映射到同一文件的其他程序也不是可见的；相反，会创建缓冲区已修改部分的专用副本。 (MapMode.PRIVATE)</p>
<blockquote>
<p>使用参数-XX:MaxDirectMemorySize=10M，可以指定DirectByteBuffer的大小最多是10M。</p>
</blockquote>
<p><a href="https://github.com/zzkenyon/thinking/blob/master/nio/src/main/java/zerocopy/MMPtest.java" target="_blank" rel="noopener">对比代码</a></p>
<p>将一个文件读入内存不做处理，与nio处理方式进行对比，直接内存处理性能提升500%</p>
</div><div class="post-copyright"><blockquote><p>原文作者: Zhao Zhengkang</p><p>原文链接: <a href="http://yoursite.com/child/2019/10/19/nio-说说零拷贝/">http://yoursite.com/child/2019/10/19/nio-说说零拷贝/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/zzkenyon.github.io/tags/nio/">nio</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/zzkenyon.github.io/2019/10/23/其他-git规范的Commit Message/" class="pre">git规范的commit message（转）</a><a href="/zzkenyon.github.io/2019/09/02/redis-缓存数据库双写一致性/" class="next">redis-缓存数据库双写一致性方案解析</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-NIO的零拷贝"><span class="toc-text">1. NIO的零拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-直接内存"><span class="toc-text">2. 直接内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-直接内存的创建"><span class="toc-text">2.1 直接内存的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么使用直接内存"><span class="toc-text">为什么使用直接内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用直接内存注意事项"><span class="toc-text">使用直接内存注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NIO的直接内存映射"><span class="toc-text">NIO的直接内存映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NIO的直接内存映射的函数调用"><span class="toc-text">NIO的直接内存映射的函数调用</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/zzkenyon.github.io/2020/04/24/MyBatis-给源码加中文注释(转)/">MyBatis-给源码加中文注释(转)</a></li><li class="post-list-item"><a class="post-list-link" href="/zzkenyon.github.io/2020/04/14/其他-CSRF攻击与防御/">CSRF攻击与防御（转）</a></li><li class="post-list-item"><a class="post-list-link" href="/zzkenyon.github.io/2020/04/07/分布式-日志上传es/">ELK日志系统</a></li><li class="post-list-item"><a class="post-list-link" href="/zzkenyon.github.io/2020/01/02/SpringCloud-服务注册、调用以及负载均衡/">SpringCloud-服务注册、调用以及负载均衡</a></li><li class="post-list-item"><a class="post-list-link" href="/zzkenyon.github.io/2020/01/02/redis-热点key问题/">redis-热key问题</a></li><li class="post-list-item"><a class="post-list-link" href="/zzkenyon.github.io/2020/01/02/mysql-innoDB架构分析/">mysql-innoDB架构分析</a></li><li class="post-list-item"><a class="post-list-link" href="/zzkenyon.github.io/2020/01/02/mysql-redo log写流程分析/">mysql-redo log写流程分析(转)</a></li><li class="post-list-item"><a class="post-list-link" href="/zzkenyon.github.io/2019/12/31/jvm-对象的内存布局/">jvm-对象的内存布局</a></li><li class="post-list-item"><a class="post-list-link" href="/zzkenyon.github.io/2019/12/31/redis-集群搭建/">reids-5.0版本的高可用集群搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/zzkenyon.github.io/2019/11/23/web-彻底理解cookie，session，token/">（转）彻底理解cookie，session，token</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/zzkenyon.github.io/tags/java/" style="font-size: 15px;">java</a> <a href="/zzkenyon.github.io/tags/MQ/" style="font-size: 15px;">MQ</a> <a href="/zzkenyon.github.io/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/zzkenyon.github.io/tags/其他/" style="font-size: 15px;">其他</a> <a href="/zzkenyon.github.io/tags/linux命令/" style="font-size: 15px;">linux命令</a> <a href="/zzkenyon.github.io/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/zzkenyon.github.io/tags/redis/" style="font-size: 15px;">redis</a> <a href="/zzkenyon.github.io/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/zzkenyon.github.io/tags/并发编程/" style="font-size: 15px;">并发编程</a> <a href="/zzkenyon.github.io/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/zzkenyon.github.io/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/zzkenyon.github.io/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/zzkenyon.github.io/tags/nio/" style="font-size: 15px;">nio</a> <a href="/zzkenyon.github.io/tags/SpringCloud/" style="font-size: 15px;">SpringCloud</a> <a href="/zzkenyon.github.io/tags/web/" style="font-size: 15px;">web</a> <a href="/zzkenyon.github.io/tags/jdk/" style="font-size: 15px;">jdk</a> <a href="/zzkenyon.github.io/tags/日志/" style="font-size: 15px;">日志</a> <a href="/zzkenyon.github.io/tags/Mybatis/" style="font-size: 15px;">Mybatis</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2016/05/">五月 2016</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/zzkenyon.github.io/baidusitemap.xml">网站地图</a> |  <a href="/zzkenyon.github.io/atom.xml">订阅本站</a> |  <a href="/zzkenyon.github.io/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/zzkenyon.github.io/." rel="nofollow">Zhao Zhengkang.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/zzkenyon.github.io/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/zzkenyon.github.io/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/zzkenyon.github.io/share/css/share.css"><script type="text/javascript" src="/zzkenyon.github.io/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/zzkenyon.github.io/share/js/qrcode.js" charset="utf-8"></script></body></html>