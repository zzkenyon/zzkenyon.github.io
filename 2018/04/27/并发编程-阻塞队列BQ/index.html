<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>并发编程-阻塞队列BQ | 黑风雅过吟</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/zzkenyon.github.io/css/style.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/zzkenyon.github.io/css/highlight.css?v=2.0.3"><link rel="Shortcut Icon" href="/zzkenyon.github.io/favicon.ico"><link rel="bookmark" href="/zzkenyon.github.io/favicon.ico"><link rel="apple-touch-icon" href="/zzkenyon.github.io/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/zzkenyon.github.io/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/zzkenyon.github.io/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">并发编程-阻塞队列BQ</h1><a id="logo" href="/zzkenyon.github.io/.">黑风雅过吟</a><p class="description">不积跬步无以至千里</p></div><div id="nav-menu"><a href="/zzkenyon.github.io/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/zzkenyon.github.io/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/zzkenyon.github.io/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">并发编程-阻塞队列BQ</h1><div class="post-meta"><a href="/zzkenyon.github.io/2018/04/27/并发编程-阻塞队列BQ/#comments" class="comment-count"></a><p><span class="date">Apr 27, 2018</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>阻塞队列常用于生产者-消费者场景。</p>
<p>BQ有4套出队入队操作：</p>
<ul>
<li>offer(e) &amp; pool() 这套操作不会阻塞线程，队列满/空的时候返回特殊值 false/null</li>
<li>add(e) &amp; remove() 该操作对offer(e) &amp; pool()返回的特殊值抛出异常</li>
<li>put(e) &amp; take() 阻塞方法，遇到队列满/空的时候会阻塞，直到收到通知可以继续执行</li>
<li>offer(e,time,unit) &amp; poll(time,unit) 超时阻塞方法，超时返回 false/null </li>
</ul>
<p>Jdk7中给出了7种BQ：</p>
<ul>
<li>ArrayBlockingQueue</li>
<li>LinkedBlockingQueue</li>
<li>priorityBlockingQueue</li>
<li>DelayQueue</li>
<li>SynchronousQueue</li>
<li>LinkenTransferQueue</li>
<li>LinkedBlockingDeque</li>
</ul>
<p>本文将以LinkedBlockingQueue为例进行源码解读</p>
<h3 id="1-Condition"><a href="#1-Condition" class="headerlink" title="1. Condition"></a>1. Condition</h3><p>任意的一个java对象，都拥有一组监视器方法（定义在Object类中），主要包括wait()、wait(long timeout)、notify()、notifyAll()方法，这些方法与sychronized关键字配合使用，可以实现等待/通知模式。Condition接口也通过平了类似Object的监视器方法，与Lock配合可以实现等待/通知模式。但是这两种方式在使用方式以及功能特性上还是有差别的：</p>
<ol>
<li>每个Object监视器只有一个等待队列，而Condition接口可以支持多个等待队列</li>
<li>当前线程释放锁进入等待状态，Object监视器在等待过程中是不相应中断的，而Condition接口是可以的</li>
<li>Object监视器不支持线程等待到将来的某个特定时间，Condition接口支持</li>
</ol>
<h4 id="1-1-Condition的原理"><a href="#1-1-Condition的原理" class="headerlink" title="1.1 Condition的原理"></a>1.1 Condition的原理</h4><p>将在另一篇中解析AQS.ConditionObject类的源码</p>
<h4 id="1-2-LBQ中的Condition"><a href="#1-2-LBQ中的Condition" class="headerlink" title="1.2 LBQ中的Condition"></a>1.2 LBQ中的Condition</h4><p>LBQ的入队和出队使用了两把重入锁，相应的也有两个条件队列notFull和notEmpty：</p>
<ul>
<li>当队列满的时候执行入队操作，入队线程会进入notFull等待，当有元素出队则通知入队线程–队列notFull，可以继续执行；</li>
<li>当队列为空执行出队操作，出队线程会进入notEmpty等待，当有元素入队后则通知出队线程–队列notEmpty，可以继续执行。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/** Lock held by take, poll, etc */</span><br><span class="line">private final ReentrantLock takeLock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">/** Wait queue for waiting takes */</span><br><span class="line">private final Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">/** Lock held by put, offer, etc */</span><br><span class="line">private final ReentrantLock putLock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">/** Wait queue for waiting puts */</span><br><span class="line">private final Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>具体如何使用的，见下文LBQ源码分析</p>
<h3 id="2-offer-e-amp-poll"><a href="#2-offer-e-amp-poll" class="headerlink" title="2. offer(e) &amp; poll()"></a>2. offer(e) &amp; poll()</h3><p>这套方法是在接口 Queue<e> 中定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">以下代码摘自： java.util.concurrent.LinkedBlockingQueue</span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    if (e == null) throw new NullPointerException();</span><br><span class="line">    final AtomicInteger count = this.count;</span><br><span class="line">    //满了直接返回失败</span><br><span class="line">    if (count.get() == capacity)</span><br><span class="line">        return false;</span><br><span class="line">    int c = -1;</span><br><span class="line">    Node&lt;E&gt; node = new Node&lt;E&gt;(e);</span><br><span class="line">    final ReentrantLock putLock = this.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (count.get() &lt; capacity) &#123;</span><br><span class="line">            enqueue(node);</span><br><span class="line">            c = count.getAndIncrement();</span><br><span class="line">            //c是更新之前的计数</span><br><span class="line">            if (c + 1 &lt; capacity)</span><br><span class="line">                //更新之后还未满，唤醒一个入队线程</span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    if (c == 0)</span><br><span class="line">        //更新之前是空的，更新完就不空了，唤醒一个阻塞的出队线程</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    return c &gt;= 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></e></p>
<p>offer(e)方法总结：  </p>
<ol>
<li>开始先检查参数是否为null，null则抛出NPE异常；</li>
<li>然后判断队列是否已经满了，满了直接返回false；</li>
<li>以上检查都通过，构造新节点，获取入队锁putLock</li>
<li>二重检查，判断队列是否未满，如果未满执行入队，计数器加1，如果计数器更新之后还小于capacity，则唤醒一个入队线程(如果有入队线程阻塞)</li>
<li>最后判断一下该线程入队前是否为空队列，如果之前是空的，入队完成就可以唤醒一个阻塞的出队线程。</li>
<li>最后入队成功返回true<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public E poll() &#123;</span><br><span class="line">    final AtomicInteger count = this.count;</span><br><span class="line">    if (count.get() == 0)</span><br><span class="line">        return null;</span><br><span class="line">    E x = null;</span><br><span class="line">    int c = -1;</span><br><span class="line">    final ReentrantLock takeLock = this.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (count.get() &gt; 0) &#123;</span><br><span class="line">            x = dequeue();</span><br><span class="line">            c = count.getAndDecrement();</span><br><span class="line">            if (c &gt; 1)</span><br><span class="line">                notEmpty.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125; </span><br><span class="line">    if (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>poll()方法总结：  </p>
<ol>
<li>首先检查队列是否空，若空直接返回null，不空继续执行；</li>
<li>获取出队锁takelock</li>
<li>二重检查，检查队列是否不空，不空执行出队，计数器减1，计数器更新之后还大于0(出队后队列还不空)，唤醒一个出队线程（如果有阻塞的出队线程）</li>
<li>释放锁，然后判断此次出队前队列是否满的，若出队前满则此次出队结束就有余位了，唤醒一个阻塞入队线程执行</li>
</ol>
<h3 id="3-add-e-amp-remove"><a href="#3-add-e-amp-remove" class="headerlink" title="3. add(e) &amp; remove()"></a>3. add(e) &amp; remove()</h3><p>这套方法也是在 Queue<e> 中定义，add方法继承自Collection接口，内部调用了offer(e) &amp; pool()，对队空或队满返回的特殊值做异常处理，队满执行入队操作抛 IllegalStateException 异常；队空做出队操作抛 NoSuchElementException 异常 。源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">以下代码摘自： java.util.AbstractQueue</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    if (offer(e))</span><br><span class="line">        return true;</span><br><span class="line">    else</span><br><span class="line">        throw new IllegalStateException(&quot;Queue full&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E remove() &#123;</span><br><span class="line">    E x = poll();</span><br><span class="line">    if (x != null)</span><br><span class="line">        return x;</span><br><span class="line">    else</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></e></p>
<h3 id="4-put-e-amp-take"><a href="#4-put-e-amp-take" class="headerlink" title="4. put(e) &amp; take()"></a>4. put(e) &amp; take()</h3><p>这是阻塞接口，定义在 BlockingQueue<e> 接口中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">以下代码摘自： java.util.concurrent.LinkedBlockingQueue</span><br><span class="line">public void put(E e) throws InterruptedException &#123;</span><br><span class="line">    if (e == null) throw new NullPointerException();</span><br><span class="line">    // 除非设置，否则保持计数器的值为-1表示失败</span><br><span class="line">    int c = -1;</span><br><span class="line">    Node&lt;E&gt; node = new Node&lt;E&gt;(e);</span><br><span class="line">    final ReentrantLock putLock = this.putLock;</span><br><span class="line">    final AtomicInteger count = this.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        //这里使用while进行判断，是因为await的线程被唤醒时从await返回，需要再进行一次判断</span><br><span class="line">        //如果使用if的话就直接往下运行了，运行结果会不稳定。</span><br><span class="line">        while (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(node);</span><br><span class="line">        //返回旧的计数然后计数+1</span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        //入队之后如果还有位置，给notFull队列发信号，唤醒put线程</span><br><span class="line">        if (c + 1 &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    //这个c是入队之前的计数，入队之前为空，入队后有元素了，所以要唤醒一个出队线程</span><br><span class="line">    if (c == 0)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></e></p>
<p>put(e)方法总结：  </p>
<ol>
<li>检查参数为空抛NPE异常</li>
<li>使用参数构造新节点，获取入队锁putLock</li>
<li>当队满时，调用 notFull.await() 阻塞当前线程，注意此处使用while语句进行判断，原因后文分析。</li>
<li>队不满执行入队，计数器 +1</li>
<li>判断计数器更新后队是否未满，未满则唤醒阻塞的入队线程（如果存在的话）</li>
<li>解锁</li>
<li>判断此次入队前是否为空队列，如果是，此次入队完成就不是了，唤醒一个阻塞的出队线程。</li>
<li>无返回值</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">    E x;</span><br><span class="line">    int c = -1;</span><br><span class="line">    final AtomicInteger count = this.count;</span><br><span class="line">    final ReentrantLock takeLock = this.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();//1</span><br><span class="line">    try &#123;</span><br><span class="line">        while (count.get() == 0) &#123;//2</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();//3</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        if (c &gt; 1)//4</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        takeLock.unlock();//5</span><br><span class="line">    &#125;</span><br><span class="line">    if (c == capacity)//6</span><br><span class="line">        signalNotFull();</span><br><span class="line">    return x;//7</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>take()方法总结：  </p>
<ol>
<li>获取出队锁takeLock</li>
<li>判断队列是否为空，为空就调用notEmpty.await()阻塞线程</li>
<li>不空就执行出队操作，计数器 -1</li>
<li>如果出队后队列仍然不空，唤醒一个阻塞的出队线程（如果存在的话）</li>
<li>解锁</li>
<li>若此次出队之前队列满，执行完本次出队就不满了，可以唤醒一个入队线程</li>
<li>返回出队的元素</li>
</ol>
<h3 id="5-offer-e-time-unit-amp-poll-time-unit"><a href="#5-offer-e-time-unit-amp-poll-time-unit" class="headerlink" title="5. offer(e,time,unit) &amp; poll(time, unit)"></a>5. offer(e,time,unit) &amp; poll(time, unit)</h3><p>超时阻塞方法，定义在 BlockingQueue<e> 接口中，该组方法在put/take的基础上加上了超时返回的功能，出队超时返回null，入队超时返回false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">以下代码摘自： java.util.concurrent.LinkedBlockingQueue</span><br><span class="line">public boolean offer(E e, long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (e == null) throw new NullPointerException();</span><br><span class="line">    long nanos = unit.toNanos(timeout);//1</span><br><span class="line">    int c = -1;</span><br><span class="line">    final ReentrantLock putLock = this.putLock;</span><br><span class="line">    final AtomicInteger count = this.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        while (count.get() == capacity) &#123;</span><br><span class="line">            if (nanos &lt;= 0)//超时了</span><br><span class="line">                return false;</span><br><span class="line">            //没超时阻塞，nanos之后自动唤醒</span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">            //唤醒后返回到这里，继续while循环判断队列是否满，还是满就妥妥的超时了</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(new Node&lt;E&gt;(e));</span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        if (c + 1 &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    if (c == 0)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E poll(long timeout, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">    E x = null;</span><br><span class="line">    int c = -1;</span><br><span class="line">    long nanos = unit.toNanos(timeout);</span><br><span class="line">    final AtomicInteger count = this.count;</span><br><span class="line">    final ReentrantLock takeLock = this.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        while (count.get() == 0) &#123;</span><br><span class="line">            if (nanos &lt;= 0)//超时了</span><br><span class="line">                return null;</span><br><span class="line">            //没超时阻塞，nanos之后自动唤醒</span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">            //唤醒后返回到这，继续为了循环判断队列是否为空，还是为空妥妥的超时</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        if (c &gt; 1)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    if (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></e></p>
<h3 id="6-await之前的判断为什么用while"><a href="#6-await之前的判断为什么用while" class="headerlink" title="6. await之前的判断为什么用while"></a>6. await之前的判断为什么用while</h3><p>用put作为例子解释一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">putLock.lockInterruptibly();</span><br><span class="line">try &#123;</span><br><span class="line">    while (count.get() == capacity) &#123;</span><br><span class="line">        notFull.await();//1</span><br><span class="line">    &#125;</span><br><span class="line">    enqueue(node);</span><br><span class="line">    c = count.getAndIncrement(); //2</span><br><span class="line">    if (c + 1 &lt; capacity)</span><br><span class="line">        notFull.signal();//3</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    putLock.unlock();//4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>假设A线程入队操作结束后(执行到2位置)，队列还剩一个空位，那么程序会唤醒阻塞队列中的put线程（3位置）B线程</li>
<li>B线程从await返回前需要竞争put锁（await会释放锁），但这时候有个C线程也来竞争put锁并且成功，C执行入队之后队列已经满了</li>
<li>C释放锁之后B获得锁，从await返回（位置1），如果这里使用 if 判断，1位置之后继续向下执行入队操作，显然会出错，因为最后一个空位让C线程用掉了</li>
<li>但是使用 while 判断，await返回之后，还在循环体内，继续循环判断队列是否满，发现满了，再次await。</li>
</ol>
<p>所以使用while判断其实是在这里进行了一次 double check， 不管是使用await还是wait，都需要while进行判断，不然在多线程环境中就会出错。</p>
<h3 id="7-其他方法"><a href="#7-其他方法" class="headerlink" title="7. 其他方法"></a>7. 其他方法</h3><ul>
<li>peek() 返回头结点，队列空返回null</li>
<li>element() 调用peak()，peak()返回null则抛异常 NoSuchElementException</li>
<li>remove(o) 移除指定的元素，参数接受null，若没找到该元素返回false</li>
<li>contains(o) 判断是否包含指定元素，参数为空或不包含返回false</li>
<li>remainingCapacity() 返回剩余容量</li>
<li>size() 返回现有元素数量</li>
<li>clear() 原子性的清除所有元素</li>
<li>drainTo(c) 将队列中的元素放到集合c中，返回转换的元素个数</li>
</ul>
</div><div class="post-copyright"><blockquote><p>原文作者: Zhao Zhengkang</p><p>原文链接: <a href="http://yoursite.com/child/2018/04/27/并发编程-阻塞队列BQ/">http://yoursite.com/child/2018/04/27/并发编程-阻塞队列BQ/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/zzkenyon.github.io/tags/并发编程/">并发编程</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/zzkenyon.github.io/2018/05/03/并发编程-ThreadLocal原理/" class="pre">并发编程-ThreadLocal原理</a><a href="/zzkenyon.github.io/2018/04/25/并发编程-共享式AQS源码详解/" class="next">并发编程-共享式AQS源码详解</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Condition"><span class="toc-text">1. Condition</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-Condition的原理"><span class="toc-text">1.1 Condition的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-LBQ中的Condition"><span class="toc-text">1.2 LBQ中的Condition</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-offer-e-amp-poll"><span class="toc-text">2. offer(e) &amp; poll()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-add-e-amp-remove"><span class="toc-text">3. add(e) &amp; remove()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-put-e-amp-take"><span class="toc-text">4. put(e) &amp; take()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-offer-e-time-unit-amp-poll-time-unit"><span class="toc-text">5. offer(e,time,unit) &amp; poll(time, unit)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-await之前的判断为什么用while"><span class="toc-text">6. await之前的判断为什么用while</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-其他方法"><span class="toc-text">7. 其他方法</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/zzkenyon.github.io/2019/05/26/nio-入门篇-应用案例讲解/">nio-入门篇-应用案例讲解</a></li><li class="post-list-item"><a class="post-list-link" href="/zzkenyon.github.io/2018/07/21/源码分析-会用HashMap/">源码分析-会用HashMap</a></li><li class="post-list-item"><a class="post-list-link" href="/zzkenyon.github.io/2018/05/26/并发编程-CopyOnWrite容器/">并发编程-并发容器CopyOnWriteArrayList</a></li><li class="post-list-item"><a class="post-list-link" href="/zzkenyon.github.io/2018/05/25/并发编程-ConcurrentHashMap源码分析/">并发编程-ConcurrentHashMap源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/zzkenyon.github.io/2018/05/17/并发编程-并发工具类/">并发编程-并发工具类</a></li><li class="post-list-item"><a class="post-list-link" href="/zzkenyon.github.io/2018/05/15/并发编程-线程池源码详解/">并发编程-线程池源码详解</a></li><li class="post-list-item"><a class="post-list-link" href="/zzkenyon.github.io/2018/05/03/并发编程-ThreadLocal原理/">并发编程-ThreadLocal原理</a></li><li class="post-list-item"><a class="post-list-link" href="/zzkenyon.github.io/2018/04/27/并发编程-阻塞队列BQ/">并发编程-阻塞队列BQ</a></li><li class="post-list-item"><a class="post-list-link" href="/zzkenyon.github.io/2018/04/25/并发编程-共享式AQS源码详解/">并发编程-共享式AQS源码详解</a></li><li class="post-list-item"><a class="post-list-link" href="/zzkenyon.github.io/2018/04/23/nginx入门/">nginx入门</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/zzkenyon.github.io/tags/java编程/" style="font-size: 15px;">java编程</a> <a href="/zzkenyon.github.io/tags/linux命令/" style="font-size: 15px;">linux命令</a> <a href="/zzkenyon.github.io/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/zzkenyon.github.io/tags/并发编程/" style="font-size: 15px;">并发编程</a> <a href="/zzkenyon.github.io/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/zzkenyon.github.io/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/zzkenyon.github.io/tags/spring/" style="font-size: 15px;">spring</a> <a href="/zzkenyon.github.io/tags/源码分析/" style="font-size: 15px;">源码分析</a> <a href="/zzkenyon.github.io/tags/转载/" style="font-size: 15px;">转载</a> <a href="/zzkenyon.github.io/tags/nio/" style="font-size: 15px;">nio</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zzkenyon.github.io/archives/2016/05/">五月 2016</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/zzkenyon.github.io/baidusitemap.xml">网站地图</a> |  <a href="/zzkenyon.github.io/atom.xml">订阅本站</a> |  <a href="/zzkenyon.github.io/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/zzkenyon.github.io/." rel="nofollow">Zhao Zhengkang.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/zzkenyon.github.io/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/zzkenyon.github.io/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/zzkenyon.github.io/share/css/share.css"><script type="text/javascript" src="/zzkenyon.github.io/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/zzkenyon.github.io/share/js/qrcode.js" charset="utf-8"></script></body></html>