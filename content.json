{"meta":{"title":"黑风雅过吟","subtitle":"不积跬步无以至千里","description":null,"author":"Zhao Zhengkang","url":"http://zzkenyon.github.io"},"pages":[{"title":"about","date":"2019-05-23T07:59:58.000Z","updated":"2019-05-23T07:59:58.731Z","comments":true,"path":"about/index.html","permalink":"http://zzkenyon.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"源码分析-会用HashMap","slug":"源码分析-会用HashMap","date":"2018-07-21T12:41:36.000Z","updated":"2019-05-23T02:57:29.493Z","comments":true,"path":"2018/07/21/源码分析-会用HashMap/","link":"","permalink":"http://zzkenyon.github.io/2018/07/21/源码分析-会用HashMap/","excerpt":"","text":"一个问题引发的思考如果确定只装载100个元素，new HashMap(?)多少是最佳的，why？要弄解答这个问题，第一要知道HashMap的数据结构，第二再弄明白存取数据的逻辑。 1.首先，我是一个数组HashMap本质上是一个数组，数组的每个元素是一个单链表或者红黑树，由0个或多个节点组成。java源码中的定义如下： 1transient Node&lt;K,V&gt;[] table; 1.1节点类Node&lt;K,V&gt;Node类是HashMap的一个静态内部类，可以将其看成是一个独立的类，只是声明在HashMap类内部而已。下面是源码： 123456789101112131415161718192021222324252627282930313233343536373839static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;//Entry是Map接口中的一个内部接口 final int hash;//此节点的哈希值，同一个链表上的哈希值不一定相同 final K key;//键，不能修改 V value;//值 Node&lt;K,V&gt; next;//指向下一个节点 Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + &quot;=&quot; + value; &#125; public final int hashCode() &#123;//此Node类的hashCode方法 return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123;//重新设置节点Value，返回旧Value V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123;//判断节点相等的方法， if (o == this)//同一个对象，返回true return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true;//键和值都相等则返回true &#125; return false; &#125;&#125; 1.2为啥有链表还有树为了提高查询效率，当链表的长度达到阈值的时候会自动将链表树形化，源码中的三个阈值常量如下： 123static final int TREEIFY_THRESHOLD = 8;static final int UNTREEIFY_THRESHOLD = 6;static final int MIN_TREEIFY_CAPACITY = 64; TREEIFY_THRESHOLD 树形化阈值：当链表长度超过这个值的时候，将链表进行树形化改造 UNTREEIFY_THRESHOLD 链表化阈值：当节点数低于这个阈值，将红黑树改造成链表。这个值必须必树形化阈值小，避免频繁的转换。 MIN_TREEIFY_CAPACITY 最小树形化容量：当数组table的长度低于这个值，即使元素链表的长度超过树形化阈值，也不会进行树形化改造，而是对table进行扩容。这个值不能小于4*TREEIFY_THRESHOLD 2.怎么进行数据的存取呢2.1hash方法拿到一个&lt;Key,Value&gt;，要存在table的哪个位置呢，这就需要用hash方法来决定了。。。从代码说起： 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; key.hashCode()函数调用的是key键值类型自带的哈希函数（与HashMap的hashCode()函数不是同一个），它返回一个32位int类型的散列值。 考虑到hash值得取值范围太大，不可能创建一个如此大的hash table，因此定位到table的位置只使用hash值的后几位（具体位数与table长度有关）。 如果只取后几位，碰撞会比较严重，因此就有了扰动函数，将hash值右移16位（高16位移到低16位），再与自身亦或，得到的结果混合了原hash值得高位和低位，以此来加大低位的随机性。 2.2定位最终得到的hash值，将由低位进行定位，定位操作如下：12n = tab.lengthtab[(n - 1) &amp; hash] 数组长度必为2的整数次幂，因此(n-1)相当于低位掩码，与h进行与操作，保留h低位，掩盖高位。 这里不做取余，是因为取余可能为负数（hashCode为负数的时候） 不对取余进行模运算，是因为最大的整数Math.abs()会返回负值 由此可知，对于HashMap的同一个链表的各个节点key值得hash值不一定相同（只是低位相同） 2.3扩容(resize)默认容量是1616是2的整数次幂的原因，在小数据量的情况下16比15或20更能减少key之间的碰撞，而加快查询的效率。 容量是15会怎样？当数组长度为15的时候，hashcode的值会与14（1110）进行“与”，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率（hash不均匀），降低了查询的效率！所以，在存储大容量数据的时候，最好预先指定hashmap的size为2的整数次幂次方。就算不指定的话，也会以大于且最接近指定值大小的2次幂来初始化的，代码如下(HashMap的构造方法中)：123int capacity = 1; while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; //乘以2 什么时候扩容&amp;怎么扩容当hashmap中的元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对hashmap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，所以这是一个通用的操作，很多人对它的性能表示过怀疑，不过想想我们的“均摊”原理，就释然了，而在hashmap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。那么hashmap什么时候进行扩容呢？当hashmap中的元素个数超过数组大小length x loadFactor时，就会进行数组扩容，==loadFactor的默认值为0.75==，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过16x0.75=12的时候，就把数组的大小扩展为2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以++如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能++。 回到开篇的问题当有100个元素new HashMap(100), 但是理论上来讲new HashMap(128)更合适，不过上面已经说过，即使是100，hashmap也自动会将其设置为128。 但是new HashMap(128)还不是更合适的，因为0.75x100 &lt; 100, 也就是说为了让0.75 x size &gt; 100, 我们必须这样new HashMap(256)才最合适，既考虑了&amp;的问题，也避免了resize的问题。 3.可以使用自定义的类作为key的类型吗可以，但是必须改写key类型的hashcode与equals方法首先计算key的hashcode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。所以，hashcode与equals方法对于找到对应元素是两个关键方法。Hashmap的key可以是任何类型的对象，例如User这种对象，为了保证两个具有相同属性的user的hashcode相同，我们就需要改写hashcode方法，比方把hashcode值的计算与User对象的id关联起来，那么只要user对象拥有相同id，那么他们的hashcode也能保持一致了，这样就可以找到在hashmap数组中的位置了。如果这个位置上有多个元素，还需要用key的equals方法在对应位置的链表中找到需要的元素，所以只改写了hashcode方法是不够的，equals方法也是需要改写滴~当然啦，按正常思维逻辑，equals方法一般都会根据实际的业务内容来定义，例如根据user对象的id来判断两个user是否相等。 参考链接深入理解HashMapHashMap详解","categories":[],"tags":[{"name":"源码分析","slug":"源码分析","permalink":"http://zzkenyon.github.io/tags/源码分析/"}],"keywords":[]},{"title":"并发编程-线程池源码详解","slug":"并发编程-线程池源码详解","date":"2018-05-15T03:28:21.000Z","updated":"2019-05-23T08:09:31.265Z","comments":true,"path":"2018/05/15/并发编程-线程池源码详解/","link":"","permalink":"http://zzkenyon.github.io/2018/05/15/并发编程-线程池源码详解/","excerpt":"","text":"阿里巴巴Java手册有一条：【强制】线程资源必须通过线程池提供，禁止在应用程序中显示创建线程。说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程导致消耗完内存或者过度切换的问题。 简单来说使用线程池有以下几个目的： 避免频繁的创建。线程是稀缺资源。 解耦。线程的创建与执行分开，方便维护。 线程资源复用。 1. 线程池原理本文从线程池的创建开始说起，跟着源码分析一下线程池的工作原理，本文源码基于JDK1.8 1.1 ExecutorsExecutors有一个私有的默认构造函数，不能实例化，是一个工具类，主要用于提供各种类型线程池创建的静态方法。提供的静态创建方法有： newSingleThreadExecutor 创建一个执行器，该执行器使用一个工作线程操作一个无界队列。(但是请注意，如果这个线程在关闭之前的执行过程中由于失败而终止，那么如果需要执行后续任务，将会有一个新的线程代替它。与 newFixedThreadPool(1)不同，返回的executor不能被其他线程重新配置。 newFixedThreadPool 创建一个线程池，该线程池重用固定数量的线，如果任何线程在关闭之前的执行过程中由于失败而终止，那么如果需要执行后续任务，则会替换一个新线程。池中的线程将一直存在，直到显式关闭为止操作一个共享的无界队列。 newWorkStealingPool 创建一个线程池，该线程池维护足够的线程以支持给定的并行度级别，并且可以使用多个队列来减少争用。并行度级别对应于积极参与或可用参与任务处理的线程的最大数量。线程的实际数量可以动态地增长和收缩。工作窃取池不能保证所提交任务的执行顺序。 newCachedThreadPool 创建一个线程池，该线程池根据需要创建新线程，但在可用时将重用以前构造的线程。这些池通常会提高执行许多短期异步任务的程序的性能。如果可用，对execute的调用将重用以前构造的线程。如果没有可用的现有线程，将创建一个新线程并将其添加到池中。未使用60秒的线程将被终止并从缓存中删除。因此，长时间空闲的池不会消耗任何资源。注意，可以使用ThreadPoolExecutor构造函数创建具有相似属性但不同细节(例如超时参数)的池。 newSingleThreadScheduledExecutor 创建一个单线程执行器，该执行器可以安排命令在给定的延迟之后运行，或者定期执行。(但是请注意，如果这个线程在关闭之前的执行过程中由于失败而终止，那么如果需要执行后续任务，将会有一个新的线程代替它。)，与 newFixedThreadPool(1)不同，返回的executor不能被其他线程重新配置。 newScheduledThreadPool 创建一个线程池，该线程池可以在给定延迟之后调度命令运行，或者定期执行命令。 Executors 返回的线程池对象的弊端如下： FixedThreadPool 和 SingleThreadPool: 允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。 CachedThreadPool 和 ScheduledThreadPool: 允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。 1.2 ThreadPoolExecutor首先看一下newFixedThreadPool创建方法的源码：12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 事实上，大多数类型的线程池创建都是调用new ThreadPoolExecutor(…)创建一个ThreadPoolExecutor对象，只不过初始化参数不同而已。newWorkStealingPool创建时构造的是ForkJoinPool对象，本文不述。 下面是ThreadPoolExecutor的其中一个构造方法：123456789public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; ...&#125; 初始化参数的如下： corePoolSize 表示线程池的核心数,线程池保持alive状态的线程数，即使线程是空闲的。 maximumPoolSize 表示线程池支持的最大的线程个数。 keepAliveTime 表示池中线程空闲后的生存时间 unit 表示上一个时间参数的单位 workQueue 用于存放任务的阻塞队列 threadFactory 表示创建线程的工厂，一般使用默认的线程创建工厂Excutors.DefaultThreadFactor() handler 当队列和最大线程池都满了之后的饱和策略，一般使用默认的handler—AbortPolicy（内部类） 1234567891011121314151617代码摘自：java.util.concurrent.ThreadPoolExecutorprivate static final RejectedExecutionHandler defaultHandler = new AbortPolicy();public static class AbortPolicy implements RejectedExecutionHandler &#123; public AbortPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; throw new RejectedExecutionException(&quot;Task &quot; + r.toString() + &quot; rejected from &quot; + e.toString()); &#125;&#125;final void reject(Runnable command) &#123; handler.rejectedExecution(command, this);&#125; 用户也可以自己实现RejectedExecutionHandler接口定义一个handler，当提交的任务因为各种原因被线程池拒绝，就会调用rejectedExecution方法。 1.2.1 excute()使用线程池时，通常我们用1threadPool.execute(new Job()); 这样的方式提交一个任务到线程池中，所以线程池ThreadPoolExecutor的核心逻辑就是execute()函数了，这个方法是在Excutor接口中声明。 在分析核心逻辑之前，先了解一下线程池重定义的状态，这些状态都和线程的执行密切相关 1234567891011121314代码摘自：java.util.concurrent.ThreadPoolExecutorprivate static final int COUNT_BITS = Integer.SIZE - 3;private static final int CAPCITY = (1 &lt;&lt; COUNT_BITS) - 1;private static final int RUNNING = -1 &lt;&lt; COUNT_BITS;private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;private static final int STOP = 1 &lt;&lt; COUNT_BITS;private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS;private static int runStateOf(int c)&#123;return c &amp; ~CAPCITY;&#125;private static int workerCountOf(int c)&#123;return c &amp; CAPCITY;&#125;private static int ctlOf(int rs, int wc)&#123;return rs | wc;&#125; 分析上面的代码得到下表：常量名| 二进制—|—CAPCITY | 0001 1111 1111 1111 1111 1111 1111 1111RUNNING | 1110 0000 0000 0000 0000 0000 0000 0000SHUTDOWN | 0000 0000 0000 0000 0000 0000 0000 0000STOP | 0010 0000 0000 0000 0000 0000 0000 0000TIDYING | 0100 0000 0000 0000 0000 0000 0000 0000TERMINATED | 0110 0000 0000 0000 0000 0000 0000 0000 由上表可以看出，原子对象ctl的前三位表示状态，后29位记录池中worker的个数，CAPCITY就像是一个掩码，通过掩码可以快速的从ctl中获得当前线程池的运行状态和池中的worker个数。 JDK1.8的并发包中不再通过设置阻塞队列的长度来限制任务的提交。阻塞队列的长度初始化之后就不能改变，因此如果担心阻塞队列太大导致内存占用太多，可以从两方面入手：1、初始化的时候选择合适的阻塞队列大小；2、调高corePoolSize或maxmumPoolSize加快任务的处理速度。参数的动态调整见下文。 线程池状态简述： RUNNING 是运行状态，指可以接受任务，执行队列里的任务。 SHUTDOWN 是指调用了shutdown()函数，不再接受新任务，但是会把队列里的任务执行完毕。 STOP 是指调用了shutdownNow()函数，不再接受新任务，同时终端正在执行的任务并丢弃队列中的待执行任务。 TIDYING 指所用任务都执行完毕。 TERMINATED 终止状态，在调用shutdown()/shutdownNow()中都会尝试更新这个状态。 下面分析核心代码excute()方法1234567891011121314151617181920212223242526代码摘自：java.util.concurrent.ThreadPoolExecutorpublic void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); //1、获取当前线程池的状态 int c = ctl.get(); //2、当线程数量小于corePoolSize，创建新线程运行 if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; //3、如果线程池处于运行状态，并且写入阻塞队列成功 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); //4、双重检查，再次获取线程状态；如果线程池状态改变（非运行状态），需要从阻塞队列移除任务，并执行拒绝策略 if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); //5、如果第二次检查通过，判断当前池是否为空，为空就创建新线程并执行 else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; //6、如果第一次检查不通过（线程池不处于运行状态或者任务写入队列失败），尝试新建线程，如果失败则执行拒绝策略 else if (!addWorker(command, false)) reject(command);&#125; 下图表示了当有任务提交到线程池后线程池的处理流程： 1.2.2 addWorker()addWorker函数是excute函数的核心逻辑—创建线程执行任务123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475代码摘自：java.util.concurrent.ThreadPoolExecutorprivate final ReentrantLock mainLock = new ReentrantLock();private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); //状态为 RUNNING 继续往下执行 //状态为不为RUNNING时，如果状态为SHUTDOWN并且firstTask为null并且阻塞队列空时，可继续向下运行 //否则返回false，添加worker失败 if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; int wc = workerCountOf(c); //线程数大于CAPACITY //线程数大于corePoolSize或maximumPoolSize（取决于core） //否则添加worker失败 if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; //线程数验证通过，使用CAS对c加1，执行成功则终止大循环继续向下运行 if (compareAndIncrementWorkerCount(c)) break retry; //CAS设置失败则重新获取运行状态，若线程池状态发生改变，从头开始大循环，否则继续小循环 c = ctl.get(); if (runStateOf(c) != rs) continue retry; &#125; &#125; boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; w = new Worker(firstTask); final Thread t = w.thread; if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; // 二重验证，获取池状态 int rs = runStateOf(ctl.get()); //状态为RUNNING 则通过继续执行 //状态为SHUTDOWN并且提交的任务为null 则通过继续执行 //否则直接执行finally解锁 if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) // 如果worker中的线程t已经处于运行状态 throw new IllegalThreadStateException();//抛异常 workers.add(w);//将w加入HashSet int s = workers.size(); //更新largestPoolSize，largestPoolSize只能在lock下修改 if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; if (workerAdded) &#123; t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) addWorkerFailed(w); &#125; return workerStarted;&#125; 1.2.3 addWorkerFailed()当任务执行失败，程序需要进行善后处理，即恢复任务执行过程中对内存的改动，移除set中的worker对象，修改池状态，最后尝试终止线程池。1234567891011121314代码摘自：java.util.concurrent.ThreadPoolExecutorprivate void addWorkerFailed(Worker w) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; if (w != null) workers.remove(w); //CAS对ctl减1 decrementWorkerCount(); tryTerminate(); &#125; finally &#123; mainLock.unlock(); &#125;&#125; 2. 配置线程池流程介绍完了先来总结以下上文提到了几个核心参数在流程中的具体作用，然后介绍应该如何配置。 2.1 参数详解 corePoolSize：核心线程数 核心线程会一直存活，即使没有任务需要执行 当线程数小于核心线程数时，即使有线程空闲，线程池也会有限创建新的线程 设置allowCoreThreadTimeout=true（默认是false）时，核心线程会超时关闭 maximumPoolSize：最大线程数 当线程数 &gt;= corePoolSize，且队列已满。线程池会创建新线程来处理 当线程数 = maxmumPoolSize，且队列任务已满是，线程会拒绝处理任务 keepAliveTime：线程空闲时间 当线程空闲时间达到keepAliveTime时，线程会退出，知道线程数量 = corePoolSize 如果allowCoreThreadTimeout = true，则会知道线程数量 = 0 rejectedExecutionHandler：任务拒绝处理器两种情况会拒绝处理任务： 当线程数已经达到maxmumPoolSize，且队列已满，会拒绝新任务 当线程池被调用shutdown()后，会等待线程池里的任务执行完毕，再shutdown。如果在调用shutdown()和线程池真正shutdown之间提交任务，会拒绝新任务 线程池会调用rejectedExecutionHandler来处理这个任务。如果没有设置默认是AbortPolicy，会抛出异常，ThreadPoolExecutor类有几个内部实现类来处理这类情况： AbortPolicy 丢弃任务，抛运行时异常CallerRunsPolicy 执行任务，调用Runnable的run强制执行。DiscardPolicy 忽视，什么都不会发生DiscardOldestPolicy 如果是应为第一种情况被拒绝，则从阻塞队列中踢出最先进入队列（最后一个执行）的任务，然后再次提交当前任务。 实现RejectedExecutionHandler接口，可自定义处理器处理reject。 2.2 参数配置默认值：12345corePoolSize=1maxPoolSize=Integer.MAX_VALUEkeepAliveTime=60sallowCoreThreadTimeout=falserejectedExecutionHandler=AbortPolicy() 如何设置，需要根据几个值来决定： tasks ：系统每秒任务数，假设为500~1000 taskcost：单任务耗时，假设为0.1s responsetime：系统允许容忍的最大响应时间，假设为1s 做几个计算：corePoolSize = 系统每秒任务数/单线程每秒任务数 = 系统每秒任务数/（1/单任务耗时）corePoolSize = tasks/(1/taskcost) =taskstaskcout = (500~1000)0.1 = 50~100 。 corePoolSize设置应该大于50，根据8020原则，如果80%的系统每秒任务数小于800，那么corePoolSize设置为80即可 maxPoolSize = （最大任务数-队列容量）/每个线程每秒处理能力 = 最大线程数计算可得 maxPoolSize = (1000-80)/10 = 92队列容量在初始化池的时候指定，一旦指定不能修改 rejectedExecutionHandler：根据具体情况来决定，任务不重要可丢弃，任务重要则要利用一些缓冲机制来处理 keepAliveTime和allowCoreThreadTimeout采用默认通常能满足以上都是理想值，实际情况下要根据机器性能来决定。如果在未达到最大线程数的情况机器cpu load已经满了，则需要通过升级硬件和优化代码，降低taskcost来处理。 2.3 参数动态调整用户可以通过corePoolSize和maxmumPoolSize的getter/setter进行访问和设置，具体怎么设置需要根据当前池中一些状态变量进行判断，如： getLargestPoolSize() 获取到目前为止达到过的最大线程数 getPoolSize() 获取当前线程数 getQueue().size() 获取当前阻塞队列任务数 3. 关闭线程池关闭线程池无非就是两个方法 shutdown()/shutdownNow()。 但他们有着重要的区别： shutdown() 执行后停止接受新任务，会把队列的任务执行完毕。 shutdownNow() 也是停止接受新任务，但会中断所有的任务，将线程池状态变为 stop。 两个方法都会中断线程，用户可自行判断是否需要响应中断。shutdownNow() 要更简单粗暴，可以根据实际场景选择不同的方法。 通常是按照以下方式关闭线程池的：12345678910long start = System.currentTimeMillis();for (int i = 0; i &lt;= 5; i++) &#123; pool.execute(new Job());&#125;pool.shutdown();while (!pool.awaitTermination(1, TimeUnit.SECONDS)) &#123; LOGGER.info(&quot;线程还在执行。。。&quot;);&#125;long end = System.currentTimeMillis();LOGGER.info(&quot;一共处理了【&#123;&#125;】&quot;, (end - start)); pool.awaitTermination(1, TimeUnit.SECONDS) 会每隔一秒钟检查一次是否执行完毕（状态为 TERMINATED），当从 while 循环退出时就表明线程池已经完全终止了。","categories":[],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"http://zzkenyon.github.io/tags/并发编程/"}],"keywords":[]},{"title":"并发编程-ThreadLocal原理","slug":"并发编程-ThreadLocal原理","date":"2018-05-03T12:58:11.000Z","updated":"2019-05-17T04:53:22.000Z","comments":true,"path":"2018/05/03/并发编程-ThreadLocal原理/","link":"","permalink":"http://zzkenyon.github.io/2018/05/03/并发编程-ThreadLocal原理/","excerpt":"","text":"ThreadLocal是一个本地线程副本变量工具类，ThreadLocal的实例代表了一个线程局部的变量，主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。 1. 我是什么 是让线程拥有独占的变量 它通过set、get方法进行设值和取值操作 它可以覆盖initialValue方法设置初始值，在没进行set之前调用get会调用初始化方法，一个线程只会调用一次 每个线程都会有一个指向threadLocal的弱引用，只要线程一直存活或者该threadLocal实例能被访问到，就不会被GC清理掉。当jvm内存溢出时，会清理掉值为Null的弱引用。 2. 使用方法1234567891011121314public static void main(String[] args)&#123; ThreadLocal&lt;String&gt; stringThreadLocal = new ThreadLocal&lt;String&gt;()&#123; @Override protected String initialValue()&#123; return &quot;default string&quot;; &#125; &#125;; for(int i = 0; i&lt; 10; i++)&#123; new Thread(() -&gt; &#123; stringThreadLocal.set(Thread.currentThread().getName()); System.out.println(stringThreadLocal.get()); &#125;).start(); &#125;&#125; 3. 我在一个map里每个线程都有一个ThreadLocalMap对象，map中存放了(ThreadLocal,t)键值对 3.1 get源码12345678910111213public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; 获取当前线程内部的ThreadLocalMap map存在则获取当前ThreadLocal对应的值 不存在则调用setInitialValue进行初始化 3.2 setInitialValue()源码12345678910private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value;&#125; 调用重载的initialValue方法获取初始值 获取当前线程的ThreadLocalMap map存在则将初始值put进去 map不存在则使用初始值为当前线程创建ThreadLocalMap 3.3 set(T value)源码12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; 获取当前线程内部的ThreadLocalMap map存在则把当前ThreadLocal和value添加到map中 map不存在则创建一个ThreadLocalMap，保存到当前线程内部 小结每个线程都有一个ThreadLocalMap类型的私有变量，当为线程添加ThreadLocal对象时，就是保存到了这个map中，所以线程之间不会相互干扰。 4. 我还有一个大坑ThreadLocal使用不当，会引发内存泄露的问题ThreadLocal对象存在thread对象中，只要线程没有死亡，该对象就不会被回收 remove()源码12345public void remove() &#123; ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this); &#125; 获取当前线程内部的ThreadLocalMap，存在则从map中删除这个ThreadLocal对象。 5. 无处不在的map分析完4个公开方法的源码，发现每个方法都离不开ThreadLocalMap类，下面分析一下这个无处不在的map。 ThreadLocalMap是一个自定义的Hashmap，专门用来保存线程的ThreadLocal变量 它的操作仅限于ThreadLocal类中，不对外暴露 这个类被用在Thread类的私有变量threadLocals和inheritableThreadLocals上 为了能够保存大量且存活时间较长的threadLocal实例，hash table entries采用了WeakReferences作为key的类型 一旦hash table运行空间不足，key为null的entry就会被清理掉 源码1234567891011121314151617181920212223242526272829static class ThreadLocalMap &#123; static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; private static final int INITIAL_CAPACITY = 16; private Entry[] table; private int size = 0; private int threshold; // Default to 0 private void setThreshold(int len) &#123; threshold = len * 2 / 3; &#125; ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY); &#125;&#125;","categories":[],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"http://zzkenyon.github.io/tags/并发编程/"}],"keywords":[]},{"title":"并发编程-并发工具类","slug":"并发编程-并发工具类","date":"2018-04-27T12:36:12.000Z","updated":"2019-05-21T06:49:36.000Z","comments":true,"path":"2018/04/27/并发编程-并发工具类/","link":"","permalink":"http://zzkenyon.github.io/2018/04/27/并发编程-并发工具类/","excerpt":"","text":"在JDK的并发包中提供了几个非常有用的并发工具类。CountDownLatch、CyclicBarrier和Semaphore提供了并发流程控制手段，Exchanger提供了两个线程之间交换数据的手段，本文将配合应用场景介绍该如何使用这几个工具类。 1. CountDownLatchCountDownLatch是JDK 5+里面闭锁的一个实现，他允许一个或多个线程等待其他线程完成各自的工作后再执行。 闭锁（Latch）：一种同步方法，可以延迟线程的进度直到线程到达某个终点状态。 与CountDownLatch第一次交互是主线程等待其它的线程，主线程必须在启动其它线程后立即调用await方法，这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。 其他的N个线程必须引用闭锁对象，因为他们需要通知CountDownLatch对象，他们已经完成了各自的任务，这种机制就是通过调用countDown()方法来完成的。每调用一次这个方法，在构造函数中初始化的count值就减1，所以当N个线程都调用了这个方法count的值等于0，然后主线程就能通过await方法，恢复自己的任务。 与Join的区别：调用join方法需要等待thread执行完毕才能继续向下执行,而CountDownLatch只需要检查计数器的值为零就可以继续向下执行，相比之下，CountDownLatch更加灵活一些，可以实现一些更加复杂的业务场景。 1.1 使用场景 开启多个线程分块下载一个大文件，每个线程只下载固定的一截，最后由另外一个线程来拼接所有的分段。 应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。 确保一个计算不会执行，直到所需要的资源被初始化。 1.2 主要方法12345678910//初始化计数的次数，不能重置public CountDownLatch(int count); //调用此方法则计数减1public void countDown(); //得到当前的计数Public Long getCount(); //调用此方法会一直阻塞当前线程，直到计时器的值为0，除非线程被中断。public void await() throws InterruptedException //调用此方法会一直阻塞当前线程，直到计时器的值为0，除非线程被中断或者计数器超时，返回false代表计数器超时。Public boolean await(long timeout, TimeUnit unit) 1.3 使用案例 latch.countDown(); 建议放到finally语句里。 对这个计数器的操作都是原子操作，同时只能有一个线程去操作这个计数器。 12345678910111213141516171819202122232425262728293031public class CountDownLatchTest &#123; private final CountDownLatch latch = new CountDownLatch(3); private final ReentrantLock lock = new ReentrantLock(); private int count; public int getCount()&#123; return this.count; &#125; public class RunnableTask implements Runnable&#123; @Override public void run() &#123; try &#123; lock.lock(); count += 100; &#125;finally &#123; latch.countDown(); lock.unlock(); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException&#123; CountDownLatchTest demo = new CountDownLatchTest(); int i = 3; while(i-- &gt; 0)&#123; new Thread(demo.new RunnableTask()).start(); &#125; demo.latch.await(); System.out.println(demo.getCount()); &#125;&#125; 三个线程分别对count加100，等三个线程执行完后，主线程输出count的值。输出300 2. CyclicBarrier字面意思是可以循环使用的屏障。他要做的事情是让一组线程到达一个同步点时被阻塞，直到最后一个线程到达同步点，才会打开屏障，所有线程继续运行。 默认的构造方法 CyclicBarrier(int parties) ，参数代表屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier已经到达屏障，然后被阻塞。 1.1 使用场景可用于多线程计算数据，最后合并计算结果 1.2 主要方法123456789101112131415//初始化public CyclicBarrier(int parties)//barrierAction表示被拦住的线程需要执行的任务public CyclicBarrier(int parties, Runnable barrierAction)//被拦住的线程调用次函数进入阻塞状态public int await()//被拦住的线程调用次函数进入阻塞状态，超时唤醒public int await(long timeout, TimeUnit unit)public void reset() //返回需要被拦住的线程数量public int getParties() //查询此屏障是否处于断开状态public boolean isBroken()//返回已被拦住的线程数量public int getNumberWaiting() 1.3 使用案例初始化线程数为2，加上主线程调用await()3次，所以得出结论主线程调用不计入await次数之内。123456789101112131415161718192021222324252627public class CyclicBarrierTest &#123; private static CyclicBarrier cb = new CyclicBarrier(2); private static ReentrantLock lock = new ReentrantLock(); private static int count; public static class RunnableTask implements Runnable&#123; @Override public void run() &#123; try &#123; lock.lock(); count += 100; cb.await(); &#125;catch (Throwable e)&#123; &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; public static void main(String[] args) throws Exception&#123; for(int i = 0; i &lt; 2; i++) &#123; new Thread(new RunnableTask()).start(); &#125; cb.await(); System.out.println(count); &#125;&#125; 输出200 1.4 与CountDownLatch的区别 CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置，可以使用多次，所以CyclicBarrier能够处理更为复杂的场景； CyclicBarrier还提供了一些其他有用的方法，比如getNumberWaiting()方法可以获得CyclicBarrier阻塞的线程数量，isBroken()方法用来了解阻塞的线程是否被中断； CountDownLatch允许一个或多个线程等待一组事件的产生，而CyclicBarrier用于等待其他线程运行到栅栏位置。 3. SemaphoreSemaphore是用来控制同事访问特定资源的线程数量，它通过协调各个线程以保证合理的使用公共资源。 3.1 使用场景可用于做流量控制，特别是公用资源有限的场景，比如数据库连接。 4. ExchangerExchanger类可用于两个线程之间交换信息。可简单地将Exchanger对象理解为一个包含两个格子的容器，通过exchanger方法可以向两个格子中填充信息。当两个格子中的均被填充时，该对象会自动将两个格子的信息交换，然后返回给线程，从而实现两个线程的信息交换。 Exchanger类仅可用作两个线程的信息交换，当超过两个线程调用同一个exchanger对象时，得到的结果是不确定的，exchanger对象仅关心其包含的两个“格子”是否已被填充数据，当两个格子都填充数据完成时，该对象就认为线程之间已经配对成功，然后开始执行数据交换操作。12345678910111213141516171819202122232425public class ExchangerTest &#123; private static Exchanger&lt;String&gt; exgr = new Exchanger&lt;&gt;(); private static ExecutorService threadpool = Executors.newFixedThreadPool(3); public static void main(String[] args)&#123; threadpool.execute(() -&gt; &#123; String a = &quot;银行流水A&quot;; try &#123; exgr.exchange(a); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); threadpool.execute(() -&gt; &#123; String b = &quot;银行流水B&quot;; try &#123; String a = exgr.exchange(b); System.out.println(a); &#125; catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;); threadpool.shutdown(); &#125;&#125;","categories":[],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"http://zzkenyon.github.io/tags/并发编程/"}],"keywords":[]},{"title":"并发编程-共享式AQS源码详解","slug":"并发编程-共享式AQS源码详解","date":"2018-04-25T12:36:12.000Z","updated":"2019-05-21T06:49:12.000Z","comments":true,"path":"2018/04/25/并发编程-共享式AQS源码详解/","link":"","permalink":"http://zzkenyon.github.io/2018/04/25/并发编程-共享式AQS源码详解/","excerpt":"","text":"上篇文章详细的阐述了AQS在独占模式下的底层原理，本篇主要讲述共享式同步器的原理。 1. acquireShared(int)此方式是共享模式下线程获取贡献资源的入口，他会获取指定量的资源，获取成功直接返回，失败则进入等待队列，知道获取到资源为止，整个过程忽略终端。下面看源码： 12345public final void acquireShared(int arg) &#123; // if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg);&#125; 123protected int tryAcquireShared(int arg) &#123; throw new UnsupportedOperationException();&#125; 这里 tryAcquireShared 依然需要自定义同步器去实现，但是AQS已经将返回值的语义定义好了，重载该函数的时候执行逻辑要符合下列语义：-返回负值表示获取失败 返回0表示获取成功，但是没有剩余资源 返回正数表示获取成功，还有剩余资源 tryAcquireShared获取失败则执行 doAcquireShared 方法，看下面源码：12345678910111213141516171819202122232425262728293031323334private void doAcquireShared(int arg) &#123; //将线程以共享方式加入同步队列尾部 final Node node = addWaiter(Node.SHARED); //获取失败吗，默认true（失败） boolean failed = true; try &#123; //记录等待过程是否被中断过 boolean interrupted = false; for (;;) &#123; //拿到前驱节点 final Node p = node.predecessor(); if (p == head) &#123;//如果前驱是头结点 //尝试获取 int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; //自己获取资源的同时，如果还有剩余资源,唤醒后继节点 setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted)//补上中断标志 selfInterrupt(); failed = false; return; &#125; &#125; //前驱不是头结点，获取失败后寻找安全点 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; 整个过程与acquireQueued()很相似，区别在于唤醒等待线程的条件不同。setHeadAndPropagate方法在setHead()的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，看代码： 1234567891011private void setHeadAndPropagate(Node node, int propagate) &#123; Node h = head; //与独占式不同原head并没有释放资源 setHead(node); if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || (h = head) == null || h.waitStatus &lt; 0) &#123; Node s = node.next; if (s == null || s.isShared()) doReleaseShared(); &#125;&#125; 2. releaseShared()上一小节已经把acquireShared()说完了，这一小节就来讲讲它的反操作releaseShared()吧。此方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。下面是releaseShared()的源码： 1234567public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125; 此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。例如，资源总量是13，A（5）和B（7）分别获取到资源并发运行，C（4）来时只剩1个资源就需要等待。A在运行过程中释放掉2个资源量，然后tryReleaseShared(2)返回true唤醒C，C一看只有3个仍不够继续等待；随后B又释放2个，tryReleaseShared(2)返回true唤醒C，C一看有5个够自己用了，然后C就可以跟A和B一起运行。而ReentrantReadWriteLock读锁的tryReleaseShared()只有在完全释放掉资源（state=0）才返回true，所以自定义同步器可以根据需要决定tryReleaseShared()的返回值。 2.1 doReleaseShared()此方法主要用于唤醒后继。下面是它的源码：123456789101112131415161718private void doReleaseShared() &#123; for (;;) &#123; Node h = head; if (h != null &amp;&amp; h != tail) &#123; int ws = h.waitStatus; if (ws == Node.SIGNAL) &#123; if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases unparkSuccessor(h); &#125; else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS &#125; if (h == head) // loop if head changed break; &#125;&#125; 3. Semaphore一个具象化的例子：停车场运作，假设停车场有10个车位，刚开始都是空的。如果同时来了11辆车，看守者只能允许10辆车进入，另一辆排队等候，当有车为空出来，等候车辆进入填满空车位。Semaphore就相当于停车场看守者。 和RentrantLock不同Semaphore没有实现Lock接口，获取资源有响应中断模式和忽略中断模式，中断模式获取资源： 123456public void acquire() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1);&#125;public void acquire(int i) throws InterruptedException &#123; sync.acquireSharedInterruptibly(i);&#125; 释放资源统一使用： 123456public void release() &#123; sync.releaseShared(1);&#125;public void release(int i) &#123; sync.releaseShared(i);&#125; 内部同步器sync重载的tryAcquireShared-tryRealseShared源码如下，代码逻辑简单易懂，实现自定义的同步器一般也只需要实现这几个方法。 123456789101112131415161718192021222324252627282930313233//非公平final int nonfairTryAcquireShared(int acquires) &#123; for (;;) &#123; int available = getState(); int remaining = available - acquires; if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; &#125;&#125;//公平protected int tryAcquireShared(int acquires) &#123; for (;;) &#123; if (hasQueuedPredecessors()) return -1; int available = getState(); int remaining = available - acquires; if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; &#125;&#125;protected final boolean tryReleaseShared(int releases) &#123; for (;;) &#123; int current = getState(); int next = current + releases; if (next &lt; current) // overflow throw new Error(&quot;Maximum permit count exceeded&quot;); if (compareAndSetState(current, next)) return true; &#125;&#125;","categories":[],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"http://zzkenyon.github.io/tags/并发编程/"}],"keywords":[]},{"title":"nginx入门","slug":"nginx入门","date":"2018-04-23T07:17:36.000Z","updated":"2019-04-26T07:17:24.000Z","comments":true,"path":"2018/04/23/nginx入门/","link":"","permalink":"http://zzkenyon.github.io/2018/04/23/nginx入门/","excerpt":"","text":"Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现。 1、正向代理与反向代理1.1 正向代理：代理服务器代表的是客户端，代理对服务器端透明。正向代理的应用场景： vpn 缓存，加速访问资源 对客户端访问授权，上网进行认证 记录用户的上网记录，对外隐藏用户信息 正向代理产品：CCProxy 1.2 反向代理：代理服务器代表的是服务器端，代理对客户端透明反向代理的应用场景： 保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击 负载均衡 反向代理产品：Nginx 2、nginx安装2.1 安装环境 yum -y install wget #安装下载工具 yum install -y gcc gcc-c++ #安装gcc编译环境 yum install -y pcre-devel #安装PERE库 yum -y install openssl openssl-devel #安装OpenSsl库 2.2 准备安装nginx wget http://nginx.org/download/nginx-1.14.0.tar.gz #下载 tar -zxf nginx-1.14.0.tar.gz #解压 cd nginx-1.14.0 sed -i -e’s/1.14.0//g’ -e’ s/nginx\\//WS/g’ -e’s/“NGINX”/“WS”/g’ src/core/nginx.h #隐藏版本号(安全性考虑，爆出有些版本的nginx存在漏洞，容易被攻击) 2.3编译安装nginx useradd www #添加用户，不添加默认为nobody ./configure –user=www –group=www –prefix=/usr/local/nginx –with-http_ssl_module make &amp; make install 3、nginx的五种负载分配算法3.1 round robin（默认）轮询方式，依次将请求分配到各个后台服务器中，默认的负载均衡方式。适用于后台机器性能一致的情况。挂掉的机器可以自动从服务列表中剔除。 3.2 weight根据权重来分发请求到不同的机器中，指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。1234upstream bakend &#123; server 192.168.0.14 weight=10; server 192.168.0.15 weight=10; &#125; 3.3 IP_hash根据请求者ip的hash值将请求发送到后台服务器中，可以保证来自同一ip的请求被打到固定的机器上，可以解决session问题 12345upstream bakend &#123; ip_hash; server 192.168.0.14:88; server 192.168.0.15:80; &#125; 3.4 url_hash（第三方）根据请求的url的hash值将请求分到不同的机器中，当后台服务器为缓存的时候效率高。例如：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法 123456upstream backend &#123; server squid1:3128; server squid2:3128; hash $request_uri; hash_method crc32; &#125; 3.5 fair（第三方）根据后台响应时间来分发请求，响应时间短的分发的请求多。例如：12345upstream backend &#123; server server1; server server2; fair; &#125;","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://zzkenyon.github.io/tags/nginx/"}],"keywords":[]},{"title":"并发编程-独占式AQS源码详解","slug":"并发编程-独占式AQS源码详解","date":"2018-04-19T12:36:12.000Z","updated":"2019-05-23T08:09:23.112Z","comments":true,"path":"2018/04/19/并发编程-独占式AQS源码详解/","link":"","permalink":"http://zzkenyon.github.io/2018/04/19/并发编程-独占式AQS源码详解/","excerpt":"","text":"1. 框架概述AQS是AbstractQueuedSynchronizer的简称，抽象队列同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类的实现都依赖于它，比如常用的ReentrantLock/CountDownLatch/Semaphore… AQS维护了一个volatile int state 代表共享资源，一个FIFO线程等待队列用来记录争用资源而进入等待的线程，这里有一点需要强调，AQS同步队列中的线程是处于WAITING状态的，而竞争synchronized同步块的线程是处于BLOCKING状态的。 AQS定义了两种组员共享方式：Exclusive 和 Share 自定义同步器在实现时只需要实现共享资源state的获取与释放方式，至于具体的线程等待队列的维护，AQS已经实现好了。自定义同步器是现实需要实现的几个方法： isHeldExclusively() 该线程是否正在独占资源，只有用到Condition才需要实现它 tryAcquire(int) 独占方式获取资源，获取成功返回ture tryRelease(int) 独占方式释放资源，释放成功返回ture tryAcquireShared(int) 共享方式获取资源，负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。 tryReleaseShared(int) 共享方式释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。 以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。 再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。 一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。 2. 源码详解本节依照acquire-release、acquireShared-releaseShared的次序来讲解AQS的源码实现。 2.1 acquire(int)该方法是在独占模式下获取共享资源的底层入口，如果获取资源成功tryAcquire返回true，该函数直接返回，且整个过程忽略中断的影响；否则调用addWaiter将线程包装成Node对象进入阻塞队列，并不断acquireQueued获取资源。12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 函数流程如下： tryAcquire() 尝试直接去获取资源，如果成功则直接返回； addWaiter() 将该线程加入等待队列的尾部，并标记为独占模式； acquireQueued() 使线程在等待队列中尝试获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。 如果线程在等待过程中被中断过，它是不响应的（关于中断的介绍请参考文章线程中断），获取资源后通过selfInterrupt()，将该线程的中断标志置为true。 2.1.1 tryAcquire(int)此方法尝试获取独占资源，如果成功返回true，否则返回false。123protected boolean tryAcquire(int arg) &#123; throw new UnsupportedOperationException();&#125; AQS中该方法没有具体的执行逻辑，这是因为这是AQS定义DE1一个方法模板，具体的实现需要自定义同步类自己完成，能不能重入，竞争资源时可不可以加塞，都需要子类自己设计。如果子类没有实现该方法，就会调用AQS的默认实现，如上直接抛出异常。 2.1.2 addWaiter(Node)此方法作用是将当前线程加入到阻塞队列的队尾，并返回当前线程所在节点。123456789101112131415private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); // 尝试快速入队 Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; //快速入队失败，调用enq方法入队 enq(node); return node;&#125; 先介绍一下Node，Node节点是对每一个竞争同步代码的线程的封装，主要包含了当前线程对象以及线程的状态。变量waitStatus表示当前Node节点的等待状态，共有4中取值CANCELLED、SIGNAL、CONDITION、PROPAGATE CANCELLED ： 值为1，表示当前节点处于结束状态，在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该Node节点 SIGNAL 值为-1，表示当前节点线程取消或者释放资源的时候，需要unpark其后继节点 CONDITION 值为-2，表示当前节点处于条件队列，在转变（状态被设为0）之前不会被当做同步队列节点 PROPAGATE 值为-3，与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态 0 代表初始状态。 2.1.3 enq(Node)此方法用于将node加入队尾。源码如下：123456789101112131415private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; 如果你看过AtomicInteger.getAndIncrement()函数源码，那么相信你一眼便看出这段代码的精华。CAS自旋volatile变量，是一种很经典的用法。 2.1.4 acquireQueued(Node, int)通过tryAcquire()和addWaiter()，该线程获取资源失败，已经被放入等待队列尾部了，下一步该干什么？进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了。这个函数非常关键，上源码：1234567891011121314151617181920212223242526272829final boolean acquireQueued(final Node node, int arg) &#123; //获取资源失败了吗，true就是失败了 boolean failed = true; try &#123; //标识等待过程中是否被中断过 boolean interrupted = false; for (;;) &#123; //获得当前节点的前驱 final Node p = node.predecessor(); //如果前驱是head，那就有资格去尝试获取 if (p == head &amp;&amp; tryAcquire(arg)) &#123; //获取资源成功，将自己设置成head setHead(node); //help GC，原头结点断开与队列的链接，等待被回收 p.next = null; failed = false;//表示获取资源成功 return interrupted; &#125; //先判断此次获取失败后可不可以 WAITTING，如果不能，继续重复循环 //执行park让线程进入WAITTING状态，并判断等待过程中有没有中断，发生过就改状态 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 那么怎么判断线程是不是应该执行park()呢？继续看下面代码，shouldParkAfterFailedAcquire方法主要用于检查状态，看看自己是否真的可以去休息了（进入waiting状态），万一排在队列前边的线程都放弃了只是瞎站着，那就需要往前加塞。 12345678910111213141516171819private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; //获取前驱节点的状态 int ws = pred.waitStatus; //如果前驱节点状态是SIGNAL，说明前驱节点释放资源后会通知本节点，可以安全的执行park() if (ws == Node.SIGNAL) return true; if (ws &gt; 0) &#123; //如果前驱节点是取消状态CANCELLED，执行加塞操作，跳过所有取消节点 do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; //如果前驱节点状态正常有效，那就把前驱节点的状态设置成SIGNAL，前驱节点执行完释放资源就会通知本节点 compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; //返回false表示此次循环不能更改线程状态，返回到acquireQueued方法即系执行循环获取资源 return false;&#125; 整个流程用一句话概括，如果前驱结点的状态不是SIGNAL，那么自己就不能放心去休息，需要去找个安全的休息点，找到安全点后可以再尝试下看能不能获取资源，再次获取失败就可以放心进入WAITTING状态。 parkAndCheckInterrupt方法就是让线程执行park()进入WAITTINGZ状态，并返回该线程的中断标志1234private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this); return Thread.interrupted();&#125; 注意，Thread.interrupted()方法在获取线程中断标志的同事会将该标志复位为false 2.1.5 小结源码再贴一遍：12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); &#125; 获取独占资源流程如下： 调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回； 没成功，则addWaiter()将该线程加入等待队列的尾部； acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。 如果线程在等待过程中被中断过，它是不响应的，并且中断标志被Thread.interrupted()重置为false了，所以获取资源后才再进行自我中断selfInterrupt()，将中断标志重置为true。 2.2 release(int)release是独占模式下线程释放共享资源的底层接口。它会释放指定量的资源，如果彻底释放了（即state=0），它会唤醒等待队列里的其他线程来获取资源。源码：123456789public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h);//唤醒后继节点 return true; &#125; return false; &#125; 逻辑并不复杂。它调用tryRelease()来释放资源。有一点需要注意的是，它是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了。所以自定义同步器在设计tryRelease()的时候要明确这一点 2.2.1 tryRelease(int)123protected boolean tryRelease(int arg) &#123; throw new UnsupportedOperationException();&#125; 跟tryAcquire()一样，这个方法是需要独占模式的自定义同步器去实现的。正常来说，tryRelease()都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可(state-=arg)，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，release()是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回true，否则返回false。 2.2.2 unparkSuccessor(Node)此方法用于唤醒等待队列中下一个线程。123456789101112131415161718private void unparkSuccessor(Node node) &#123; //获取当前节点的状态 int ws = node.waitStatus; if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0);//置0 //获取下一个将唤醒的节点 Node s = node.next; //若后继节点已取消，找到最靠近head的有效节点 if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) //waitStatus&lt;=0的都是有效节点，都可以唤醒 if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) LockSupport.unpark(s.thread);//唤醒 &#125; 一句话概括，用用unpark()唤醒等待队列中最前边的那个有效线程。 3. ReentrantLockReentrantLock自身没有继承AQS，但是它持有一个AQS的子类Sync的对象实例sync，Sync又派生了两个子类 FairSync 和 NonfairSync。ReentrantLock实例化时，无参的默认构造函数会使用NonfairSync对sync进行初始化；而接受一个布尔型变量的构造函数根据用户传入的参数决定使用公平锁还是非公平锁。 公平性是针对锁获取而言的，如果是公平锁，那么锁的获取顺序应该符合请求的绝对时间顺序，也就是FIFO，该原则保证公平的代价是进行大量的线程切换。非公平锁虽然可能造成线程饥饿，但是极少的线程切换保证了其更大的吞吐量，因此ReentrantLock默认实现非公平锁。 3.1 获取锁下面代码是非公平锁和公平锁分别获取资源的操作：1234567891011121314151617181920final boolean nonfairTryAcquire(int acquires) &#123; //获取当前线程对象 final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123;//如果资源空闲，CAS设置状态量 if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; //如果资源被占用，判断持有锁的线程是不是本线程，是的话重入 else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; &#125; return false;&#125; 重入锁的意义就是持有锁的线程可以多次重复进入临界区，而不需要在同步队列中等待，每次进入状态量加1，进入几次就要释放几次，释放1次状态量减1，当状态量为0时，完全释放资源。 1234567891011121314151617181920protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; //注意与非公平锁的区别 if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; &#125; return false;&#125; 比较以上两个获取资源的函数，发现唯一的区别在于公平锁在设置状态量之前多做了一次判断 !hasQueuedPredecessors()，该函数返回是否有线程排在当前线程前面，如果没有则可以获得锁。hasQueuedPredecessors源码如下123456789public final boolean hasQueuedPredecessors() &#123; Node t = tail; // Read fields in reverse initialization order Node h = head; Node s; //队列中不止一个线程 //并且第二个线程节点为空或者第二个节点不是是自己 return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread()); &#125; 3.2 释放锁释放操作没有公平与非公平之分，所以释放操作是在父类Sync中实现，下面看源码： 1234567891011121314protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; //如果当前线程不是占用线程，抛异常 if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; //状态量等于0，才是真正释放 if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; setState(c); return free;&#125; 因为释放锁之前，当前线程还持有锁，其他线程无权访问，所以修改状态没有用CAS，直接使用setState 共享式同步器 请看下一篇 并发编程-共享式AQS源码详解","categories":[],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"http://zzkenyon.github.io/tags/并发编程/"}],"keywords":[]},{"title":"spring-HV参数校验","slug":"spring-HV参数校验","date":"2018-04-02T07:39:40.000Z","updated":"2019-05-23T02:59:16.742Z","comments":true,"path":"2018/04/02/spring-HV参数校验/","link":"","permalink":"http://zzkenyon.github.io/2018/04/02/spring-HV参数校验/","excerpt":"","text":"参数验证是一个常见的问题，无论是前端还是后台，都需对用户输入进行验证，以此来保证系统数据的正确性。对于web来说，有些人可能理所当然的想在前端验证就行了，但这样是非常错误的做法，前端代码对于用户来说是透明的，稍微有点技术的人就可以绕过这个验证，直接提交数据到后台。无论是前端网页提交的接口，还是提供给外部的接口，参数验证随处可见，也是必不可少的。前端做验证只是为了用户体验，比如控制按钮的显示隐藏，单页应用的路由跳转等等。后端才是最终的保障。总之，一切用户的输入都是不可信的。 1、gradle依赖1compile &apos;org.springframework.boot:spring-boot-starter-validation&apos; 2、常用约束123456789101112131415161718@Null 被注释的元素必须为 null @NotNull 被注释的元素必须不为 null @AssertTrue 被注释的元素必须为 true @AssertFalse 被注释的元素必须为 false @Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值@Size(max=, min=) 被注释的元素的大小必须在指定的范围内 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past 被注释的元素必须是一个过去的日期 @Future 被注释的元素必须是一个将来的日期 @Pattern(regex=,flag=) 被注释的元素必须符合指定的正则表达式Hibernate Validator附加的constraint @NotBlank(message =) 验证字符串非null，且长度必须大于0 @Email 被注释的元素必须是电子邮箱地址 @Length(min=,max=) 被注释的字符串的大小必须在指定的范围内 @NotEmpty 被注释的字符串的必须非空 @Range(min=,max=,message=) 被注释的元素必须在合适的范围内 3、使用方法 在model类中使用注解约束字段 接口中需要校验的model对象前使用@Valid注解，并在接口方法参数列表中增加BindingResult对象来接受校验错误信息123456789@PostMapping(value = &quot;/demo&quot;) public Integer addDemo(@Valid @RequestBody Demo demo, BindingResult bindingResult)&#123; if(bindingResult.hasErrors())&#123; for(ObjectError error : bindingResult.getAllErrors())&#123; throw new DemoException(DemoExceptionEnum.PARAM_ERROR.getCode(),error.getDefaultMessage()); &#125; &#125; return demoService.insert(demo); &#125; 注意：如果在一个接口中有多个参数需要校验，那么每一个参数都需要定义一个BindingResult对象来接收校验结果 123public void test()(@RequestBody @Valid DemoModel demo, BindingResult result)public void test()(@RequestBody @Valid DemoModel demo, BindingResult result,@RequestBody @Valid DemoModel demo2, BindingResult result2) 4、深入使用4.1 配置校验模式 默认的校验模式为普通模式，普通模式下会校验完所有的属性然后返回所有的校验失败信息 可配置为快速失败返回模式，只要有一个属性校验失败则立即返回 配置方式 1234567891011121314@Configurationpublic class ValidatorConfiguration &#123; @Bean public Validator validator()&#123; ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class ) .configure() /**设置validator模式为快速失败返回*/ .addProperty( &quot;hibernate.validator.fail_fast&quot;, &quot;true&quot; ) .buildValidatorFactory(); Validator validator = validatorFactory.getValidator(); return validator; &#125;&#125; 4.2 分组校验 使用场景：针对同一个model类，不同的接口需要对不同的属性进行校验 例如，数据插入接口与数据更新接口需要校验的参数是不同的 使用方法 在model类中定义内部接口 约束增加组别属性1234&gt; public class Demo&#123;&gt; public interface AddGorup&#123;&#125;&gt; public interface UpdateGroup&#123;&#125;&gt; @Range(min = 1,max = Integer.MAX_VALUE,groups = {UpdateGroup.class}) private Integer id; @Email(groups = {AddGroup.class,UpdateGroup.class}) private String email; @Past(groups = {UpdateGroup.class}) private Date birthday; } 12345678 3. 在接口中使用@Validated(&#123;Demo.AddGroup.class&#125;)来注解参数，表示该参数使用AddGroup来进行校验 &gt;约束的groups属性中可以填写多个接口名，表示该参数加入多个组进行校验 4. #### 4.3 自定义约束- 创建约束标注 @Target({ElementType.METHOD,ElementType.ANNOTATION_TYPE,ElementType.FIELD,ElementType.PARAMETER})@Retention(RetentionPolicy.RUNTIME)@Constraint(validatedBy = DemoConstraintValidator.class)@Documentedpublic @interface DemoConstraint { String message() default “default message”; Class&lt;?&gt;[] groups() default {}; Class&lt;? extends Payload&gt;[] payload() default {}; E value();//约束中设置的value值}1- 实现一个验证器 /** T 自定义的约束注解类型DemoConstraint V 需要检验的参数类型public class DemoConstraintValidator implements ConstraintValidator&lt;T, V&gt;{ private E value;//注入设置的具体约束 @Override public void initialize(T t) { this.value = t.value(); } @Override public boolean isValid(V v, ConstraintValidatorContext constraintValidatorContext) { //根据value 对 参数v 进行一些判断 return true; if(!isValid) { constraintContext.disableDefaultConstraintViolation(); constraintContext.buildConstraintViolationWithTemplate(&quot;new default message&quot;).addConstraintViolation(); return false; } }} 1234567891011 &gt;T表示创建的注解，V表示该约束校验的数据类型- 定义默认的验证错误信息 可以通过ConstraintValidatorContext修改默认的message信息，一旦使用，在注解中给message赋值将不起作用（一般情况下不推荐使用）#### 4.4 检验组序列默认情况下，约束的计算没有特定的顺序，这与它们属于哪个组无关。然而，在某些情况下，控制约束求值的顺序是有用的，例如，我们可以要求在检查汽车的道路价值之前，首先通过所有默认的汽车约束。最后，在我们开车离开之前，我们检查了实际司机的约束条件。为了实现这样的顺序，需要定义一个新的接口，并使用@GroupSequence对其进行注释，以定义必须验证组的顺序。~~~注意：如果这个校验组序列中有一个约束条件没有通过验证的话, 那么此约束条件后面的都不会再继续被校验了.~~~ @GroupSequence({Default.class, CarChecks.class, DriverChecks.class})public interface OrderedChecks {}` 5、@Valid &amp; @Validated 用法 @valid @validated 类名前 √ 类属性前 √ 方法前 √ √ 入参前 √ √ 类名前是否加@Validated只影响@RequestParam注解的参数校验，如要进行校验，必须加。 不需要分组校验的情况下，接口入参之前只能注解@Valid才能正常校验 需要分组校验的时候，接口入参之前需要使用@Validated({GroupA.class,…})才能正常校验 @Valid用在类成员属性名之前，是为了实现嵌套校验 参考资料官方文档springboot使用hibernate validator校验@Validated和@Valid区别","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"http://zzkenyon.github.io/tags/spring/"}],"keywords":[]},{"title":"并发编程-线程中断","slug":"并发编程-线程中断","date":"2018-03-20T12:36:12.000Z","updated":"2019-05-17T04:52:58.000Z","comments":true,"path":"2018/03/20/并发编程-线程中断/","link":"","permalink":"http://zzkenyon.github.io/2018/03/20/并发编程-线程中断/","excerpt":"","text":"中断可以理解为现成的一个标识位属性，它表示一个运行中的线程是否被被其他线程进行了中断操作。中断好比其他线程对该线程打了个招呼，其他线程通过调用该线程的interrupt()方法对其进行中断操作。 线程通过检查自身是否被中断来进行响应，线程通过方法 isInterrupted()来进行判断是否被中断，也可以调用静态方法Thread.interrupted()对当前线程的中断标识进行复位。如果该线程已经处于中介状态，即使该线程被中断过，在调用该线程对象的isInterrupted()时依旧会返回false。 本篇将从以下两个方面来介绍Java中对线程中断机制的具体实现： Java中对线程中断所提供的API支持 线程在不同状态下对于中断所产生的反应 1. Java中线程中断的API在以前的jdk版本中，我们使用stop方法中断线程，但是现在的jdk版本中已经不再推荐使用该方法了，反而由以下三个方法完成对线程中断的支持。12345public boolean isInterrupted()public void interrupt()public static boolean interrupted() 每个线程都一个状态位用于标识当前线程对象是否是中断状态。isInterrupted是一个实例方法，主要用于判断当前线程对象的中断标志位是否被标记了，如果被标记了则返回true表示当前已经被中断，否则返回false。我们也可以看看它的实现源码：123public boolean isInterrupted() &#123; return isInterrupted(false);&#125; 1private native boolean isInterrupted(boolean ClearInterrupted); 底层调用的本地方法isInterrupted，传入一个boolean类型的参数，用于指定调用该方法之后是否需要清除该线程对象的中断标识位。从这里我们也可以看出来，调用isInterrupted并不会清除线程对象的中断标识位。 interrupt也是一个实例方法，该方法用于设置线程对象的中断标识位，只要能获取到实例对象，就能调用该方法。 interrupted是一个静态的方法，用于返回当前线程是否被中断，并清空标志位。123public static boolean interrupted() &#123; return currentThread().isInterrupted(true);&#125; 1private native boolean isInterrupted(boolean ClearInterrupted); 该方法用于判断当前线程是否被中断，并且该方法调用结束的时候会清空中断标识位。下面我们看看线程所处不同状态下对于中断操作的反应。 2. 线程在不同状态下对于中断所产生的反应线程一共6种状态，分别是NEW，RUNNABLE，BLOCKED，WAITING，TIMED_WAITING，TERMINATED（Thread类中有一个State枚举类型列举了线程的所有状态）。下面我们就将把线程分别置于上述的不同种状态，然后看看我们的中断操作对它们的影响。 2.1 NEW和TERMINATED线程的new状态表示还未调用start方法，还未真正启动。线程的terminated状态表示线程已经运行终止。这两个状态下调用中断方法来中断线程的时候，Java认为毫无意义，所以并不会设置线程的中断标识位，什么事也不会发生。例如：123456public static void main(String[] args) throws InterruptedException &#123; Thread thread = new MyThread(); System.out.println(thread.getState()); thread.interrupt(); System.out.println(thread.isInterrupted());&#125; 输出结果如下：12NEWfales terminated状态：12345678public static void main(String[] args) throws InterruptedException &#123; Thread thread = new MyThread(); thread.start(); thread.join(); System.out.println(thread.getState()); thread.interrupt(); System.out.println(thread.isInterrupted());&#125; 输出结果如下：12TERMINATEDfalse 从上述的两个例子来看，对于处于new和terminated状态的线程对于中断是屏蔽的，也就是说中断操作对这两种状态下的线程是无效的。 2.2 RUNNABLE如果线程处于运行状态，那么该线程的状态就是RUNNABLE，但是不一定所有处于RUNNABLE状态的线程都能获得CPU运行，在某个时间段，只能由一个线程占用CPU，那么其余的线程虽然状态是RUNNABLE，但是都没有处于运行状态。而我们处于RUNNABLE状态的线程在遭遇中断操作的时候只会设置该线程的中断标志位，并不会让线程实际中断，想要发现本线程已经被要求中断了则需要用程序去判断。例如： 1234567891011121314151617public class MyThread extends Thread&#123; @Override public void run()&#123; while(true)&#123; &#125; &#125;&#125;public static void main(String[] args) throws InterruptedException &#123; Thread thread = new MyThread(); thread.start(); System.out.println(thread.getState()); thread.interrupt(); Thread.sleep(1000);//等到thread线程被中断之后 System.out.println(thread.isInterrupted()); System.out.println(thread.getState());&#125; 我们定义的线程始终循环做一些事情，主线程启动该线程并输出该线程的状态，然后调用中断方法中断该线程并再次输出该线程的状态。总的输出结果如下： 123RUNNABLEtureRUNNABLE 可以看到在我们启动线程之后，线程状态变为RUNNABLE，中断之后输出中断标志，显然中断位已经被标记，但是当我们再次输出线程状态的时候发现，线程仍然处于RUNNABLE状态。很显然，处于RUNNBALE状态下的线程即便遇到中断操作，也只会设置中断标志位并不会实际中断线程运行。那么问题是，既然不能直接中断线程，我要中断标志有何用处？这里其实Java将这种权力交给了我们的程序，Java给我们提供了一个中断标志位，我们的程序可以通过if判断中断标志位是否被设置来中断我们的程序而不是系统强制的中断。例如： 12345678public void run()&#123; while(true)&#123; if (Thread.currentThread().isInterrupted())&#123; System.out.println(&quot;exit MyThread&quot;); break; &#125; &#125;&#125; 线程一旦发现自己的中断标志为被设置了，立马跳出死循环。这样的设计好处就在于给了我们程序更大的灵活性。 2.3 BLOCKED当线程处于BLOCKED状态说明该线程由于竞争某个对象的锁失败而被挂在了该对象的阻塞队列上了。那么此时发起中断操作不会对该线程产生任何影响，依然只是设置中断标志位。例如：1234567891011public class MyThread extends Thread&#123; public synchronized static void doSomething()&#123; while(true)&#123; //do something &#125; &#125; @Override public void run()&#123; doSomething(); &#125;&#125; 这里我们自定义了一个线程类，run方法中主要就做一件事情，调用一个有锁的静态方法，该方法内部是一个死循环（占用该锁让其他线程阻塞）。123456789101112131415public static void main(String[] args) throws InterruptedException &#123; Thread thread1 = new MyThread(); thread1.start(); Thread thread2 = new MyThread(); thread2.start(); Thread.sleep(1000); System.out.println(thread1.getState()); System.out.println(thread2.getState()); thread2.interrupt(); System.out.println(thread2.isInterrupted()); System.out.println(thread2.getState());&#125; 在我们的主线程中，我们定义了两个线程并按照定义顺序启动他们，显然thread1启动后便占用MyThread类锁，此后thread2在获取锁的时候一定失败，自然被阻塞在阻塞队列上，而我们对thread2进行中断，输出结果如下：1234RUNNABLEBLOCKEDtrueBLOCKED 从输出结果看来，thread2处于BLOCKED状态，执行中断操作之后，该线程仍然处于BLOCKED状态，但是中断标志位却已被修改。这种状态下的线程和处于RUNNABLE状态下的线程是类似的，给了我们程序更大的灵活性去判断和处理中断。 2.4 WAITING/TIMED_WAITING这两种状态本质上是同一种状态，只不过TIMED_WAITING在等待一段时间后会自动释放自己，而WAITING则是无限期等待，需要其他线程调用notify方法释放自己。但是他们都是线程在运行的过程中由于缺少某些条件而被挂起在某个对象的等待队列上。当这些线程遇到中断操作的时候，会抛出一个InterruptedException异常，并清空中断标志位。例如：123456789101112public class MyThread extends Thread&#123; @Override public void run()&#123; synchronized (this)&#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; System.out.println(&quot;i am waiting but facing interruptexception now&quot;); &#125; &#125; &#125;&#125; 我们定义了一个线程类，其中run方法让当前线程阻塞到条件队列上，并且针对InterruptedException 进行捕获，如果遇到InterruptedException 异常则输出一行信息。12345678910public static void main(String[] args) throws InterruptedException &#123; Thread thread = new MyThread(); thread.start(); Thread.sleep(500); System.out.println(thread.getState()); thread.interrupt(); Thread.sleep(1000); System.out.println(thread.isInterrupted());&#125; 在main线程中我们启动一个MyThread线程，然后对其进行中断操作。运行结果如下：123WAITINGi am waiting but facing interruptexception nowfalse 从运行结果看，当前程thread启动之后就被挂起到该线程对象的条件队列上，然后我们调用interrupt方法对该线程进行中断，输出了我们在catch中的输出语句，显然是捕获了InterruptedException异常，接着就看到该线程的中断标志位被清空。 综上所述，我们分别介绍了不同种线程的不同状态下对于中断请求的反应。NEW和TERMINATED对于中断操作几乎是屏蔽的，RUNNABLE和BLOCKED类似，对于中断操作只是设置中断标志位并没有强制终止线程，对于线程的终止权利依然在程序手中。WAITING/TIMED_WAITING状态下的线程对于中断操作是敏感的，他们会抛出异常并清空中断标志位。","categories":[],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"http://zzkenyon.github.io/tags/并发编程/"}],"keywords":[]},{"title":"源码分析-SimpleDateFormat的用法以及线程安全","slug":"源码分析-SimpleDateFormat的用法以及线程安全","date":"2017-12-21T01:02:32.000Z","updated":"2019-05-23T03:00:04.545Z","comments":true,"path":"2017/12/21/源码分析-SimpleDateFormat的用法以及线程安全/","link":"","permalink":"http://zzkenyon.github.io/2017/12/21/源码分析-SimpleDateFormat的用法以及线程安全/","excerpt":"","text":"开发中我们经常会用到时间相关类，我们有很多办法在Java代码中获取时间。但是不同的方法获取到的时间的格式都不尽相同，这时候就需要一种格式化工具，把时间显示成我们需要的格式。最常用的方法就是使用SimpleDateFormat类。这是一个看上去功能比较简单的类，但是，一旦使用不当也有可能导致很大的问题。 在阿里巴巴Java开发手册中，有如下明确规定：本文就围绕SimpleDateFormat的用法、原理等来深入分析下如何以正确使用它。 1. SimpleDateFormat用法1.1 基本用法SimpleDateFormat是java提供的能对时间格式化及解析的工具类。 格式化：将规范日期格式化成日期文本（时间字符串） 12SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);String dateStr = sdf.format(new Date()); 解析： 将文本日期解析成规范化的时间格式 1Date d = sdf.parse(dataStr); 用户可以自定义文本日期的格式，通过字母来描述时间元素，并组装成想要的日期和时间格式。常用的时间元素和字母的对应表如下：模式字母通常是重复的，其数量确定其精确表示。如下表是常用的输出格式的表示方法。 1.2 时区如何在Java代码中获取不同时区的时间呢？SimpleDateFormat可以实现这个功能。123456public static void main(String[] args)&#123; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); System.out.println(sdf.format(Calendar.getInstance().getTime())); sdf.setTimeZone(TimeZone.getTimeZone(&quot;America/Los_Angeles&quot;)); System.out.println(sdf.format(Calendar.getInstance().getTime())); &#125; 以上代码，输出的结果 122019-04-24 09:26:382019-04-23 18:26:38 中国的时间第一行，而美国洛杉矶时间比中国北京时间慢了17个小时（这还和冬夏令时有关系）。当然，这不是显示其他时区的唯一方法 2. SimpleDateFormat线程安全性由于SimpleDateFormat比较常用，而且在一般情况下，一个应用中的时间显示模式都是一样的，所以很多人愿意使用如下方式定义SimpleDateFormat：1234567public class Main &#123; private static SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); public static void main(String[] args) &#123; sdf.setTimeZone(TimeZone.getTimeZone(&quot;America/New_York&quot;)); ... &#125;&#125; 这种定义方式，存在很大的线程安全隐患。 2.1 问题重现以下代码使用线程池来执行时间输出。12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Main &#123; /** * 定义一个全局的SimpleDateFormat */ private static SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); /** * 使用ThreadFactoryBuilder定义一个线程池 */ private static ThreadFactory namedThreadFactory = new ThreadFactoryBuilder() .setNameFormat(&quot;demo-pool-%d&quot;).build(); private static ExecutorService pool = new ThreadPoolExecutor(5, 200, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy()); /** * 定义一个CountDownLatch，保证所有子线程执行完之后主线程再执行 */ private static CountDownLatch countDownLatch = new CountDownLatch(100); public static void main(String[] args) &#123; //定义一个线程安全的HashSet Set&lt;String&gt; dates = Collections.synchronizedSet(new HashSet&lt;String&gt;()); for (int i = 0; i &lt; 100; i++) &#123; //获取当前时间 Calendar calendar = Calendar.getInstance(); int finalI = i; pool.execute(() -&gt; &#123; //时间增加 calendar.add(Calendar.DATE, finalI); //通过simpleDateFormat把时间转换成字符串 String dateString = sdf.format(calendar.getTime()); //把字符串放入Set中 dates.add(dateString); //countDown countDownLatch.countDown(); &#125;); &#125; //阻塞，直到countDown数量为0 countDownLatch.await(); //输出去重后的时间个数 System.out.println(dates.size()); &#125;&#125; 以上代码，其实比较容易理解。就是循环一百次，每次循环的时候都在当前时间基础上增加一个天数（这个天数随着循环次数而变化），然后把所有日期放入一个线程安全的、带有去重功能的Set中，然后输出Set中元素个数。 正常情况下，以上代码输出结果应该是100。但是实际执行结果是一个小于100的数字。 原因就是因为SimpleDateFormat作为一个非线程安全的类，被当做了共享变量在多个线程中进行使用，这就出现了线程安全问题。 2.2 线程不安全原因其实，JDK文档中已经明确表明了SimpleDateFormat不应该用在多线程场景中：123Date formats are not synchronized.It is recommended to create separate format instances for each thread.If multiple threads access a format concurrently, it must be synchronized externally. 那么为什么会出现这种问题，SimpleDateFormat底层到底是怎么实现的？跟踪一下SimpleDateFormat类中format方法的实现其实就能发现端倪。1234567891011121314151617181920212223242526272829303132333435363738394041@Override public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition pos) &#123; pos.beginIndex = pos.endIndex = 0; return format(date, toAppendTo, pos.getFieldDelegate()); &#125; // Called from Format after creating a FieldDelegate private StringBuffer format(Date date, StringBuffer toAppendTo, FieldDelegate delegate) &#123; // Convert input date to time field list calendar.setTime(date); boolean useDateFormatSymbols = useDateFormatSymbols(); for (int i = 0; i &lt; compiledPattern.length; ) &#123; int tag = compiledPattern[i] &gt;&gt;&gt; 8; int count = compiledPattern[i++] &amp; 0xff; if (count == 255) &#123; count = compiledPattern[i++] &lt;&lt; 16; count |= compiledPattern[i++]; &#125; switch (tag) &#123; case TAG_QUOTE_ASCII_CHAR: toAppendTo.append((char)count); break; case TAG_QUOTE_CHARS: toAppendTo.append(compiledPattern, i, count); i += count; break; default: subFormat(tag, count, delegate, toAppendTo, useDateFormatSymbols); break; &#125; &#125; return toAppendTo; &#125; SimpleDateFormat中的format方法在执行过程中，会使用一个成员变量calendar来保存时间。这其实就是问题的关键。 由于我们在声明SimpleDateFormat的时候，使用的是static定义的。那么这个SimpleDateFormat就是一个共享变量，随之，SimpleDateFormat中的calendar也就可以被多个线程访问到。 假设线程1刚刚执行完calendar.setTime把时间设置成2018-11-11，还没等执行完，线程2又执行了calendar.setTime把时间改成了2018-12-12。这时候线程1继续往下执行，拿到的calendar.getTime得到的时间就是线程2改过之后的。 除了format方法以外，SimpleDateFormat的parse方法也有同样的问题。 3. 如何解决解决方法有很多，先介绍三个比较常用的方法。 3.1 使用局部变量SimpleDateFormat变成了局部变量，就不会被多个线程同时访问到了，就避免了线程安全问题。1234567891011121314151617for (int i = 0; i &lt; 100; i++) &#123; //获取当前时间 Calendar calendar = Calendar.getInstance(); int finalI = i; pool.execute(() -&gt; &#123; // SimpleDateFormat声明成局部变量 SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); //时间增加 calendar.add(Calendar.DATE, finalI); //通过simpleDateFormat把时间转换成字符串 String dateString = simpleDateFormat.format(calendar.getTime()); //把字符串放入Set中 dates.add(dateString); //countDown countDownLatch.countDown(); &#125;);&#125; 3.2 加同步锁除了改成局部变量以外，还有一种方法大家可能比较熟悉的，就是对于共享变量进行加锁。12345678910111213141516171819for (int i = 0; i &lt; 100; i++) &#123; //获取当前时间 Calendar calendar = Calendar.getInstance(); int finalI = i; pool.execute(() -&gt; &#123; //时间增加 calendar.add(Calendar.DATE, finalI); //通过simpleDateFormat把时间转换成字符串 //加锁 synchronized (simpleDateFormat) &#123; String dateString = simpleDateFormat.format(calendar.getTime()); &#125; //把字符串放入Set中 dates.add(dateString); //countDown countDownLatch.countDown(); &#125;);&#125; 通过加锁，使多个线程排队顺序执行。避免了并发导致的线程安全问题。 3.3 使用ThreadLocal第三种方式，就是使用 ThreadLocal。 ThreadLocal 可以确保每个线程都可以得到单独的一个 SimpleDateFormat 的对象，那么自然也就不存在竞争问题了。1234567891011/*** 使用ThreadLocal定义一个全局的SimpleDateFormat*/private static ThreadLocal&lt;SimpleDateFormat&gt; simpleDateFormatThreadLocal = new ThreadLocal&lt;SimpleDateFormat&gt;() &#123; @Override protected SimpleDateFormat initialValue() &#123; return new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); &#125;&#125;;//用法String dateString = simpleDateFormatThreadLocal.get().format(calendar.getTime()); 当然，以上代码也有改进空间，就是，其实SimpleDateFormat的创建过程可以改为延迟加载。这里就不详细介绍了。 4. 使用DateTimeFormatter如果是Java8应用，可以使用DateTimeFormatter代替SimpleDateFormat，这是一个线程安全的格式化工具类。12345678910//解析日期String dateStr= &quot;2016年10月25日&quot;;DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日&quot;);LocalDate date= LocalDate.parse(dateStr, formatter);//日期转换为字符串LocalDateTime now = LocalDateTime.now();DateTimeFormatter format = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日 hh:mm a&quot;);String nowStr = now .format(format);System.out.println(nowStr); 5. 总结本文介绍了SimpleDateFormat的用法，SimpleDateFormat主要可以在String和Date之间做转换，还可以将时间转换成不同时区输出。同时提到在并发场景中SimpleDateFormat是不能保证线程安全的，需要开发者自己来保证其安全性。 主要的几个手段有改为局部变量、使用synchronized加锁、使用Threadlocal为每一个线程单独创建一个和使用Java8中的DateTimeFormatter类代替等。","categories":[],"tags":[{"name":"源码分析","slug":"源码分析","permalink":"http://zzkenyon.github.io/tags/源码分析/"}],"keywords":[]},{"title":"设计模式之策略模式","slug":"设计模式之策略模式","date":"2017-05-14T03:17:23.000Z","updated":"2019-05-14T05:41:52.000Z","comments":true,"path":"2017/05/14/设计模式之策略模式/","link":"","permalink":"http://zzkenyon.github.io/2017/05/14/设计模式之策略模式/","excerpt":"","text":"文章以jdk并发包中的一个策略模式实现作为开篇。 使用线程池处理并发任务时，当用户提交任务到线程池，线程池因为线程池已满或者线程池处于SHUTDOWN状态拒接任务的时候，会调用reject函数对任务进行后处理，代码如下： 123456789代码摘自：java.util.concurrent.ThreadPoolExecutorprivate volatile RejectedExecutionHandler handler;private static final RejectedExecutionHandler defaultHandler = new AbortPolicy(); final void reject(Runnable command) &#123; handler.rejectedExecution(command, this);&#125; 在线程池创建的时候，用户会初始化handler变量，或者使用默认的初始化defaultHandler，即AbortPolicy对象，AbortPolicy就是策略的一种实现，该策略丢弃被拒绝的任务，并抛出RejectedExecutionException异常。12345678910代码摘自：java.util.concurrent.ThreadPoolExecutorpublic static class AbortPolicy implements RejectedExecutionHandler &#123; public AbortPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; throw new RejectedExecutionException(&quot;Task &quot; + r.toString() + &quot; rejected from &quot; + e.toString()); &#125;&#125; 策略接口类：12345代码摘自：java.util.concurrent.RejectedExecutionHandlerpublic interface RejectedExecutionHandler &#123; void rejectedExecution(Runnable r, ThreadPoolExecutor executor);&#125; 所有的后处理策略都要实现该接口，ThreadPoolExecutor持有改接口对象，在初始化ThreadPoolExecutor的时候再指定使用哪种策略，下面我们看一下其他策略源码： 12345678910111213141516171819202122232425//该策略直接调用被拒绝任务的Run函数强制执行任务public static class CallerRunsPolicy implements RejectedExecutionHandler &#123; public CallerRunsPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; r.run(); &#125; &#125;&#125;//该策略忽略被拒任务，不做任何处理public static class DiscardPolicy implements RejectedExecutionHandler &#123; public DiscardPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; &#125;&#125;//该策略丢弃阻塞队列中等待最久的任务（下一个被执行的任务），再次提交被拒任务public static class implements RejectedExecutionHandler &#123; public DiscardOldestPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; e.getQueue().poll(); e.execute(r); &#125; &#125;&#125; 到此我们可以画一个简单的类图表示上述类型之间的关系：可以说这是一个很典型的策略模式类图了。 策略模式其思想是针对一组算法，将每一种算法都封装到具有共同接口的独立的类中，从而是它们可以相互替换。策略模式的最大特点是使得算法可以在不影响客户端的情况下发生变化，从而改变不同的功能。 下图所示为策略模式的UML图，上文所述的ThreadPoolExecutor就是Context，contextInterface指的就是reject函数。 策略模式的优缺点 优点 策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码转移到父类里面，从而避免重复的代码。 策略模式提供了可以替换继承关系的办法。继承可以处理多种算法或行为。如果不是用策略模式，那么使用算法或行为的环境类就可能会有一些子类，每一个子类提供一个不同的算法或行为。但是，这样一来算法或行为的使用者就和算法或行为本身混在一起。决定使用哪一种算法或采取哪一种行为的逻辑就和算法或行为的逻辑混合在一起，从而不可能再独立演化。继承使得动态改变算法或行为变得不可能。 使用策略模式可以避免使用多重条件转移语句。多重转移语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重转移语句里面，比使用继承的办法还要原始和落后。 缺点 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道所有的算法或行为的情况。 策略模式造成很多的策略类，每个具体策略类都会产生一个新类。有时候可以通过把依赖于环境的状态保存到客户端里面，而将策略类设计成可共享的，这样策略类实例可以被不同客户端使用。换言之，可以使用享元模式来减少对象的数量。 应用场景 多个类只区别在表现行为不同，可以使用Strategy模式，在运行时动态选择具体要执行的行为。 需要在不同情况下使用不同的策略(算法)，或者策略还可能在未来用其它方式来实现。 对客户隐藏具体策略(算法)的实现细节，彼此完全独立。 参考文档：www.w3sdesign.com/strategy_design_pattern.php","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://zzkenyon.github.io/tags/设计模式/"}],"keywords":[]},{"title":"linux命令-tail","slug":"linux命令-tail","date":"2017-04-23T07:52:38.000Z","updated":"2019-05-23T03:03:01.787Z","comments":true,"path":"2017/04/23/linux命令-tail/","link":"","permalink":"http://zzkenyon.github.io/2017/04/23/linux命令-tail/","excerpt":"","text":"tail显示文件的末尾部分，默认显示10行 举例：看日志文件时 1tail -fn 30 xxxx.log","categories":[],"tags":[{"name":"linux命令","slug":"linux命令","permalink":"http://zzkenyon.github.io/tags/linux命令/"}],"keywords":[]},{"title":"linux命令-nohup","slug":"linux命令-nohup","date":"2017-04-23T07:39:40.000Z","updated":"2019-05-23T03:03:26.891Z","comments":true,"path":"2017/04/23/linux命令-nohup/","link":"","permalink":"http://zzkenyon.github.io/2017/04/23/linux命令-nohup/","excerpt":"","text":"nohup 是 no hang up 的缩写，就是不挂断的意思。 nohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以 使用nohup命令,该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。 在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中。nohup 命令运行由 Command参数和任何相关的Arg参数指定的命令，忽略所有挂断（SIGHUP）信号。在注销后使用 nohup 命令运行后台中的程序。要运行后台中的 nohup 命令，添加 &amp; （表示“and”的符号）到命令的尾部。 案例1. nohup command &gt; myout.file 2&gt;&amp;1 &amp;在上面的例子中，0 – stdin (standard input)，1 – stdout (standard output)，2 – stderr (standard error) ；2&gt;&amp;1是将标准错误（2）重定向到标准输出（&amp;1），标准输出（&amp;1）再被重定向输入到myout.file文件中。 2. 0 22 * /usr/bin/python /home/pu/download_pdf/download_dfcf_pdf_to_oss.py &gt; /home/pu/download_pdf/download_dfcf_pdf_to_oss.log 2&gt;&amp;1这是放在crontab中的定时任务，晚上22点时候怕这个任务，启动这个python的脚本，并把日志写在download_dfcf_pdf_to_oss.log文件中 nohup和&amp;的区别&amp; ： 指在后台运行nohup ： 不挂断的运行，注意并没有后台运行的功能，就是指用nohup运行命令可以使命令永久的执行下去，和用户终端没有关系，例如我们断开SSH连接都不会影响他的运行 例如： sh test.sh &amp;将sh test.sh任务放到后台 ，关闭xshell，对应的任务也跟着停止。 nohup sh test.sh将sh test.sh任务放到后台，关闭标准输入，终端不再能够接收任何输入（标准输入），重定向标准输出和标准错误到当前目录下的nohup.out文件，即使关闭xshell退出当前session依然继续运行。 nohup sh test.sh &amp;将sh test.sh任务放到后台，但是依然可以使用标准输入，终端能够接收任何输入，重定向标准输出和标准错误到当前目录下的nohup.out文件，即使关闭xshell退出当前session依然继续运行。","categories":[],"tags":[{"name":"linux命令","slug":"linux命令","permalink":"http://zzkenyon.github.io/tags/linux命令/"}],"keywords":[]},{"title":"postgreSQL 让主键自增","slug":"数据库-postgreSQL-让主键自增","date":"2017-03-21T01:48:56.000Z","updated":"2019-04-25T08:55:20.000Z","comments":true,"path":"2017/03/21/数据库-postgreSQL-让主键自增/","link":"","permalink":"http://zzkenyon.github.io/2017/03/21/数据库-postgreSQL-让主键自增/","excerpt":"","text":"1.建表时创建12345678CREATE TABLE test( test_id SERIAL primary key , test_name character varying, contactname character varying, phone character varying, country character varying ) 2.在已建表的情况下创建12345678CREATE SEQUENCE test_id_seq START WITH 1 INCREMENT BY 1 NO MINVALUE NO MAXVALUE CACHE 1; alter table test alter column id set default nextval(&apos;test_id_seq&apos;);","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://zzkenyon.github.io/tags/数据库/"}],"keywords":[]},{"title":"java编程-移位操作符","slug":"Java编程-移位操作符","date":"2016-12-23T13:00:45.000Z","updated":"2019-05-23T02:57:03.740Z","comments":true,"path":"2016/12/23/Java编程-移位操作符/","link":"","permalink":"http://zzkenyon.github.io/2016/12/23/Java编程-移位操作符/","excerpt":"","text":"在java代码优化时一般会遵循一个原则， 尽量使用移位来代替’a/b’和’a*b’的操作，这两个操作代价很高，使用移位操作将会更快更有效。 1、三种移位操作 “&lt;&lt;” 不带符号左移，符号位不动，低位补0，高位丢失 “&gt;&gt;” 不带符号右移，符号位不动，正数高位补0，负数高位补1(机器数为补码)，低位丢失 “&gt;&gt;&gt;” 带符号右移，高位补0，低位丢失 2、五种左操作数类型左操作数有五种：long, int, short, byte, char int 移位时左操作数是32位的，此时移位操作作用到32bit上 long 移位时做操作数是64位的，此时移位操作作用到32bit上 short byte char 在移位之前先将左操作数转换成int，然后在32bit上进行移位最终得到一个int类型，所以用&gt;&gt;=,&gt;&gt;&gt;=, &lt;&lt;= 其实是将得到的int做低位截取得到的数值，这里往往容易犯错。 3、右操作数有坑 如果左操作数（转换之后的）是int,那么右操作数只有低5位有效，因为int只有32位，低5位最多可以移动31位 如果左边操作数是long，那么右边操作数只有低6位有效，同理 4、移位操作是对补码进行的 正数的 补码 = 原码 负数的 补码 = 反码 + 1 补码的补码等于原码","categories":[],"tags":[{"name":"java编程","slug":"java编程","permalink":"http://zzkenyon.github.io/tags/java编程/"}],"keywords":[]},{"title":"设计模式之代理模式","slug":"设计模式之代理模式","date":"2016-08-19T13:23:12.000Z","updated":"2019-05-17T04:52:20.000Z","comments":true,"path":"2016/08/19/设计模式之代理模式/","link":"","permalink":"http://zzkenyon.github.io/2016/08/19/设计模式之代理模式/","excerpt":"","text":"代理模式提供了目标对象另外的访问方式，在不修改目标类型的基础上对目标类型进行扩展，符合设计模式中遵循的开闭原则，对扩展开放，对修改关闭。 1. 静态代理静态代理在使用时需要定义接口或者超类，被代理对象与代理对象一起实现同一个接口或者是继承同一个超类。 下面举个例子说明：我们在购买火车票时可以到火车站购买，也可到各个代售点购买，火车站就是目标对象，代售点即是代理对象，他们都能完成购票，最主要的是代售点使用的售票接口就是车站官方的售票接口。 票务接口 TicketService.java1234public interface TicketService&#123; void buyTicket(); void refund();//退票&#125; 目标对象车站 Station.java12345678public class Station implement TicketService&#123; public void buyTicket()&#123; System.out.println(&quot;----买票-----&quot;); &#125; public void refund()&#123; System.out.println(&quot;----退票----&quot;); &#125;&#125; 代理对象代售处 Agency.java12345678910public class Agency implement TicketService&#123; private Station station; public void buyTicket()&#123; System.out.println(&quot;----这里是代售点-----&quot;); station.buyTicket(); &#125; public void refund()&#123; System.out.println(&quot;----代售点不支持退票----&quot;) &#125;&#125; 静态代理可以在不修改目标对象的前提下对目标扩展，但也存在缺点。 因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多；此外，一旦接口增加方法,目标对象与代理对象都要维护。那么如何解决这些缺点呢，JDK中给出了动态代理的解决方案。 2. 动态代理动态代理又叫做JDK代理，接口代理 动态代理的特点： 代理对象不需要实现接口 代理对象的生成，是利用JDK中的api，动态的在内存中构建代理对象（需要我们指定创建代理对象/目标对象实现的接口类型） JDK中生成代理对象的API代理类所在包:java.lang.reflect.ProxyJDK实现代理只需要使用newProxyInstance方法，但是该方法需要接收三个参数，完整的写法是:1static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h ) 注意该方法是在Proxy类中是静态方法,且接收的三个参数依次为: ClassLoader loader：指定当前目标对象使用类加载器,获取加载器的方法是固定的 Class&lt;?&gt;[] interfaces：目标对象实现的接口的类型,使用泛型方式确认类型 InvocationHandler h：事件处理,执行目标对象的方法时，会触发事件处理器的方法，会把当前执行目标对象的方法作为参数传入。 代码示例:接口类 TicketService.java以及接口实现类,目标对象Station是一样的，没有做修改。在这个基础上，增加一个代理工厂类(ProxyFactory.java)，将代理类写在这个地方，然后在测试类(需要使用到代理的代码)中先建立目标对象和代理对象的联系，然后代用代理对象的中同名方法代理工厂类:ProxyFactory.java 1234567891011121314151617181920212223242526public class ProxyFactory&#123; //维护一个目标对象 private Object target; public ProxyFactory(Object target)&#123; this.target=target; &#125; //给目标对象生成代理对象 public Object getProxyInstance()&#123; return Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;--这是代售点购票系统--&quot;); //执行目标对象方法 Object returnValue = method.invoke(target, args); return returnValue; &#125; &#125; ); &#125;&#125; 测试类:DynamicProxyTest.java123456789101112public class DynamicProxyTest &#123; public static void main(String[] args) &#123; // 目标对象 TicketService target = new Station(); System.out.println(target.getClass()); // 创建代理对象 TicketService proxy = (TicketService) new ProxyFactory(target).getProxyInstance(); System.out.println(proxy.getClass()); // 代理对象执行方法 proxy.buyTicket(); &#125;&#125; 总结：代理对象不需要实现接口，但是目标对象一定要实现接口，否则不能用动态代理。 3. Cglib代理上面的静态代理和动态代理模式都是要求目标对象是实现一个接口的目标对象，但是有时候目标对象只是一个单独的对象,并没有实现任何的接口，这个时候就可以使用以目标对象子类的方式类实现代理，这种方法就叫做:Cglib代理 Cglib代理，也叫作子类代理，它是在内存中构建一个子类对象从而实现对目标对象功能的扩展。 JDK的动态代理有一个限制，就是使用动态代理的对象必须实现一个或多个接口，如果想代理没有实现接口的类,就可以使用Cglib实现。 Cglib是一个强大的高性能的代码生成包，它可以在运行期扩展java类与实现java接口。它广泛的被许多AOP的框架使用，例如Spring AOP和synaop，为他们提供方法的interception(拦截)。 Cglib包的底层是通过使用一个小而块的字节码处理框架ASM来转换字节码并生成新的类。不鼓励直接使用ASM,因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。 Cglib子类代理实现方法: 需要引入cglib的jar文件，但是Spring的核心包中已经包括了Cglib功能,所以直接引入pring-core-3.2.5.jar即可。 引入功能包后，就可以在内存中动态构建子类 代理的类不能为final，否则报错 目标对象的方法如果为final/stati，那么就不会被拦截，即不会执行目标对象额外的业务方法。 代码示例:目标对象类 Station.java ，目标对象,没有实现任何接口123456public class Station &#123; public void buyTicket() &#123; System.out.println(&quot;----买票----&quot;); &#125;&#125; Cglib代理工厂 ProxyFactory.java123456789101112131415161718192021222324252627public class ProxyFactory implements MethodInterceptor&#123; private Object target; public ProxyFactory(Object target) &#123; this.target = target; &#125; //给目标对象创建一个代理对象 public Object getProxyInstance()&#123; //1.工具类 Enhancer en = new Enhancer(); //2.设置父类 en.setSuperclass(target.getClass()); //3.设置回调函数 en.setCallback(this); //4.创建子类(代理对象) return en.create(); &#125; @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; System.out.println(&quot;--这是代售点购票系统--&quot;); //执行目标对象的方法 Object returnValue = method.invoke(target, args); return returnValue; &#125;&#125; 测试类:1234567891011public class CglibProxyTest &#123; @Test public void test()&#123; //目标对象 Station target = new Station(); //代理对象 Station proxy = (Station)new ProxyFactory(target).getProxyInstance(); //执行代理对象的方法 proxy.buyTicket(); &#125;&#125; 在Spring的AOP编程中:如果加入容器的目标对象有实现接口，用JDK代理如果目标对象没有实现接口，用Cglib代理","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://zzkenyon.github.io/tags/设计模式/"}],"keywords":[]},{"title":"设计模式之单例模式","slug":"设计模式之单例模式","date":"2016-08-04T07:15:31.000Z","updated":"2019-04-25T07:16:26.000Z","comments":true,"path":"2016/08/04/设计模式之单例模式/","link":"","permalink":"http://zzkenyon.github.io/2016/08/04/设计模式之单例模式/","excerpt":"","text":"许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。 1、什么是单例1.1 定义单例模式，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。 1.2 实现思路面向对象编程中，我们通过类的构造器生成对象，只要内存足够就可以构造出很多个实例，所以要限制某个类型只有唯一的一个实例对象，那就要从构造函数着手。 需要声明一个能返回对象的引用，定义一个获得该对象引用的方法（必须是静态方法，通常使用getInstance这个名称) 当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用 最后将该类的构造函数定义为私有方法 2、懒汉式单例按照以上的实现思路，实现出第一个单例类型：1234567891011public class Singleton &#123; private static Singleton instance; //引用 private Singleton ()&#123;&#125; //私有构造器 public static Singleton getInstance() &#123; //静态方法 if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 这种实现方式称为懒汉式，所谓懒汉，指的是只有在需要对象的时候才生成。 2.1 单例的线程安全单例的线程安全是指在并发环境中，不同的线程拿到的单例对象也必须保证是同一个实例。 上文实现的单例类型是线程不安全的，如果有两个线程同时执行到 if (instance == null) 这行代码，判断都通过，然后各自执行 new 语句并各自返回一个实例，这时候就产生了多个对象。 解决方法有两种： 给getInstance方法加互斥锁(不推荐使用) 12345678910public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 缺点：效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低要改进。 双重检验锁（推荐使用）1234567891011121314public class Singleton &#123; private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; &#125; Double-Check概念对于多线程开发者来说不会陌生，如代码中所示，我们进行了两次if (singleton == null)检查,这样实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)，直接return实例化对象。 还有值得注意的是，双重校验锁的实现方式中，静态成员变量singleton必须通过volatile来修饰，保证其初始化的原子性，否则可能被引用到一个未初始化完成的对象。 3、饿汉式单例前面提到的懒汉模式，其实是一种lazy-loading思想的实践，这种实现有一个比较大的好处，就是只有真正用到的时候才创建，如果没被使用到，就一直不会被创建，这就避免了不必要的开销。 但是这种做法，其实也有一个小缺点，就是第一次使用的时候，需要进行初始化操作，可能会有比较高的耗时。如果是已知某一个对象一定会使用到的话，其实可以采用一种饿汉的实现方式。所谓饿汉，就是事先准备好，需要的时候直接给你就行了。 1234567891011121314151617public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; public class Singleton &#123; private Singleton instance = null; static &#123; instance = new Singleton(); &#125; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return this.instance; &#125; 以上两段代码都是通过定义静态的成员变量（懒汉式只有声明没有定义）。饿汉模式中的静态变量是随着类加载时被完成实例化的。饿汉变种中的静态代码块也会随着类的加载一块执行。 因为类的初始化是由ClassLoader完成的，这其实是利用了ClassLoader的线程安全机制。ClassLoader的loadClass方法在加载类的时候使用了synchronized关键字。也正是因为这样， 除非被重写，这个方法默认在整个装载过程中都是同步的（线程安全的） 除了以上两种饿汉方式，还有一种实现方式也是借助了calss的初始化来实现的，那就是通过静态内部类来实现的单例（推荐使用）： 123456789public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; &#125; 前面提到的饿汉模式，只要Singleton类被装载了，那么instance就会被实例化。 而这种方式是Singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。 使用静态内部类，借助了classloader来实现了线程安全，这与饿汉模式有着异曲同工之妙，但是他有兼顾了懒汉模式的lazy-loading功能，相比较之下，有很大优势。 4、枚举式单例Joshua Bloch大神在《Effective Java》中明确表达过的观点： 使用枚举实现单例的方法虽然还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法。 枚举单例：（墙裂推荐）12345public enum Singleton &#123; INSTANCE; public void whateverMethod() &#123; &#125; &#125; 最精简的 线程安全的 可解决反序列化破坏单例的问题 5、应用场景 Windows的Task Manager（任务管理器）就是很典型的单例模式 windows的Recycle Bin（回收站）也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。 操作系统的文件系统，也是大的单例模式实现的具体例子，一个操作系统只能有一个文件系统。 网站的计数器，一般也是采用单例模式实现，否则难以同步。 应用程序的日志应用，一般都何用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。 Web应用的配置对象的读取，一般也应用单例模式，这个是由于配置文件是共享的资源。 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。数据库软件系统中使用数据库连接池，主要是节省打开或者关闭数据库连接所引起的效率损耗，这种效率上的损耗还是非常昂贵的，用单例模式来维护，就可以大大降低这种损耗。 多线程的线程池的设计一般也是采用单例模式，这是由于线程池要方便对池中的线程进行控制。 HttpApplication 也是单例的典型应用。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://zzkenyon.github.io/tags/设计模式/"}],"keywords":[]},{"title":"设计模式之建造者模式","slug":"设计模式之建造者模式","date":"2016-08-02T05:35:36.000Z","updated":"2019-04-24T08:30:10.000Z","comments":true,"path":"2016/08/02/设计模式之建造者模式/","link":"","permalink":"http://zzkenyon.github.io/2016/08/02/设计模式之建造者模式/","excerpt":"","text":"静态工厂和构造器有一个共同的局限性：不能很好的扩展到大量的可选参数。对于初始化参数很多的类，常规的做法是使用重载构造器，但是当参数很多的时候，客户端代码会很难写，并且较难阅读。 这时，还有另外一种替代方案，使用javaBean模式，在这种模式下先默认构造器创建对象，然后用setter方法设置需要的参数。遗憾的是，JavaBean模式自身有着很严重的缺点，因为构造过程分成了好几个调用，在构造过程中JavaBean可能处于不一致的状态，类无法仅仅通过检查构造器参数的有效性来保证一致性。 最终还有第三种替代方案，既能确保安全性，也能保证可读性，那就是建造者模式。 1. 建造者模式直接看一个简单例子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Person &#123; private final String name; private final String address; private final int age; private final int sex; private final String tel; public static class Builder &#123; //Required parameters private final String name; private final int age; private final int sex; //Optional parameters private String address = &quot;浙江杭州&quot;; private String tel = &quot;0571&quot;; public Builder(String name, int age, int sex) &#123; this.name = name; this.age = age; this.sex = sex; &#125; public Builder address(String address) &#123; this.address = address; return this; &#125; public Builder tel(String tel) &#123; this.tel = tel; return this; &#125; public Person build()&#123; return new Person(this); &#125; &#125; private Person(Builder builder)&#123; name = builder.name; address = builder.address; sex = builder.sex; age = builder.age; tel = builder.tel; &#125; public static void main(String[] args)&#123; Person p = new Builder(&quot;zhaozhengkang&quot;,25,1).address(&quot;yuhang&quot;).tel(&quot;123456789&quot;).build(); &#125;&#125; builder的设值方法返回builder本身，以便把调用连接起来形成一个流式的API. 2. 类层次中使用建造者模式 （effective java rule2,30）使用平行层次结构的builder时，各自嵌套在相应类中。抽象类有抽象类的builder，具体类有具体类的builder。12345678910111213141516171819public abstract class Pizza &#123; public enum Topping &#123; HAM, MUSHROOM, ONION, PEPPER, SAUSAGE &#125; final Set&lt;Topping&gt; toppings; abstract static class Builder&lt;T extends Builder&lt;T&gt;&gt;&#123; EnumSet&lt;Topping&gt; toppings = EnumSet.noneOf(Topping.class); public T addTopping(Topping topping)&#123; toppings.add(Objects.requireNonNull(topping)); return self(); &#125; abstract Pizza build(); protected abstract T self(); &#125; Pizza(Builder&lt;?&gt; builder)&#123; toppings = builder.toppings.clone(); &#125;&#125; Builder&lt;T extends Builder&gt;这一句使用了递归类型限制中的模拟自类型模拟自类型（自限定类型）所做的就是要求在继承关系中，强制要求将正在定义的类当做参数传递给基类，看下面代码： 1234567891011121314151617181920212223242526public class NyPizza extends Pizza &#123; public enum Size&#123;SMALL, MEDIUM, LARGER&#125; private final Size size; public static class NyPizzaBuilder extends Pizza.Builder&lt;NyPizzaBuilder&gt;&#123; private final Size size; public NyPizzaBuilder(Size size)&#123; this.size = Objects.requireNonNull(size); &#125; @Override public NyPizza build() &#123; return new NyPizza(this); &#125; @Override protected NyPizzaBuilder self() &#123; return this; &#125; &#125; private NyPizza(NyPizzaBuilder builder) &#123; super(builder); size = builder.size; &#125; public static void main(String[] args)&#123; NyPizza p = new NyPizzaBuilder(Size.SMALL).addTopping(Topping.SAUSAGE).addTopping(Topping.ONION).build(); &#125;&#125; 继承时，必须将正在定义的类NyPizzaBuilder作为类型参数传给基类Pizza.Builder，否则无法编译。自限定类型属于泛型知识，将另开一篇进行研究。 参考资料《Effcitive Java》","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://zzkenyon.github.io/tags/设计模式/"}],"keywords":[]},{"title":"设计模式之工厂模式","slug":"设计模式之工厂模式","date":"2016-08-01T05:35:36.000Z","updated":"2019-04-24T08:34:02.000Z","comments":true,"path":"2016/08/01/设计模式之工厂模式/","link":"","permalink":"http://zzkenyon.github.io/2016/08/01/设计模式之工厂模式/","excerpt":"","text":"1. 简单工厂根据客户端传入的参数进行判断，再决定创建哪种实例，缺点很明显： 传参错误则不能创建正确的实例 扩展需要修改工厂方法 2.工厂方法在工厂类中定义若干的函数来创建实例，每个函数创建一种实例，解决的简单工厂需要传参的问题 3. 静态工厂方法3.1 定义将工厂类中的工厂方法定义为静态类型，使用静态工厂不需要创建工厂实例。1234567891011121314151617public class SendFactory &#123; public static Sender produceMail()&#123; return new MailSender(); &#125; public static Sender produceSms()&#123; return new SmsSender(); &#125; &#125; public class FactoryTest &#123; public static void main(String[] args) &#123; Sender sender = SendFactory.produceMail(); sender.Send(); &#125; &#125; （静态）工厂方法缺点是： 对于扩展需要修改工厂类 3.2 用静态工厂方法代替构造器（Effective java：rule 1）如果不通过共有构造器，或者说除了公有构造器之外，类还可以给他的客户端提供静态工厂方法，这样做既有优势又有劣势。优势在于： 第一点：它们有名称。使客户端代码更容易阅读，例如：构造器BigInteger(int,int,Random)返回的BigInteger可能是素数，如果用静态工厂方法BigInteger.probablePrime来表示，就会更清楚。 第二点：不必每次调用的时候都创建一个新对象。静态工厂方法能够为重复的调用返回相同的对象 第三点：静态工厂方法可以返回类型的任何子类型对象，构造器则做不到这一点。 第四点：每次调用返回对象的类可以变化，取决于静态工厂方法的参数 12345678910111213141516171819202122232425262728//该代码 解释以上四点优势public class Child &#123; protected String classId; public Child()&#123; classId = &quot;CHILD&quot;; &#125; public static class Son extends Child &#123; public Son()&#123; classId = &quot;SON&quot;; &#125; &#125; public static class Daughter extends Child &#123; public Daughter()&#123; classId = &quot;DAUGHTER&quot;; &#125; &#125; public static Child sonFactory()&#123; return new Son(); &#125; public static Child daughterFactory()&#123; return new Daughter(); &#125; public static Child childFactory(int sex)&#123; return sex == 1 ? new Son() : new Daughter(); &#125; public static void main(String[] args)&#123; Child son = Child.sonFactory(); Child child = Child.childFactory(2); System.out.println(son.classId + &quot;\\n&quot; + child.classId); &#125;&#125; 第五点：方法返回对象的类，在编写包含该静态方法的类时是可以不存在的。第五点的灵活性是构成服务提供者框架（Service Provider Framework）的基础，将另起一片单独研究。 静态工厂方法的劣势在于： 程序员很难发现这些静态工厂方法。 类如果没有公有或者受保护的构造器，就不能被子类化（不允许被继承）。 4.抽象工厂对每一个需要创建实例的类都配置了一个工厂类，需要扩展的时候，增加一个工厂类，实现工厂类的抽象方法进行实例创建，实现了开闭原则。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://zzkenyon.github.io/tags/设计模式/"}],"keywords":[]},{"title":"转载Log4j 配置文件解析","slug":"转载-Log4j-配置文件解析","date":"2016-07-23T07:39:40.000Z","updated":"2019-05-23T03:01:35.581Z","comments":true,"path":"2016/07/23/转载-Log4j-配置文件解析/","link":"","permalink":"http://zzkenyon.github.io/2016/07/23/转载-Log4j-配置文件解析/","excerpt":"","text":"1、简介Log4j有三个主要的组件： Loggers(记录器):日志类别和级别; Appenders (输出源):日志要输出的地方; Layouts(布局):日志以何种形式输出 1.1、Loggers Loggers组件在此系统中被分为五个级别,分别用来指定这条日志信息的重要程度：DEBUG、INFO、WARN、ERROR和FATAL; 这五个级别是有顺序的，DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL; Log4j有一个规则：只输出级别不低于设定级别的日志信息，假设Loggers级别设定为INFO，则INFO、WARN、ERROR和FATAL级别的日志信息都会输出，而级别比INFO低的DEBUG则不会输出。 1.2、Appenders禁用和使用日志请求只是Log4j的基本功能，Log4j日志系统还提供许多强大的功能，比如允许把日志输出到不同的地方，如控制台（Console）、文件（Files）等，可以根据天数或者文件大小产生新的文件，可以以流的形式发送到其它地方等等。 常使用的类如下： org.apache.log4j.ConsoleAppender（控制台） org.apache.log4j.FileAppender（文件） org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件） org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件） org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方） 配置模式1234log4j.appender.appenderName = classNamelog4j.appender.appenderName.Option1 = value1…log4j.appender.appenderName.OptionN = valueN 1.3、LayoutsLog4j可以在Appenders的后面附加Layouts来完成这个功能。Layouts提供四种日志输出样式，如根据HTML样式、自由指定样式、包含日志级别与信息的样式和包含日志时间、线程、类别等信息的样式。 常使用的类如下： org.apache.log4j.HTMLLayout（以HTML表格形式布局） org.apache.log4j.PatternLayout（可以灵活地指定布局模式） org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串） org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等信息） 配置模式： 1234log4j.appender.appenderName.layout =classNamelog4j.appender.appenderName.layout.Option1 = value1...log4j.appender.appenderName.layout.OptionN = valueN 2、配置详解在实际应用中，要使Log4j在系统中运行须事先设定配置文件。配置文件事实上也就是对Logger、Appender及Layout进行相应设定。Log4j支持两种配置文件格式: 一种是XML格式的文件， 一种是properties属性文件。 下面以properties属性文件为例介绍log4j.properties的配置。 2.1、配置根Logger12log4j.rootLogger = [ level ] , appenderName1, appenderName2, …log4j.additivity.org.apache=false：表示Logger不会在父Logger的appender里输出，默认为true。 level ：设定日志记录的最低级别，可设的值有OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者自定义的级别，Log4j建议只使用中间四个级别。通过在这里设定级别，您可以控制应用程序中相应级别的日志信息的开关，比如在这里设定了INFO级别，则应用程序中所有DEBUG级别的日志信息将不会被打印出来。 appenderName：就是指定日志信息要输出到哪里。可以同时指定多个输出目的地，用逗号隔开。例如：log4j.rootLogger＝INFO,A1,B2,C3 2.2、配置日志信息输出目的地（appender）1log4j.appender.appenderName = className appenderName：自定义appderName，在log4j.rootLogger设置中使用；className：可设值如下： org.apache.log4j.ConsoleAppender（控制台） org.apache.log4j.FileAppender（文件） org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件） org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件） org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方） ConsoleAppender选项 Threshold=WARN：指定日志信息的最低输出级别，默认为DEBUG。 ImmediateFlush=true：表示所有消息都会被立即输出，设为false则不输出，默认值是true。 Target=System.err：默认值是System.out。 FileAppender选项 Threshold=WARN：指定日志信息的最低输出级别，默认为DEBUG。 ImmediateFlush=true：表示所有消息都会被立即输出，设为false则不输出，默认值是true。 Append=false：true表示消息增加到指定文件中，false则将消息覆盖指定的文件内容，默认值是true。 File=D:/logs/logging.log4j：指定消息输出到logging.log4j文件中。 DailyRollingFileAppender选项 Threshold=WARN：指定日志信息的最低输出级别，默认为DEBUG。 ImmediateFlush=true：表示所有消息都会被立即输出，设为false则不输出，默认值是true。 Append=false：true表示消息增加到指定文件中，false则将消息覆盖指定的文件内容，默认值是true。 File=D:/logs/logging.log4j：指定当前消息输出到logging.log4j文件中。 DatePattern=’.’yyyy-MM：每月滚动一次日志文件，即每月产生一个新的日志文件。当前月的日志文件名为logging.log4j，前一个月的日志文件名为logging.log4j.yyyy-MM。另外，也可以指定按周、天、时、分等来滚动日志文件，对应的格式如下：123456&apos;.&apos;yyyy-MM：每月&apos;.&apos;yyyy-ww：每周&apos;.&apos;yyyy-MM-dd：每天&apos;.&apos;yyyy-MM-dd-a：每天两次&apos;.&apos;yyyy-MM-dd-HH：每小时&apos;.&apos;yyyy-MM-dd-HH-mm：每分钟 RollingFileAppender选项 Threshold=WARN：指定日志信息的最低输出级别，默认为DEBUG。 ImmediateFlush=true：表示所有消息都会被立即输出，设为false则不输出，默认值是true。 Append=false：true表示消息增加到指定文件中，false则将消息覆盖指定的文件内容，默认值是true。 File=D:/logs/logging.log4j：指定消息输出到logging.log4j文件中。 MaxFileSize=100KB：后缀可以是KB, MB 或者GB。在日志文件到达该大小时，将会自动滚动，即将原来的内容移到logging.log4j.1文件中。 MaxBackupIndex=2：指定可以产生的滚动文件的最大数，例如，设为2则可以产生logging.log4j.1，logging.log4j.2两个滚动文件和一个logging.log4j文件。 2.3、配置日志信息的输出格式（Layout）1log4j.appender.appenderName.layout=className className：可设值如下： org.apache.log4j.HTMLLayout（以HTML表格形式布局） org.apache.log4j.PatternLayout（可以灵活地指定布局模式） org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串） org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息） HTMLLayout选项 LocationInfo=true：输出java文件名称和行号，默认值是false。 Title=My Logging： 默认值是Log4J Log Messages。 PatternLayout选项：ConversionPattern=%m%n：设定以怎样的格式显示消息。 格式化符号说明：12345678910111213%p：输出日志信息的优先级，即DEBUG，INFO，WARN，ERROR，FATAL。%d：输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，如：%d&#123;yyyy/MM/dd HH:mm:ss,SSS&#125;。%r：输出自应用程序启动到输出该log信息耗费的毫秒数。%t：输出产生该日志事件的线程名。%l：输出日志事件的发生位置，相当于%c.%M(%F:%L)的组合，包括类全名、方法、文件名以及在代码中的行数。例如：test.TestLog4j.main(TestLog4j.java:10)。%c：输出日志信息所属的类目，通常就是所在类的全名。%M：输出产生日志信息的方法名。%F：输出日志消息产生时所在的文件名称。%L:：输出代码中的行号。%m:：输出代码中指定的具体日志信息。%n：输出一个回车换行符，Windows平台为&quot;\\r\\n&quot;，Unix平台为&quot;\\n&quot;。%x：输出和当前线程相关联的NDC(嵌套诊断环境)，尤其用到像java servlets这样的多客户多线程的应用中。%%：输出一个&quot;%&quot;字符。 另外，还可以在%与格式字符之间加上修饰符来控制其最小长度、最大长度、和文本的对齐方式。如： 指定输出category的名称，最小的长度是20，如果category的名称长度小于20的话，默认的情况下右对齐。 %-20c：”-“号表示左对齐。 %.30c：指定输出category的名称，最大的长度是30，如果category的名称长度大于30的话，就会将左边多出的字符截掉，但小于30的话也不会补空格。 附：Log4j比较全面的配置Log4j配置文件实现了输出到控制台、文件、回滚文件、发送日志邮件、输出到数据库日志表、自定义标签等全套功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475log4j.rootLogger=DEBUG,console,dailyFile,imlog4j.additivity.org.apache=true# 控制台(console)log4j.appender.console=org.apache.log4j.ConsoleAppenderlog4j.appender.console.Threshold=DEBUGlog4j.appender.console.ImmediateFlush=truelog4j.appender.console.Target=System.errlog4j.appender.console.layout=org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n# 日志文件(logFile)log4j.appender.logFile=org.apache.log4j.FileAppenderlog4j.appender.logFile.Threshold=DEBUGlog4j.appender.logFile.ImmediateFlush=truelog4j.appender.logFile.Append=truelog4j.appender.logFile.File=D:/logs/log.log4jlog4j.appender.logFile.layout=org.apache.log4j.PatternLayoutlog4j.appender.logFile.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n# 回滚文件(rollingFile)log4j.appender.rollingFile=org.apache.log4j.RollingFileAppenderlog4j.appender.rollingFile.Threshold=DEBUGlog4j.appender.rollingFile.ImmediateFlush=truelog4j.appender.rollingFile.Append=truelog4j.appender.rollingFile.File=D:/logs/log.log4jlog4j.appender.rollingFile.MaxFileSize=200KBlog4j.appender.rollingFile.MaxBackupIndex=50log4j.appender.rollingFile.layout=org.apache.log4j.PatternLayoutlog4j.appender.rollingFile.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n# 定期回滚日志文件(dailyFile)log4j.appender.dailyFile=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.dailyFile.Threshold=DEBUGlog4j.appender.dailyFile.ImmediateFlush=truelog4j.appender.dailyFile.Append=truelog4j.appender.dailyFile.File=D:/logs/log.log4jlog4j.appender.dailyFile.DatePattern=&apos;.&apos;yyyy-MM-ddlog4j.appender.dailyFile.layout=org.apache.log4j.PatternLayoutlog4j.appender.dailyFile.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n# 应用于socketlog4j.appender.socket=org.apache.log4j.RollingFileAppenderlog4j.appender.socket.RemoteHost=localhostlog4j.appender.socket.Port=5001log4j.appender.socket.LocationInfo=true# Set up for Log Factor 5log4j.appender.socket.layout=org.apache.log4j.PatternLayoutlog4j.appender.socket.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n# Log Factor 5 Appenderlog4j.appender.LF5_APPENDER=org.apache.log4j.lf5.LF5Appenderlog4j.appender.LF5_APPENDER.MaxNumberOfRecords=2000# 发送日志到指定邮件log4j.appender.mail=org.apache.log4j.net.SMTPAppenderlog4j.appender.mail.Threshold=FATALlog4j.appender.mail.BufferSize=10log4j.appender.mail.From = xxx@mail.comlog4j.appender.mail.SMTPHost=mail.comlog4j.appender.mail.Subject=Log4J Messagelog4j.appender.mail.To= xxx@mail.comlog4j.appender.mail.layout=org.apache.log4j.PatternLayoutlog4j.appender.mail.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n# 应用于数据库log4j.appender.database=org.apache.log4j.jdbc.JDBCAppenderlog4j.appender.database.URL=jdbc:mysql://localhost:3306/testlog4j.appender.database.driver=com.mysql.jdbc.Driverlog4j.appender.database.user=rootlog4j.appender.database.password=log4j.appender.database.sql=INSERT INTO LOG4J (Message) VALUES(&apos;=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n&apos;)log4j.appender.database.layout=org.apache.log4j.PatternLayoutlog4j.appender.database.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n# 自定义Appenderlog4j.appender.im = net.cybercorlin.util.logger.appender.IMAppenderlog4j.appender.im.host = mail.cybercorlin.netlog4j.appender.im.username = usernamelog4j.appender.im.password = passwordlog4j.appender.im.recipient = corlin@cybercorlin.netlog4j.appender.im.layout=org.apache.log4j.PatternLayoutlog4j.appender.im.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n 附: 输出独立日志文件log4j的强大功能无可置疑，但实际应用中免不了遇到某个功能需要输出独立的日志文件的情况，怎样才能把所需的内容从原有日志中分离，形成单独的日志文件呢？其实只要在现有的log4j基础上稍加配置即可轻松实现这一功能。 常见先看一个常见的log4j.properties文件，它是在控制台和myweb.log文件中记录日志：123456789101112131415log4j.rootLogger=DEBUG, stdout, logfile log4j.category.org.springframework=ERRORlog4j.category.org.apache=INFO log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m%n log4j.appender.logfile=org.apache.log4j.RollingFileAppenderlog4j.appender.logfile.File=$&#123;myweb.root&#125;/WEB-INF/log/myweb.loglog4j.appender.logfile.MaxFileSize=512KBlog4j.appender.logfile.MaxBackupIndex=5log4j.appender.logfile.layout=org.apache.log4j.PatternLayoutlog4j.appender.logfile.layout.ConversionPattern=%d %p [%c] - %m%n 不同类输出不同文件如果想对不同的类输出不同的文件(以cn.com.Test为例)，先要在Test.java中定义: 12345678private static Log logger = LogFactory.getLog(Test.class); 然后在log4j.properties中加入:log4j.logger.cn.com.Test= DEBUG, testlog4j.appender.test=org.apache.log4j.FileAppenderlog4j.appender.test.File=$&#123;myweb.root&#125;/WEB-INF/log/test.loglog4j.appender.test.layout=org.apache.log4j.PatternLayoutlog4j.appender.test.layout.ConversionPattern=%d %p [%c] - %m%n 也就是让cn.com.Test中的logger使用log4j.appender.test所做的配置。 同一类输出多个日志文件但是，如果在同一类中需要输出多个日志文件呢？其实道理是一样的，先在Test.java中定义: 12private static Log logger1 = LogFactory.getLog(&quot;myTest1&quot;);private static Log logger2 = LogFactory.getLog(&quot;myTest2&quot;); 然后在log4j.properties中加入: 1234567891011log4j.logger.myTest1= DEBUG, test1log4j.appender.test1=org.apache.log4j.FileAppenderlog4j.appender.test1.File=$&#123;myweb.root&#125;/WEB-INF/log/test1.loglog4j.appender.test1.layout=org.apache.log4j.PatternLayoutlog4j.appender.test1.layout.ConversionPattern=%d %p [%c] - %m%n log4j.logger.myTest2= DEBUG, test2log4j.appender.test2=org.apache.log4j.FileAppenderlog4j.appender.test2.File=$&#123;myweb.root&#125;/WEB-INF/log/test2.loglog4j.appender.test2.layout=org.apache.log4j.PatternLayoutlog4j.appender.test2.layout.ConversionPattern=%d %p [%c] - %m%n 也就是在用logger时给它一个自定义的名字(如这里的”myTest1”)，然后在log4j.properties中做出相应配置即可。别忘了不同日志要使用不同的logger如输出到test1.log的要用logger1.info(“abc”)。 还有一个问题，就是这些自定义的日志默认是同时输出到log4j.rootLogger所配置的日志中的，如何能只让它们输出到自己指定的日志中呢？别急，这里有个开关： 1log4j.additivity.myTest1 = false 它用来设置是否同时输出到log4j.rootLogger所配置的日志中，设为false就不会输出到其它地方啦！注意这里的”myTest1”是你在程序中给logger起的那个自定义的名字！如果你说，我只是不想同时输出这个日志到log4j.rootLogger所配置的logfile中，stdout里我还想同时输出呢！那也好办，把你的log4j.logger.myTest1 = DEBUG, test1改为下式就OK啦！ 1log4j.logger.myTest1=DEBUG, test1","categories":[],"tags":[{"name":"转载","slug":"转载","permalink":"http://zzkenyon.github.io/tags/转载/"}],"keywords":[]},{"title":"Mysql 5.7 windows下安装","slug":"数据库-Mysql-5-7-windows下安装","date":"2016-05-10T02:56:23.000Z","updated":"2019-04-25T08:55:06.000Z","comments":true,"path":"2016/05/10/数据库-Mysql-5-7-windows下安装/","link":"","permalink":"http://zzkenyon.github.io/2016/05/10/数据库-Mysql-5-7-windows下安装/","excerpt":"","text":"1. 下载选择zip格式的压缩包，解压到指定盘中D:\\mysql-5.7 2. 配置环境变量MYSQL_HOME:D:\\mysql-5.7在path 后面添加 ;%MYSQL_HOME%\\bin 3. 添加文件my.ini文件将如下代码放入my.ini文件中basedir和datadir，请根据实际安装目录进行修改 [mysql] # 设置mysql客户端默认字符集 default-character-set=utf8 [mysqld] #设置3306端口 port = 3306 # 设置mysql的安装目录 basedir=D:\\mysql5.7 # 设置mysql数据库的数据的存放目录 datadir=D:\\mysql5.7\\data # 允许最大连接数 max_connections=200 # 服务端使用的字符集默认为8比特编码的latin1字符集 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB 4. 打开cmd.exe必须以管理员的身份运行，从c:/windows/systen32文件夹中找到cmd.exe，右击以管理员身份打开。 5. 初始化数据库mysqld –initialize –user=mysql –console记住分配的密码:最后一行（很重要） 6. 安装服务mysqld –install MySQL 7. 启动服务net start MySQL 8. 修改初始化密码使用初始密码登陆后,执行下面指令：set password for root@localhost=password(‘111111’); * 附录：相关指令 停止服务：net stop MySQL 删除服务：sc delete MySQL 移除mysql：mysqld -remove MySQL","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://zzkenyon.github.io/tags/数据库/"}],"keywords":[]}]}