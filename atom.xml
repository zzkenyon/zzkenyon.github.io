<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>黑风雅过吟</title>
  
  <subtitle>不积跬步无以至千里</subtitle>
  <link href="/zzkenyon.github.io/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/child/"/>
  <updated>2019-06-09T12:14:33.240Z</updated>
  <id>http://yoursite.com/child/</id>
  
  <author>
    <name>Zhao Zhengkang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nio-入门篇-应用案例讲解</title>
    <link href="http://yoursite.com/child/2019/05/26/nio-%E5%85%A5%E9%97%A8%E7%AF%87-%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B%E8%AE%B2%E8%A7%A3/"/>
    <id>http://yoursite.com/child/2019/05/26/nio-入门篇-应用案例讲解/</id>
    <published>2019-05-26T02:21:34.000Z</published>
    <updated>2019-06-09T12:14:33.240Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Buffer"><a href="#1-Buffer" class="headerlink" title="1. Buffer"></a>1. Buffer</h3><p>在channel中传输的是buffer中的数据，而不是buffer对象。</p><p>使用Buffer读写数据一般遵循以下四个步骤（buffer为读写主体）：</p><ol><li>写入数据到Buffer</li><li>调用flip()方法</li><li>从Buffer中读取数据</li><li>调用clear()方法或者compact()方法  </li></ol><p>说明：</p><ul><li>当向buffer写入数据时，buffer会记录下写了多少数据。一旦要读取数据，需要通过flip()方法将Buffer从写模式切换到读模式。在读模式下，可以读取之前写入到buffer的所有数据。</li><li>一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用clear()或compact()方法。clear()方法会清空整个缓冲区。compact()方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。<h4 id="1-1-Buffer抽象类"><a href="#1-1-Buffer抽象类" class="headerlink" title="1.1 Buffer抽象类"></a>1.1 Buffer抽象类</h4>Buffer抽象类中定义的常用方法：</li><li><strong>Buffer flip()</strong> flip方法将Buffer从写模式切换到读模式。调用flip()方法会将position设回0，并将limit设置成之前position的值。</li><li><strong>Buffer rewind()</strong> 将position设回0，所以你可以重读Buffer中的所有数据。limit保持不变，仍然表示能从Buffer中读取多少个元素（byte、char等）</li><li><strong>int remaining()</strong> 返回position到limit之间的元素个数（未读出元素个数）</li><li><strong>boolean hasRemaining()</strong> 返回是否还有未读出的数据</li><li><strong>boolean isReadOnly()</strong> 是否此buffer只能读出</li><li><strong>Buffer mark()</strong> 可以标记Buffer中的一个特定position，之后可以通过调用Buffer.reset()方法恢复到这个position。</li><li><strong>Buffer reset()</strong> 恢复到mark()标记的状态</li><li><strong>Buffer clear()</strong> 重置position、limit、capacity和mark，从读模式转换成写模式 </li></ul><p>此外Buffer还声明了几个抽象方法如下，这些方法都是在Buffer的子类中定义的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boolean hasArray();</span><br><span class="line">boolean isReadOnly();</span><br><span class="line">Object array();</span><br><span class="line">int arrayOffset();</span><br><span class="line">boolean isDirect();</span><br></pre></td></tr></table></figure></p><h4 id="1-2-Buffer的类型"><a href="#1-2-Buffer的类型" class="headerlink" title="1.2 Buffer的类型"></a>1.2 Buffer的类型</h4><p>Java NIO 有以下Buffer类型：</p><ul><li>ByteBuffer</li><li>MappedByteBuffer</li><li>CharBuffer</li><li>DoubleBuffer</li><li>FloatBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>ShortBuffer </li></ul><p>这些类都是Buffer的子类，其实也是抽象类，它们在Buffer抽象类的基础上扩展了与数据类型相关的功能，下面以ByteBuffer为例介绍</p><p>扩展的常用方法：</p><ul><li><strong>ByteBuffer compact()</strong> 将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样，设置成capacity。</li><li><strong>byte get()</strong> 获取position所指的byte，并且position加1</li><li><strong>byte get(int index)</strong> 获取指定位置的byte</li><li><strong>ByteBuffer put(byte b)</strong> 将指定的byte写入buffer</li><li><strong>ByteBuffer put(int index,byte b)</strong> 将指定的byte写入buffer的指定位置</li><li>…许多的不同类型的get/put操作</li></ul><h3 id="2-Channel"><a href="#2-Channel" class="headerlink" title="2. Channel"></a>2. Channel</h3><p>Java NIO的通道类似流，但又有些不同：</p><ul><li>既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。</li><li>通道可以异步地读写。</li><li>通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入。</li></ul><p>常见的channel：</p><ol><li>FileChannel 从文件中读写数据。</li><li>DatagramChannel 能通过UDP读写网络中的数据。</li><li>SocketChannel 能通过TCP读写网络中的数据。</li><li>ServerSocketChannel可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。</li></ol><p>本文暂不分析具体的Channel类型，将在下一篇博文中具体阐述。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reads a sequence of bytes from this channel into the given buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Writes a sequence of bytes to this channel from the given buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure></p><p>注意对Channel的read和write的理解容易让人懵圈：   </p><ul><li>channel.read(buffer) 意思是Read from this channel to buffer  </li><li>channel.write(buffer) 意思是Write to this channel from buffer</li></ul><h3 id="3-Selector"><a href="#3-Selector" class="headerlink" title="3. Selector"></a>3. Selector</h3><ol><li>创建：调用Selector类的静态方法open()创建selector对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><ol start="2"><li>注册通道：调用Channel的实例方法将通道注册到selector上<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key = channel.register(selector,Selectionkey.OP_READ);</span><br></pre></td></tr></table></figure></li></ol><p>与Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。</p><p>register()方法的第二个参数是一个“interest集合”，意思是在Selector监听该Channel时对什么事件感兴趣。可以监听四种不同类型的事件：</p><ul><li>connect </li><li>accept</li><li>read</li><li>write</li></ul><p>当以上四种事件就绪的时候，会触发对应的通道事件，通道事件会被selector发现。所以，某个channel成功连接到另一个服务器称为“连接就绪”。一个server socket channel准备好接收新进入的连接称为“接收就绪”。一个有数据可读的通道可以说是“读就绪”。通道等待写数据可以说是“写就绪”。</p><p>这四种事件用SelectionKey的四个常量来表示：</p><ul><li>SelectionKey.OP_CONNECT</li><li>SelectionKey.OP_ACCEPT</li><li>SelectionKey.OP_READ</li><li>SelectionKey.OP_WRITE</li></ul><p>如果对不止一种事件感兴趣，那么可以用“位或”操作符将常量连接起来，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure></p><h4 id="3-1-SelectionKey"><a href="#3-1-SelectionKey" class="headerlink" title="3.1 SelectionKey"></a>3.1 SelectionKey</h4><p>当向Selector注册Channel时，register()方法会返回一个SelectionKey对象。这个对象包含了一些有用的属性：</p><ul><li>interest集合</li><li>ready集合</li><li>Channel</li><li>Selector</li><li>附件对象（可选）</li></ul><p><strong>interest集合</strong><br>可以通过SelectionKey读写interest集合，像这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = selectionKey.interestOps();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isInterestedInAccept  = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT；</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInRead    = interestSet &amp; SelectionKey.OP_READ;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInWrite   = interestSet &amp; SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure></p><p>可以看到，用“位与”操作interest 集合和给定的SelectionKey常量，可以确定某个确定的事件是否在interest 集合中。</p><p><strong>ready集合</strong><br>ready 集合是通道已经准备就绪的操作的集合，是四个常量通过‘或’运算生成的。在一次选择(Selection)之后，你会首先访问这个ready set。Selection将在下一小节进行解释。可以这样访问ready集合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int readySet = selectionKey.readyOps();</span><br></pre></td></tr></table></figure></p><p>可以用像检测interest集合那样的方法，来检测channel中什么事件或操作已经就绪。但是，也可以使用以下四个方法，它们都会返回一个布尔类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.isAcceptable();</span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure><p><strong>Channel &amp; Selector</strong><br>从SelectionKey访问Channel和Selector很简单。如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Channel  channel  = selectionKey.channel();</span><br><span class="line">Selector selector = selectionKey.selector();</span><br></pre></td></tr></table></figure></p><p>在程序中需要对返回的channel做类型转换  </p><p><strong>附件对象</strong><br>可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个给定的通道。例如，可以附加 与通道一起使用的Buffer，或是包含聚集数据的某个对象。使用方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.attach(theObject);</span><br><span class="line">Object attachedObj = selectionKey.attachment();</span><br></pre></td></tr></table></figure></p><p>还可以在用register()方法向Selector注册Channel的时候附加对象。如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);</span><br></pre></td></tr></table></figure></p><h4 id="3-2-Selector选择通道"><a href="#3-2-Selector选择通道" class="headerlink" title="3.2 Selector选择通道"></a>3.2 Selector选择通道</h4><p><strong>select()</strong></p><p>一旦向Selector注册了一或多个通道，就可以调用几个重载的select()方法。这些方法返回你所感兴趣的事件（如连接、接受、读或写）已经准备就绪的那些通道。换句话说，如果你对“读就绪”的通道感兴趣，select()方法会返回读事件已经就绪的那些通道。</p><p>三种select：</p><ul><li>int select() 阻塞方法，阻塞到至少有一个通道在注册的事件上就绪。</li><li>int select(long timeout) 超时返回的阻塞方法</li><li>int selectNow() 非阻塞方法，不管是否有通道就绪，立即返回。如果自上次select之后没有通道就绪，直接返回0</li></ul><p>方法返回的int值表示有多少通道已经就绪。亦即，自上次调用select()方法后有多少通道变成就绪状态。例如第一次调用select()方法，有一个通道变成就绪状态，返回了1，若再次调用select()方法，如果另一个通道就绪了，它会再次返回1，即使对第一个就绪的channel没有做任何操作，现在有两个就绪的通道。</p><p><strong>selectedKeys()</strong></p><p>一旦调用了select()方法，并且返回值表明有一个或更多个通道就绪了，然后可以通过调用selector的selectedKeys()方法，访问“已选择键集（selected key set）”中的就绪通道。如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br></pre></td></tr></table></figure></p><p>可以遍历这个已选择的键集合来访问就绪通道，像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">    SelectionKey key = iter.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">        handleAccept(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">        handleRead(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(key.isWritable() &amp;&amp; key.isValid())&#123;</span><br><span class="line">        handleWrite(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(key.isConnectable())&#123;</span><br><span class="line">        System.out.println(<span class="string">"isConnectable = true"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    iter.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意每次迭代末尾需要调用remove()。Selector不会自己从已选择键集中移除SelectionKey实例，必须在处理完通道时自己移除。下次该通道变成就绪时，Selector会再次将其放入已选择键集中。</p><p><strong>wakeUp()</strong></p><p>某个线程调用select()方法后阻塞了，即使没有通道已经就绪，也有办法让其从select()方法返回。只要让其它线程在第一个线程调用select()方法的那个对象上调用Selector.wakeup()方法即可。阻塞在select()方法上的线程会立马返回。</p><p>如果有其它线程调用了wakeup()方法，但当前没有线程阻塞在select()方法上，下个调用select()方法的线程会立即“醒来（wake up）”。</p><p><strong>close()</strong></p><p>用完Selector后调用其close()方法会关闭该Selector，该方法使注册到该Selector上的所有SelectionKey实例无效，通道本身并不会关闭。</p><h3 id="4-一个完整的案例"><a href="#4-一个完整的案例" class="headerlink" title="4. 一个完整的案例"></a>4. 一个完整的案例</h3><p>客户端程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketChannelClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        client();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">client</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        SocketChannel socketChannel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            socketChannel = SocketChannel.open();</span><br><span class="line">            socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>,<span class="number">8080</span>));</span><br><span class="line">            <span class="keyword">if</span>(socketChannel.finishConnect()) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    String info = <span class="string">"I'm "</span> + i++ + <span class="string">"-th information from client"</span>;</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                    buffer.put(info.getBytes());</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                        System.out.println(buffer);</span><br><span class="line">                        socketChannel.write(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException | InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(socketChannel!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    socketChannel.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>服务器端程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOSocketServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUF_SIZE=<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">8080</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIMEOUT = <span class="number">3000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        selector();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Selector selector = <span class="keyword">null</span>;</span><br><span class="line">        ServerSocketChannel ssc = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            ssc= ServerSocketChannel.open();</span><br><span class="line">            ssc.socket().bind(<span class="keyword">new</span> InetSocketAddress(PORT));</span><br><span class="line">            ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(selector.select(TIMEOUT) == <span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"=="</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">                    SelectionKey key = iter.next();</span><br><span class="line">                    <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                        handleAccept(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                        handleRead(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(key.isWritable() &amp;&amp; key.isValid())&#123;</span><br><span class="line">                        handleWrite(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(key.isConnectable())&#123;</span><br><span class="line">                        System.out.println(<span class="string">"isConnectable = true"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    iter.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(selector!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    selector.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ssc!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    ssc.close();<span class="comment">//关闭ServerSocketChannel</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleAccept</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel ssChannel = (ServerSocketChannel)key.channel();</span><br><span class="line">        SocketChannel sc = ssChannel.accept();</span><br><span class="line">        sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        sc.register(key.selector(), SelectionKey.OP_READ, ByteBuffer.allocateDirect(BUF_SIZE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleRead</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        SocketChannel sc = (SocketChannel)key.channel();</span><br><span class="line">        ByteBuffer buf = (ByteBuffer)key.attachment();</span><br><span class="line">        <span class="keyword">long</span> bytesRead = sc.read(buf);</span><br><span class="line">        <span class="keyword">while</span>(bytesRead&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            buf.flip();</span><br><span class="line">            <span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>)buf.get());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            buf.clear();</span><br><span class="line">            bytesRead = sc.read(buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(bytesRead == -<span class="number">1</span>)&#123;</span><br><span class="line">            sc.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleWrite</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        ByteBuffer buf = (ByteBuffer)key.attachment();</span><br><span class="line">        buf.flip();</span><br><span class="line">        SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">        <span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">            sc.write(buf);</span><br><span class="line">        &#125;</span><br><span class="line">        buf.compact();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Buffer&quot;&gt;&lt;a href=&quot;#1-Buffer&quot; class=&quot;headerlink&quot; title=&quot;1. Buffer&quot;&gt;&lt;/a&gt;1. Buffer&lt;/h3&gt;&lt;p&gt;在channel中传输的是buffer中的数据，而不是buffer对象。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="nio" scheme="http://yoursite.com/child/tags/nio/"/>
    
  </entry>
  
  <entry>
    <title>源码分析-会用HashMap</title>
    <link href="http://yoursite.com/child/2018/07/21/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BC%9A%E7%94%A8HashMap/"/>
    <id>http://yoursite.com/child/2018/07/21/源码分析-会用HashMap/</id>
    <published>2018-07-21T12:41:36.000Z</published>
    <updated>2019-05-23T02:57:29.493Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一个问题引发的思考"><a href="#一个问题引发的思考" class="headerlink" title="一个问题引发的思考"></a>一个问题引发的思考</h3><p>如果确定只装载100个元素，new HashMap(?)多少是最佳的，why？<br>要弄解答这个问题，第一要知道HashMap的数据结构，第二再弄明白存取数据的逻辑。</p><h3 id="1-首先，我是一个数组"><a href="#1-首先，我是一个数组" class="headerlink" title="1.首先，我是一个数组"></a>1.首先，我是一个数组</h3><p>HashMap本质上是一个数组，数组的每个元素是一个单链表或者红黑树，由0个或多个节点组成。<br>java源码中的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><h4 id="1-1节点类Node-lt-K-V-gt"><a href="#1-1节点类Node-lt-K-V-gt" class="headerlink" title="1.1节点类Node&lt;K,V&gt;"></a>1.1节点类Node&lt;K,V&gt;</h4><p>Node类是HashMap的一个静态内部类，可以将其看成是一个独立的类，只是声明在HashMap类内部而已。下面是源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;//Entry是Map接口中的一个内部接口</span><br><span class="line">    final int hash;//此节点的哈希值，同一个链表上的哈希值不一定相同</span><br><span class="line">    final K key;//键，不能修改</span><br><span class="line">    V value;//值</span><br><span class="line">    Node&lt;K,V&gt; next;//指向下一个节点</span><br><span class="line"> </span><br><span class="line">    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        this.hash = hash;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public final K getKey()        &#123; return key; &#125;</span><br><span class="line">    public final V getValue()      &#123; return value; &#125;</span><br><span class="line">    public final String toString() &#123; return key + &quot;=&quot; + value; &#125;</span><br><span class="line"> </span><br><span class="line">    public final int hashCode() &#123;//此Node类的hashCode方法</span><br><span class="line">        return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public final V setValue(V newValue) &#123;//重新设置节点Value，返回旧Value</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public final boolean equals(Object o) &#123;//判断节点相等的方法，</span><br><span class="line">        if (o == this)//同一个对象，返回true</span><br><span class="line">            return true;</span><br><span class="line">        if (o instanceof Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                return true;//键和值都相等则返回true</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2为啥有链表还有树"><a href="#1-2为啥有链表还有树" class="headerlink" title="1.2为啥有链表还有树"></a>1.2为啥有链表还有树</h4><p>为了提高查询效率，当链表的长度达到阈值的时候会自动将链表树形化，源码中的三个阈值常量如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static final int TREEIFY_THRESHOLD = 8;</span><br><span class="line">static final int UNTREEIFY_THRESHOLD = 6;</span><br><span class="line">static final int MIN_TREEIFY_CAPACITY = 64;</span><br></pre></td></tr></table></figure><ul><li>TREEIFY_THRESHOLD 树形化阈值：当链表长度超过这个值的时候，将链表进行树形化改造</li><li>UNTREEIFY_THRESHOLD 链表化阈值：当节点数低于这个阈值，将红黑树改造成链表。这个值必须必树形化阈值小，避免频繁的转换。</li><li>MIN_TREEIFY_CAPACITY 最小树形化容量：当数组table的长度低于这个值，即使元素链表的长度超过树形化阈值，也不会进行树形化改造，而是对table进行扩容。这个值不能小于4*TREEIFY_THRESHOLD  <h3 id="2-怎么进行数据的存取呢"><a href="#2-怎么进行数据的存取呢" class="headerlink" title="2.怎么进行数据的存取呢"></a>2.怎么进行数据的存取呢</h3><h4 id="2-1hash方法"><a href="#2-1hash方法" class="headerlink" title="2.1hash方法"></a>2.1hash方法</h4>拿到一个&lt;Key,Value&gt;，要存在table的哪个位置呢，这就需要用hash方法来决定了。。。<br>从代码说起：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>key.hashCode()函数调用的是key键值类型自带的哈希函数（与HashMap的hashCode()函数不是同一个），它返回一个32位int类型的散列值。</li><li>考虑到hash值得取值范围太大，不可能创建一个如此大的hash table，因此定位到table的位置只使用hash值的后几位（具体位数与table长度有关）。</li><li>如果只取后几位，碰撞会比较严重，因此就有了扰动函数，将hash值右移16位（高16位移到低16位），再与自身亦或，得到的结果混合了原hash值得高位和低位，以此来加大低位的随机性。</li></ul><h4 id="2-2定位"><a href="#2-2定位" class="headerlink" title="2.2定位"></a>2.2定位</h4><p>最终得到的hash值，将由低位进行定位，定位操作如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n = tab.length</span><br><span class="line">tab[(n - 1) &amp; hash]</span><br></pre></td></tr></table></figure></p><ul><li>数组长度必为2的整数次幂，因此(n-1)相当于低位掩码，与h进行与操作，保留h低位，掩盖高位。</li><li>这里不做取余，是因为取余可能为负数（hashCode为负数的时候）</li><li>不对取余进行模运算，是因为最大的整数Math.abs()会返回负值</li><li>由此可知，对于HashMap的同一个链表的各个节点key值得hash值不一定相同（只是低位相同）</li></ul><h4 id="2-3扩容-resize"><a href="#2-3扩容-resize" class="headerlink" title="2.3扩容(resize)"></a>2.3扩容(resize)</h4><h5 id="默认容量是16"><a href="#默认容量是16" class="headerlink" title="默认容量是16"></a>默认容量是16</h5><p>16是2的整数次幂的原因，在小数据量的情况下16比15或20更能减少key之间的碰撞，而加快查询的效率。 </p><h5 id="容量是15会怎样？"><a href="#容量是15会怎样？" class="headerlink" title="容量是15会怎样？"></a>容量是15会怎样？</h5><p>当数组长度为15的时候，hashcode的值会与14（1110）进行“与”，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率（hash不均匀），降低了查询的效率！<br>所以，在存储大容量数据的时候，最好预先指定hashmap的size为2的整数次幂次方。就算不指定的话，也会以大于且最接近指定值大小的2次幂来初始化的，代码如下(HashMap的构造方法中)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int capacity = 1;  </span><br><span class="line">while (capacity &lt; initialCapacity)   </span><br><span class="line">    capacity &lt;&lt;= 1;  //乘以2</span><br></pre></td></tr></table></figure></p><h5 id="什么时候扩容-amp-怎么扩容"><a href="#什么时候扩容-amp-怎么扩容" class="headerlink" title="什么时候扩容&amp;怎么扩容"></a>什么时候扩容&amp;怎么扩容</h5><p>当hashmap中的元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对hashmap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，所以这是一个通用的操作，很多人对它的性能表示过怀疑，不过想想我们的“均摊”原理，就释然了，而在hashmap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。<br>那么hashmap什么时候进行扩容呢？当hashmap中的元素个数超过数组大小length x loadFactor时，就会进行数组扩容，==<strong>loadFactor的默认值为0.75</strong>==，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过16x0.75=12的时候，就把数组的大小扩展为2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以++如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能++。  </p><h5 id="回到开篇的问题"><a href="#回到开篇的问题" class="headerlink" title="回到开篇的问题"></a>回到开篇的问题</h5><p>当有100个元素new HashMap(100), 但是理论上来讲new HashMap(128)更合适，不过上面已经说过，即使是100，hashmap也自动会将其设置为128。 但是new HashMap(128)还不是更合适的，因为0.75x100 &lt; 100, 也就是说为了让0.75 x size &gt; 100, 我们必须这样new HashMap(256)才最合适，既考虑了&amp;的问题，也避免了resize的问题。 </p><h3 id="3-可以使用自定义的类作为key的类型吗"><a href="#3-可以使用自定义的类作为key的类型吗" class="headerlink" title="3.可以使用自定义的类作为key的类型吗"></a>3.可以使用自定义的类作为key的类型吗</h3><p>可以，但是必须改写key类型的hashcode与equals方法<br>首先计算key的hashcode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。所以，hashcode与equals方法对于找到对应元素是两个关键方法。<br>Hashmap的key可以是任何类型的对象，例如User这种对象，为了保证两个具有相同属性的user的hashcode相同，我们就需要改写hashcode方法，比方把hashcode值的计算与User对象的id关联起来，那么只要user对象拥有相同id，那么他们的hashcode也能保持一致了，这样就可以找到在hashmap数组中的位置了。如果这个位置上有多个元素，还需要用key的equals方法在对应位置的链表中找到需要的元素，所以只改写了hashcode方法是不够的，equals方法也是需要改写滴~当然啦，按正常思维逻辑，equals方法一般都会根据实际的业务内容来定义，例如根据user对象的id来判断两个user是否相等。  </p><hr><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://www.iteye.com/topic/539465" target="_blank" rel="noopener">深入理解HashMap</a><br><a href="https://blog.csdn.net/u010292561/article/details/80472555" target="_blank" rel="noopener">HashMap详解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一个问题引发的思考&quot;&gt;&lt;a href=&quot;#一个问题引发的思考&quot; class=&quot;headerlink&quot; title=&quot;一个问题引发的思考&quot;&gt;&lt;/a&gt;一个问题引发的思考&lt;/h3&gt;&lt;p&gt;如果确定只装载100个元素，new HashMap(?)多少是最佳的，why？&lt;br
      
    
    </summary>
    
    
      <category term="源码分析" scheme="http://yoursite.com/child/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-并发容器CopyOnWriteArrayList</title>
    <link href="http://yoursite.com/child/2018/05/26/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-CopyOnWrite%E5%AE%B9%E5%99%A8/"/>
    <id>http://yoursite.com/child/2018/05/26/并发编程-CopyOnWrite容器/</id>
    <published>2018-05-26T04:32:12.000Z</published>
    <updated>2019-05-28T14:59:58.865Z</updated>
    
    <content type="html"><![CDATA[<p>Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。</p><h3 id="1-什么是CopyOnWrite容器"><a href="#1-什么是CopyOnWrite容器" class="headerlink" title="1. 什么是CopyOnWrite容器"></a>1. 什么是CopyOnWrite容器</h3><p>CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p><h3 id="2-CopyOnWriteArrayList的实现原理"><a href="#2-CopyOnWriteArrayList的实现原理" class="headerlink" title="2. CopyOnWriteArrayList的实现原理"></a>2. CopyOnWriteArrayList的实现原理</h3><p>在使用CopyOnWriteArrayList之前，我们先阅读其源码了解下它是如何实现的。以下代码是向CopyOnWriteArrayList中add方法的实现（向CopyOnWriteArrayList里添加元素），可以发现在添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        int len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + 1);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读的时候不需要加锁，如果读的时候有多个线程正在向CopyOnWriteArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的CopyOnWriteArrayList。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    return get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK中并没有提供CopyOnWriteMap，我们可以参考CopyOnWriteArrayList来实现一个，基本代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Set;</span><br><span class="line"> </span><br><span class="line">public class CopyOnWriteMap&lt;K, V&gt; implements Map&lt;K, V&gt;, Cloneable &#123;</span><br><span class="line">    private volatile Map&lt;K, V&gt; internalMap;</span><br><span class="line"> </span><br><span class="line">    public CopyOnWriteMap() &#123;</span><br><span class="line">        internalMap = new HashMap&lt;K, V&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public V put(K key, V value) &#123;</span><br><span class="line"> </span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            Map&lt;K, V&gt; newMap = new HashMap&lt;K, V&gt;(internalMap);</span><br><span class="line">            V val = newMap.put(key, value);</span><br><span class="line">            internalMap = newMap;</span><br><span class="line">            return val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public V get(Object key) &#123;</span><br><span class="line">        return internalMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void putAll(Map&lt;? extends K, ? extends V&gt; newData) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            Map&lt;K, V&gt; newMap = new HashMap&lt;K, V&gt;(internalMap);</span><br><span class="line">            newMap.putAll(newData);</span><br><span class="line">            internalMap = newMap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现很简单，只要了解了CopyOnWrite机制，我们可以实现各种CopyOnWrite容器，并且在不同的应用场景中使用。</p><h3 id="3-CopyOnWrite的应用场景"><a href="#3-CopyOnWrite的应用场景" class="headerlink" title="3. CopyOnWrite的应用场景"></a>3. CopyOnWrite的应用场景</h3><p>CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Map;</span><br><span class="line"> </span><br><span class="line">import com.ifeve.book.forkjoin.CopyOnWriteMap;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 黑名单服务</span><br><span class="line"> *</span><br><span class="line"> * @author fangtengfei</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class BlackListServiceImpl &#123;</span><br><span class="line"> </span><br><span class="line">    private static CopyOnWriteMap&lt;String, Boolean&gt; blackListMap = new CopyOnWriteMap&lt;String, Boolean&gt;(</span><br><span class="line">            1000);</span><br><span class="line"> </span><br><span class="line">    public static boolean isBlackList(String id) &#123;</span><br><span class="line">        return blackListMap.get(id) == null ? false : true;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void addBlackList(String id) &#123;</span><br><span class="line">        blackListMap.put(id, Boolean.TRUE);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 批量添加黑名单</span><br><span class="line">     *</span><br><span class="line">     * @param ids</span><br><span class="line">     */</span><br><span class="line">    public static void addBlackList(Map&lt;String,Boolean&gt; ids) &#123;</span><br><span class="line">        blackListMap.putAll(ids);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，但是使用CopyOnWriteMap需要注意两件事情：</p><ol><li>减少扩容开销。根据实际需要，初始化CopyOnWriteMap的大小，避免写时CopyOnWriteMap扩容的开销。</li><li>使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。如使用上面代码里的addBlackList方法。  </li></ol><h3 id="4-CopyOnWrite的缺点"><a href="#4-CopyOnWrite的缺点" class="headerlink" title="4. CopyOnWrite的缺点"></a>4. CopyOnWrite的缺点</h3><p>CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。</p><ul><li>内存占用问题。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。</li></ul><p>针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。</p><ul><li>数据一致性问题。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</li></ul><h3 id="5-相关文章"><a href="#5-相关文章" class="headerlink" title="5. 相关文章"></a>5. 相关文章</h3><p><a href="http://blog.csdn.net/wind5shy/article/details/5396887" target="_blank" rel="noopener">CopyOnWriteArrayList和同步容器的性能验证</a></p><p><a href="http://blog.csdn.net/imzoer/article/details/9751591" target="_blank" rel="noopener">CopyOnWriteArrayList使用简介</a></p><p>　　</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用Co
      
    
    </summary>
    
    
      <category term="并发编程" scheme="http://yoursite.com/child/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-ConcurrentHashMap源码分析</title>
    <link href="http://yoursite.com/child/2018/05/25/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/child/2018/05/25/并发编程-ConcurrentHashMap源码分析/</id>
    <published>2018-05-25T04:35:45.000Z</published>
    <updated>2019-05-28T14:59:50.485Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-重要的属性"><a href="#1-重要的属性" class="headerlink" title="1.重要的属性"></a>1.重要的属性</h3><p>首先来看几个重要的属性，与HashMap相同的就不再介绍了，这里重点解释一下sizeCtl这个属性。可以说它是ConcurrentHashMap中出镜率很高的一个属性，因为它是一个控制标识符，在不同的地方有不同用途，而且它的取值不同，也代表不同的含义。</p><ul><li>负数代表正在进行初始化或扩容操作</li><li>-1代表正在初始化</li><li>-N 表示有N-1个线程正在进行扩容操作</li><li>正数或0代表hash表还没有被初始化，这个数值表示初始化或下一次进行扩容的大小，这一点类似于扩容阈值的概念。还后面可以看到，它的值始终是当前ConcurrentHashMap容量的0.75倍，这与loadfactor是对应的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//盛装Node元素的数组,它的大小是2的整数次幂</span><br><span class="line"></span><br><span class="line">transient volatile Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> hash表初始化或扩容时的一个控制位标识量。</span><br><span class="line"> 负数代表正在进行初始化或扩容操作</span><br><span class="line"> -1代表正在初始化</span><br><span class="line"> -N 表示有N-1个线程正在进行扩容操作</span><br><span class="line"> 正数或0代表hash表还没有被初始化，这个数值表示初始化或下一次进行扩容的大小</span><br><span class="line"> */</span><br><span class="line">private transient volatile int sizeCtl;</span><br><span class="line"></span><br><span class="line">// 以下两个是用来控制扩容的时候 单线程进入的变量</span><br><span class="line"> /**</span><br><span class="line"> * The number of bits used for generation stamp in sizeCtl.</span><br><span class="line"> * Must be at least 6 for 32bit arrays.</span><br><span class="line"> */</span><br><span class="line">private static int RESIZE_STAMP_BITS = 16;</span><br><span class="line">/**</span><br><span class="line"> * The bit shift for recording size stamp in sizeCtl.</span><br><span class="line"> */</span><br><span class="line">private static final int RESIZE_STAMP_SHIFT = 32- RESIZE_STAMP_BITS;</span><br><span class="line"></span><br><span class="line">static final int MOVED     = -1;// hash值是-1，表示这是一个forwardNode节点</span><br><span class="line">static final int TREEBIN   = -2;// hash值是-2  表示这时一个TreeBin节点</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-重要的类"><a href="#2-重要的类" class="headerlink" title="2.重要的类"></a>2.重要的类</h3><h4 id="2-1-Node"><a href="#2-1-Node" class="headerlink" title="2.1 Node"></a>2.1 Node</h4><p>Node是最核心的内部类，它包装了key-value键值对，所有插入ConcurrentHashMap的数据都包装在这里面。它与HashMap中的定义很相似，但是但是有一些差别它对value和next属性设置了volatile同步锁(与JDK7的Segment相同)，它不允许调用setValue方法直接改变Node的value域，它增加了find方法辅助map.get()方法。</p><h4 id="2-2-TreeNode"><a href="#2-2-TreeNode" class="headerlink" title="2.2 TreeNode"></a>2.2 TreeNode</h4><p>树节点类，另外一个核心的数据结构。当链表长度过长的时候，会转换为TreeNode。但是与HashMap不相同的是，它并不是直接转换为红黑树，而是把这些结点包装成TreeNode放在TreeBin对象中，由TreeBin完成对红黑树的包装。而且TreeNode在ConcurrentHashMap集成自Node类，而并非HashMap中的集成自LinkedHashMap.Entry&lt;K,V&gt;类，也就是说TreeNode带有next指针，这样做的目的是方便基于TreeBin的访问。</p><h4 id="2-3-TreeBin"><a href="#2-3-TreeBin" class="headerlink" title="2.3 TreeBin"></a>2.3 TreeBin</h4><p>这个类并不负责包装用户的key、value信息，而是包装的很多TreeNode节点。它代替了TreeNode的根节点，也就是说在实际的ConcurrentHashMap“数组”中，存放的是TreeBin对象，而不是TreeNode对象，这是与HashMap的区别。另外这个类还带有了读写锁。</p><p>这里仅贴出它的构造方法。可以看到在构造TreeBin节点时，仅仅指定了它的hash值为TREEBIN常量，这也就是个标识为。同时也看到我们熟悉的红黑树构造方法</p><h4 id="2-4-ForwardingNode"><a href="#2-4-ForwardingNode" class="headerlink" title="2.4 ForwardingNode"></a>2.4 ForwardingNode</h4><p>一个用于连接两个table的节点类。它包含一个nextTable指针，用于指向下一张表。而且这个节点的key value next指针全部为null，它的hash值为-1. 这里面定义的find的方法是从nextTable里进行查询节点，而不是以自身为头节点进行查找。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A node inserted at head of bins during transfer operations.</span><br><span class="line"> */</span><br><span class="line">static final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;</span><br><span class="line">    final Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        super(MOVED,null,null,null);</span><br><span class="line">        this.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;K,V&gt; find(inth, Object k) &#123;</span><br><span class="line">        // loop to avoid arbitrarily deep recursion on forwarding nodes</span><br><span class="line">        outer:for(Node&lt;K,V&gt;[] tab = nextTable;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; intn;</span><br><span class="line">            if(k == null|| tab == null|| (n = tab.length) == 0||</span><br><span class="line">                (e = tabAt(tab, (n - 1) &amp; h)) == null)</span><br><span class="line">                returnnull;</span><br><span class="line">            for(;;) &#123;</span><br><span class="line">                inteh; K ek;</span><br><span class="line">                if((eh = e.hash) == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == k || (ek != null&amp;&amp; k.equals(ek))))</span><br><span class="line">                    returne;</span><br><span class="line">                if(eh &lt; 0) &#123;</span><br><span class="line">                    if(einstanceofForwardingNode) &#123;</span><br><span class="line">                        tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;</span><br><span class="line">                        continueouter;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                        returne.find(h, k);</span><br><span class="line">                &#125;</span><br><span class="line">                if((e = e.next) == null)</span><br><span class="line">                    returnnull;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Unsafe与CAS"><a href="#3-Unsafe与CAS" class="headerlink" title="3.Unsafe与CAS"></a>3.Unsafe与CAS</h3><p>在ConcurrentHashMap中，随处可以看到U, 大量使用了U.compareAndSwapXXX的方法，这个方法是利用一个CAS算法实现无锁化的修改值的操作，他可以大大降低锁代理的性能消耗。这个算法的基本思想就是不断地去比较当前内存中的变量值与你指定的一个变量值是否相等，如果相等，则接受你指定的修改的值，否则拒绝你的操作。因为当前线程中的值已经不是最新的值，你的修改很可能会覆盖掉其他线程修改的结果。这一点与乐观锁，SVN的思想是比较类似的。</p><h4 id="3-1-unsafe静态块"><a href="#3-1-unsafe静态块" class="headerlink" title="3.1 unsafe静态块"></a>3.1 unsafe静态块</h4><p>unsafe代码块控制了一些属性的修改工作，比如最常用的SIZECTL 。在这一版本的concurrentHashMap中，大量应用来的CAS方法进行变量、属性的修改工作。利用CAS进行无锁操作，可以大大提高性能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private static final sun.misc.Unsafe U;</span><br><span class="line">   private static final long SIZECTL;</span><br><span class="line">   private static final long TRANSFERINDEX;</span><br><span class="line">   private static final long BASECOUNT;</span><br><span class="line">   private static final long CELLSBUSY;</span><br><span class="line">   private static final long CELLVALUE;</span><br><span class="line">   private static final long ABASE;</span><br><span class="line">   private static final int ASHIFT;</span><br><span class="line"> </span><br><span class="line">   static&#123;</span><br><span class="line">       try&#123;</span><br><span class="line">           U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">           Class&lt;?&gt; k = ConcurrentHashMap.class;</span><br><span class="line">           SIZECTL = U.objectFieldOffset(k.getDeclaredField(&quot;sizeCtl&quot;));</span><br><span class="line">           TRANSFERINDEX = U.objectFieldOffset(k.getDeclaredField(&quot;transferIndex&quot;));</span><br><span class="line">           BASECOUNT = U.objectFieldOffset(k.getDeclaredField(&quot;baseCount&quot;));</span><br><span class="line">           CELLSBUSY = U.objectFieldOffset(k.getDeclaredField(&quot;cellsBusy&quot;));</span><br><span class="line">           Class&lt;?&gt; ck = CounterCell.class;</span><br><span class="line">           CELLVALUE = U.objectFieldOffset(ck.getDeclaredField(&quot;value&quot;));</span><br><span class="line">           Class&lt;?&gt; ak = Node[].class;</span><br><span class="line">           ABASE = U.arrayBaseOffset(ak);</span><br><span class="line">           intscale = U.arrayIndexScale(ak);</span><br><span class="line">           if((scale &amp; (scale - 1)) != 0)</span><br><span class="line">               thrownewError(&quot;data type scale not a power of two&quot;);</span><br><span class="line">           ASHIFT = 31- Integer.numberOfLeadingZeros(scale);</span><br><span class="line">       &#125;catch(Exception e) &#123;</span><br><span class="line">           thrownewError(e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-三个核心方法"><a href="#3-2-三个核心方法" class="headerlink" title="3.2 三个核心方法"></a>3.2 三个核心方法</h4><p>ConcurrentHashMap定义了三个原子操作，用于对指定位置的节点进行操作。正是这些原子操作保证了ConcurrentHashMap的线程安全。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123;</span><br><span class="line">//获得在i位置上的Node节点</span><br><span class="line">    return(Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123;</span><br><span class="line">    //因此当前线程中的值并不是最新的值，这种修改可能会覆盖掉其他线程的修改结果有点类似于SVN</span><br><span class="line">    returnU.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static final &lt;K,V&gt; voidsetTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v) &#123;</span><br><span class="line">    //利用volatile方法设置节点位置的值</span><br><span class="line">    U.putObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-初始化方法initTable"><a href="#4-初始化方法initTable" class="headerlink" title="4 初始化方法initTable"></a>4 初始化方法initTable</h3><p>对于ConcurrentHashMap来说，调用它的构造方法仅仅是设置了一些参数而已。而整个table的初始化是在向ConcurrentHashMap中插入元素的时候发生的。如调用put、computeIfAbsent、compute、merge等方法的时候，调用时机是检查table==null。</p><p>初始化方法主要应用了关键属性sizeCtl 如果这个值〈0，表示其他线程正在进行初始化，就放弃这个操作。在这也可以看出ConcurrentHashMap的初始化只能由一个线程完成。如果获得了初始化权限，就用CAS方法将sizeCtl置为-1，防止其他线程进入。初始化数组后，将sizeCtl的值改为0.75*n。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; </span><br><span class="line">    int sc;</span><br><span class="line">    while((tab = table) == null|| tab.length == 0) &#123;</span><br><span class="line">        //sizeCtl表示有其他线程正在进行初始化操作，把线程挂起。对于table的初始化工作，只能有一个线程在进行。</span><br><span class="line">        if((sc = sizeCtl) &lt; 0)</span><br><span class="line">            Thread.yield();</span><br><span class="line">        else if(U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line">            //利用CAS方法把sizectl的值置为-1 表示本线程正在进行初始化</span><br><span class="line">            try&#123;</span><br><span class="line">                if((tab = table) == null|| tab.length == 0) &#123;</span><br><span class="line">                    intn = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])newNode&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; 2);//相当于0.75*n 设置一个扩容的阈值</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;finally&#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    returntab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-扩容方法-transfer"><a href="#5-扩容方法-transfer" class="headerlink" title="5 扩容方法 transfer"></a>5 扩容方法 transfer</h3><p>当ConcurrentHashMap容量不足的时候，需要对table进行扩容。这个方法的基本思想跟HashMap是很像的，但是由于它是支持并发扩容的，所以要复杂的多。原因是它支持多线程进行扩容操作，而并没有加锁。我想这样做的目的不仅仅是为了满足concurrent的要求，而是希望利用并发处理去减少扩容带来的时间影响。因为在扩容的时候，总是会涉及到从一个“数组”到另一个“数组”拷贝的操作，如果这个操作能够并发进行，那真真是极好的了。</p><p>整个扩容操作分为两个部分</p><ul><li>第一部分是构建一个nextTable,它的容量是原来的两倍，这个操作是单线程完成的。这个单线程的保证是通过RESIZE_STAMP_SHIFT这个常量经过一次运算来保证的，这个地方在后面会有提到；</li><li>第二个部分就是将原来table中的元素复制到nextTable中，这里允许多线程进行操作。  </li></ul><p>先来看一下单线程是如何完成的：<br>它的大体思想就是遍历、复制的过程。首先根据运算得到需要遍历的次数i，然后利用tabAt方法获得i位置的元素：</p><ol><li>如果这个位置为空，就在原table中的i位置放入forwardNode节点，这个也是触发并发扩容的关键点； </li><li>如果这个位置是Node节点（fh&gt;=0），如果它是一个链表的头节点，就构造一个反序链表，把他们分别放在nextTable的i和i+n的位置上</li><li>如果这个位置是TreeBin节点（fh&lt;0），也做一个反序处理，并且判断是否需要untreefi，把处理的结果分别放在nextTable的i和i+n的位置上</li><li>遍历过所有的节点以后就完成了复制工作，这时让nextTable作为新的table，并且更新sizeCtl为新容量的0.75倍 ，完成扩容。<br>再看一下多线程是如何完成的：</li></ol><p>在代码的69行有一个判断，如果遍历到的节点是forward节点，就向后继续遍历，再加上给节点上锁的机制，就完成了多线程的控制。多线程遍历节点，处理了一个节点，就把对应点的值set为forward，另一个线程看到forward，就向后遍历。这样交叉就完成了复制工作。而且还很好的解决了线程安全的问题。 这个方法的设计实在是让我膜拜。</p><h3 id="6-Put方法"><a href="#6-Put方法" class="headerlink" title="6 Put方法"></a>6 Put方法</h3><p>前面的所有的介绍其实都为这个方法做铺垫。ConcurrentHashMap最常用的就是put和get两个方法。现在来介绍put方法，这个put方法依然沿用HashMap的put方法的思想，根据hash值计算这个新插入的点在table中的位置i，如果i位置是空的，直接放进去，否则进行判断，如果i位置是树节点，按照树的方式插入新的节点，否则把i插入到链表的末尾。ConcurrentHashMap中依然沿用这个思想，有一个最重要的不同点就是ConcurrentHashMap不允许key或value为null值。另外由于涉及到多线程，put方法就要复杂一点。在多线程中可能有以下两个情况</p><ol><li>如果一个或多个线程正在对ConcurrentHashMap进行扩容操作，当前线程也要进入扩容的操作中。这个扩容的操作之所以能被检测到，是因为transfer方法中在空结点上插入forward节点，如果检测到需要插入的位置被forward节点占有，就帮助进行扩容；</li><li>如果检测到要插入的节点是非空且不是forward节点，就对这个节点加锁，这样就保证了线程安全。尽管这个有一些影响效率，但是还是会比hashTable的synchronized要好得多。  </li></ol><p>整体流程就是首先定义不允许key或value为null的情况放入  对于每一个放入的值，首先利用spread方法对key的hashcode进行一次hash计算，由此来确定这个值在table中的位置。</p><p>如果这个位置是空的，那么直接放入，而且不需要加锁操作。</p><p>如果这个位置存在结点，说明发生了hash碰撞，首先判断这个节点的类型。如果是链表节点（fh&gt;0）,则得到的结点就是hash值相同的节点组成的链表的头节点。需要依次向后遍历确定这个新加入的值所在位置。如果遇到hash值与key值都与新加入节点是一致的情况，则只需要更新value值即可。否则依次向后遍历，直到链表尾插入这个结点。如果加入这个节点以后链表长度大于8，就把这个链表转换成红黑树。如果这个节点的类型已经是树节点的话，直接调用树节点的插入方法进行插入新的值。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">publicV put(K key, V value) &#123;</span><br><span class="line">    return putVal(key, value, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** Implementation for put and putIfAbsent */</span><br><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    if(key == null|| value == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    //计算hash值</span><br><span class="line">    int hash = spread(key.hashCode());</span><br><span class="line">    int binCount = 0;</span><br><span class="line">    //死循环 何时插入成功 何时跳出</span><br><span class="line">    for(Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; </span><br><span class="line">        int n, i, fh;</span><br><span class="line">        //如果table为空的话，初始化table</span><br><span class="line">        if(tab == null|| (n = tab.length) == 0)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        //根据hash值计算出在table里面的位置</span><br><span class="line">        else if((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</span><br><span class="line">            //如果这个位置没有值 ，直接放进去，不需要加锁</span><br><span class="line">            if(casTabAt(tab, i, null,new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">                break;  // no lock when adding to empty bin</span><br><span class="line">        &#125;</span><br><span class="line">        //当遇到表连接点时，需要进行整合表的操作</span><br><span class="line">        else if((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        else&#123;</span><br><span class="line">            V oldVal = null;</span><br><span class="line">            //结点上锁  这里的结点可以理解为hash值相同组成的链表的头结点</span><br><span class="line">            synchronized(f) &#123;</span><br><span class="line">                if(tabAt(tab, i) == f) &#123;</span><br><span class="line">                    //fh〉0 说明这个节点是一个链表的节点 不是树的节点</span><br><span class="line">                    if(fh &gt;= 0) &#123;</span><br><span class="line">                        binCount = 1;</span><br><span class="line">                        //在这里遍历链表所有的结点</span><br><span class="line">                        for(Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            //如果hash值和key值相同  则修改对应结点的value值</span><br><span class="line">                            if(e.hash == hash &amp;&amp;((ek = e.key) == key ||(ek != null&amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                if(!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            //如果遍历到了最后一个结点，那么就证明新的节点需要插入 就把它插入在链表尾部</span><br><span class="line">                            if((e = e.next) == null) &#123;</span><br><span class="line">                                pred.next = newNode&lt;K,V&gt;(hash, key,value,null);</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //如果这个节点是树节点，就按照树的方式插入值</span><br><span class="line">                    else if(f instanceof TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = 2;</span><br><span class="line">                        if((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,value)) != null) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            if(!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(binCount != 0) &#123;</span><br><span class="line">                //如果链表长度已经达到临界值8 就需要把链表转换为树结构</span><br><span class="line">                if(binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                if(oldVal != null)</span><br><span class="line">                    return oldVal;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //将当前ConcurrentHashMap的元素数量+1</span><br><span class="line">    addCount(1L, binCount);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以发现JDK8中的实现也是锁分离的思想，只是锁住的是一个Node，而不是JDK7中的Segment，而锁住Node之前的操作是无锁的并且也是线程安全的，建立在之前提到的3个原子操作上。</p><h4 id="6-1-helpTransfer方法"><a href="#6-1-helpTransfer方法" class="headerlink" title="6.1 helpTransfer方法"></a>6.1 helpTransfer方法</h4><p>这是一个协助扩容的方法。这个方法被调用的时候，当前ConcurrentHashMap一定已经有了nextTable对象，首先拿到这个nextTable对象，调用transfer方法。回看上面的transfer方法可以看到，当本线程进入扩容方法的时候会直接进入复制阶段。</p><h4 id="6-2-treeifyBin方法"><a href="#6-2-treeifyBin方法" class="headerlink" title="6.2 treeifyBin方法"></a>6.2 treeifyBin方法</h4><p>这个方法用于将过长的链表转换为TreeBin对象。但是他并不是直接转换，而是进行一次容量判断，如果容量没有达到转换的要求，直接进行扩容操作并返回；如果满足条件才链表的结构抓换为TreeBin ，这与HashMap不同的是，它并没有把TreeNode直接放入红黑树，而是利用了TreeBin这个小容器来封装所有的TreeNode.</p><h3 id="7-get方法"><a href="#7-get方法" class="headerlink" title="7 get方法"></a>7 get方法</h3><p>get方法比较简单，给定一个key来确定value的时候，必须满足两个条件  key相同  hash值相同，对于节点可能在链表或树上的情况，需要分别去查找。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; </span><br><span class="line">    Node&lt;K,V&gt; e, p; </span><br><span class="line">    int n, eh; </span><br><span class="line">    K ek;</span><br><span class="line">    //计算hash值</span><br><span class="line">    int h = spread(key.hashCode());</span><br><span class="line">    //根据hash值确定节点位置</span><br><span class="line">    if((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123;</span><br><span class="line">        //如果搜索到的节点key与传入的key相同且不为null,直接返回这个节点 </span><br><span class="line">        if((eh = e.hash) == h) &#123;</span><br><span class="line">            if((ek = e.key) == key || (ek != null&amp;&amp; key.equals(ek)))</span><br><span class="line">                returne.val;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果eh&lt;0 说明这个节点在树上 直接寻找</span><br><span class="line">        else if(eh &lt; 0)</span><br><span class="line">             return (p = e.find(h, key)) != null ? p.val : null;</span><br><span class="line">         //否则遍历链表 找到对应的值并返回</span><br><span class="line">        while((e = e.next) != null) &#123;</span><br><span class="line">            if(e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != null&amp;&amp; key.equals(ek))))</span><br><span class="line">                return e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-Size相关的方法"><a href="#8-Size相关的方法" class="headerlink" title="8 Size相关的方法"></a>8 Size相关的方法</h3><p>对于ConcurrentHashMap来说，这个table里到底装了多少东西其实是个不确定的数量，因为不可能在调用size()方法的时候像GC的“stop the world”一样让其他线程都停下来让你去统计，因此只能说这个数量是个估计值。对于这个估计值，ConcurrentHashMap也是大费周章才计算出来的。</p><h4 id="8-1-辅助定义"><a href="#8-1-辅助定义" class="headerlink" title="8.1 辅助定义"></a>8.1 辅助定义</h4><p>为了统计元素个数，ConcurrentHashMap定义了一些变量和一个内部类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A padded cell for distributing counts.  Adapted from LongAdder</span><br><span class="line"> * and Striped64.  See their internal docs for explanation.</span><br><span class="line"> */</span><br><span class="line">@sun.misc.Contendedstaticfinalclass CounterCell &#123;</span><br><span class="line">    volatilelongvalue;</span><br><span class="line">    CounterCell(longx) &#123; value = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/******************************************/ </span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 实际上保存的是hashmap中的元素个数  利用CAS锁进行更新</span><br><span class="line"> 但它并不用返回当前hashmap的元素个数</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line">privatetransientvolatile long baseCount;</span><br><span class="line">/**</span><br><span class="line"> * Spinlock (locked via CAS) used when resizing and/or creating CounterCells.</span><br><span class="line"> */</span><br><span class="line">privatetransientvolatile int cellsBusy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Table of counter cells. When non-null, size is a power of 2.</span><br><span class="line"> */</span><br><span class="line">privatetransientvolatile CounterCell[] counterCells;</span><br></pre></td></tr></table></figure><h4 id="8-2-mappingCount与Size方法"><a href="#8-2-mappingCount与Size方法" class="headerlink" title="8.2 mappingCount与Size方法"></a>8.2 mappingCount与Size方法</h4><p>mappingCount与size方法的类似  从Java工程师给出的注释来看，应该使用mappingCount代替size方法 两个方法都没有直接返回basecount 而是统计一次这个值，而这个值其实也是一个大概的数值，因此可能在统计的时候有其他线程正在执行插入或删除操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">publicintsize() &#123;</span><br><span class="line">        longn = sumCount();</span><br><span class="line">        return((n &lt; 0L) ? 0:</span><br><span class="line">                (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">                (int)n);</span><br><span class="line">    &#125;</span><br><span class="line">     /**</span><br><span class="line">     * Returns the number of mappings. This method should be used</span><br><span class="line">     * instead of &#123;@link #size&#125; because a ConcurrentHashMap may</span><br><span class="line">     * contain more mappings than can be represented as an int. The</span><br><span class="line">     * value returned is an estimate; the actual count may differ if</span><br><span class="line">     * there are concurrent insertions or removals.</span><br><span class="line">     *</span><br><span class="line">     * @return the number of mappings</span><br><span class="line">     * @since 1.8</span><br><span class="line">     */</span><br><span class="line">    publiclongmappingCount() &#123;</span><br><span class="line">        longn = sumCount();</span><br><span class="line">        return(n &lt; 0L) ? 0L : n; // ignore transient negative values</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">     finallongsumCount() &#123;</span><br><span class="line">        CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">        longsum = baseCount;</span><br><span class="line">        if(as != null) &#123;</span><br><span class="line">            for(inti = 0; i &lt; as.length; ++i) &#123;</span><br><span class="line">                if((a = as[i]) != null)</span><br><span class="line">                    sum += a.value;//所有counter的值求和</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        returnsum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-addCount方法"><a href="#8-3-addCount方法" class="headerlink" title="8.3 addCount方法"></a>8.3 addCount方法</h4><p>在put方法结尾处调用了addCount方法，把当前ConcurrentHashMap的元素个数+1这个方法一共做了两件事,更新baseCount的值，检测是否进行扩容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">privatefinalvoid addCount(longx,intcheck) &#123;</span><br><span class="line">    CounterCell[] as; longb, s;</span><br><span class="line">    //利用CAS方法更新baseCount的值</span><br><span class="line">    if((as = counterCells) != null||</span><br><span class="line">        !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; longv;intm;</span><br><span class="line">        booleanuncontended = true;</span><br><span class="line">        if(as == null|| (m = as.length - 1) &lt; 0||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(check &lt;= 1)</span><br><span class="line">            return;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    //如果check值大于等于0 则需要检验是否需要进行扩容操作</span><br><span class="line">    if(check &gt;= 0) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; intn, sc;</span><br><span class="line">        while(s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null&amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            intrs = resizeStamp(n);</span><br><span class="line">            //</span><br><span class="line">            if(sc &lt; 0) &#123;</span><br><span class="line">                if((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null||</span><br><span class="line">                    transferIndex &lt;= 0)</span><br><span class="line">                    break;</span><br><span class="line">                 //如果已经有其他线程在执行扩容操作</span><br><span class="line">                if(U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            //当前线程是唯一的或是第一个发起扩容的线程  此时nextTable=null</span><br><span class="line">            elseif(U.compareAndSwapInt(this, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</span><br><span class="line">                transfer(tab,null);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>JDK6,7中的ConcurrentHashmap主要使用Segment来实现减小锁粒度，把HashMap分割成若干个Segment，在put的时候需要锁住Segment，get时候不加锁，使用volatile来保证可见性，当要统计全局时（比如size），首先会尝试多次计算modcount来确定，这几次尝试中，是否有其他线程进行了修改操作，如果没有，则直接返回size。如果有，则需要依次锁住所有的Segment来计算。</p><p>jdk7中ConcurrentHashmap中，当长度过长碰撞会很频繁，链表的增改删查操作都会消耗很长的时间，影响性能,所以jdk8 中完全重写了concurrentHashmap,代码量从原来的1000多行变成了 6000多 行，实现上也和原来的分段式存储有很大的区别。</p><p>主要设计上的变化有以下几点:</p><ol><li>不采用segment而采用node，锁住node来实现减小锁粒度。</li><li>设计了MOVED状态 当resize的中过程中 线程2还在put数据，线程2会帮助resize。</li><li>使用3个CAS操作来确保node的一些操作的原子性，这种方式代替了锁。</li><li>sizeCtl的不同值来代表不同含义，起到了控制的作用。  </li></ol><p>至于为什么JDK8中使用synchronized而不是ReentrantLock，我猜是因为JDK8中对synchronized有了足够的优化吧。</p><hr><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://blog.csdn.net/moakun/article/details/80203568" target="_blank" rel="noopener">JDK1.8 实现解读</a><br><a href="http://www.cnblogs.com/stateis0/p/9062086.html" target="_blank" rel="noopener">扩容源码分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-重要的属性&quot;&gt;&lt;a href=&quot;#1-重要的属性&quot; class=&quot;headerlink&quot; title=&quot;1.重要的属性&quot;&gt;&lt;/a&gt;1.重要的属性&lt;/h3&gt;&lt;p&gt;首先来看几个重要的属性，与HashMap相同的就不再介绍了，这里重点解释一下sizeCtl这个属性。
      
    
    </summary>
    
    
      <category term="并发编程" scheme="http://yoursite.com/child/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-并发工具类</title>
    <link href="http://yoursite.com/child/2018/05/17/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://yoursite.com/child/2018/05/17/并发编程-并发工具类/</id>
    <published>2018-05-17T12:36:12.000Z</published>
    <updated>2019-05-28T14:59:12.732Z</updated>
    
    <content type="html"><![CDATA[<p>在JDK的并发包中提供了几个非常有用的并发工具类。CountDownLatch、CyclicBarrier和Semaphore提供了并发流程控制手段，Exchanger提供了两个线程之间交换数据的手段，本文将配合应用场景介绍该如何使用这几个工具类。</p><h3 id="1-CountDownLatch"><a href="#1-CountDownLatch" class="headerlink" title="1. CountDownLatch"></a>1. CountDownLatch</h3><p>CountDownLatch是JDK 5+里面闭锁的一个实现，他允许一个或多个线程等待其他线程完成各自的工作后再执行。</p><p>闭锁（Latch）：一种同步方法，可以延迟线程的进度直到线程到达某个终点状态。</p><p>与CountDownLatch第一次交互是主线程等待其它的线程，主线程必须在启动其它线程后立即调用await方法，这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。</p><p>其他的N个线程必须引用闭锁对象，因为他们需要通知CountDownLatch对象，他们已经完成了各自的任务，这种机制就是通过调用countDown()方法来完成的。每调用一次这个方法，在构造函数中初始化的count值就减1，所以当N个线程都调用了这个方法count的值等于0，然后主线程就能通过await方法，恢复自己的任务。</p><p>与Join的区别：调用join方法需要等待thread执行完毕才能继续向下执行,而CountDownLatch只需要检查计数器的值为零就可以继续向下执行，相比之下，CountDownLatch更加灵活一些，可以实现一些更加复杂的业务场景。</p><h4 id="1-1-使用场景"><a href="#1-1-使用场景" class="headerlink" title="1.1 使用场景"></a>1.1 使用场景</h4><ol><li>开启多个线程分块下载一个大文件，每个线程只下载固定的一截，最后由另外一个线程来拼接所有的分段。</li><li>应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。</li><li>确保一个计算不会执行，直到所需要的资源被初始化。</li></ol><h4 id="1-2-主要方法"><a href="#1-2-主要方法" class="headerlink" title="1.2 主要方法"></a>1.2 主要方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//初始化计数的次数，不能重置</span><br><span class="line">public CountDownLatch(int count); </span><br><span class="line">//调用此方法则计数减1</span><br><span class="line">public void countDown();   </span><br><span class="line">//得到当前的计数</span><br><span class="line">Public Long getCount();           </span><br><span class="line">//调用此方法会一直阻塞当前线程，直到计时器的值为0，除非线程被中断。</span><br><span class="line">public void await() throws InterruptedException   </span><br><span class="line">//调用此方法会一直阻塞当前线程，直到计时器的值为0，除非线程被中断或者计数器超时，返回false代表计数器超时。</span><br><span class="line">Public boolean await(long timeout, TimeUnit unit)</span><br></pre></td></tr></table></figure><h4 id="1-3-使用案例"><a href="#1-3-使用案例" class="headerlink" title="1.3 使用案例"></a>1.3 使用案例</h4><ol><li>latch.countDown(); 建议放到finally语句里。</li><li>对这个计数器的操作都是原子操作，同时只能有一个线程去操作这个计数器。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class CountDownLatchTest &#123;</span><br><span class="line">    private final CountDownLatch latch = new CountDownLatch(3);</span><br><span class="line">    private final ReentrantLock lock = new ReentrantLock();</span><br><span class="line">    private int count;</span><br><span class="line"></span><br><span class="line">    public int getCount()&#123;</span><br><span class="line">        return this.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class RunnableTask implements Runnable&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                count += 100;</span><br><span class="line">            &#125;finally &#123;</span><br><span class="line">                latch.countDown();</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException&#123;</span><br><span class="line">        CountDownLatchTest demo = new CountDownLatchTest();</span><br><span class="line">        int i = 3;</span><br><span class="line">        while(i-- &gt; 0)&#123;</span><br><span class="line">            new Thread(demo.new RunnableTask()).start();</span><br><span class="line">        &#125;</span><br><span class="line">        demo.latch.await();</span><br><span class="line">        System.out.println(demo.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个线程分别对count加100，等三个线程执行完后，主线程输出count的值。输出300</p><h3 id="2-CyclicBarrier"><a href="#2-CyclicBarrier" class="headerlink" title="2. CyclicBarrier"></a>2. CyclicBarrier</h3><p>字面意思是可以循环使用的屏障。他要做的事情是让一组线程到达一个同步点时被阻塞，直到最后一个线程到达同步点，才会打开屏障，所有线程继续运行。</p><p>默认的构造方法 CyclicBarrier(int parties) ，参数代表屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier已经到达屏障，然后被阻塞。</p><h4 id="1-1-使用场景-1"><a href="#1-1-使用场景-1" class="headerlink" title="1.1 使用场景"></a>1.1 使用场景</h4><p>可用于多线程计算数据，最后合并计算结果</p><h4 id="1-2-主要方法-1"><a href="#1-2-主要方法-1" class="headerlink" title="1.2 主要方法"></a>1.2 主要方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//初始化</span><br><span class="line">public CyclicBarrier(int parties)</span><br><span class="line">//barrierAction表示被拦住的线程需要执行的任务</span><br><span class="line">public CyclicBarrier(int parties, Runnable barrierAction)</span><br><span class="line">//被拦住的线程调用次函数进入阻塞状态</span><br><span class="line">public int await()</span><br><span class="line">//被拦住的线程调用次函数进入阻塞状态，超时唤醒</span><br><span class="line">public int await(long timeout, TimeUnit unit)</span><br><span class="line">public void reset() </span><br><span class="line">//返回需要被拦住的线程数量</span><br><span class="line">public int getParties() </span><br><span class="line">//查询此屏障是否处于断开状态</span><br><span class="line">public boolean isBroken()</span><br><span class="line">//返回已被拦住的线程数量</span><br><span class="line">public int getNumberWaiting()</span><br></pre></td></tr></table></figure><h4 id="1-3-使用案例-1"><a href="#1-3-使用案例-1" class="headerlink" title="1.3 使用案例"></a>1.3 使用案例</h4><p>初始化线程数为2，加上主线程调用await()3次，所以得出结论主线程调用不计入await次数之内。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class CyclicBarrierTest &#123;</span><br><span class="line">    private static CyclicBarrier cb = new CyclicBarrier(2);</span><br><span class="line">    private static ReentrantLock lock = new ReentrantLock();</span><br><span class="line">    private static int count;</span><br><span class="line">    public static class RunnableTask implements Runnable&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                count += 100;</span><br><span class="line">                cb.await();</span><br><span class="line">            &#125;catch (Throwable e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        for(int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            new Thread(new RunnableTask()).start();</span><br><span class="line">        &#125;</span><br><span class="line">        cb.await();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出200</p><h4 id="1-4-与CountDownLatch的区别"><a href="#1-4-与CountDownLatch的区别" class="headerlink" title="1.4 与CountDownLatch的区别"></a>1.4 与CountDownLatch的区别</h4><ul><li>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置，可以使用多次，所以CyclicBarrier能够处理更为复杂的场景；</li><li>CyclicBarrier还提供了一些其他有用的方法，比如getNumberWaiting()方法可以获得CyclicBarrier阻塞的线程数量，isBroken()方法用来了解阻塞的线程是否被中断；</li><li>CountDownLatch允许一个或多个线程等待一组事件的产生，而CyclicBarrier用于等待其他线程运行到栅栏位置。</li></ul><h3 id="3-Semaphore"><a href="#3-Semaphore" class="headerlink" title="3. Semaphore"></a>3. Semaphore</h3><p>Semaphore是用来控制同事访问特定资源的线程数量，它通过协调各个线程以保证合理的使用公共资源。</p><h4 id="3-1-使用场景"><a href="#3-1-使用场景" class="headerlink" title="3.1 使用场景"></a>3.1 使用场景</h4><p>可用于做流量控制，特别是公用资源有限的场景，比如数据库连接。</p><h3 id="4-Exchanger"><a href="#4-Exchanger" class="headerlink" title="4. Exchanger"></a>4. Exchanger</h3><p>Exchanger类可用于两个线程之间交换信息。可简单地将Exchanger对象理解为一个包含两个格子的容器，通过exchanger方法可以向两个格子中填充信息。当两个格子中的均被填充时，该对象会自动将两个格子的信息交换，然后返回给线程，从而实现两个线程的信息交换。</p><p>Exchanger类仅可用作两个线程的信息交换，当超过两个线程调用同一个exchanger对象时，得到的结果是不确定的，exchanger对象仅关心其包含的两个“格子”是否已被填充数据，当两个格子都填充数据完成时，该对象就认为线程之间已经配对成功，然后开始执行数据交换操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class ExchangerTest &#123;</span><br><span class="line">    private static Exchanger&lt;String&gt; exgr = new Exchanger&lt;&gt;();</span><br><span class="line">    private static ExecutorService threadpool = Executors.newFixedThreadPool(3);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        threadpool.execute(() -&gt; &#123;</span><br><span class="line">            String a = &quot;银行流水A&quot;;</span><br><span class="line">            try &#123;</span><br><span class="line">                exgr.exchange(a);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadpool.execute(() -&gt; &#123;</span><br><span class="line">            String b = &quot;银行流水B&quot;;</span><br><span class="line">            try &#123;</span><br><span class="line">                String a = exgr.exchange(b);</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125; catch (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadpool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在JDK的并发包中提供了几个非常有用的并发工具类。CountDownLatch、CyclicBarrier和Semaphore提供了并发流程控制手段，Exchanger提供了两个线程之间交换数据的手段，本文将配合应用场景介绍该如何使用这几个工具类。&lt;/p&gt;
&lt;h3 id=&quot;
      
    
    </summary>
    
    
      <category term="并发编程" scheme="http://yoursite.com/child/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-线程池源码详解</title>
    <link href="http://yoursite.com/child/2018/05/15/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/child/2018/05/15/并发编程-线程池源码详解/</id>
    <published>2018-05-15T03:28:21.000Z</published>
    <updated>2019-06-09T01:21:43.793Z</updated>
    
    <content type="html"><![CDATA[<p>阿里巴巴Java手册有一条：<br>【强制】线程资源必须通过线程池提供，禁止在应用程序中显示创建线程。<br>说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程导致消耗完内存或者过度切换的问题。</p><p>简单来说使用线程池有以下几个目的：  </p><ul><li>避免频繁的创建。线程是稀缺资源。</li><li>解耦。线程的创建与执行分开，方便维护。</li><li>线程资源复用。</li></ul><h3 id="1-线程池原理"><a href="#1-线程池原理" class="headerlink" title="1. 线程池原理"></a>1. 线程池原理</h3><p>本文从线程池的创建开始说起，跟着源码分析一下线程池的工作原理，本文源码基于JDK1.8</p><h4 id="1-1-Executors"><a href="#1-1-Executors" class="headerlink" title="1.1 Executors"></a>1.1 Executors</h4><p>Executors有一个私有的默认构造函数，不能实例化，是一个工具类，主要用于提供各种类型线程池创建的静态方法。<br>提供的静态创建方法有：</p><ul><li>newSingleThreadExecutor 创建一个执行器，该执行器使用一个工作线程操作一个无界队列。(但是请注意，如果这个线程在关闭之前的执行过程中由于失败而终止，那么如果需要执行后续任务，将会有一个新的线程代替它。与 newFixedThreadPool(1)不同，返回的executor不能被其他线程重新配置。</li><li>newFixedThreadPool  创建一个线程池，该线程池重用固定数量的线，如果任何线程在关闭之前的执行过程中由于失败而终止，那么如果需要执行后续任务，则会替换一个新线程。池中的线程将一直存在，直到显式关闭为止<br>操作一个共享的无界队列。</li><li>newWorkStealingPool  创建一个线程池，该线程池维护足够的线程以支持给定的并行度级别，并且可以使用多个队列来减少争用。并行度级别对应于积极参与或可用参与任务处理的线程的最大数量。线程的实际数量可以动态地增长和收缩。工作窃取池不能保证所提交任务的执行顺序。</li><li>newCachedThreadPool  创建一个线程池，该线程池根据需要创建新线程，但在可用时将重用以前构造的线程。这些池通常会提高执行许多短期异步任务的程序的性能。如果可用，对execute的调用将重用以前构造的线程。如果没有可用的现有线程，将创建一个新线程并将其添加到池中。未使用60秒的线程将被终止并从缓存中删除。因此，长时间空闲的池不会消耗任何资源。注意，可以使用ThreadPoolExecutor构造函数创建具有相似属性但不同细节(例如超时参数)的池。</li><li>newSingleThreadScheduledExecutor  创建一个单线程执行器，该执行器可以安排命令在给定的延迟之后运行，或者定期执行。(但是请注意，如果这个线程在关闭之前的执行过程中由于失败而终止，那么如果需要执行后续任务，将会有一个新的线程代替它。)，与 newFixedThreadPool(1)不同，返回的executor不能被其他线程重新配置。</li><li>newScheduledThreadPool  创建一个线程池，该线程池可以在给定延迟之后调度命令运行，或者定期执行命令。</li></ul><p>Executors 返回的线程池对象的弊端如下：</p><ol><li>FixedThreadPool 和 SingleThreadPool: 允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。</li><li>CachedThreadPool 和 ScheduledThreadPool: 允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</li></ol><h4 id="1-2-ThreadPoolExecutor"><a href="#1-2-ThreadPoolExecutor" class="headerlink" title="1.2 ThreadPoolExecutor"></a>1.2 ThreadPoolExecutor</h4><p>首先看一下newFixedThreadPool创建方法的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>事实上，大多数类型的线程池创建都是调用new ThreadPoolExecutor(…)创建一个ThreadPoolExecutor对象，只不过初始化参数不同而已。newWorkStealingPool创建时构造的是ForkJoinPool对象，本文不述。</p><p>下面是ThreadPoolExecutor的其中一个构造方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>初始化参数的如下：</p><ul><li>corePoolSize 表示线程池的核心数,线程池保持alive状态的线程数，即使线程是空闲的。</li><li>maximumPoolSize 表示线程池支持的最大的线程个数。</li><li>keepAliveTime 表示池中线程空闲后的生存时间</li><li>unit 表示上一个时间参数的单位</li><li>workQueue 用于存放任务的阻塞队列</li><li>threadFactory 表示创建线程的工厂，一般使用默认的线程创建工厂Excutors.DefaultThreadFactor()</li><li>handler 当队列和最大线程池都满了之后的饱和策略，一般使用默认的handler—AbortPolicy（内部类）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">代码摘自：java.util.concurrent.ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler defaultHandler = <span class="keyword">new</span> AbortPolicy();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</span><br><span class="line">                                             <span class="string">" rejected from "</span> +</span><br><span class="line">                                             e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    handler.rejectedExecution(command, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户也可以自己实现RejectedExecutionHandler接口定义一个handler，当提交的任务因为各种原因被线程池拒绝，就会调用rejectedExecution方法。</p><h5 id="1-2-1-提交任务excute"><a href="#1-2-1-提交任务excute" class="headerlink" title="1.2.1 提交任务excute()"></a>1.2.1 提交任务excute()</h5><p>使用线程池时，通常我们用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threadPool.execute(<span class="keyword">new</span> Job());</span><br></pre></td></tr></table></figure></p><p>这样的方式提交一个任务到线程池中，所以线程池ThreadPoolExecutor的核心逻辑就是execute()函数了，这个方法是在Excutor接口中声明。</p><p>在分析核心逻辑之前，先了解一下线程池重定义的状态，这些状态都和线程的执行密切相关</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">代码摘自：java.util.concurrent.ThreadPoolExecutor</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPCITY = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;<span class="keyword">return</span> c &amp; ~CAPCITY;&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;<span class="keyword">return</span> c &amp; CAPCITY;&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span></span>&#123;<span class="keyword">return</span> rs | wc;&#125;</span><br></pre></td></tr></table></figure><p>分析上面的代码得到下表：</p><table><thead><tr><th>常量名</th><th>二进制</th></tr></thead><tbody><tr><td>CAPCITY</td><td>0001 1111 1111 1111 1111 1111 1111 1111</td></tr><tr><td>RUNNING</td><td>1110 0000 0000 0000 0000 0000 0000 0000</td></tr><tr><td>SHUTDOWN</td><td>0000 0000 0000 0000 0000 0000 0000 0000</td></tr><tr><td>STOP</td><td>0010 0000 0000 0000 0000 0000 0000 0000</td></tr><tr><td>TIDYING</td><td>0100 0000 0000 0000 0000 0000 0000 0000</td></tr><tr><td>TERMINATED</td><td>0110 0000 0000 0000 0000 0000 0000 0000</td></tr></tbody></table><p>由上表可以看出，原子对象ctl的前三位表示状态，后29位记录池中worker的个数，CAPCITY就像是一个掩码，通过掩码可以快速的从ctl中获得当前线程池的运行状态和池中的worker个数。  </p><p>JDK1.8的并发包中不再通过设置阻塞队列的长度来限制任务的提交。阻塞队列的长度初始化之后就不能改变，因此如果担心阻塞队列太大导致内存占用太多，可以从两方面入手：1、初始化的时候选择合适的阻塞队列大小；2、调高corePoolSize或maxmumPoolSize加快任务的处理速度。参数的动态调整见下文。</p><p>线程池状态简述：</p><ul><li>RUNNING 是运行状态，指可以接受任务，执行队列里的任务。</li><li>SHUTDOWN 是指调用了shutdown()函数，不再接受新任务，但是会把队列里的任务执行完毕。</li><li>STOP 是指调用了shutdownNow()函数，不再接受新任务，同时终端正在执行的任务并丢弃队列中的待执行任务。</li><li>TIDYING 指所用任务都执行完毕。</li><li>TERMINATED 终止状态，在调用shutdown()/shutdownNow()中都会尝试更新这个状态。</li></ul><p>下面分析核心代码excute()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">代码摘自：java.util.concurrent.ThreadPoolExecutor</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//1、获取当前线程池的状态</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">//2、当线程数量小于corePoolSize，创建新线程运行</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//线程池线程数大于核心线程数 或者 新增worker失败 会执行下面的代码</span></span><br><span class="line">    <span class="comment">//3、如果线程池处于运行状态，并且写入阻塞队列成功</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">//4、再次检查线程状态，若线程池状态改变（非运行状态），需要从阻塞队列移除该任务，并执行拒绝策略</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">//5、如果线程池状态没有发生变化，判断当前池是否为空，为空就创建一个没有指定具体任务的新线程</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6、如果第一次检查不通过（线程池不处于运行状态或者任务写入队列失败），尝试新建线程，如果失败则执行拒绝策略</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>疑问：addWorker(null, false) 添加了一个没有具体任务的worker，作用是什么？  </p><p>如果线程池中的线程数为0，但任务队列中有需要执行的任务，这时候新建一个没有任务的线程是为了去执行任务队列中的任务。</p><p>下图表示了当有任务提交到线程池后线程池的处理流程：<br><img src="https://wx3.sinaimg.cn/large/87c9e458ly1g3tvn4t29jj20p30qqjtq.jpg" alt="execute执行流程图1">  </p><h5 id="1-2-2-创建工人（线程）"><a href="#1-2-2-创建工人（线程）" class="headerlink" title="1.2.2 创建工人（线程）"></a>1.2.2 创建工人（线程）</h5><p><strong>addWorker(Runnable firstTask, boolean core)</strong></p><p>参数：</p><p>firstTask：    worker线程的初始任务，可以为空<br>core：           true：将corePoolSize作为上限，false：将maximumPoolSize作为上限</p><p>addWorker函数是execute函数的核心逻辑，线程池持有一个HashSet<worker>对象存放池中的workers，每个worker对应一个线程，addWorker的作用就是创建worker执行任务。</worker></p><p><strong>addWorker方法有4种调用方式：</strong></p><ul><li><p>addWorker(command, true)</p></li><li><p>addWorker(command, false)</p></li><li><p>addWorker(null, false)</p></li><li><p>addWorker(null, true)</p></li></ul><p>在execute方法中就使用了前3种，结合这个方法进行以下分析</p><ol><li>线程数小于corePoolSize时，放一个需要处理的task进Workers Set。如果Workers Set长度超过corePoolSize，就返回false</li><li>当队列被放满时，就尝试将这个新来的task直接放入Workers Set，而此时Workers Set的长度限制是maximumPoolSize。如果线程池也满了的话就返回false</li><li>放入一个空的task进workers Set，长度限制是maximumPoolSize。这样一个task为空的worker在线程执行的时候会去任务队列里拿任务，这样就相当于创建了一个新的线程，只是没有马上分配任务</li><li>这个方法就是放一个null的task进Workers Set，而且是在小于corePoolSize时，如果此时Set中的数量已经达到corePoolSize那就返回false，什么也不干。实际使用中是在prestartAllCoreThreads()方法，这个方法用来为线程池预先启动corePoolSize个worker等待从workQueue中获取任务执行</li></ol><p>下面将源代码分成两部分进行分析，第一段代码为<strong>检验模块</strong>，主要判断线程池当前是否为可以添加worker线程的状态，可以则继续下一步，不可以则返回 false，具体分为三种情况：</p><ul><li>线程池状态&gt;shutdown，可能为stop、tidying、terminated，不能添加worker线程</li><li>线程池状态==shutdown，firstTask不为空，不能添加worker线程，因为shutdown状态的线程池不接收新任务</li><li>线程池状态==shutdown，firstTask==null，workQueue为空，不能添加worker线程，因为firstTask为空是为了添加一个没有任务的线程再从workQueue获取task，而workQueue为空，说明添加无任务线程已经没有意义</li></ul><p>当以上的情况都没有发生，在创建worker之前还需要验证一下线程池中的线程数量有没有达到极限，达到极限直接返回false；没达到极限，先CAS修改线程池状态(+1操作)，若修改成功，直接退出检验模块循环，执行下面的<strong>运行模块</strong>。CAS设置状态失败则重新获取运行状态进行二重检验，若线程池状态发生改变，从头开始大循环检验，否则继续小循环执行cas。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">代码摘自：java.util.concurrent.ThreadPoolExecutor</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">        <span class="comment">//状态为 RUNNING 继续往下执行</span></span><br><span class="line">        <span class="comment">//状态为不为RUNNING时，如果状态为SHUTDOWN并且firstTask为null并且阻塞队列空时，可继续向下运行</span></span><br><span class="line">        <span class="comment">//否则返回false，添加worker失败</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">//线程数大于CAPACITY </span></span><br><span class="line">            <span class="comment">//线程数大于corePoolSize或maximumPoolSize（取决于core）</span></span><br><span class="line">            <span class="comment">//否则添加worker失败</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//线程数验证通过，使用CAS对c加1，执行成功则终止大循环继续向下运行</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">//CAS设置失败则重新获取运行状态，若线程池状态发生改变，从头开始大循环，否则继续小循环</span></span><br><span class="line">            c = ctl.get(); </span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二部分为运行模块，直接进入主题，将提交的任务包装成worker对象，加入worker set 并启动该worker的线程，worker插入set需要加锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 二重验证，获取池状态</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                <span class="comment">//状态为RUNNING 则通过继续执行</span></span><br><span class="line">                <span class="comment">//状态为SHUTDOWN并且提交的任务为null 则通过继续执行</span></span><br><span class="line">                <span class="comment">//否则直接执行finally解锁</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// 如果worker中的线程t已经处于运行状态</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();<span class="comment">//抛异常</span></span><br><span class="line">                    workers.add(w);<span class="comment">//将w加入HashSet</span></span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="comment">//更新largestPoolSize，largestPoolSize只能在lock下修改</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>addWorker执行流程总结：</strong></p><ol><li>判断是否可以addworker</li><li>线程池当前线程数量是否超过上限（corePoolSize 或 maximumPoolSize），超过了return false，没超过则对workerCount+1，继续下一步</li><li>在线程池的ReentrantLock保证下，向Workers Set中添加新创建的worker实例，添加完成后解锁，并启动worker线程，只有在新建的线程成功启动的情况下才能返回 true。如果添加worker入Set失败或启动失败，调用addWorkerFailed()逻辑</li></ol><h5 id="1-2-3-worker创建失败的善后处理"><a href="#1-2-3-worker创建失败的善后处理" class="headerlink" title="1.2.3 worker创建失败的善后处理"></a>1.2.3 worker创建失败的善后处理</h5><p>addWorkerFailed()</p><p>当任务执行失败，程序需要进行善后处理，即恢复任务执行过程中对内存的改动，移除Worker set中的worker对象，修改池状态，最后尝试终止线程池。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">代码摘自：java.util.concurrent.ThreadPoolExecutor</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        <span class="comment">//CAS对ctl减1</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="1-2-4-空闲线程怎么从阻塞队列中取任务"><a href="#1-2-4-空闲线程怎么从阻塞队列中取任务" class="headerlink" title="1.2.4 空闲线程怎么从阻塞队列中取任务"></a>1.2.4 空闲线程怎么从阻塞队列中取任务</h5><h3 id="2-配置线程池"><a href="#2-配置线程池" class="headerlink" title="2. 配置线程池"></a>2. 配置线程池</h3><p>流程介绍完了先来总结以下上文提到了几个核心参数在流程中的具体作用，然后介绍应该如何配置。</p><h4 id="2-1-参数详解"><a href="#2-1-参数详解" class="headerlink" title="2.1 参数详解"></a>2.1 参数详解</h4><ol><li>corePoolSize：核心线程数</li></ol><ul><li>核心线程会一直存活，即使没有任务需要执行</li><li>当线程数小于核心线程数时，即使有线程空闲，线程池也会有限创建新的线程</li><li>设置allowCoreThreadTimeout=true（默认是false）时，核心线程会超时关闭</li></ul><ol start="2"><li>maximumPoolSize：最大线程数</li></ol><ul><li>当线程数 &gt;= corePoolSize，且队列已满。线程池会创建新线程来处理  </li><li>当线程数 = maxmumPoolSize，且队列任务已满是，线程会拒绝处理任务  </li></ul><ol start="3"><li>keepAliveTime：线程空闲时间</li></ol><ul><li>当线程空闲时间达到keepAliveTime时，线程会退出，知道线程数量 = corePoolSize  </li><li>如果allowCoreThreadTimeout = true，则会知道线程数量 = 0</li></ul><ol start="4"><li>rejectedExecutionHandler：任务拒绝处理器<br>两种情况会拒绝处理任务： </li></ol><ul><li>当线程数已经达到maxmumPoolSize，且队列已满，会拒绝新任务</li><li>当线程池被调用shutdown()后，会等待线程池里的任务执行完毕，再shutdown。如果在调用shutdown()和线程池真正shutdown之间提交任务，会拒绝新任务</li></ul><p>线程池会调用rejectedExecutionHandler来处理这个任务。如果没有设置默认是AbortPolicy，会抛出异常，<br>ThreadPoolExecutor类有几个内部实现类来处理这类情况：  </p><blockquote><p>AbortPolicy 丢弃任务，抛运行时异常<br>CallerRunsPolicy 执行任务，调用Runnable的run强制执行。<br>DiscardPolicy 忽视，什么都不会发生<br>DiscardOldestPolicy 如果是应为第一种情况被拒绝，则从阻塞队列中踢出最先进入队列（最后一个执行）的任务，然后再次提交当前任务。</p></blockquote><p>实现RejectedExecutionHandler接口，可自定义处理器处理reject。</p><h4 id="2-2-参数配置"><a href="#2-2-参数配置" class="headerlink" title="2.2 参数配置"></a>2.2 参数配置</h4><p>默认值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">corePoolSize=<span class="number">1</span></span><br><span class="line">maxPoolSize=Integer.MAX_VALUE</span><br><span class="line">keepAliveTime=<span class="number">60</span>s</span><br><span class="line">allowCoreThreadTimeout=<span class="keyword">false</span></span><br><span class="line">rejectedExecutionHandler=AbortPolicy()</span><br></pre></td></tr></table></figure></p><p>如何设置，需要根据几个值来决定：  </p><ul><li>tasks ：系统每秒任务数，假设为500~1000</li><li>taskcost：单任务耗时，假设为0.1s</li><li>responsetime：系统允许容忍的最大响应时间，假设为1s</li></ul><p>做几个计算：<br>corePoolSize = 系统每秒任务数/单线程每秒任务数 = 系统每秒任务数/（1/单任务耗时）<br>corePoolSize = tasks/(1/taskcost) =tasks<em>taskcout =  (500~1000)</em>0.1 = 50~100 。  corePoolSize设置应该大于50，根据8020原则，如果80%的系统每秒任务数小于800，那么corePoolSize设置为80即可  </p><p>maxPoolSize = （最大任务数-队列容量）/每个线程每秒处理能力 = 最大线程数<br>计算可得 maxPoolSize = (1000-80)/10 = 92<br>队列容量在初始化池的时候指定，一旦指定不能修改</p><p>rejectedExecutionHandler：根据具体情况来决定，任务不重要可丢弃，任务重要则要利用一些缓冲机制来处理</p><p>keepAliveTime和allowCoreThreadTimeout采用默认通常能满足<br>以上都是理想值，实际情况下要根据机器性能来决定。如果在未达到最大线程数的情况机器cpu load已经满了，则需要通过升级硬件和优化代码，降低taskcost来处理。</p><h4 id="2-3-参数动态调整"><a href="#2-3-参数动态调整" class="headerlink" title="2.3 参数动态调整"></a>2.3 参数动态调整</h4><p>用户可以通过corePoolSize和maxmumPoolSize的getter/setter进行访问和设置，具体怎么设置需要根据当前池中一些状态变量进行判断，如：</p><ul><li>getLargestPoolSize() 获取到目前为止达到过的最大线程数</li><li>getPoolSize() 获取当前线程数</li><li>getQueue().size() 获取当前阻塞队列任务数</li></ul><h3 id="3-关闭线程池"><a href="#3-关闭线程池" class="headerlink" title="3. 关闭线程池"></a>3. 关闭线程池</h3><p>关闭线程池无非就是两个方法 shutdown()/shutdownNow()。</p><p>但他们有着重要的区别：</p><ul><li>shutdown() 执行后停止接受新任务，会把队列的任务执行完毕。</li><li>shutdownNow() 也是停止接受新任务，但会中断所有的任务，将线程池状态变为 stop。</li></ul><p>两个方法都会中断线程，用户可自行判断是否需要响应中断。<br>shutdownNow() 要更简单粗暴，可以根据实际场景选择不同的方法。</p><p>通常是按照以下方式关闭线程池的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    pool.execute(<span class="keyword">new</span> Job());</span><br><span class="line">&#125;</span><br><span class="line">pool.shutdown();</span><br><span class="line"><span class="keyword">while</span> (!pool.awaitTermination(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    LOGGER.info(<span class="string">"线程还在执行。。。"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">LOGGER.info(<span class="string">"一共处理了【&#123;&#125;】"</span>, (end - start));</span><br></pre></td></tr></table></figure></p><p>pool.awaitTermination(1, TimeUnit.SECONDS) 会每隔一秒钟检查一次是否执行完毕（状态为 TERMINATED），当从 while 循环退出时就表明线程池已经完全终止了。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;阿里巴巴Java手册有一条：&lt;br&gt;【强制】线程资源必须通过线程池提供，禁止在应用程序中显示创建线程。&lt;br&gt;说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程导致消耗完内存或者过
      
    
    </summary>
    
    
      <category term="并发编程" scheme="http://yoursite.com/child/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-ThreadLocal原理</title>
    <link href="http://yoursite.com/child/2018/05/03/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-ThreadLocal%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/child/2018/05/03/并发编程-ThreadLocal原理/</id>
    <published>2018-05-03T12:58:11.000Z</published>
    <updated>2019-05-17T04:53:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>ThreadLocal是一个本地线程副本变量工具类，ThreadLocal的实例代表了一个线程局部的变量，主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。</p><h3 id="1-我是什么"><a href="#1-我是什么" class="headerlink" title="1. 我是什么"></a>1. 我是什么</h3><ul><li>是让线程拥有独占的变量</li><li>它通过set、get方法进行设值和取值操作</li><li>它可以覆盖initialValue方法设置初始值，在没进行set之前调用get会调用初始化方法，一个线程只会调用一次</li><li>每个线程都会有一个指向threadLocal的弱引用，只要线程一直存活或者该threadLocal实例能被访问到，就不会被GC清理掉。当jvm内存溢出时，会清理掉值为Null的弱引用。</li></ul><h3 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2. 使用方法"></a>2. 使用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    ThreadLocal&lt;String&gt; stringThreadLocal = new ThreadLocal&lt;String&gt;()&#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected String initialValue()&#123;</span><br><span class="line">            return &quot;default string&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    for(int i = 0; i&lt; 10; i++)&#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            stringThreadLocal.set(Thread.currentThread().getName());</span><br><span class="line">            System.out.println(stringThreadLocal.get());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-我在一个map里"><a href="#3-我在一个map里" class="headerlink" title="3. 我在一个map里"></a>3. 我在一个map里</h3><p>每个线程都有一个ThreadLocalMap对象，map中存放了(ThreadLocal<t>,t)键值对<br><img src="http://ws1.sinaimg.cn/mw690/87c9e458gy1g2dhy5bvohj20me0n9q49.jpg" alt="timg">  </t></p><h4 id="3-1-get源码"><a href="#3-1-get源码" class="headerlink" title="3.1 get源码"></a>3.1 get源码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取当前线程内部的ThreadLocalMap</li><li>map存在则获取当前ThreadLocal对应的值</li><li>不存在则调用setInitialValue进行初始化</li></ul><h4 id="3-2-setInitialValue-源码"><a href="#3-2-setInitialValue-源码" class="headerlink" title="3.2 setInitialValue()源码"></a>3.2 setInitialValue()源码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private T setInitialValue() &#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调用重载的initialValue方法获取初始值</li><li>获取当前线程的ThreadLocalMap</li><li>map存在则将初始值put进去</li><li>map不存在则使用初始值为当前线程创建ThreadLocalMap</li></ul><h4 id="3-3-set-T-value-源码"><a href="#3-3-set-T-value-源码" class="headerlink" title="3.3 set(T value)源码"></a>3.3 set(T value)源码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取当前线程内部的ThreadLocalMap</li><li>map存在则把当前ThreadLocal和value添加到map中</li><li>map不存在则创建一个ThreadLocalMap，保存到当前线程内部</li></ul><p><strong>小结</strong><br>每个线程都有一个ThreadLocalMap类型的私有变量，当为线程添加ThreadLocal对象时，就是保存到了这个map中，所以线程之间不会相互干扰。</p><h3 id="4-我还有一个大坑"><a href="#4-我还有一个大坑" class="headerlink" title="4. 我还有一个大坑"></a>4. 我还有一个大坑</h3><p>ThreadLocal使用不当，会引发内存泄露的问题<br>ThreadLocal对象存在thread对象中，只要线程没有死亡，该对象就不会被回收</p><p>remove()源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void remove() &#123;</span><br><span class="line">     ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">     if (m != null)</span><br><span class="line">         m.remove(this);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><ul><li>获取当前线程内部的ThreadLocalMap，存在则从map中删除这个ThreadLocal对象。</li></ul><h3 id="5-无处不在的map"><a href="#5-无处不在的map" class="headerlink" title="5. 无处不在的map"></a>5. 无处不在的map</h3><p>分析完4个公开方法的源码，发现每个方法都离不开ThreadLocalMap类，下面分析一下这个无处不在的map。</p><ul><li>ThreadLocalMap是一个自定义的Hashmap，专门用来保存线程的ThreadLocal变量</li><li>它的操作仅限于ThreadLocal类中，不对外暴露</li><li>这个类被用在Thread类的私有变量threadLocals和inheritableThreadLocals上</li><li>为了能够保存大量且存活时间较长的threadLocal实例，hash table entries采用了WeakReferences作为key的类型</li><li>一旦hash table运行空间不足，key为null的entry就会被清理掉</li></ul><p><strong>源码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static class ThreadLocalMap &#123;</span><br><span class="line">    static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">        Object value;</span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            super(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final int INITIAL_CAPACITY = 16;</span><br><span class="line"></span><br><span class="line">    private Entry[] table;</span><br><span class="line"></span><br><span class="line">    private int size = 0;</span><br><span class="line"></span><br><span class="line">    private int threshold; // Default to 0</span><br><span class="line"></span><br><span class="line">    private void setThreshold(int len) &#123;</span><br><span class="line">        threshold = len * 2 / 3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        table = new Entry[INITIAL_CAPACITY];</span><br><span class="line">        int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);</span><br><span class="line">        table[i] = new Entry(firstKey, firstValue);</span><br><span class="line">        size = 1;</span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ThreadLocal是一个本地线程副本变量工具类，ThreadLocal的实例代表了一个线程局部的变量，主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。
      
    
    </summary>
    
    
      <category term="并发编程" scheme="http://yoursite.com/child/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-阻塞队列BQ</title>
    <link href="http://yoursite.com/child/2018/04/27/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97BQ/"/>
    <id>http://yoursite.com/child/2018/04/27/并发编程-阻塞队列BQ/</id>
    <published>2018-04-27T07:37:41.000Z</published>
    <updated>2019-05-28T14:58:34.739Z</updated>
    
    <content type="html"><![CDATA[<p>阻塞队列常用于生产者-消费者场景。</p><p>BQ有4套出队入队操作：</p><ul><li>offer(e) &amp; pool() 这套操作不会阻塞线程，队列满/空的时候返回特殊值 false/null</li><li>add(e) &amp; remove() 该操作对offer(e) &amp; pool()返回的特殊值抛出异常</li><li>put(e) &amp; take() 阻塞方法，遇到队列满/空的时候会阻塞，直到收到通知可以继续执行</li><li>offer(e,time,unit) &amp; poll(time,unit) 超时阻塞方法，超时返回 false/null </li></ul><p>Jdk7中给出了7种BQ：</p><ul><li>ArrayBlockingQueue</li><li>LinkedBlockingQueue</li><li>priorityBlockingQueue</li><li>DelayQueue</li><li>SynchronousQueue</li><li>LinkenTransferQueue</li><li>LinkedBlockingDeque</li></ul><p>本文将以LinkedBlockingQueue为例进行源码解读</p><h3 id="1-Condition"><a href="#1-Condition" class="headerlink" title="1. Condition"></a>1. Condition</h3><p>任意的一个java对象，都拥有一组监视器方法（定义在Object类中），主要包括wait()、wait(long timeout)、notify()、notifyAll()方法，这些方法与sychronized关键字配合使用，可以实现等待/通知模式。Condition接口也通过平了类似Object的监视器方法，与Lock配合可以实现等待/通知模式。但是这两种方式在使用方式以及功能特性上还是有差别的：</p><ol><li>每个Object监视器只有一个等待队列，而Condition接口可以支持多个等待队列</li><li>当前线程释放锁进入等待状态，Object监视器在等待过程中是不相应中断的，而Condition接口是可以的</li><li>Object监视器不支持线程等待到将来的某个特定时间，Condition接口支持</li></ol><h4 id="1-1-Condition的原理"><a href="#1-1-Condition的原理" class="headerlink" title="1.1 Condition的原理"></a>1.1 Condition的原理</h4><p>将在另一篇中解析AQS.ConditionObject类的源码</p><h4 id="1-2-LBQ中的Condition"><a href="#1-2-LBQ中的Condition" class="headerlink" title="1.2 LBQ中的Condition"></a>1.2 LBQ中的Condition</h4><p>LBQ的入队和出队使用了两把重入锁，相应的也有两个条件队列notFull和notEmpty：</p><ul><li>当队列满的时候执行入队操作，入队线程会进入notFull等待，当有元素出队则通知入队线程–队列notFull，可以继续执行；</li><li>当队列为空执行出队操作，出队线程会进入notEmpty等待，当有元素入队后则通知出队线程–队列notEmpty，可以继续执行。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/** Lock held by take, poll, etc */</span><br><span class="line">private final ReentrantLock takeLock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">/** Wait queue for waiting takes */</span><br><span class="line">private final Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">/** Lock held by put, offer, etc */</span><br><span class="line">private final ReentrantLock putLock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">/** Wait queue for waiting puts */</span><br><span class="line">private final Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure></li></ul><p>具体如何使用的，见下文LBQ源码分析</p><h3 id="2-offer-e-amp-poll"><a href="#2-offer-e-amp-poll" class="headerlink" title="2. offer(e) &amp; poll()"></a>2. offer(e) &amp; poll()</h3><p>这套方法是在接口 Queue<e> 中定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">以下代码摘自： java.util.concurrent.LinkedBlockingQueue</span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    if (e == null) throw new NullPointerException();</span><br><span class="line">    final AtomicInteger count = this.count;</span><br><span class="line">    //满了直接返回失败</span><br><span class="line">    if (count.get() == capacity)</span><br><span class="line">        return false;</span><br><span class="line">    int c = -1;</span><br><span class="line">    Node&lt;E&gt; node = new Node&lt;E&gt;(e);</span><br><span class="line">    final ReentrantLock putLock = this.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (count.get() &lt; capacity) &#123;</span><br><span class="line">            enqueue(node);</span><br><span class="line">            c = count.getAndIncrement();</span><br><span class="line">            //c是更新之前的计数</span><br><span class="line">            if (c + 1 &lt; capacity)</span><br><span class="line">                //更新之后还未满，唤醒一个入队线程</span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    if (c == 0)</span><br><span class="line">        //更新之前是空的，更新完就不空了，唤醒一个阻塞的出队线程</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    return c &gt;= 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></e></p><p>offer(e)方法总结：  </p><ol><li>开始先检查参数是否为null，null则抛出NPE异常；</li><li>然后判断队列是否已经满了，满了直接返回false；</li><li>以上检查都通过，构造新节点，获取入队锁putLock</li><li>二重检查，判断队列是否未满，如果未满执行入队，计数器加1，如果计数器更新之后还小于capacity，则唤醒一个入队线程(如果有入队线程阻塞)</li><li>最后判断一下该线程入队前是否为空队列，如果之前是空的，入队完成就可以唤醒一个阻塞的出队线程。</li><li>最后入队成功返回true<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public E poll() &#123;</span><br><span class="line">    final AtomicInteger count = this.count;</span><br><span class="line">    if (count.get() == 0)</span><br><span class="line">        return null;</span><br><span class="line">    E x = null;</span><br><span class="line">    int c = -1;</span><br><span class="line">    final ReentrantLock takeLock = this.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (count.get() &gt; 0) &#123;</span><br><span class="line">            x = dequeue();</span><br><span class="line">            c = count.getAndDecrement();</span><br><span class="line">            if (c &gt; 1)</span><br><span class="line">                notEmpty.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125; </span><br><span class="line">    if (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>poll()方法总结：  </p><ol><li>首先检查队列是否空，若空直接返回null，不空继续执行；</li><li>获取出队锁takelock</li><li>二重检查，检查队列是否不空，不空执行出队，计数器减1，计数器更新之后还大于0(出队后队列还不空)，唤醒一个出队线程（如果有阻塞的出队线程）</li><li>释放锁，然后判断此次出队前队列是否满的，若出队前满则此次出队结束就有余位了，唤醒一个阻塞入队线程执行</li></ol><h3 id="3-add-e-amp-remove"><a href="#3-add-e-amp-remove" class="headerlink" title="3. add(e) &amp; remove()"></a>3. add(e) &amp; remove()</h3><p>这套方法也是在 Queue<e> 中定义，add方法继承自Collection接口，内部调用了offer(e) &amp; pool()，对队空或队满返回的特殊值做异常处理，队满执行入队操作抛 IllegalStateException 异常；队空做出队操作抛 NoSuchElementException 异常 。源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">以下代码摘自： java.util.AbstractQueue</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    if (offer(e))</span><br><span class="line">        return true;</span><br><span class="line">    else</span><br><span class="line">        throw new IllegalStateException(&quot;Queue full&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E remove() &#123;</span><br><span class="line">    E x = poll();</span><br><span class="line">    if (x != null)</span><br><span class="line">        return x;</span><br><span class="line">    else</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></e></p><h3 id="4-put-e-amp-take"><a href="#4-put-e-amp-take" class="headerlink" title="4. put(e) &amp; take()"></a>4. put(e) &amp; take()</h3><p>这是阻塞接口，定义在 BlockingQueue<e> 接口中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">以下代码摘自： java.util.concurrent.LinkedBlockingQueue</span><br><span class="line">public void put(E e) throws InterruptedException &#123;</span><br><span class="line">    if (e == null) throw new NullPointerException();</span><br><span class="line">    // 除非设置，否则保持计数器的值为-1表示失败</span><br><span class="line">    int c = -1;</span><br><span class="line">    Node&lt;E&gt; node = new Node&lt;E&gt;(e);</span><br><span class="line">    final ReentrantLock putLock = this.putLock;</span><br><span class="line">    final AtomicInteger count = this.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        //这里使用while进行判断，是因为await的线程被唤醒时从await返回，需要再进行一次判断</span><br><span class="line">        //如果使用if的话就直接往下运行了，运行结果会不稳定。</span><br><span class="line">        while (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(node);</span><br><span class="line">        //返回旧的计数然后计数+1</span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        //入队之后如果还有位置，给notFull队列发信号，唤醒put线程</span><br><span class="line">        if (c + 1 &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    //这个c是入队之前的计数，入队之前为空，入队后有元素了，所以要唤醒一个出队线程</span><br><span class="line">    if (c == 0)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></e></p><p>put(e)方法总结：  </p><ol><li>检查参数为空抛NPE异常</li><li>使用参数构造新节点，获取入队锁putLock</li><li>当队满时，调用 notFull.await() 阻塞当前线程，注意此处使用while语句进行判断，原因后文分析。</li><li>队不满执行入队，计数器 +1</li><li>判断计数器更新后队是否未满，未满则唤醒阻塞的入队线程（如果存在的话）</li><li>解锁</li><li>判断此次入队前是否为空队列，如果是，此次入队完成就不是了，唤醒一个阻塞的出队线程。</li><li>无返回值</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">    E x;</span><br><span class="line">    int c = -1;</span><br><span class="line">    final AtomicInteger count = this.count;</span><br><span class="line">    final ReentrantLock takeLock = this.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();//1</span><br><span class="line">    try &#123;</span><br><span class="line">        while (count.get() == 0) &#123;//2</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();//3</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        if (c &gt; 1)//4</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        takeLock.unlock();//5</span><br><span class="line">    &#125;</span><br><span class="line">    if (c == capacity)//6</span><br><span class="line">        signalNotFull();</span><br><span class="line">    return x;//7</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>take()方法总结：  </p><ol><li>获取出队锁takeLock</li><li>判断队列是否为空，为空就调用notEmpty.await()阻塞线程</li><li>不空就执行出队操作，计数器 -1</li><li>如果出队后队列仍然不空，唤醒一个阻塞的出队线程（如果存在的话）</li><li>解锁</li><li>若此次出队之前队列满，执行完本次出队就不满了，可以唤醒一个入队线程</li><li>返回出队的元素</li></ol><h3 id="5-offer-e-time-unit-amp-poll-time-unit"><a href="#5-offer-e-time-unit-amp-poll-time-unit" class="headerlink" title="5. offer(e,time,unit) &amp; poll(time, unit)"></a>5. offer(e,time,unit) &amp; poll(time, unit)</h3><p>超时阻塞方法，定义在 BlockingQueue<e> 接口中，该组方法在put/take的基础上加上了超时返回的功能，出队超时返回null，入队超时返回false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">以下代码摘自： java.util.concurrent.LinkedBlockingQueue</span><br><span class="line">public boolean offer(E e, long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (e == null) throw new NullPointerException();</span><br><span class="line">    long nanos = unit.toNanos(timeout);//1</span><br><span class="line">    int c = -1;</span><br><span class="line">    final ReentrantLock putLock = this.putLock;</span><br><span class="line">    final AtomicInteger count = this.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        while (count.get() == capacity) &#123;</span><br><span class="line">            if (nanos &lt;= 0)//超时了</span><br><span class="line">                return false;</span><br><span class="line">            //没超时阻塞，nanos之后自动唤醒</span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">            //唤醒后返回到这里，继续while循环判断队列是否满，还是满就妥妥的超时了</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(new Node&lt;E&gt;(e));</span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        if (c + 1 &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    if (c == 0)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E poll(long timeout, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">    E x = null;</span><br><span class="line">    int c = -1;</span><br><span class="line">    long nanos = unit.toNanos(timeout);</span><br><span class="line">    final AtomicInteger count = this.count;</span><br><span class="line">    final ReentrantLock takeLock = this.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        while (count.get() == 0) &#123;</span><br><span class="line">            if (nanos &lt;= 0)//超时了</span><br><span class="line">                return null;</span><br><span class="line">            //没超时阻塞，nanos之后自动唤醒</span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">            //唤醒后返回到这，继续为了循环判断队列是否为空，还是为空妥妥的超时</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        if (c &gt; 1)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    if (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></e></p><h3 id="6-await之前的判断为什么用while"><a href="#6-await之前的判断为什么用while" class="headerlink" title="6. await之前的判断为什么用while"></a>6. await之前的判断为什么用while</h3><p>用put作为例子解释一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">putLock.lockInterruptibly();</span><br><span class="line">try &#123;</span><br><span class="line">    while (count.get() == capacity) &#123;</span><br><span class="line">        notFull.await();//1</span><br><span class="line">    &#125;</span><br><span class="line">    enqueue(node);</span><br><span class="line">    c = count.getAndIncrement(); //2</span><br><span class="line">    if (c + 1 &lt; capacity)</span><br><span class="line">        notFull.signal();//3</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    putLock.unlock();//4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>假设A线程入队操作结束后(执行到2位置)，队列还剩一个空位，那么程序会唤醒阻塞队列中的put线程（3位置）B线程</li><li>B线程从await返回前需要竞争put锁（await会释放锁），但这时候有个C线程也来竞争put锁并且成功，C执行入队之后队列已经满了</li><li>C释放锁之后B获得锁，从await返回（位置1），如果这里使用 if 判断，1位置之后继续向下执行入队操作，显然会出错，因为最后一个空位让C线程用掉了</li><li>但是使用 while 判断，await返回之后，还在循环体内，继续循环判断队列是否满，发现满了，再次await。</li></ol><p>所以使用while判断其实是在这里进行了一次 double check， 不管是使用await还是wait，都需要while进行判断，不然在多线程环境中就会出错。</p><h3 id="7-其他方法"><a href="#7-其他方法" class="headerlink" title="7. 其他方法"></a>7. 其他方法</h3><ul><li>peek() 返回头结点，队列空返回null</li><li>element() 调用peak()，peak()返回null则抛异常 NoSuchElementException</li><li>remove(o) 移除指定的元素，参数接受null，若没找到该元素返回false</li><li>contains(o) 判断是否包含指定元素，参数为空或不包含返回false</li><li>remainingCapacity() 返回剩余容量</li><li>size() 返回现有元素数量</li><li>clear() 原子性的清除所有元素</li><li>drainTo(c) 将队列中的元素放到集合c中，返回转换的元素个数</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;阻塞队列常用于生产者-消费者场景。&lt;/p&gt;
&lt;p&gt;BQ有4套出队入队操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;offer(e) &amp;amp; pool() 这套操作不会阻塞线程，队列满/空的时候返回特殊值 false/null&lt;/li&gt;
&lt;li&gt;add(e) &amp;amp; remove
      
    
    </summary>
    
    
      <category term="并发编程" scheme="http://yoursite.com/child/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-共享式AQS源码详解</title>
    <link href="http://yoursite.com/child/2018/04/25/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%85%B1%E4%BA%AB%E5%BC%8FAQS%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/child/2018/04/25/并发编程-共享式AQS源码详解/</id>
    <published>2018-04-25T12:36:12.000Z</published>
    <updated>2019-05-21T06:49:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章详细的阐述了AQS在独占模式下的底层原理，本篇主要讲述共享式同步器的原理。</p><h3 id="1-acquireShared-int"><a href="#1-acquireShared-int" class="headerlink" title="1. acquireShared(int)"></a>1. acquireShared(int)</h3><p>此方式是共享模式下线程获取贡献资源的入口，他会获取指定量的资源，获取成功直接返回，失败则进入等待队列，知道获取到资源为止，整个过程忽略终端。下面看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    //</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected int tryAcquireShared(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 tryAcquireShared 依然需要自定义同步器去实现，但是AQS已经将返回值的语义定义好了，重载该函数的时候执行逻辑要符合下列语义：<br>-返回负值表示获取失败</p><ul><li>返回0表示获取成功，但是没有剩余资源</li><li>返回正数表示获取成功，还有剩余资源</li></ul><p>tryAcquireShared获取失败则执行 doAcquireShared 方法，看下面源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireShared(int arg) &#123;</span><br><span class="line">        //将线程以共享方式加入同步队列尾部</span><br><span class="line">        final Node node = addWaiter(Node.SHARED);</span><br><span class="line">        //获取失败吗，默认true（失败）</span><br><span class="line">        boolean failed = true;</span><br><span class="line">        try &#123;</span><br><span class="line">            //记录等待过程是否被中断过</span><br><span class="line">            boolean interrupted = false;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                //拿到前驱节点</span><br><span class="line">                final Node p = node.predecessor();</span><br><span class="line">                if (p == head) &#123;//如果前驱是头结点</span><br><span class="line">                    //尝试获取</span><br><span class="line">                    int r = tryAcquireShared(arg);</span><br><span class="line">                    if (r &gt;= 0) &#123;</span><br><span class="line">                        //自己获取资源的同时，如果还有剩余资源,唤醒后继节点</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = null; // help GC</span><br><span class="line">                        if (interrupted)//补上中断标志</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = false;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //前驱不是头结点，获取失败后寻找安全点</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>整个过程与acquireQueued()很相似，区别在于唤醒等待线程的条件不同。setHeadAndPropagate方法在setHead()的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line">    Node h = head; //与独占式不同原head并没有释放资源</span><br><span class="line">    setHead(node);</span><br><span class="line">    </span><br><span class="line">    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||</span><br><span class="line">        (h = head) == null || h.waitStatus &lt; 0) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        if (s == null || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-releaseShared"><a href="#2-releaseShared" class="headerlink" title="2. releaseShared()"></a>2. releaseShared()</h3><p>上一小节已经把acquireShared()说完了，这一小节就来讲讲它的反操作releaseShared()吧。此方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。下面是releaseShared()的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。例如，资源总量是13，A（5）和B（7）分别获取到资源并发运行，C（4）来时只剩1个资源就需要等待。A在运行过程中释放掉2个资源量，然后tryReleaseShared(2)返回true唤醒C，C一看只有3个仍不够继续等待；随后B又释放2个，tryReleaseShared(2)返回true唤醒C，C一看有5个够自己用了，然后C就可以跟A和B一起运行。而ReentrantReadWriteLock读锁的tryReleaseShared()只有在完全释放掉资源（state=0）才返回true，所以自定义同步器可以根据需要决定tryReleaseShared()的返回值。</p><h4 id="2-1-doReleaseShared"><a href="#2-1-doReleaseShared" class="headerlink" title="2.1 doReleaseShared()"></a>2.1 doReleaseShared()</h4><p>此方法主要用于唤醒后继。下面是它的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void doReleaseShared() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h != tail) &#123;</span><br><span class="line">            int ws = h.waitStatus;</span><br><span class="line">            if (ws == Node.SIGNAL) &#123;</span><br><span class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                    continue;            // loop to recheck cases</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ws == 0 &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                continue;                // loop on failed CAS</span><br><span class="line">        &#125;</span><br><span class="line">        if (h == head)                   // loop if head changed</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-Semaphore"><a href="#3-Semaphore" class="headerlink" title="3. Semaphore"></a>3. Semaphore</h3><p>一个具象化的例子：<br>停车场运作，假设停车场有10个车位，刚开始都是空的。如果同时来了11辆车，看守者只能允许10辆车进入，另一辆排队等候，当有车为空出来，等候车辆进入填满空车位。Semaphore就相当于停车场看守者。</p><p>和RentrantLock不同Semaphore没有实现Lock接口，获取资源有响应中断模式和忽略中断模式，中断模式获取资源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void acquire() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(1);</span><br><span class="line">&#125;</span><br><span class="line">public void acquire(int i) throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放资源统一使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void release() &#123;</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br><span class="line">public void release(int i) &#123;</span><br><span class="line">    sync.releaseShared(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部同步器sync重载的tryAcquireShared-tryRealseShared源码如下，代码逻辑简单易懂，实现自定义的同步器一般也只需要实现这几个方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//非公平</span><br><span class="line">final int nonfairTryAcquireShared(int acquires) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int available = getState();</span><br><span class="line">        int remaining = available - acquires;</span><br><span class="line">        if (remaining &lt; 0 ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            return remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//公平</span><br><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        if (hasQueuedPredecessors())</span><br><span class="line">            return -1;</span><br><span class="line">        int available = getState();</span><br><span class="line">        int remaining = available - acquires;</span><br><span class="line">        if (remaining &lt; 0 ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            return remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected final boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int current = getState();</span><br><span class="line">        int next = current + releases;</span><br><span class="line">        if (next &lt; current) // overflow</span><br><span class="line">            throw new Error(&quot;Maximum permit count exceeded&quot;);</span><br><span class="line">        if (compareAndSetState(current, next))</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上篇文章详细的阐述了AQS在独占模式下的底层原理，本篇主要讲述共享式同步器的原理。&lt;/p&gt;
&lt;h3 id=&quot;1-acquireShared-int&quot;&gt;&lt;a href=&quot;#1-acquireShared-int&quot; class=&quot;headerlink&quot; title=&quot;1. ac
      
    
    </summary>
    
    
      <category term="并发编程" scheme="http://yoursite.com/child/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>nginx入门</title>
    <link href="http://yoursite.com/child/2018/04/23/nginx%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/child/2018/04/23/nginx入门/</id>
    <published>2018-04-23T07:17:36.000Z</published>
    <updated>2019-04-26T07:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现。</p><h3 id="1、正向代理与反向代理"><a href="#1、正向代理与反向代理" class="headerlink" title="1、正向代理与反向代理"></a>1、正向代理与反向代理</h3><h4 id="1-1-正向代理：代理服务器代表的是客户端，代理对服务器端透明。"><a href="#1-1-正向代理：代理服务器代表的是客户端，代理对服务器端透明。" class="headerlink" title="1.1 正向代理：代理服务器代表的是客户端，代理对服务器端透明。"></a>1.1 正向代理：代理服务器代表的是客户端，代理对服务器端透明。</h4><p>正向代理的应用场景：  </p><ul><li>vpn  </li><li>缓存，加速访问资源  </li><li>对客户端访问授权，上网进行认证  </li><li>记录用户的上网记录，对外隐藏用户信息  </li></ul><p>正向代理产品：CCProxy  </p><h4 id="1-2-反向代理：代理服务器代表的是服务器端，代理对客户端透明"><a href="#1-2-反向代理：代理服务器代表的是服务器端，代理对客户端透明" class="headerlink" title="1.2 反向代理：代理服务器代表的是服务器端，代理对客户端透明"></a>1.2 反向代理：代理服务器代表的是服务器端，代理对客户端透明</h4><p>反向代理的应用场景：</p><ul><li>保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击</li><li>负载均衡  </li></ul><p>反向代理产品：Nginx  </p><p><img src="http://ws1.sinaimg.cn/mw690/87c9e458gy1g2cldja14kj20rm0op7wh.jpg" alt="正向代理和反向代理">  </p><h3 id="2、nginx安装"><a href="#2、nginx安装" class="headerlink" title="2、nginx安装"></a>2、nginx安装</h3><h4 id="2-1-安装环境"><a href="#2-1-安装环境" class="headerlink" title="2.1 安装环境"></a>2.1 安装环境</h4><ul><li>yum -y install wget      #安装下载工具</li><li>yum install -y gcc gcc-c++        #安装gcc编译环境</li><li>yum install -y pcre-devel          #安装PERE库</li><li>yum -y install openssl openssl-devel    #安装OpenSsl库</li></ul><h4 id="2-2-准备安装nginx"><a href="#2-2-准备安装nginx" class="headerlink" title="2.2 准备安装nginx"></a>2.2 准备安装nginx</h4><ul><li>wget <a href="http://nginx.org/download/nginx-1.14.0.tar.gz" target="_blank" rel="noopener">http://nginx.org/download/nginx-1.14.0.tar.gz</a>   #下载</li><li>tar -zxf nginx-1.14.0.tar.gz             #解压</li><li>cd nginx-1.14.0 </li><li>sed -i -e’s/1.14.0//g’ -e’ s/nginx\//WS/g’ -e’s/“NGINX”/“WS”/g’ src/core/nginx.h    #隐藏版本号(安全性考虑，爆出有些版本的nginx存在漏洞，容易被攻击)</li></ul><h4 id="2-3编译安装nginx"><a href="#2-3编译安装nginx" class="headerlink" title="2.3编译安装nginx"></a>2.3编译安装nginx</h4><ul><li>useradd www      #添加用户，不添加默认为nobody</li><li>./configure –user=www –group=www –prefix=/usr/local/nginx –with-http_ssl_module</li><li>make &amp; make install</li></ul><h3 id="3、nginx的五种负载分配算法"><a href="#3、nginx的五种负载分配算法" class="headerlink" title="3、nginx的五种负载分配算法"></a>3、nginx的五种负载分配算法</h3><h4 id="3-1-round-robin（默认）"><a href="#3-1-round-robin（默认）" class="headerlink" title="3.1 round robin（默认）"></a>3.1 round robin（默认）</h4><p>轮询方式，依次将请求分配到各个后台服务器中，默认的负载均衡方式。<br>适用于后台机器性能一致的情况。<br>挂掉的机器可以自动从服务列表中剔除。</p><h4 id="3-2-weight"><a href="#3-2-weight" class="headerlink" title="3.2 weight"></a>3.2 weight</h4><p>根据权重来分发请求到不同的机器中，指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream bakend &#123;    </span><br><span class="line">    server 192.168.0.14 weight=10;    </span><br><span class="line">    server 192.168.0.15 weight=10;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-3-IP-hash"><a href="#3-3-IP-hash" class="headerlink" title="3.3 IP_hash"></a>3.3 IP_hash</h4><p>根据请求者ip的hash值将请求发送到后台服务器中，可以保证来自同一ip的请求被打到固定的机器上，可以解决session问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream bakend &#123;    </span><br><span class="line">ip_hash;    </span><br><span class="line">server 192.168.0.14:88;    </span><br><span class="line">server 192.168.0.15:80;    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-url-hash（第三方）"><a href="#3-4-url-hash（第三方）" class="headerlink" title="3.4 url_hash（第三方）"></a>3.4 url_hash（第三方）</h4><p>根据请求的url的hash值将请求分到不同的机器中，当后台服务器为缓存的时候效率高。<br>例如：<br>在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;    </span><br><span class="line">    server squid1:3128;    </span><br><span class="line">    server squid2:3128;    </span><br><span class="line">    hash $request_uri;    </span><br><span class="line">    hash_method crc32;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-5-fair（第三方）"><a href="#3-5-fair（第三方）" class="headerlink" title="3.5 fair（第三方）"></a>3.5 fair（第三方）</h4><p>根据后台响应时间来分发请求，响应时间短的分发的请求多。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;    </span><br><span class="line">    server server1;    </span><br><span class="line">    server server2;    </span><br><span class="line">    fair;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现。&lt;/p&gt;
&lt;h3 id=&quot;1、正向代理与反向
      
    
    </summary>
    
    
      <category term="nginx" scheme="http://yoursite.com/child/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-独占式AQS源码详解</title>
    <link href="http://yoursite.com/child/2018/04/19/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E7%8B%AC%E5%8D%A0%E5%BC%8FAQS%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/child/2018/04/19/并发编程-独占式AQS源码详解/</id>
    <published>2018-04-19T12:36:12.000Z</published>
    <updated>2019-06-12T09:07:40.730Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-框架概述"><a href="#1-框架概述" class="headerlink" title="1. 框架概述"></a>1. 框架概述</h3><p>AQS是AbstractQueuedSynchronizer的简称，抽象队列同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类的实现都依赖于它，比如常用的ReentrantLock/CountDownLatch/Semaphore…</p><p>AQS维护了一个volatile int state 代表共享资源，一个FIFO线程等待队列用来记录争用资源而进入等待的线程，这里有一点需要强调，AQS同步队列中的线程是处于WAITING状态的，而竞争synchronized同步块的线程是处于BLOCKING状态的。</p><p>AQS定义了两种组员共享方式：Exclusive 和 Share</p><p>自定义同步器在实现时只需要实现共享资源state的获取与释放方式，至于具体的线程等待队列的维护，AQS已经实现好了。自定义同步器是现实需要实现的几个方法：</p><ul><li>isHeldExclusively() 该线程是否正在独占资源，只有用到Condition才需要实现它</li><li>tryAcquire(int) 独占方式获取资源，获取成功返回ture</li><li>tryRelease(int) 独占方式释放资源，释放成功返回ture</li><li>tryAcquireShared(int) 共享方式获取资源，负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int) 共享方式释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ul><p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p><p>再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p><p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p><h3 id="2-源码详解"><a href="#2-源码详解" class="headerlink" title="2. 源码详解"></a>2. 源码详解</h3><p>本节依照acquire-release、acquireShared-releaseShared的次序来讲解AQS的源码实现。</p><h4 id="2-1-acquire-int"><a href="#2-1-acquire-int" class="headerlink" title="2.1 acquire(int)"></a>2.1 acquire(int)</h4><p>该方法是在独占模式下获取共享资源的顶层入口，如果获取资源成功tryAcquire返回true，该函数直接返回，且整个过程忽略中断的影响；否则调用addWaiter将线程包装成Node对象进入阻塞队列，并不断acquireQueued获取资源。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数流程如下：</p><ol><li>tryAcquire() 尝试直接去获取资源，如果成功则直接返回；</li><li>addWaiter() 将该线程加入等待队列的尾部，并标记为独占模式；</li><li>acquireQueued() 使线程在等待队列中尝试获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li><li>如果线程在等待过程中被中断过，它是不响应的（关于中断的介绍请参考文章线程中断），获取资源后通过selfInterrupt()，将该线程的中断标志置为true。</li></ol><h5 id="2-1-1-tryAcquire-int"><a href="#2-1-1-tryAcquire-int" class="headerlink" title="2.1.1 tryAcquire(int)"></a>2.1.1 tryAcquire(int)</h5><p>此方法尝试获取独占资源，如果成功返回true，否则返回false。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>AQS中该方法没有具体的执行逻辑，这是因为这是AQS定义的一个方法模板，具体的实现需要自定义同步类自己完成，能不能重入，竞争资源时可不可以加塞，都需要子类自己设计。如果子类没有实现该方法，就会调用AQS的默认实现，如上直接抛出异常。</p><h5 id="2-1-2-addWaiter-Node"><a href="#2-1-2-addWaiter-Node" class="headerlink" title="2.1.2 addWaiter(Node)"></a>2.1.2 addWaiter(Node)</h5><p>此方法作用是将当前线程加入到阻塞队列的队尾，并返回当前线程所在节点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 尝试快速入队</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//快速入队失败，调用enq方法入队</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先介绍一下Node，Node节点是对每一个竞争同步代码的线程的封装，主要包含了当前线程对象以及线程的状态。变量waitStatus表示当前Node节点的等待状态，共有4中取值CANCELLED、SIGNAL、CONDITION、PROPAGATE</p><ul><li>CANCELLED ： 值为1，表示当前节点处于结束状态，在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该Node节点</li><li>SIGNAL 值为-1，表示当前节点线程取消或者释放资源的时候，需要unpark其后继节点</li><li>CONDITION 值为-2，表示当前节点处于条件队列，在转变（状态被设为0）之前不会被当做同步队列节点</li><li>PROPAGATE 值为-3，与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态</li><li>0 代表初始状态。</li></ul><h5 id="2-1-3-enq-Node"><a href="#2-1-3-enq-Node" class="headerlink" title="2.1.3 enq(Node)"></a>2.1.3 enq(Node)</h5><p>此方法用于将node加入队尾。源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果你看过AtomicInteger.getAndIncrement()函数源码，那么相信你一眼便看出这段代码的精华。CAS自旋volatile变量，是一种很经典的用法。</p><h5 id="2-1-4-acquireQueued-Node-int"><a href="#2-1-4-acquireQueued-Node-int" class="headerlink" title="2.1.4 acquireQueued(Node, int)"></a>2.1.4 acquireQueued(Node, int)</h5><p>通过tryAcquire()和addWaiter()，该线程获取资源失败，已经被放入等待队列尾部了，下一步该干什么？进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了。这个函数非常关键，上源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取资源失败了吗？</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//标识等待过程中是否被中断过</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获得当前节点的前驱</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//如果前驱是head，那就有资格去尝试获取</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">//获取资源成功，将自己设置成head</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">//help GC，原头结点断开与队列的链接，等待被回收</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; </span><br><span class="line">                failed = <span class="keyword">false</span>;<span class="comment">//表示获取资源成功</span></span><br><span class="line">                <span class="keyword">return</span> interrupted; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//先判断此次获取失败后可不可以 WAITTING，如果不能，继续重复循环</span></span><br><span class="line">            <span class="comment">//执行park让线程进入WAITTING状态，并判断等待过程中有没有中断，发生过就改状态</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么怎么判断线程是不是应该执行park()呢？继续看下面代码，shouldParkAfterFailedAcquire方法主要用于检查状态，看看自己是否真的可以去休息了（进入waiting状态），万一排在队列前边的线程都取消了只是瞎站着，那就需要往前加塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取前驱节点的状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">//如果前驱节点状态是SIGNAL，说明前驱节点释放资源后会通知本节点，可以安全的执行park()</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果前驱节点是取消状态CANCELLED，执行加塞操作，跳过所有取消节点</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果前驱节点状态正常有效，那就把前驱节点的状态设置成SIGNAL，前驱节点执行完释放资源就会通知本节点</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回false表示此次循环不能更改线程状态，返回到acquireQueued方法即系执行循环获取资源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个流程用一句话概括，如果前驱结点的状态不是SIGNAL，那么自己就不能放心去休息，需要去找个安全的休息点，找到安全点后可以再尝试下看能不能获取资源，再次获取失败就可以放心进入WAITTING状态。</p><p>parkAndCheckInterrupt方法就是让线程执行park()进入WAITTINGZ状态，并返回该线程的中断标志<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，Thread.interrupted()方法在获取线程中断标志的同时会将该标志复位为false</p><h5 id="2-1-5-小结"><a href="#2-1-5-小结" class="headerlink" title="2.1.5 小结"></a>2.1.5 小结</h5><p>源码再贴一遍：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>获取独占资源流程如下：<br><img src="https://ws2.sinaimg.cn/large/87c9e458ly1g3vucyalgfj20nz0jdgnc.jpg" alt="独占式AQS获取资源流程"></p><ol><li>调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回；</li><li>否则addWaiter()将该线程加入等待队列的尾部；</li><li>acquireQueued()使线程在等待队列中休息，当前驱节点为head 会去尝试获取资源，获取到资源后将自己设置为head，获取失败寻找安全点等待。注意此处寻找到安全点后不会立即park()，而是在下一次循环尝试获取失败后才会执行park()。如果在整个等待过程中被中断过，则返回true，否则返回false。</li><li>如果线程在等待过程中被中断过，它是不响应的，并且中断标志被Thread.interrupted()重置为false了，所以获取资源后才再进行自我中断selfInterrupt()，将中断标志重置为true。</li></ol><h4 id="2-2-release-int"><a href="#2-2-release-int" class="headerlink" title="2.2 release(int)"></a>2.2 release(int)</h4><p>release是独占模式下线程释放共享资源的顶层接口。它会释放指定量的资源，如果彻底释放了（即state=0），它会唤醒等待队列里的其他线程来获取资源。<br>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);<span class="comment">//唤醒后继节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>逻辑并不复杂。它调用tryRelease()来释放资源。有一点需要注意的是，它是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了。所以自定义同步器在设计tryRelease()的时候要明确这一点</p><h5 id="2-2-1-tryRelease-int"><a href="#2-2-1-tryRelease-int" class="headerlink" title="2.2.1 tryRelease(int)"></a>2.2.1 tryRelease(int)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟tryAcquire()一样，这个方法是需要独占模式的自定义同步器去实现的。正常来说，tryRelease()都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可(state-=arg)，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，release()是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回true，否则返回false。</p><h5 id="2-2-2-unparkSuccessor-Node"><a href="#2-2-2-unparkSuccessor-Node" class="headerlink" title="2.2.2 unparkSuccessor(Node)"></a>2.2.2 unparkSuccessor(Node)</h5><p>此方法用于唤醒等待队列中下一个线程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前节点的状态</span></span><br><span class="line">        <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);<span class="comment">//置0</span></span><br><span class="line">        <span class="comment">//获取下一个将唤醒的节点</span></span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="comment">//若后继节点已取消，找到最靠近head的有效节点</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="comment">//waitStatus&lt;=0的都是有效节点，都可以唤醒</span></span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">            LockSupport.unpark(s.thread);<span class="comment">//唤醒</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>一句话概括，用用unpark()唤醒等待队列中最前边的那个有效线程。</p><h3 id="3-ReentrantLock"><a href="#3-ReentrantLock" class="headerlink" title="3. ReentrantLock"></a>3. ReentrantLock</h3><p>ReentrantLock自身没有继承AQS，但是它持有一个AQS的子类Sync的对象实例sync，Sync又派生了两个子类 FairSync 和 NonfairSync。ReentrantLock实例化时，无参的默认构造函数会使用NonfairSync对sync进行初始化；而接受一个布尔型变量的构造函数根据用户传入的参数决定使用公平锁还是非公平锁。</p><p>公平性是针对锁获取而言的，如果是公平锁，那么锁的获取顺序应该符合请求的绝对时间顺序，也就是FIFO，该原则保证公平的代价是进行大量的线程切换。非公平锁虽然可能造成线程饥饿，但是极少的线程切换保证了其更大的吞吐量，因此ReentrantLock默认实现非公平锁。</p><h4 id="3-1-获取锁"><a href="#3-1-获取锁" class="headerlink" title="3.1 获取锁"></a>3.1 获取锁</h4><p>下面代码是非公平锁和公平锁分别获取资源的操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程对象</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="comment">//如果资源空闲，CAS设置状态量</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果资源被占用，判断持有锁的线程是不是本线程，是的话重入</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重入锁的意义就是持有锁的线程可以多次重复进入临界区，而不需要在同步队列中等待，每次进入状态量加1，进入几次就要释放几次，释放1次状态量减1，当状态量为0时，完全释放资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    int c = getState();</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">    //注意与非公平锁的区别</span><br><span class="line">        if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较以上两个获取资源的函数，发现唯一的区别在于公平锁在设置状态量之前多做了一次判断 !hasQueuedPredecessors()，该函数返回是否有线程排在当前线程前面，如果没有则可以获得锁。hasQueuedPredecessors源码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final boolean hasQueuedPredecessors() &#123;</span><br><span class="line">        Node t = tail; // Read fields in reverse initialization order</span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        //队列中不止一个线程</span><br><span class="line">        //并且第二个线程节点为空或者第二个节点不是是自己</span><br><span class="line">        return h != t &amp;&amp;</span><br><span class="line">            ((s = h.next) == null || s.thread != Thread.currentThread());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-2-释放锁"><a href="#3-2-释放锁" class="headerlink" title="3.2 释放锁"></a>3.2 释放锁</h4><p>释放操作没有公平与非公平之分，所以释放操作是在父类Sync中实现，下面看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    int c = getState() - releases;</span><br><span class="line">    //如果当前线程不是占用线程，抛异常</span><br><span class="line">    if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    boolean free = false;</span><br><span class="line">    //状态量等于0，才是真正释放</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        free = true;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为释放锁之前，当前线程还持有锁，其他线程无权访问，所以修改状态没有用CAS，直接使用setState</p><p>共享式同步器 请看下一篇 并发编程-共享式AQS源码详解</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-框架概述&quot;&gt;&lt;a href=&quot;#1-框架概述&quot; class=&quot;headerlink&quot; title=&quot;1. 框架概述&quot;&gt;&lt;/a&gt;1. 框架概述&lt;/h3&gt;&lt;p&gt;AQS是AbstractQueuedSynchronizer的简称，抽象队列同步器，AQS定义了一套多线
      
    
    </summary>
    
    
      <category term="并发编程" scheme="http://yoursite.com/child/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>spring-HV参数校验</title>
    <link href="http://yoursite.com/child/2018/04/02/spring-HV%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"/>
    <id>http://yoursite.com/child/2018/04/02/spring-HV参数校验/</id>
    <published>2018-04-02T07:39:40.000Z</published>
    <updated>2019-05-23T02:59:16.742Z</updated>
    
    <content type="html"><![CDATA[<p>参数验证是一个常见的问题，无论是前端还是后台，都需对用户输入进行验证，以此来保证系统数据的正确性。对于web来说，有些人可能理所当然的想在前端验证就行了，但这样是非常错误的做法，前端代码对于用户来说是透明的，稍微有点技术的人就可以绕过这个验证，直接提交数据到后台。无论是前端网页提交的接口，还是提供给外部的接口，参数验证随处可见，也是必不可少的。前端做验证只是为了用户体验，比如控制按钮的显示隐藏，单页应用的路由跳转等等。后端才是最终的保障。总之，一切用户的输入都是不可信的。</p><h3 id="1、gradle依赖"><a href="#1、gradle依赖" class="headerlink" title="1、gradle依赖"></a>1、gradle依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;org.springframework.boot:spring-boot-starter-validation&apos;</span><br></pre></td></tr></table></figure><h3 id="2、常用约束"><a href="#2、常用约束" class="headerlink" title="2、常用约束"></a>2、常用约束</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Null             被注释的元素必须为 null     </span><br><span class="line">@NotNull          被注释的元素必须不为 null     </span><br><span class="line">@AssertTrue       被注释的元素必须为 true     </span><br><span class="line">@AssertFalse      被注释的元素必须为 false     </span><br><span class="line">@Min(value)       被注释的元素必须是一个数字，其值必须大于等于指定的最小值     </span><br><span class="line">@Max(value)       被注释的元素必须是一个数字，其值必须小于等于指定的最大值     </span><br><span class="line">@DecimalMin(value)  被注释的元素必须是一个数字，其值必须大于等于指定的最小值 </span><br><span class="line">@DecimalMax(value)  被注释的元素必须是一个数字，其值必须小于等于指定的最大值</span><br><span class="line">@Size(max=, min=)   被注释的元素的大小必须在指定的范围内     </span><br><span class="line">@Digits (integer, fraction)  被注释的元素必须是一个数字，其值必须在可接受的范围内     </span><br><span class="line">@Past   被注释的元素必须是一个过去的日期     </span><br><span class="line">@Future     被注释的元素必须是一个将来的日期     </span><br><span class="line">@Pattern(regex=,flag=)  被注释的元素必须符合指定的正则表达式Hibernate Validator附加的constraint     </span><br><span class="line">@NotBlank(message =)   验证字符串非null，且长度必须大于0     </span><br><span class="line">@Email  被注释的元素必须是电子邮箱地址     </span><br><span class="line">@Length(min=,max=)  被注释的字符串的大小必须在指定的范围内     </span><br><span class="line">@NotEmpty   被注释的字符串的必须非空     </span><br><span class="line">@Range(min=,max=,message=)  被注释的元素必须在合适的范围内</span><br></pre></td></tr></table></figure><h3 id="3、使用方法"><a href="#3、使用方法" class="headerlink" title="3、使用方法"></a>3、使用方法</h3><ul><li>在model类中使用注解约束字段</li><li>接口中需要校验的model对象前使用@Valid注解，并在接口方法参数列表中增加BindingResult对象来接受校验错误信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(value = &quot;/demo&quot;)</span><br><span class="line">    public Integer addDemo(@Valid @RequestBody Demo demo, BindingResult bindingResult)&#123;</span><br><span class="line">        if(bindingResult.hasErrors())&#123;</span><br><span class="line">            for(ObjectError error : bindingResult.getAllErrors())&#123;</span><br><span class="line">                throw new DemoException(DemoExceptionEnum.PARAM_ERROR.getCode(),error.getDefaultMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return demoService.insert(demo);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意：如果在一个接口中有多个参数需要校验，那么每一个参数都需要定义一个BindingResult对象来接收校验结果</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void test()(@RequestBody @Valid DemoModel demo, BindingResult result)</span><br><span class="line"></span><br><span class="line">public void test()(@RequestBody @Valid DemoModel demo, BindingResult result,@RequestBody @Valid DemoModel demo2, BindingResult result2)</span><br></pre></td></tr></table></figure><h3 id="4、深入使用"><a href="#4、深入使用" class="headerlink" title="4、深入使用"></a>4、深入使用</h3><h4 id="4-1-配置校验模式"><a href="#4-1-配置校验模式" class="headerlink" title="4.1 配置校验模式"></a>4.1 配置校验模式</h4><ul><li>默认的校验模式为<strong>普通模式</strong>，普通模式下会校验完所有的属性然后返回所有的校验失败信息</li><li>可配置为<strong>快速失败返回模式</strong>，只要有一个属性校验失败则立即返回</li></ul><blockquote><p>配置方式</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ValidatorConfiguration &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Validator validator()&#123;</span><br><span class="line">        ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )</span><br><span class="line">                .configure()</span><br><span class="line">            　　/**设置validator模式为快速失败返回*/</span><br><span class="line">                .addProperty( &quot;hibernate.validator.fail_fast&quot;, &quot;true&quot; )</span><br><span class="line">                .buildValidatorFactory();</span><br><span class="line">        Validator validator = validatorFactory.getValidator();</span><br><span class="line"></span><br><span class="line">        return validator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-分组校验"><a href="#4-2-分组校验" class="headerlink" title="4.2 分组校验"></a>4.2 分组校验</h4><ul><li><p>使用场景：针对同一个model类，不同的接口需要对不同的属性进行校验  </p><blockquote><p>例如，数据插入接口与数据更新接口需要校验的参数是不同的</p><ul><li>使用方法  <ol><li>在model类中定义内部接口 </li><li>约束增加组别属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;    public class Demo&#123;</span><br><span class="line">&gt;        public interface AddGorup&#123;&#125;</span><br><span class="line">&gt;        public interface UpdateGroup&#123;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></li></ul></blockquote><pre><code>@Range(min = 1,max = Integer.MAX_VALUE,groups = {UpdateGroup.class})private Integer id;@Email(groups = {AddGroup.class,UpdateGroup.class})private String email;@Past(groups = {UpdateGroup.class})private Date birthday; </code></pre><p>  }</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   3. 在接口中使用@Validated(&#123;Demo.AddGroup.class&#125;)来注解参数，表示该参数使用AddGroup来进行校验</span><br><span class="line">     </span><br><span class="line">     &gt;约束的groups属性中可以填写多个接口名，表示该参数加入多个组进行校验</span><br><span class="line">   4. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 4.3 自定义约束</span><br><span class="line">- 创建约束标注</span><br></pre></td></tr></table></figure></li></ul><p>@Target({ElementType.METHOD,ElementType.ANNOTATION_TYPE,ElementType.FIELD,ElementType.PARAMETER})<br>@Retention(RetentionPolicy.RUNTIME)<br>@Constraint(validatedBy = DemoConstraintValidator.class)<br>@Documented<br>public @interface DemoConstraint {<br>    String message() default “default message”;<br>    Class&lt;?&gt;[] groups() default {};<br>    Class&lt;? extends Payload&gt;[] payload() default {};<br>    E value();//约束中设置的value值<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 实现一个验证器</span><br></pre></td></tr></table></figure></p><p>/**</p><ul><li>T  自定义的约束注解类型DemoConstraint</li><li><p>V  需要检验的参数类型<br>public class DemoConstraintValidator implements ConstraintValidator&lt;T, V&gt;{<br> private E value;//注入设置的具体约束<br> @Override<br> public void initialize(T t) {</p><pre><code>this.value = t.value();</code></pre><p> }</p><p> @Override<br> public boolean isValid(V v, ConstraintValidatorContext constraintValidatorContext) {</p><pre><code>//根据value 对 参数v 进行一些判断return true;if(!isValid) {    constraintContext.disableDefaultConstraintViolation();    constraintContext.buildConstraintViolationWithTemplate(&quot;new default message&quot;).addConstraintViolation();    return false;}</code></pre><p> }<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  &gt;T表示创建的注解，V表示该约束校验的数据类型</span><br><span class="line">- 定义默认的验证错误信息  </span><br><span class="line">可以通过ConstraintValidatorContext修改默认的message信息，一旦使用，在注解中给message赋值将不起作用（一般情况下不推荐使用）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 4.4 检验组序列</span><br><span class="line">默认情况下，约束的计算没有特定的顺序，这与它们属于哪个组无关。然而，在某些情况下，控制约束求值的顺序是有用的，例如，我们可以要求在检查汽车的道路价值之前，首先通过所有默认的汽车约束。最后，在我们开车离开之前，我们检查了实际司机的约束条件。为了实现这样的顺序，需要定义一个新的接口，并使用@GroupSequence对其进行注释，以定义必须验证组的顺序。</span><br><span class="line">~~~</span><br><span class="line">注意：</span><br><span class="line">如果这个校验组序列中有一个约束条件没有通过验证的话, 那么此约束条件后面的都不会再继续被校验了.</span><br><span class="line">~~~</span><br></pre></td></tr></table></figure></li></ul><p>@GroupSequence({Default.class, CarChecks.class, DriverChecks.class})<br>public interface OrderedChecks {<br>}<br><code>`</code></p><h3 id="5、-Valid-amp-Validated"><a href="#5、-Valid-amp-Validated" class="headerlink" title="5、@Valid  &amp; @Validated"></a>5、@Valid  &amp; @Validated</h3><table><thead><tr><th>用法</th><th style="text-align:center">@valid</th><th style="text-align:center">@validated</th></tr></thead><tbody><tr><td>类名前</td><td style="text-align:center"></td><td style="text-align:center">√</td></tr><tr><td>类属性前</td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td>方法前</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td>入参前</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr></tbody></table><blockquote><ul><li>类名前是否加@Validated只影响@RequestParam注解的参数校验，如要进行校验，必须加。  </li><li>不需要分组校验的情况下，接口入参之前只能注解@Valid才能正常校验</li><li>需要分组校验的时候，接口入参之前需要使用@Validated({GroupA.class,…})才能正常校验</li><li>@Valid用在类成员属性名之前，是为了实现嵌套校验</li></ul></blockquote><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://docs.jboss.org/hibernate/validator/4.2/reference/zh-CN/html_single/#preface" target="_blank" rel="noopener">官方文档</a><br><a href="https://www.cnblogs.com/mr-yang-localhost/p/7812038.html" target="_blank" rel="noopener">springboot使用hibernate validator校验</a><br><a href="https://blog.csdn.net/qq_27680317/article/details/79970590" target="_blank" rel="noopener">@Validated和@Valid区别</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参数验证是一个常见的问题，无论是前端还是后台，都需对用户输入进行验证，以此来保证系统数据的正确性。对于web来说，有些人可能理所当然的想在前端验证就行了，但这样是非常错误的做法，前端代码对于用户来说是透明的，稍微有点技术的人就可以绕过这个验证，直接提交数据到后台。无论是前端
      
    
    </summary>
    
    
      <category term="spring" scheme="http://yoursite.com/child/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-锁</title>
    <link href="http://yoursite.com/child/2018/04/01/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E9%94%81/"/>
    <id>http://yoursite.com/child/2018/04/01/并发编程-锁/</id>
    <published>2018-04-01T04:32:12.000Z</published>
    <updated>2019-05-28T14:57:42.154Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-基础"><a href="#1-基础" class="headerlink" title="1 基础"></a>1 基础</h3><h4 id="1-1-锁的类型"><a href="#1-1-锁的类型" class="headerlink" title="1.1 锁的类型"></a>1.1 锁的类型</h4><p>锁从宏观上分类，分为悲观锁与乐观锁。</p><p><strong>乐观锁</strong>是一种乐观思想，认为读多写少，遇到并发写的可能性低。每次读数据的时候，都认为别的线程没有修改过数据，所以不会上锁；但是写数据的时候会判断一下其他线程有没有更新过该数据。具体操作方式是：先读出当前版本号，然后加锁操作，如果跟之前的版本号一致则更新，否则重复 读-比较-写 的操作。java中的乐观锁基本上都是使用CAS实现的。</p><p><strong>悲观锁</strong>就是一种悲观思想，认为写多读少，遇到并发写的可能性高。每次读数据的时候都认为会被其他线程修改，所以每次读写都会上锁。java中的 synchronized 即使悲观锁，而AQS框架下的锁先是尝试CAS乐观锁去获取，获取不到才会转换为悲观锁，如ReentrantLock。</p><h4 id="1-2-java线程阻塞的代价"><a href="#1-2-java线程阻塞的代价" class="headerlink" title="1.2 java线程阻塞的代价"></a>1.2 java线程阻塞的代价</h4><p>java的线程是映射到操作系统原生线程上的，如果要阻塞或唤醒一个线程就需要操作系统介入，操作系统需要在用户态与核心态之间转换，这种切换会消耗大量的系统资源（因为用户态与核心态有各自的内存区域、寄存器等资源，用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。）</p><ul><li>如果线程状态切换是一个高频操作时，这将会消耗很多CPU处理时间；</li><li>如果对于那些需要同步的简单的代码块，获取锁挂起操作消耗的时间比用户代码执行的时间还要长，这种同步策略显然非常糟糕的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java线程的 WAITING 和 BLOCKED 状态对于操作系统来说其实是一回事，都是暂停线程，都需要进行上下文切换。</span><br><span class="line">他们的区别在于唤醒方式不同，W 是用户主动唤醒，而 B 是系统自动唤醒。</span><br></pre></td></tr></table></figure></li></ul><p>synchronized会导致争用不到锁的线程进入阻塞状态，所以说它是java语言中一个重量级的同步操纵，被称为重量级锁，为了缓解上述性能问题，JVM从1.5开始，引入了轻量锁与偏向锁，默认启用了自旋锁，他们都属于乐观锁。</p><p>明确java线程切换的代价，是理解java中各种锁的优缺点的基础。</p><h3 id="1-3-MarkWord"><a href="#1-3-MarkWord" class="headerlink" title="1.3 MarkWord"></a>1.3 MarkWord</h3><p>markword是java对象数据结构中的一部分，对象的markword和java各种类型的锁密切相关。</p><p>markword数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，它的最后2bit是锁状态标志位，用来标记当前对象的状态，对象的所处的状态，决定了markword存储的内容，如下表所示:  </p><table><thead><tr><th>状态</th><th>标志位</th><th>存储内容</th></tr></thead><tbody><tr><td>未锁定</td><td>01</td><td>对象哈希码、对象分代年龄</td></tr><tr><td>轻量级锁定</td><td>00</td><td>指向锁记录的指针</td></tr><tr><td>膨胀(重量级锁定)</td><td>10</td><td>执行重量级锁定的指针</td></tr><tr><td>GC标记</td><td>11</td><td>空(不需要记录信息)</td></tr><tr><td>可偏向</td><td>01</td><td>偏向线程ID、偏向时间戳、对象分代年龄</td></tr></tbody></table><p>32位虚拟机在不同状态下markword结构如下图所示：<br><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Mark%20Word.png" alt="MarkWord"><br>了解了markword结构，有助于后面了解java锁的加锁解锁过程；</p><p><strong>小结：</strong><br>前面提到了java的4种锁，他们分别是重量级锁、自旋锁、轻量级锁和偏向锁，<br>不同的锁有不同特点，每种锁只有在其特定的场景下，才会有出色的表现，java中没有哪种锁能够在所有情况下都能有出色的效率，引入这么多锁的原因就是为了应对不同的情况；</p><p>前面讲到了重量级锁是悲观锁的一种，自旋锁、轻量级锁与偏向锁属于乐观锁，所以现在你就能够大致理解了他们的适用范围，但是具体如何使用这几种锁呢，就要看后面的具体分析他们的特性；</p><h3 id="2-java中的锁"><a href="#2-java中的锁" class="headerlink" title="2. java中的锁"></a>2. java中的锁</h3><h4 id="2-1-自旋锁"><a href="#2-1-自旋锁" class="headerlink" title="2.1 自旋锁"></a>2.1 自旋锁</h4><p>自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p><p>但是线程自旋是需要消耗cup的，说白了就是让cup在做无用功，线程不能一直占用cup自旋做无用功，所以需要设定一个自旋等待的最大时间。</p><p>如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。</p><p><strong>优缺点</strong>  自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起操作的消耗！</p><p>但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用cpu做无用功，占着XX不XX，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要cup的线程又不能获取到cpu，造成cpu的浪费。</p><p>自旋锁时间阈值<br>自旋锁的目的是为了占着CPU的资源不释放，等到获取到锁立即进行处理。但是如何去选择自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用CPU资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要！</p><p>JVM对于自旋周期的选择，jdk1.5这个限度是一定的写死的，在1.6引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间，同时JVM还针对当前CPU的负荷情况做了较多的优化</p><ol><li>如果平均负载小于CPUs则一直自旋</li><li>如果有超过(CPUs/2)个线程正在自旋，则后来线程直接阻塞</li><li>如果正在自旋的线程发现Owner发生了变化则延迟自旋时间（自旋计数）或进入阻塞</li><li>如果CPU处于节电模式则停止自旋</li><li>自旋时间的最坏情况是CPU的存储延迟（CPU A存储了一个数据，到CPU B得知这个数据直接的时间差）</li><li>自旋时会适当放弃线程优先级之间的差异</li></ol><h4 id="2-2-重量级锁Synchronized"><a href="#2-2-重量级锁Synchronized" class="headerlink" title="2.2 重量级锁Synchronized"></a>2.2 重量级锁Synchronized</h4><h5 id="2-2-1-Synchronized的作用"><a href="#2-2-1-Synchronized的作用" class="headerlink" title="2.2.1 Synchronized的作用"></a>2.2.1 Synchronized的作用</h5><p>在JDK1.5之前都是使用synchronized关键字保证同步的，<br>它可以把任意一个非NULL的对象当作锁。</p><ul><li>作用于方法时，锁住的是对象的实例(this)；</li><li>当作用于静态方法时，锁住的是Class实例，又因为Class的相关数据存储在永久带PermGen（jdk1.8则是metaspace），永久带是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程；</li><li>当作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。</li></ul><h5 id="2-2-2-Synchronized的实现"><a href="#2-2-2-Synchronized的实现" class="headerlink" title="2.2.2 Synchronized的实现"></a>2.2.2 Synchronized的实现</h5><p>它有多个队列，当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中，如下如所示：<br><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.png" alt="重量级锁">  </p><ol><li>Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；</li><li>Entry List：Contention List中那些有资格成为候选资源的线程被移动到Entry List中；</li><li>Wait Set：哪些调用wait方法被阻塞的线程被放置在这里；</li><li>OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为OnDeck；</li><li>Owner：当前已经获取到所资源的线程被称为Owner；</li><li>!Owner：当前释放锁的线程。</li></ol><p>JVM每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下，ContentionList会被大量的并发线程进行CAS访问，为了降低对尾部元素的竞争，JVM会将一部分线程移动到EntryList中作为候选竞争线程。Owner线程会在unlock时，将ContentionList中的部分线程迁移到EntryList中，并指定EntryList中的某个线程为OnDeck线程（一般是最先进去的那个线程）。Owner线程并不直接把锁传递给OnDeck线程，而是把锁竞争的权利交给OnDeck，OnDeck需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在JVM中，也把这种选择行为称之为“竞争切换”。</p><p>OnDeck线程获取到锁资源后会变为Owner线程，而没有得到锁资源的仍然停留在EntryList中。如果Owner线程被wait方法阻塞，则转移到WaitSet队列中，直到某个时刻通过notify或者notifyAll唤醒，会重新进去EntryList中。</p><p>处于ContentionList、EntryList、WaitSet中的线程都处于阻塞状态，该阻塞是由操作系统来完成的（Linux内核下采用pthread_mutex_lock内核函数实现的）。</p><h5 id="2-2-3-Synchronized的非公平性"><a href="#2-2-3-Synchronized的非公平性" class="headerlink" title="2.2.3 Synchronized的非公平性"></a>2.2.3 Synchronized的非公平性</h5><ul><li>Synchronized在线程进入ContentionList时，等待的线程会先尝试自旋获取锁，如果获取不到就进入ContentionList，这明显对于已经进入队列的线程是不公平的</li><li>自旋获取锁的线程还可能直接抢占OnDeck线程的锁资源。</li></ul><h4 id="2-3-偏向锁"><a href="#2-3-偏向锁" class="headerlink" title="2.3 偏向锁"></a>2.3 偏向锁</h4><p>Java偏向锁(Biased Locking)是Java6引入的一项多线程优化。<br>偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，这种情况下，就会给线程加一个偏向锁。<br>如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。</p><h5 id="2-3-1-偏向锁的实现"><a href="#2-3-1-偏向锁的实现" class="headerlink" title="2.3.1 偏向锁的实现"></a>2.3.1 偏向锁的实现</h5><ul><li>偏向锁获取过程：</li></ul><ol><li>访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01，确认为可偏向状态。</li><li>如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤5，否则进入步骤3。</li><li>如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行5；如果竞争失败，执行4。</li><li>如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。（撤销偏向锁的时候会导致stop the word）</li><li>执行同步代码。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：第四步中到达安全点safepoint会导致stop the word，时间很短。</span><br></pre></td></tr></table></figure></li></ol><ul><li>偏向锁的释放：</li></ul><p>偏向锁的撤销在上述第四步骤中有提到。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p><h5 id="2-3-2-偏向锁的适用场景"><a href="#2-3-2-偏向锁的适用场景" class="headerlink" title="2.3.2 偏向锁的适用场景"></a>2.3.2 偏向锁的适用场景</h5><p>始终只有一个线程在执行同步块，在它没有执行完释放锁之前，没有其它线程去执行同步块，在锁无竞争的情况下使用，一旦有了竞争就升级为轻量级锁，升级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁的时候会导致stop the word操作；<br>在有锁的竞争时，偏向锁会多做很多额外操作，尤其是撤销偏向所的时候会导致进入安全点，安全点会导致stw，导致性能下降，所以高并发的应用会禁用掉偏向锁。</p><h5 id="2-3-3-jvm开启-关闭偏向锁"><a href="#2-3-3-jvm开启-关闭偏向锁" class="headerlink" title="2.3.3 jvm开启/关闭偏向锁"></a>2.3.3 jvm开启/关闭偏向锁</h5><p>开启偏向锁：-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0<br>关闭偏向锁：-XX:-UseBiasedLocking</p><h4 id="2-4-轻量级锁"><a href="#2-4-轻量级锁" class="headerlink" title="2.4 轻量级锁"></a>2.4 轻量级锁</h4><p>轻量级锁是由偏向所升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁； </p><p>轻量级锁的加锁过程：</p><ol><li>在代码进入同步块之前，如果同步对象锁状态为无锁状态（偏向锁标志为“0”，锁标志位为“01”），JVM会在当前线程的栈桢中创建用于存储<strong>锁记录</strong>的空间，并将对象头中的MarkWord复制到锁记录中，官方称为Displaced Mark Word。</li><li>然后线程尝试使用CAS将对象头中的Mark Word替换为指向该线程锁记录的指针。</li><li>如果成功，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”</li><li>如果失败，表示有其他线程竞争锁，当前线程自旋来获取锁。</li></ol><p>轻量级锁解锁过程：</p><ol><li>轻量级解锁时，会使用CAS操作将Displaced Mark Word替换回对象头</li><li>如果替换失败，说明有其他线程尝试过获取该锁（此时锁已膨胀成重量级），那就要在释放锁的同时，唤醒被挂起的线程。</li></ol><h4 id="2-5-锁升级过程"><a href="#2-5-锁升级过程" class="headerlink" title="2.5 锁升级过程"></a>2.5 锁升级过程</h4><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B%E5%9B%BE.jpeg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-基础&quot;&gt;&lt;a href=&quot;#1-基础&quot; class=&quot;headerlink&quot; title=&quot;1 基础&quot;&gt;&lt;/a&gt;1 基础&lt;/h3&gt;&lt;h4 id=&quot;1-1-锁的类型&quot;&gt;&lt;a href=&quot;#1-1-锁的类型&quot; class=&quot;headerlink&quot; title=&quot;1
      
    
    </summary>
    
    
      <category term="并发编程" scheme="http://yoursite.com/child/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-线程中断</title>
    <link href="http://yoursite.com/child/2018/03/20/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/"/>
    <id>http://yoursite.com/child/2018/03/20/并发编程-线程中断/</id>
    <published>2018-03-20T12:36:12.000Z</published>
    <updated>2019-06-09T12:12:10.193Z</updated>
    
    <content type="html"><![CDATA[<p>中断可以理解为现成的一个标识位属性，它表示一个运行中的线程是否被被其他线程进行了中断操作。中断好比其他线程对该线程打了个招呼，其他线程通过调用该线程的interrupt()方法对其进行中断操作。</p><p>线程通过检查自身是否被中断来进行响应，线程通过方法 isInterrupted()来进行判断是否被中断，也可以调用静态方法 Thread.interrupted() 对当前线程的中断标识进行复位，如果该线程已经处于中断状态，在调用该线程对象的isInterrupted()时依旧会返回false。</p><p>本篇将从以下两个方面来介绍Java中对线程中断机制的具体实现：</p><ol><li>Java中对线程中断所提供的API支持</li><li>线程在不同状态下对于中断所产生的反应</li></ol><h3 id="1-Java中线程中断的API"><a href="#1-Java中线程中断的API" class="headerlink" title="1. Java中线程中断的API"></a>1. Java中线程中断的API</h3><p>在以前的jdk版本中，我们使用stop方法中断线程，但是现在的jdk版本中已经不再推荐使用该方法了，反而由以下三个方法完成对线程中断的支持。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p><p>每个线程都一个状态位用于标识当前线程对象是否是中断状态。isInterrupted是一个实例方法，主要用于判断当前线程对象的中断标志位是否被标记了，如果被标记了则返回true表示当前已经被中断，否则返回false。我们也可以看看它的实现源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure><p>底层调用的本地方法isInterrupted，传入一个boolean类型的参数，用于指定调用该方法之后是否需要清除该线程对象的中断标识位。从这里我们也可以看出来，调用isInterrupted并不会清除线程对象的中断标识位。</p><p>interrupt也是一个实例方法，该方法用于设置线程对象的中断标识位，只要能获取到实例对象，就能调用该方法。</p><p><strong>interrupted()</strong>是一个静态的方法，用于返回当前线程是否被中断，并<strong>清空标志位</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure><p>该方法用于判断当前线程是否被中断，并且该方法调用结束的时候会清空中断标识位。下面我们看看线程所处不同状态下对于中断操作的反应。</p><h3 id="2-线程在不同状态下对于中断所产生的反应"><a href="#2-线程在不同状态下对于中断所产生的反应" class="headerlink" title="2. 线程在不同状态下对于中断所产生的反应"></a>2. 线程在不同状态下对于中断所产生的反应</h3><p>线程一共6种状态，分别是NEW，RUNNABLE，BLOCKED，WAITING，TIMED_WAITING，TERMINATED（Thread类中有一个State枚举类型列举了线程的所有状态）。下面我们就将把线程分别置于上述的不同种状态，然后看看我们的中断操作对它们的影响。</p><h4 id="2-1-NEW和TERMINATED"><a href="#2-1-NEW和TERMINATED" class="headerlink" title="2.1 NEW和TERMINATED"></a>2.1 NEW和TERMINATED</h4><p>线程的new状态表示还未调用start方法，还未真正启动。线程的terminated状态表示线程已经运行终止。这两个状态下调用中断方法来中断线程的时候，Java认为毫无意义，所以并不会设置线程的中断标识位，什么事也不会发生。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">    System.out.println(thread.getState());</span><br><span class="line">    thread.interrupt();</span><br><span class="line">    System.out.println(thread.isInterrupted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NEW</span><br><span class="line">fales</span><br></pre></td></tr></table></figure></p><p>terminated状态：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">    thread.start();</span><br><span class="line">    thread.join();</span><br><span class="line">    System.out.println(thread.getState());</span><br><span class="line">    thread.interrupt();</span><br><span class="line">    System.out.println(thread.isInterrupted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TERMINATED</span><br><span class="line">false</span><br></pre></td></tr></table></figure></p><p>从上述的两个例子来看，对于处于new和terminated状态的线程对于中断是屏蔽的，也就是说中断操作对这两种状态下的线程是无效的。</p><h4 id="2-2-RUNNABLE"><a href="#2-2-RUNNABLE" class="headerlink" title="2.2 RUNNABLE"></a>2.2 RUNNABLE</h4><p>如果线程处于运行状态，那么该线程的状态就是RUNNABLE，但是不一定所有处于RUNNABLE状态的线程都能获得CPU运行，在某个时间段，只能由一个线程占用CPU，那么其余的线程虽然状态是RUNNABLE，但是都没有处于运行状态。而我们处于RUNNABLE状态的线程在遭遇中断操作的时候只会设置该线程的中断标志位，并不会让线程实际中断，想要发现本线程已经被要求中断了则需要用程序去判断。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(thread.getState());</span><br><span class="line"></span><br><span class="line">    thread.interrupt();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">//等到thread线程被中断之后</span></span><br><span class="line">    System.out.println(thread.isInterrupted());</span><br><span class="line">    System.out.println(thread.getState());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义的线程始终循环做一些事情，主线程启动该线程并输出该线程的状态，然后调用中断方法中断该线程并再次输出该线程的状态。总的输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUNNABLE</span><br><span class="line">ture</span><br><span class="line">RUNNABLE</span><br></pre></td></tr></table></figure><p>可以看到在我们启动线程之后，线程状态变为RUNNABLE，中断之后输出中断标志，显然中断位已经被标记，但是当我们再次输出线程状态的时候发现，线程仍然处于RUNNABLE状态。很显然，处于RUNNBALE状态下的线程即便遇到中断操作，也只会设置中断标志位并不会实际中断线程运行。那么问题是，既然不能直接中断线程，我要中断标志有何用处？<br>这里其实Java将这种权力交给了我们的程序，Java给我们提供了一个中断标志位，我们的程序可以通过if判断中断标志位是否被设置来中断我们的程序而不是系统强制的中断。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">            System.out.println(<span class="string">"exit MyThread"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程一旦发现自己的中断标志为被设置了，立马跳出死循环。这样的设计好处就在于给了我们程序更大的灵活性。</p><h4 id="2-3-BLOCKED"><a href="#2-3-BLOCKED" class="headerlink" title="2.3 BLOCKED"></a>2.3 BLOCKED</h4><p>当线程处于BLOCKED状态说明该线程由于竞争某个对象的锁失败而被挂在了该对象的阻塞队列上了。那么此时发起中断操作不会对该线程产生任何影响，依然只是设置中断标志位。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends Thread&#123;</span><br><span class="line">    public synchronized static void doSomething()&#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            //do something</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里我们自定义了一个线程类，run方法中主要就做一件事情，调用一个有锁的静态方法，该方法内部是一个死循环（占用该锁让其他线程阻塞）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">    thread1.start();</span><br><span class="line"></span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">    thread2.start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    System.out.println(thread1.getState());</span><br><span class="line">    System.out.println(thread2.getState());</span><br><span class="line"></span><br><span class="line">    thread2.interrupt();</span><br><span class="line">    System.out.println(thread2.isInterrupted());</span><br><span class="line">    System.out.println(thread2.getState());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在我们的主线程中，我们定义了两个线程并按照定义顺序启动他们，显然thread1启动后便占用MyThread类锁，此后thread2在获取锁的时候一定失败，自然被阻塞在阻塞队列上，而我们对thread2进行中断，输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RUNNABLE</span><br><span class="line">BLOCKED</span><br><span class="line">true</span><br><span class="line">BLOCKED</span><br></pre></td></tr></table></figure></p><p>从输出结果看来，thread2处于BLOCKED状态，执行中断操作之后，该线程仍然处于BLOCKED状态，但是中断标志位却已被修改。这种状态下的线程和处于RUNNABLE状态下的线程是类似的，给了我们程序更大的灵活性去判断和处理中断。</p><h4 id="2-4-WAITING-TIMED-WAITING"><a href="#2-4-WAITING-TIMED-WAITING" class="headerlink" title="2.4 WAITING/TIMED_WAITING"></a>2.4 WAITING/TIMED_WAITING</h4><p>这两种状态本质上是同一种状态，只不过TIMED_WAITING在等待一段时间后会自动释放自己，而WAITING则是无限期等待，需要其他线程调用notify方法释放自己。但是他们都是线程在运行的过程中由于缺少某些条件而被挂起在某个对象的等待队列上。当这些线程遇到中断操作的时候，会抛出一个InterruptedException异常，并清空中断标志位。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"i am waiting but facing interruptexception now"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们定义了一个线程类，其中run方法让当前线程阻塞到条件队列上，并且针对InterruptedException 进行捕获，如果遇到InterruptedException 异常则输出一行信息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    System.out.println(thread.getState());</span><br><span class="line">    thread.interrupt();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    System.out.println(thread.isInterrupted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在main线程中我们启动一个MyThread线程，然后对其进行中断操作。运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WAITING</span><br><span class="line">i am waiting but facing interruptexception now</span><br><span class="line">false</span><br></pre></td></tr></table></figure></p><p>从运行结果看，当前程thread启动之后就被挂起到该线程对象的条件队列上，然后我们调用interrupt方法对该线程进行中断，输出了我们在catch中的输出语句，显然是捕获了InterruptedException异常，接着就看到该线程的中断标志位被清空。</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>综上所述，我们分别介绍了不同种线程的不同状态下对于中断请求的反应。</p><ul><li>NEW 和 TERMINATED对于中断操作几乎是屏蔽的。</li><li>RUNNABLE 和 BLOCKED类似，对于中断操作只是设置中断标志位并没有强制终止线程，对于线程的终止权利依然在程序手中。</li><li>WAITING / TIMED_WAITING 状态下的线程对于中断操作是敏感的，他们会抛出异常并清空中断标志位。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;中断可以理解为现成的一个标识位属性，它表示一个运行中的线程是否被被其他线程进行了中断操作。中断好比其他线程对该线程打了个招呼，其他线程通过调用该线程的interrupt()方法对其进行中断操作。&lt;/p&gt;
&lt;p&gt;线程通过检查自身是否被中断来进行响应，线程通过方法 isInte
      
    
    </summary>
    
    
      <category term="并发编程" scheme="http://yoursite.com/child/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-基础学习</title>
    <link href="http://yoursite.com/child/2018/03/15/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/child/2018/03/15/并发编程-基础/</id>
    <published>2018-03-15T12:36:12.000Z</published>
    <updated>2019-05-28T14:55:05.766Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-线程状态转换"><a href="#1-线程状态转换" class="headerlink" title="1. 线程状态转换"></a>1. 线程状态转换</h4><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.jpg" alt="线程状态转换"><br>重点q一下WAITING &amp; BLOCKED:<br> 从linux内核来看，线程WAITING &amp; BLOCKED都是等待状态，没区别，区别只在于java的管理需要。通常我们在系统级别说线程的blocked，是说线程操作io，被暂停了，这种线程由linux内核来唤醒（io设备报告数据来了，内核把block的线程放进可运行的进程队列，依次得到处理器时间），而wait是说，等待一个内核mutex对象，另个线程signal这个mutex后，这个线程才可以运行。区别在于由谁唤醒，是操作系统，还是另一个线程，这里倒和java很相似。</p><p> sleep(long) 不释放锁，wait()会释放锁，都进入WAITING状态，wait()返回后，重新竞争锁，进入BLOCKED状态。</p><h4 id="2-如何减少上下文切换"><a href="#2-如何减少上下文切换" class="headerlink" title="2. 如何减少上下文切换"></a>2. 如何减少上下文切换</h4><p>上下文切换指的是单个处理器处理多个线程时，时间片分配给不同的线程引起的处理器当前状态的保存和加载。发生在线程切换的时刻，保存当前线程运行状态，加载即将执行的线程状态。</p><p>锁竞争会引起上下文的切换，要减少上下文切换可以使用：</p><ul><li>无锁并发编程，例如将数据分段处理  </li><li>CAS算法，CAS没有竞争锁的过程，自然也不会引起线程切换。</li><li>避免创建不必要的线程</li><li>协程：在单线程里实现多任务调度，在单线程里维持多任务间的切换。  </li></ul><h4 id="3-避免死锁"><a href="#3-避免死锁" class="headerlink" title="3. 避免死锁"></a>3. 避免死锁</h4><ul><li>避免一个线程同时获取多个锁  </li><li>避免一个线程在一个锁内占用多个资源</li><li>尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部锁</li><li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败</li></ul><h4 id="4-CAS操作"><a href="#4-CAS操作" class="headerlink" title="4. CAS操作"></a>4. CAS操作</h4><p>compare and set</p><ul><li>原子操作，实现不被打断的数据交换操作，避免多线程同时改写某数据时由于执行顺序不确定以及中断的不可预知性而产生数据不一致问题</li><li>操作方式：将内存中的值与预期值进行比较，如果两个值一致，可以写入新的值；否则什么都不做或者重试  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CAS有3个操作数：</span><br><span class="line"></span><br><span class="line">内存值V</span><br><span class="line">旧的预期值A</span><br><span class="line">要修改的新值B</span><br><span class="line"></span><br><span class="line">当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值(A和内存值V相同时，将内存值V修改为B)，</span><br><span class="line">而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试(或者什么都不做)。</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-重量级锁Synchronized"><a href="#5-重量级锁Synchronized" class="headerlink" title="5. 重量级锁Synchronized"></a>5. 重量级锁Synchronized</h4><p>在JDK1.5之前都是使用synchronized关键字保证同步的，Synchronized 的作用相信大家都已经非常熟悉了；</p><p>它可以把任意一个非NULL的对象当作锁：</p><ul><li>作用于方法时，锁住的是对象的实例(this)； </li><li>当作用于静态方法时，锁住的是Class实例，又因为Class的相关数据存储在永久带PermGen（jdk1.8则是metaspace），永久带是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程；</li><li>synchronized作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。</li></ul><p>它有多个队列，当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。</p><ul><li>Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；</li><li>Entry List：锁池，Contention List中那些有资格成为候选资源的线程被移动到Entry List中；</li><li>Wait Set：等待池，哪些调用wait方法的线程被放置在这里进行WAITING；</li><li>OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为OnDeck；</li><li>Owner：当前已经获取到所资源的线程被称为Owner；</li><li>!Owner：当前释放锁的线程。</li></ul><p>JVM每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下，ContentionList会被大量的并发线程进行CAS访问，为了降低对尾部元素的竞争，JVM会将一部分线程移动到EntryList中作为候选竞争线程。Owner线程会在unlock时，将ContentionList中的部分线程迁移到EntryList中，并指定EntryList中的某个线程为OnDeck线程（一般是最先进去的那个线程）。Owner线程并不直接把锁传递给OnDeck线程，而是把锁竞争的权利交给OnDeck，OnDeck需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在JVM中，也把这种选择行为称之为“竞争切换”。</p><p>OnDeck线程获取到锁资源后会变为Owner线程，而没有得到锁资源的仍然停留在EntryList中。如果Owner线程调用wait方法，则转移到WaitSet队列中，直到某个时刻通过notify或者notifyAll唤醒，会重新进去EntryList中。</p><p>处于ContentionList、EntryList中的线程都处于阻塞状态，该阻塞是由操作系统来完成的（Linux内核下采用pthread_mutex_lock内核函数实现的）。</p><p>Synchronized是非公平锁。<br>Synchronized在线程进入ContentionList时，等待的线程会先尝试自旋获取锁，如果获取不到就进入ContentionList，这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占OnDeck线程的锁资源。</p><h4 id="6-等待-通知机制"><a href="#6-等待-通知机制" class="headerlink" title="6.等待/通知机制"></a>6.等待/通知机制</h4><p>帮助理解：每个对象都有一个等待池与锁池，并发编程访问临界资源时（共享对象），</p><ul><li>当共享对象调用wait函数时，当前线程阻塞进入等待池，等待池中的线程处于WAITING状态</li><li>当共享对象调用notify函数时，随机从等待池中唤醒一个线程，该线程进入到锁池参与锁竞争；</li><li>当共享对象调用notifyAll函数时，唤醒等待池中所有的线程，所有线程进入到锁池参与锁竞争。<br>建议使用notifyAll()  </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-线程状态转换&quot;&gt;&lt;a href=&quot;#1-线程状态转换&quot; class=&quot;headerlink&quot; title=&quot;1. 线程状态转换&quot;&gt;&lt;/a&gt;1. 线程状态转换&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://zzk-markdown.oss-cn-hangzh
      
    
    </summary>
    
    
      <category term="并发编程" scheme="http://yoursite.com/child/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>源码分析-SimpleDateFormat的用法以及线程安全</title>
    <link href="http://yoursite.com/child/2017/12/21/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-SimpleDateFormat%E7%9A%84%E7%94%A8%E6%B3%95%E4%BB%A5%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <id>http://yoursite.com/child/2017/12/21/源码分析-SimpleDateFormat的用法以及线程安全/</id>
    <published>2017-12-21T01:02:32.000Z</published>
    <updated>2019-05-23T03:00:04.545Z</updated>
    
    <content type="html"><![CDATA[<p>开发中我们经常会用到时间相关类，我们有很多办法在Java代码中获取时间。但是不同的方法获取到的时间的格式都不尽相同，这时候就需要一种格式化工具，把时间显示成我们需要的格式。最常用的方法就是使用SimpleDateFormat类。这是一个看上去功能比较简单的类，但是，一旦使用不当也有可能导致很大的问题。</p><p>在阿里巴巴Java开发手册中，有如下明确规定：<br><img src="http://wx2.sinaimg.cn/mw690/87c9e458gy1g2df391sgsj20u002qmy9.jpg" alt="image"><br>本文就围绕SimpleDateFormat的用法、原理等来深入分析下如何以正确使用它。</p><h3 id="1-SimpleDateFormat用法"><a href="#1-SimpleDateFormat用法" class="headerlink" title="1. SimpleDateFormat用法"></a>1. SimpleDateFormat用法</h3><h4 id="1-1-基本用法"><a href="#1-1-基本用法" class="headerlink" title="1.1 基本用法"></a>1.1 基本用法</h4><p>SimpleDateFormat是java提供的能对时间格式化及解析的工具类。  </p><ul><li><p>格式化：将规范日期格式化成日期文本（时间字符串）  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">String dateStr = sdf.format(new Date());</span><br></pre></td></tr></table></figure></li><li><p>解析： 将文本日期解析成规范化的时间格式  </p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date d = sdf.parse(dataStr);</span><br></pre></td></tr></table></figure><p>用户可以自定义文本日期的格式，通过字母来描述时间元素，并组装成想要的日期和时间格式。常用的时间元素和字母的对应表如下：<br><img src="http://wx4.sinaimg.cn/mw690/87c9e458gy1g2dfj3v4y8j20u00le7ci.jpg" alt="模板定义"><br>模式字母通常是重复的，其数量确定其精确表示。如下表是常用的输出格式的表示方法。<br><img src="http://wx4.sinaimg.cn/mw690/87c9e458gy1g2dfklzoizj20tq0bgwko.jpg" alt="image">  </p><h4 id="1-2-时区"><a href="#1-2-时区" class="headerlink" title="1.2 时区"></a>1.2 时区</h4><p>如何在Java代码中获取不同时区的时间呢？SimpleDateFormat可以实现这个功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        System.out.println(sdf.format(Calendar.getInstance().getTime()));</span><br><span class="line">        sdf.setTimeZone(TimeZone.getTimeZone(&quot;America/Los_Angeles&quot;));</span><br><span class="line">        System.out.println(sdf.format(Calendar.getInstance().getTime()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>以上代码，输出的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-04-24 09:26:38</span><br><span class="line">2019-04-23 18:26:38</span><br></pre></td></tr></table></figure><p>中国的时间第一行，而美国洛杉矶时间比中国北京时间慢了17个小时（这还和冬夏令时有关系）。<br>当然，这不是显示其他时区的唯一方法</p><h3 id="2-SimpleDateFormat线程安全性"><a href="#2-SimpleDateFormat线程安全性" class="headerlink" title="2. SimpleDateFormat线程安全性"></a>2. SimpleDateFormat线程安全性</h3><p>由于SimpleDateFormat比较常用，而且在一般情况下，一个应用中的时间显示模式都是一样的，所以很多人愿意使用如下方式定义SimpleDateFormat：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">   private static SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">        sdf.setTimeZone(TimeZone.getTimeZone(&quot;America/New_York&quot;));</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种定义方式，存在很大的线程安全隐患。  </p><h4 id="2-1-问题重现"><a href="#2-1-问题重现" class="headerlink" title="2.1 问题重现"></a>2.1 问题重现</h4><p>以下代码使用线程池来执行时间输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 定义一个全局的SimpleDateFormat</span><br><span class="line">    */</span><br><span class="line">   private static SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 使用ThreadFactoryBuilder定义一个线程池</span><br><span class="line">    */</span><br><span class="line">   private static ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()</span><br><span class="line">       .setNameFormat(&quot;demo-pool-%d&quot;).build();</span><br><span class="line"></span><br><span class="line">   private static ExecutorService pool = new ThreadPoolExecutor(5, 200,</span><br><span class="line">       0L, TimeUnit.MILLISECONDS,</span><br><span class="line">       new LinkedBlockingQueue&lt;Runnable&gt;(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 定义一个CountDownLatch，保证所有子线程执行完之后主线程再执行</span><br><span class="line">    */</span><br><span class="line">   private static CountDownLatch countDownLatch = new CountDownLatch(100);</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       //定义一个线程安全的HashSet</span><br><span class="line">       Set&lt;String&gt; dates = Collections.synchronizedSet(new HashSet&lt;String&gt;());</span><br><span class="line">       for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">           //获取当前时间</span><br><span class="line">           Calendar calendar = Calendar.getInstance();</span><br><span class="line">           int finalI = i;</span><br><span class="line">           pool.execute(() -&gt; &#123;</span><br><span class="line">                   //时间增加</span><br><span class="line">                   calendar.add(Calendar.DATE, finalI);</span><br><span class="line">                   //通过simpleDateFormat把时间转换成字符串</span><br><span class="line">                   String dateString = sdf.format(calendar.getTime());</span><br><span class="line">                   //把字符串放入Set中</span><br><span class="line">                   dates.add(dateString);</span><br><span class="line">                   //countDown</span><br><span class="line">                   countDownLatch.countDown();</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">       //阻塞，直到countDown数量为0</span><br><span class="line">       countDownLatch.await();</span><br><span class="line">       //输出去重后的时间个数</span><br><span class="line">       System.out.println(dates.size());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上代码，其实比较容易理解。就是循环一百次，每次循环的时候都在当前时间基础上增加一个天数（这个天数随着循环次数而变化），然后把所有日期放入一个线程安全的、带有去重功能的Set中，然后输出Set中元素个数。 </p><p>正常情况下，以上代码输出结果应该是100。但是实际执行结果是一个小于100的数字。</p><p>原因就是因为SimpleDateFormat作为一个非线程安全的类，被当做了共享变量在多个线程中进行使用，这就出现了线程安全问题。</p><h4 id="2-2-线程不安全原因"><a href="#2-2-线程不安全原因" class="headerlink" title="2.2 线程不安全原因"></a>2.2 线程不安全原因</h4><p>其实，JDK文档中已经明确表明了SimpleDateFormat不应该用在多线程场景中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Date formats are not synchronized.</span><br><span class="line">It is recommended to create separate format instances for each thread.</span><br><span class="line">If multiple threads access a format concurrently, it must be synchronized externally.</span><br></pre></td></tr></table></figure></p><p>那么为什么会出现这种问题，SimpleDateFormat底层到底是怎么实现的？<br>跟踪一下SimpleDateFormat类中format方法的实现其实就能发现端倪。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public StringBuffer format(Date date, StringBuffer toAppendTo,</span><br><span class="line">                               FieldPosition pos)</span><br><span class="line">    &#123;</span><br><span class="line">        pos.beginIndex = pos.endIndex = 0;</span><br><span class="line">        return format(date, toAppendTo, pos.getFieldDelegate());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Called from Format after creating a FieldDelegate</span><br><span class="line">    private StringBuffer format(Date date, StringBuffer toAppendTo,</span><br><span class="line">                                FieldDelegate delegate) &#123;</span><br><span class="line">        // Convert input date to time field list</span><br><span class="line">        calendar.setTime(date);</span><br><span class="line"></span><br><span class="line">        boolean useDateFormatSymbols = useDateFormatSymbols();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; compiledPattern.length; ) &#123;</span><br><span class="line">            int tag = compiledPattern[i] &gt;&gt;&gt; 8;</span><br><span class="line">            int count = compiledPattern[i++] &amp; 0xff;</span><br><span class="line">            if (count == 255) &#123;</span><br><span class="line">                count = compiledPattern[i++] &lt;&lt; 16;</span><br><span class="line">                count |= compiledPattern[i++];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            switch (tag) &#123;</span><br><span class="line">            case TAG_QUOTE_ASCII_CHAR:</span><br><span class="line">                toAppendTo.append((char)count);</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case TAG_QUOTE_CHARS:</span><br><span class="line">                toAppendTo.append(compiledPattern, i, count);</span><br><span class="line">                i += count;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            default:</span><br><span class="line">                subFormat(tag, count, delegate, toAppendTo, useDateFormatSymbols);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return toAppendTo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>SimpleDateFormat中的format方法在执行过程中，会使用一个成员变量calendar来保存时间。这其实就是问题的关键。</p><p>由于我们在声明SimpleDateFormat的时候，使用的是static定义的。那么这个SimpleDateFormat就是一个共享变量，随之，SimpleDateFormat中的calendar也就可以被多个线程访问到。</p><p>假设线程1刚刚执行完calendar.setTime把时间设置成2018-11-11，还没等执行完，线程2又执行了calendar.setTime把时间改成了2018-12-12。这时候线程1继续往下执行，拿到的calendar.getTime得到的时间就是线程2改过之后的。</p><p>除了format方法以外，SimpleDateFormat的parse方法也有同样的问题。</p><h3 id="3-如何解决"><a href="#3-如何解决" class="headerlink" title="3. 如何解决"></a>3. 如何解决</h3><p>解决方法有很多，先介绍三个比较常用的方法。</p><h4 id="3-1-使用局部变量"><a href="#3-1-使用局部变量" class="headerlink" title="3.1 使用局部变量"></a>3.1 使用局部变量</h4><p>SimpleDateFormat变成了局部变量，就不会被多个线程同时访问到了，就避免了线程安全问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">   //获取当前时间</span><br><span class="line">   Calendar calendar = Calendar.getInstance();</span><br><span class="line">   int finalI = i;</span><br><span class="line">   pool.execute(() -&gt; &#123;</span><br><span class="line">       // SimpleDateFormat声明成局部变量</span><br><span class="line">   SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">       //时间增加</span><br><span class="line">       calendar.add(Calendar.DATE, finalI);</span><br><span class="line">       //通过simpleDateFormat把时间转换成字符串</span><br><span class="line">       String dateString = simpleDateFormat.format(calendar.getTime());</span><br><span class="line">       //把字符串放入Set中</span><br><span class="line">       dates.add(dateString);</span><br><span class="line">       //countDown</span><br><span class="line">       countDownLatch.countDown();</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-2-加同步锁"><a href="#3-2-加同步锁" class="headerlink" title="3.2 加同步锁"></a>3.2 加同步锁</h4><p>除了改成局部变量以外，还有一种方法大家可能比较熟悉的，就是对于共享变量进行加锁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">   //获取当前时间</span><br><span class="line">   Calendar calendar = Calendar.getInstance();</span><br><span class="line">   int finalI = i;</span><br><span class="line">   pool.execute(() -&gt; &#123;</span><br><span class="line">       //时间增加</span><br><span class="line">        calendar.add(Calendar.DATE, finalI);</span><br><span class="line">       //通过simpleDateFormat把时间转换成字符串</span><br><span class="line">       //加锁</span><br><span class="line">        synchronized (simpleDateFormat) &#123;</span><br><span class="line">            String dateString = simpleDateFormat.format(calendar.getTime());</span><br><span class="line">        &#125;</span><br><span class="line">       //把字符串放入Set中</span><br><span class="line">        dates.add(dateString);</span><br><span class="line">       //countDown</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    </span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过加锁，使多个线程排队顺序执行。避免了并发导致的线程安全问题。</p><h4 id="3-3-使用ThreadLocal"><a href="#3-3-使用ThreadLocal" class="headerlink" title="3.3 使用ThreadLocal"></a>3.3 使用ThreadLocal</h4><p>第三种方式，就是使用 ThreadLocal。 ThreadLocal 可以确保每个线程都可以得到单独的一个 SimpleDateFormat 的对象，那么自然也就不存在竞争问题了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 使用ThreadLocal定义一个全局的SimpleDateFormat</span><br><span class="line">*/</span><br><span class="line">private static ThreadLocal&lt;SimpleDateFormat&gt; simpleDateFormatThreadLocal = new ThreadLocal&lt;SimpleDateFormat&gt;() &#123;</span><br><span class="line">   @Override</span><br><span class="line">   protected SimpleDateFormat initialValue() &#123;</span><br><span class="line">       return new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//用法</span><br><span class="line">String dateString = simpleDateFormatThreadLocal.get().format(calendar.getTime());</span><br></pre></td></tr></table></figure></p><p>当然，以上代码也有改进空间，就是，其实SimpleDateFormat的创建过程可以改为延迟加载。这里就不详细介绍了。</p><h3 id="4-使用DateTimeFormatter"><a href="#4-使用DateTimeFormatter" class="headerlink" title="4. 使用DateTimeFormatter"></a>4. 使用DateTimeFormatter</h3><p>如果是Java8应用，可以使用DateTimeFormatter代替SimpleDateFormat，这是一个线程安全的格式化工具类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//解析日期</span><br><span class="line">String dateStr= &quot;2016年10月25日&quot;;</span><br><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日&quot;);</span><br><span class="line">LocalDate date= LocalDate.parse(dateStr, formatter);</span><br><span class="line"></span><br><span class="line">//日期转换为字符串</span><br><span class="line">LocalDateTime now = LocalDateTime.now();</span><br><span class="line">DateTimeFormatter format = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日 hh:mm a&quot;);</span><br><span class="line">String nowStr = now .format(format);</span><br><span class="line">System.out.println(nowStr);</span><br></pre></td></tr></table></figure></p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p>本文介绍了SimpleDateFormat的用法，SimpleDateFormat主要可以在String和Date之间做转换，还可以将时间转换成不同时区输出。同时提到在并发场景中SimpleDateFormat是不能保证线程安全的，需要开发者自己来保证其安全性。</p><p>主要的几个手段有改为局部变量、使用synchronized加锁、使用Threadlocal为每一个线程单独创建一个和使用Java8中的DateTimeFormatter类代替等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开发中我们经常会用到时间相关类，我们有很多办法在Java代码中获取时间。但是不同的方法获取到的时间的格式都不尽相同，这时候就需要一种格式化工具，把时间显示成我们需要的格式。最常用的方法就是使用SimpleDateFormat类。这是一个看上去功能比较简单的类，但是，一旦使用
      
    
    </summary>
    
    
      <category term="源码分析" scheme="http://yoursite.com/child/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之策略模式</title>
    <link href="http://yoursite.com/child/2017/05/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/child/2017/05/14/设计模式之策略模式/</id>
    <published>2017-05-14T03:17:23.000Z</published>
    <updated>2019-05-14T05:41:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章以jdk并发包中的一个策略模式实现作为开篇。</p><p>使用线程池处理并发任务时，当用户提交任务到线程池，线程池因为线程池已满或者线程池处于SHUTDOWN状态拒接任务的时候，会调用reject函数对任务进行后处理，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">代码摘自：java.util.concurrent.ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">private volatile RejectedExecutionHandler handler;</span><br><span class="line">private static final RejectedExecutionHandler defaultHandler =</span><br><span class="line">        new AbortPolicy();</span><br><span class="line">        </span><br><span class="line">final void reject(Runnable command) &#123;</span><br><span class="line">    handler.rejectedExecution(command, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在线程池创建的时候，用户会初始化handler变量，或者使用默认的初始化defaultHandler，即AbortPolicy对象，AbortPolicy就是策略的一种实现，该策略丢弃被拒绝的任务，并抛出RejectedExecutionException异常。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">代码摘自：java.util.concurrent.ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">public static class AbortPolicy implements RejectedExecutionHandler &#123;</span><br><span class="line">    public AbortPolicy() &#123; &#125;</span><br><span class="line">    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">        throw new RejectedExecutionException(&quot;Task &quot; + r.toString() +</span><br><span class="line">                                             &quot; rejected from &quot; +</span><br><span class="line">                                             e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>策略接口类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">代码摘自：java.util.concurrent.RejectedExecutionHandler</span><br><span class="line"></span><br><span class="line">public interface RejectedExecutionHandler &#123;</span><br><span class="line">    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所有的后处理策略都要实现该接口，ThreadPoolExecutor持有改接口对象，在初始化ThreadPoolExecutor的时候再指定使用哪种策略，下面我们看一下其他策略源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//该策略直接调用被拒绝任务的Run函数强制执行任务</span><br><span class="line">public static class CallerRunsPolicy implements RejectedExecutionHandler &#123;</span><br><span class="line">    public CallerRunsPolicy() &#123; &#125;</span><br><span class="line">    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">        if (!e.isShutdown()) &#123;</span><br><span class="line">            r.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//该策略忽略被拒任务，不做任何处理</span><br><span class="line">public static class DiscardPolicy implements RejectedExecutionHandler &#123;</span><br><span class="line">    public DiscardPolicy() &#123; &#125;</span><br><span class="line">    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//该策略丢弃阻塞队列中等待最久的任务（下一个被执行的任务），再次提交被拒任务</span><br><span class="line">public static class  implements RejectedExecutionHandler &#123;</span><br><span class="line">    public DiscardOldestPolicy() &#123; &#125;</span><br><span class="line">    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">        if (!e.isShutdown()) &#123;</span><br><span class="line">            e.getQueue().poll();</span><br><span class="line">            e.execute(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此我们可以画一个简单的类图表示上述类型之间的关系：<br><img src="http://wx4.sinaimg.cn/large/87c9e458ly1g30nphfgr8j20u20bm0t6.jpg" alt="策略模式"><br>可以说这是一个很典型的策略模式类图了。</p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>其思想是针对一组算法，将每一种算法都封装到具有共同接口的独立的类中，从而是它们可以相互替换。策略模式的最大特点是使得算法可以在不影响客户端的情况下发生变化，从而改变不同的功能。  </p><p>下图所示为策略模式的UML图，上文所述的ThreadPoolExecutor就是Context，contextInterface指的就是reject函数。<br><img src="http://wx2.sinaimg.cn/large/87c9e458ly1g30o2l252yj20ly0bfq37.jpg" alt="策略模式111"></p><h4 id="策略模式的优缺点"><a href="#策略模式的优缺点" class="headerlink" title="策略模式的优缺点"></a>策略模式的优缺点</h4><ul><li>优点<ol><li>策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码转移到父类里面，从而避免重复的代码。</li><li>策略模式提供了可以替换继承关系的办法。继承可以处理多种算法或行为。如果不是用策略模式，那么使用算法或行为的环境类就可能会有一些子类，每一个子类提供一个不同的算法或行为。但是，这样一来算法或行为的使用者就和算法或行为本身混在一起。决定使用哪一种算法或采取哪一种行为的逻辑就和算法或行为的逻辑混合在一起，从而不可能再独立演化。继承使得动态改变算法或行为变得不可能。</li><li>使用策略模式可以避免使用多重条件转移语句。多重转移语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重转移语句里面，比使用继承的办法还要原始和落后。</li></ol></li><li>缺点<ol><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道所有的算法或行为的情况。</li><li>策略模式造成很多的策略类，每个具体策略类都会产生一个新类。有时候可以通过把依赖于环境的状态保存到客户端里面，而将策略类设计成可共享的，这样策略类实例可以被不同客户端使用。换言之，可以使用享元模式来减少对象的数量。</li></ol></li></ul><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>多个类只区别在表现行为不同，可以使用Strategy模式，在运行时动态选择具体要执行的行为。</li><li>需要在不同情况下使用不同的策略(算法)，或者策略还可能在未来用其它方式来实现。</li><li>对客户隐藏具体策略(算法)的实现细节，彼此完全独立。</li></ul><p>参考文档：<br><a href="http://www.w3sdesign.com/strategy_design_pattern.php" target="_blank" rel="noopener">www.w3sdesign.com/strategy_design_pattern.php</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文章以jdk并发包中的一个策略模式实现作为开篇。&lt;/p&gt;
&lt;p&gt;使用线程池处理并发任务时，当用户提交任务到线程池，线程池因为线程池已满或者线程池处于SHUTDOWN状态拒接任务的时候，会调用reject函数对任务进行后处理，代码如下：&lt;/p&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/child/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>linux命令-tail</title>
    <link href="http://yoursite.com/child/2017/04/23/linux%E5%91%BD%E4%BB%A4-tail/"/>
    <id>http://yoursite.com/child/2017/04/23/linux命令-tail/</id>
    <published>2017-04-23T07:52:38.000Z</published>
    <updated>2019-05-23T03:03:01.787Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h2><p>显示文件的末尾部分，默认显示10行</p><p><img src="http://wx4.sinaimg.cn/mw690/87c9e458gy1g2clz9mbgsj20jf0iyjs7.jpg" alt="tail"></p><ul><li>举例：看日志文件时      <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -fn 30 xxxx.log</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;tail&quot;&gt;&lt;a href=&quot;#tail&quot; class=&quot;headerlink&quot; title=&quot;tail&quot;&gt;&lt;/a&gt;tail&lt;/h2&gt;&lt;p&gt;显示文件的末尾部分，默认显示10行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wx4.sinaimg.cn/mw690
      
    
    </summary>
    
    
      <category term="linux命令" scheme="http://yoursite.com/child/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>linux命令-nohup</title>
    <link href="http://yoursite.com/child/2017/04/23/linux%E5%91%BD%E4%BB%A4-nohup/"/>
    <id>http://yoursite.com/child/2017/04/23/linux命令-nohup/</id>
    <published>2017-04-23T07:39:40.000Z</published>
    <updated>2019-05-23T03:03:26.891Z</updated>
    
    <content type="html"><![CDATA[<p>nohup 是 no hang up 的缩写，就是不挂断的意思。  </p><p>nohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以   使用nohup命令,该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。</p><p>在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中。nohup 命令运行由 Command参数和任何相关的Arg参数指定的命令，忽略所有挂断（SIGHUP）信号。在注销后使用 nohup 命令运行后台中的程序。要运行后台中的 nohup 命令，添加 &amp; （表示“and”的符号）到命令的尾部。  </p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h5 id="1-nohup-command-gt-myout-file-2-gt-amp-1-amp"><a href="#1-nohup-command-gt-myout-file-2-gt-amp-1-amp" class="headerlink" title="1. nohup command &gt; myout.file 2&gt;&amp;1 &amp;"></a>1. nohup command &gt; myout.file 2&gt;&amp;1 &amp;</h5><p>在上面的例子中，0 – stdin (standard input)，1 – stdout (standard output)，2 – stderr (standard error) ；<br>2&gt;&amp;1是将标准错误（2）重定向到标准输出（&amp;1），标准输出（&amp;1）再被重定向输入到myout.file文件中。</p><h5 id="2-0-22-usr-bin-python-home-pu-download-pdf-download-dfcf-pdf-to-oss-py-gt-home-pu-download-pdf-download-dfcf-pdf-to-oss-log-2-gt-amp-1"><a href="#2-0-22-usr-bin-python-home-pu-download-pdf-download-dfcf-pdf-to-oss-py-gt-home-pu-download-pdf-download-dfcf-pdf-to-oss-log-2-gt-amp-1" class="headerlink" title="2. 0 22   * /usr/bin/python /home/pu/download_pdf/download_dfcf_pdf_to_oss.py &gt; /home/pu/download_pdf/download_dfcf_pdf_to_oss.log 2&gt;&amp;1"></a>2. 0 22 <em> </em> * /usr/bin/python /home/pu/download_pdf/download_dfcf_pdf_to_oss.py &gt; /home/pu/download_pdf/download_dfcf_pdf_to_oss.log 2&gt;&amp;1</h5><p>这是放在crontab中的定时任务，晚上22点时候怕这个任务，启动这个python的脚本，并把日志写在download_dfcf_pdf_to_oss.log文件中</p><h3 id="nohup和-amp-的区别"><a href="#nohup和-amp-的区别" class="headerlink" title="nohup和&amp;的区别"></a>nohup和&amp;的区别</h3><p>&amp; ： 指在后台运行<br>nohup ： 不挂断的运行，注意并没有后台运行的功能，就是指用nohup运行命令可以使命令永久的执行下去，和用户终端没有关系，例如我们断开SSH连接都不会影响他的运行</p><h3 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h3><ol><li><strong>sh test.sh &amp;</strong><br>将sh test.sh任务放到后台 ，关闭xshell，对应的任务也跟着停止。</li><li><strong>nohup sh test.sh</strong><br>将sh test.sh任务放到后台，关闭标准输入，终端不再能够接收任何输入（标准输入），重定向标准输出和标准错误到当前目录下的nohup.out文件，即使关闭xshell退出当前session依然继续运行。</li><li><strong>nohup sh test.sh  &amp;</strong><br>将sh test.sh任务放到后台，但是依然可以使用标准输入，终端能够接收任何输入，重定向标准输出和标准错误到当前目录下的nohup.out文件，即使关闭xshell退出当前session依然继续运行。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;nohup 是 no hang up 的缩写，就是不挂断的意思。  &lt;/p&gt;
&lt;p&gt;nohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以   使用nohup命令,该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。&lt;/p&gt;
&lt;p&gt;在缺
      
    
    </summary>
    
    
      <category term="linux命令" scheme="http://yoursite.com/child/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>postgreSQL 让主键自增</title>
    <link href="http://yoursite.com/child/2017/03/21/%E6%95%B0%E6%8D%AE%E5%BA%93-postgreSQL-%E8%AE%A9%E4%B8%BB%E9%94%AE%E8%87%AA%E5%A2%9E/"/>
    <id>http://yoursite.com/child/2017/03/21/数据库-postgreSQL-让主键自增/</id>
    <published>2017-03-21T01:48:56.000Z</published>
    <updated>2019-04-25T08:55:20.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-建表时创建"><a href="#1-建表时创建" class="headerlink" title="1.建表时创建"></a>1.建表时创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test</span><br><span class="line">(  </span><br><span class="line">  test_id SERIAL primary key ,  </span><br><span class="line">  test_name character varying,  </span><br><span class="line">  contactname character varying,  </span><br><span class="line">  phone character varying,  </span><br><span class="line">  country character varying  </span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="2-在已建表的情况下创建"><a href="#2-在已建表的情况下创建" class="headerlink" title="2.在已建表的情况下创建"></a>2.在已建表的情况下创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE SEQUENCE test_id_seq  </span><br><span class="line">START WITH 1  </span><br><span class="line">INCREMENT BY 1  </span><br><span class="line">NO MINVALUE  </span><br><span class="line">NO MAXVALUE  </span><br><span class="line">CACHE 1;  </span><br><span class="line">  </span><br><span class="line">alter table test alter column id set default nextval(&apos;test_id_seq&apos;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-建表时创建&quot;&gt;&lt;a href=&quot;#1-建表时创建&quot; class=&quot;headerlink&quot; title=&quot;1.建表时创建&quot;&gt;&lt;/a&gt;1.建表时创建&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/child/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
