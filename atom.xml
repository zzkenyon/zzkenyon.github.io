<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>黑风雅过吟</title>
  
  <subtitle>不积跬步无以至千里</subtitle>
  <link href="/zzkenyon.github.io/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/child/"/>
  <updated>2020-12-31T02:19:39.385Z</updated>
  <id>http://yoursite.com/child/</id>
  
  <author>
    <name>Zhao Zhengkang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redis-客户端redisson的使用</title>
    <link href="http://yoursite.com/child/2020/12/04/redis-%E5%AE%A2%E6%88%B7%E7%AB%AFredisson%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/child/2020/12/04/redis-客户端redisson的使用/</id>
    <published>2020-12-03T16:00:00.000Z</published>
    <updated>2020-12-31T02:19:39.385Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/redisson/redisson/wiki/%E7%9B%AE%E5%BD%95" target="_blank" rel="noopener">中文文档（很详细）</a></p><p>Redisson的中文文档写的非常详细，所以本文主要记录简单使用过程中遇到的一些问题。</p><h3 id="1-原生api的使用"><a href="#1-原生api的使用" class="headerlink" title="1. 原生api的使用"></a>1. 原生api的使用</h3><p>依赖引入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.14.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置：</p><p>两种方式：代码配置和配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> RedissonClient redissonClient;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    Config config = <span class="keyword">new</span> Config();</span><br><span class="line">    <span class="comment">//config.setCodec(new org.redisson.client.codec.StringCodec());</span></span><br><span class="line">    config.setCodec(<span class="keyword">new</span> JsonJacksonCodec());</span><br><span class="line">    <span class="comment">//指定使用单节点部署方式</span></span><br><span class="line">    config.useSingleServer()</span><br><span class="line">            .setAddress(<span class="string">"redis://storage.m.io:6379"</span>)</span><br><span class="line">            .setPassword(<span class="string">"0gn736xl73083Vm6wwnBDJSI20duFIeLv068Q1kLM4u58GD8q4SEugmSFd8TfFTm"</span>);</span><br><span class="line">    redissonClient = Redisson.create(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#redisson-config.yml</span></span><br><span class="line"><span class="attr">singleServerConfig:</span></span><br><span class="line"><span class="attr">  idleConnectionTimeout:</span> <span class="number">10000</span></span><br><span class="line"><span class="attr">  connectTimeout:</span> <span class="number">10000</span></span><br><span class="line"><span class="attr">  timeout:</span> <span class="number">3000</span></span><br><span class="line"><span class="attr">  retryAttempts:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  retryInterval:</span> <span class="number">1500</span></span><br><span class="line"><span class="attr">  password:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">  subscriptionsPerConnection:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">  clientName:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">  address:</span> <span class="string">"redis://localhost:6379"</span></span><br><span class="line"><span class="attr">  subscriptionConnectionMinimumIdleSize:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  subscriptionConnectionPoolSize:</span> <span class="number">50</span></span><br><span class="line"><span class="attr">  connectionMinimumIdleSize:</span> <span class="number">32</span></span><br><span class="line"><span class="attr">  connectionPoolSize:</span> <span class="number">64</span></span><br><span class="line"><span class="attr">  database:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">  dnsMonitoringInterval:</span> <span class="number">5000</span></span><br><span class="line"><span class="attr">threads:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">nettyThreads:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">codec:</span> <span class="string">!&lt;org.redisson.client.codec.StringCodec&gt;</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">"transportMode":</span> <span class="string">"NIO"</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Config config1 = Config.fromYAML(<span class="string">"classpath:redisson-config.yml"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本使用去看文档，写得很清楚</p><p>集群模式配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">clusterServersConfig:</span></span><br><span class="line"><span class="attr">  idleConnectionTimeout:</span> <span class="number">10000</span></span><br><span class="line"><span class="attr">  connectTimeout:</span> <span class="number">10000</span></span><br><span class="line"><span class="attr">  timeout:</span> <span class="number">3000</span></span><br><span class="line"><span class="attr">  retryAttempts:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  retryInterval:</span> <span class="number">1500</span></span><br><span class="line"><span class="attr">  failedSlaveReconnectionInterval:</span> <span class="number">3000</span></span><br><span class="line"><span class="attr">  failedSlaveCheckInterval:</span> <span class="number">60000</span></span><br><span class="line"><span class="attr">  password:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">  subscriptionsPerConnection:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">  clientName:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">  loadBalancer:</span> <span class="string">!&lt;org.redisson.connection.balancer.RoundRobinLoadBalancer&gt;</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">  subscriptionConnectionMinimumIdleSize:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  subscriptionConnectionPoolSize:</span> <span class="number">50</span></span><br><span class="line"><span class="attr">  slaveConnectionMinimumIdleSize:</span> <span class="number">24</span></span><br><span class="line"><span class="attr">  slaveConnectionPoolSize:</span> <span class="number">64</span></span><br><span class="line"><span class="attr">  masterConnectionMinimumIdleSize:</span> <span class="number">24</span></span><br><span class="line"><span class="attr">  masterConnectionPoolSize:</span> <span class="number">64</span></span><br><span class="line"><span class="attr">  readMode:</span> <span class="string">"SLAVE"</span></span><br><span class="line"><span class="attr">  subscriptionMode:</span> <span class="string">"SLAVE"</span></span><br><span class="line"><span class="attr">  nodeAddresses:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">"redis://127.0.0.1:7004"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">"redis://127.0.0.1:7001"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">"redis://127.0.0.1:7000"</span></span><br><span class="line"><span class="attr">  scanInterval:</span> <span class="number">1000</span></span><br><span class="line"><span class="attr">  pingConnectionInterval:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">  keepAlive:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  tcpNoDelay:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">threads:</span> <span class="number">16</span></span><br><span class="line"><span class="attr">nettyThreads:</span> <span class="number">32</span></span><br><span class="line"><span class="attr">codec:</span> <span class="string">!&lt;org.redisson.codec.MarshallingCodec&gt;</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">transportMode:</span> <span class="string">"NIO"</span></span><br></pre></td></tr></table></figure><h3 id="2-spring集成"><a href="#2-spring集成" class="headerlink" title="2. spring集成"></a>2. spring集成</h3><p>在springboot中使用redisson需要引入另外一个包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.14.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该项目的地址如下：</p><p><a href="https://github.com/redisson/redisson/tree/master/redisson-spring-boot-starter" target="_blank" rel="noopener">https://github.com/redisson/redisson/tree/master/redisson-spring-boot-starter</a></p><p>该包中已自动引入了redisson的原生jar包，此外还需要注意与版本兼容问题：</p><table><thead><tr><th>redisson-spring-data module name</th><th>Spring Boot version</th></tr></thead><tbody><tr><td>redisson-spring-data-16</td><td>1.3.x</td></tr><tr><td>redisson-spring-data-17</td><td>1.4.x</td></tr><tr><td>redisson-spring-data-18</td><td>1.5.x</td></tr><tr><td>redisson-spring-data-20</td><td>2.0.x</td></tr><tr><td>redisson-spring-data-21</td><td>2.1.x</td></tr><tr><td>redisson-spring-data-22</td><td>2.2.x</td></tr><tr><td>redisson-spring-data-23</td><td>2.3.x</td></tr><tr><td>redisson-spring-data-24</td><td>2.4.x</td></tr></tbody></table><p>配置使用：</p><p>在application.yml配置文件中进行如下配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">redis:</span></span><br><span class="line"><span class="attr">    redisson:</span> </span><br><span class="line">    <span class="attr">file:</span> <span class="attr">classpath:redisson-config.yaml</span></span><br></pre></td></tr></table></figure><p>注意，这样配置之后，redisTemplate也能正常使用，且使用的也是redisson的配置。</p><h4 id="2-1-消息监听"><a href="#2-1-消息监听" class="headerlink" title="2.1 消息监听"></a>2.1 消息监听</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicListener</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RTopic topic = redissonClient.getTopic(<span class="string">"__keyspace@0__:name"</span>);</span><br><span class="line">        topic.addListener(String.class,<span class="keyword">new</span> MessageListener&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(CharSequence charSequence, String msg)</span> </span>&#123;</span><br><span class="line">                log.info(<span class="string">"Redisson监听器收到消息:&#123;&#125;"</span>, msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然使用redis的消息机制需要对redis-server进行设置，设置属性notifiy-space-events的值</p><h4 id="2-2-分布式锁"><a href="#2-2-分布式锁" class="headerlink" title="2.2 分布式锁"></a>2.2 分布式锁</h4><p>在方法增加 <code>@Lock</code> 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//支持 spel 表达式 如果后面需要接字符串的话请用`+`连接. 字符串一定要打`单引号`</span></span><br><span class="line"><span class="meta">@Lock</span>(keys = <span class="string">"#user.name+'locks'"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"进来了test"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Lock 注解参数介绍</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * REENTRANT(可重入锁),FAIR(公平锁),MULTIPLE(联锁),REDLOCK(红锁),READ(读锁), WRITE(写锁), </span></span><br><span class="line"><span class="comment"> * AUTO(自动模式,当参数只有一个.使用 REENTRANT 参数多个 MULTIPLE)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">LockModel <span class="title">lockModel</span><span class="params">()</span> <span class="keyword">default</span> LockModel.AUTO</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需要锁定的keys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] keys() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 锁超时时间,默认30000毫秒(可在配置文件全局设置)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">lockWatchdogTimeout</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等待加锁超时时间,默认10000毫秒 -1 则表示一直等待(可在配置文件全局设置)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">attemptTimeout</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br></pre></td></tr></table></figure><h3 id="3-属性列表"><a href="#3-属性列表" class="headerlink" title="3. 属性列表"></a>3. 属性列表</h3><p>(基本都是官方参数.我将参数整合了下.分为 <code>公共参数</code>,<code>单例模式参数</code>,<code>集群模式参数</code>)</p><blockquote><p>1.公共参数</p></blockquote><table><thead><tr><th>属性名</th><th style="text-align:left">默认值</th><th>备注</th></tr></thead><tbody><tr><td>redisson.password</td><td style="text-align:left"></td><td>用于节点身份验证的密码。</td></tr><tr><td>redisson.attemptTimeout</td><td style="text-align:left">10000L</td><td>等待获取锁超时时间,-1则是一直等待</td></tr><tr><td>redisson.lockModel</td><td style="text-align:left">单个key默认<code>可重入锁</code>多个key默认<code>联锁</code></td><td>锁的模式.如果不设置, REENTRANT(可重入锁),FAIR(公平锁),MULTIPLE(联锁),REDLOCK(红锁),READ(读锁), WRITE(写锁)</td></tr><tr><td>redisson.model</td><td style="text-align:left">SINGLE</td><td>集群模式:SINGLE(单例),SENTINEL(哨兵),MASTERSLAVE(主从),CLUSTER(集群),REPLICATED(云托管)</td></tr><tr><td>redisson.codec</td><td style="text-align:left">JsonJacksonCodec</td><td>Redisson的对象编码类是用于将对象进行序列化和反序列化，以实现对该对象在Redis里的读取和存储</td></tr><tr><td>redisson.threads</td><td style="text-align:left">当前处理核数量 * 2</td><td>这个线程池数量被所有RTopic对象监听器，RRemoteService调用者和RExecutorService任务共同共享。</td></tr><tr><td>redisson.nettyThreads</td><td style="text-align:left">当前处理核数量 * 2</td><td>这个线程池数量是在一个Redisson实例内，被其创建的所有分布式数据类型和服务，以及底层客户端所一同共享的线程池里保存的线程数量。</td></tr><tr><td>redisson.transportMode</td><td style="text-align:left">NIO</td><td>TransportMode.NIO,TransportMode.EPOLL - 需要依赖里有netty-transport-native-epoll包（Linux） TransportMode.KQUEUE - 需要依赖里有 netty-transport-native-kqueue包（macOS）</td></tr><tr><td>redisson.idleConnectionTimeout</td><td style="text-align:left">10000</td><td>如果当前连接池里的连接数量超过了最小空闲连接数，而同时有连接空闲时间超过了该数值，那么这些连接将会自动被关闭，并从连接池里去掉。时间单位是毫秒</td></tr><tr><td>redisson.connectTimeout</td><td style="text-align:left">10000</td><td>同任何节点建立连接时的等待超时。时间单位是毫秒。</td></tr><tr><td>redisson.timeout</td><td style="text-align:left">3000</td><td>等待节点回复命令的时间。该时间从命令发送成功时开始计时。</td></tr><tr><td>redisson.retryAttempts</td><td style="text-align:left">3</td><td>如果尝试达到 retryAttempts（命令失败重试次数） 仍然不能将命令发送至某个指定的节点时，将抛出错误。如果尝试在此限制之内发送成功，则开始启用 timeout（命令等待超时） 计时。</td></tr><tr><td>redisson.retryInterval</td><td style="text-align:left">1500</td><td>在一条命令发送失败以后，等待重试发送的时间间隔。时间单位是毫秒。</td></tr><tr><td>redisson.subscriptionsPerConnection</td><td style="text-align:left">5</td><td>每个连接的最大订阅数量。</td></tr><tr><td>redisson.clientName</td><td style="text-align:left"></td><td>在Redis节点里显示的客户端名称。</td></tr><tr><td>redisson.sslEnableEndpointIdentification</td><td style="text-align:left">true</td><td>开启SSL终端识别能力。</td></tr><tr><td>redisson.sslProvider</td><td style="text-align:left">JDK</td><td>确定采用哪种方式（JDK或OPENSSL）来实现SSL连接。</td></tr><tr><td>redisson.sslTruststore</td><td style="text-align:left"></td><td>指定SSL信任证书库的路径。</td></tr><tr><td>redisson.sslTruststorePassword</td><td style="text-align:left"></td><td>指定SSL信任证书库的密码。</td></tr><tr><td>redisson.sslKeystore</td><td style="text-align:left"></td><td>指定SSL钥匙库的路径。</td></tr><tr><td>redisson.sslKeystorePassword</td><td style="text-align:left"></td><td>指定SSL钥匙库的密码。</td></tr><tr><td>redisson.lockWatchdogTimeout</td><td style="text-align:left">30000</td><td>监控锁的看门狗超时时间单位为毫秒。该参数只适用于分布式锁的加锁请求中未明确使用leaseTimeout参数的情况。如果该看门口未使用lockWatchdogTimeout去重新调整一个分布式锁的lockWatchdogTimeout超时，那么这个锁将变为失效状态。这个参数可以用来避免由Redisson客户端节点宕机或其他原因造成死锁的情况。</td></tr><tr><td>redisson.keepPubSubOrder</td><td style="text-align:left">true</td><td>通过该参数来修改是否按订阅发布消息的接收顺序出来消息，如果选否将对消息实行并行处理，该参数只适用于订阅发布消息的情况。</td></tr></tbody></table><blockquote><ol><li>单例模式参数</li></ol></blockquote><p>配置前缀：redisson.singleServerConfig</p><table><thead><tr><th>属性名</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>address</td><td></td><td>服务器地址,必填ip:port</td></tr><tr><td>database</td><td>0</td><td>尝试连接的数据库编号。</td></tr><tr><td>subscriptionConnectionMinimumIdleSize</td><td>1</td><td>用于发布和订阅连接的最小保持连接数（长连接）。Redisson内部经常通过发布和订阅来实现许多功能。长期保持一定数量的发布订阅连接是必须的。</td></tr><tr><td>subscriptionConnectionPoolSize</td><td>50</td><td>用于发布和订阅连接的连接池最大容量。连接池的连接数量自动弹性伸缩。</td></tr><tr><td>connectionMinimumIdleSize</td><td>32</td><td>最小保持连接数（长连接）。长期保持一定数量的连接有利于提高瞬时写入反应速度。</td></tr><tr><td>connectionPoolSize</td><td>64</td><td>连接池最大容量。连接池的连接数量自动弹性伸缩。</td></tr><tr><td>dnsMonitoringInterval</td><td>5000</td><td>用来指定检查节点DNS变化的时间间隔。使用的时候应该确保JVM里的DNS数据的缓存时间保持在足够低的范围才有意义。用-1来禁用该功能。</td></tr></tbody></table><blockquote><ol><li>集群模式</li></ol></blockquote><p>配置前缀：redisson.multiple-server-config</p><table><thead><tr><th>属性名</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>redisson.multiple-server-config.node-addresses</td><td></td><td>服务器节点地址.必填</td></tr><tr><td>loadBalancer</td><td>RoundRobinLoadBalancer</td><td>在多Redis服务节点的环境里，可以选用以下几种负载均衡方式选择一个节点： WeightedRoundRobinBalancer - 权重轮询调度算法 RoundRobinLoadBalancer - 轮询调度算法 RandomLoadBalancer - 随机调度算法</td></tr><tr><td>slaveConnectionMinimumIdleSize</td><td>32</td><td>多从节点的环境里，每个 从服务节点里用于普通操作（非 发布和订阅）的最小保持连接数（长连接）。长期保持一定数量的连接有利于提高瞬时读取反映速度。</td></tr><tr><td>slaveConnectionPoolSize</td><td>64</td><td>多从节点的环境里，每个 从服务节点里用于普通操作（非 发布和订阅）连接的连接池最大容量。连接池的连接数量自动弹性伸缩。</td></tr><tr><td>masterConnectionMinimumIdleSize</td><td>32</td><td>多节点的环境里，每个 主节点的最小保持连接数（长连接）。长期保持一定数量的连接有利于提高瞬时写入反应速度。</td></tr><tr><td>masterConnectionPoolSize</td><td>64</td><td>多主节点的环境里，每个 主节点的连接池最大容量。连接池的连接数量自动弹性伸缩。</td></tr><tr><td>readMode</td><td>SLAVE</td><td>设置读取操作选择节点的模式。 可用值为： SLAVE - 只在从服务节点里读取。 MASTER - 只在主服务节点里读取。 MASTER_SLAVE - 在主从服务节点里都可以读取。</td></tr><tr><td>subscriptionMode</td><td>SLAVE</td><td>设置订阅操作选择节点的模式。 可用值为： SLAVE - 只在从服务节点里订阅。 MASTER - 只在主服务节点里订阅。</td></tr><tr><td>subscriptionConnectionMinimumIdleSize</td><td>1</td><td>用于发布和订阅连接的最小保持连接数（长连接）。Redisson内部经常通过发布和订阅来实现许多功能。长期保持一定数量的发布订阅连接是必须的。 redisson.multiple-server-config.subscriptionConnectionPoolSize</td></tr><tr><td>dnsMonitoringInterval</td><td>5000</td><td>监测DNS的变化情况的时间间隔。</td></tr><tr><td>scanInterval</td><td>1000</td><td>(集群,哨兵,云托管模特特有) 对Redis集群节点状态扫描的时间间隔。单位是毫秒。</td></tr><tr><td>database</td><td>0</td><td>(哨兵模式,云托管,主从模式特有)尝试连接的数据库编号。</td></tr><tr><td>masterName</td><td></td><td>(哨兵模式特有)主服务器的</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/redisson/redisson/wiki/%E7%9B%AE%E5%BD%95&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中文文档（很详细）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Redisson的中文文档写
      
    
    </summary>
    
      <category term="noSql" scheme="http://yoursite.com/child/categories/noSql/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/child/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>业务-接口鉴权设计与实现</title>
    <link href="http://yoursite.com/child/2020/12/02/%E4%B8%9A%E5%8A%A1-%E6%8E%A5%E5%8F%A3%E9%89%B4%E6%9D%83%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/child/2020/12/02/业务-接口鉴权设计与实现/</id>
    <published>2020-12-01T16:00:00.000Z</published>
    <updated>2020-12-30T02:07:38.161Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h4><p>难点在于，请求一个接口时，怎么确定当前请求的接口所对应的权限记录</p><p>request对象如下图：</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/%E9%9A%8F%E7%AC%94%E5%9B%BE%E7%89%87%E4%B8%8D%E5%88%86%E7%B1%BB/%E6%8E%A5%E5%8F%A3%E9%89%B4%E6%9D%83-1.png" alt></p><p>所以可以根据request的path进行判断。</p><p>数据库中存储了接口的信息，如下图</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/%E9%9A%8F%E7%AC%94%E5%9B%BE%E7%89%87%E4%B8%8D%E5%88%86%E7%B1%BB/%E6%8E%A5%E5%8F%A3%E9%89%B4%E6%9D%83-2.png" alt></p><p>permission表中的记录，会关联到具体的接口</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/%E9%9A%8F%E7%AC%94%E5%9B%BE%E7%89%87%E4%B8%8D%E5%88%86%E7%B1%BB/%E6%8E%A5%E5%8F%A3%E9%89%B4%E6%9D%83-3.png" alt></p><p>如图resource_type=0表示该权限记录对应的限制资源时接口，resource_id就是关联到interface表的外键</p><p>token中有用户的Uid以及用户的角色，角色用<code>List&lt;Integer&gt;</code>表示，一个用户有多个角色，存储的是role表记录的主键id</p><p>所以鉴权时，可以直接从token中获取角色信息，也就能获取到所有能够访问的接口（role和permission关联）信息。</p><p>此时，在判断当前请求的接口在不在这个有限集合中，就能得到鉴权结果，那么要怎么才能知道当前请求的接口是哪一个接口呢？</p><p>根据一个Request对象我们能得到的信息只有请求的method、uri等信息，所以初步考虑，根据请求uri的path进行判断。</p><p>潜在问题：请求url可能会被网关过滤器进行修改后再路由，所以要将可能修改url的filter放在tokenFilter的前面，保证TokenFilter拿到的path是最终要请求具体服务的Path。</p><p>此外，还要考虑到以下问题</p><ul><li>Path中的<code>@PathVariable</code>参数对Path匹配会带来影响</li><li>需要支持前缀匹配，匹配到path前面指定一部分，则表示匹配成功</li><li>Restful风格的path设计，同一个url可能应不同方法的请求接口，所以请求方法也要考虑进去，采用<code>method+uri</code>确定接口的范式</li><li>功能接口组，对于管理员用户来说授权一个功能给某用户，意味着授权一组接口，与上面一条可能重复，实现方式不同</li></ul><p>针对以上问题，提出以下设计：</p><ul><li>对于PathVariable参数内嵌在path中，在存入interface表记录时，一律用<code>*</code>替代@PathVariable参数，<code>*</code>表示匹配任意一个单词</li><li>前缀匹配的问题，采用<code>**</code>表示匹配Path中的一个或多个单词</li></ul><p>如果interface表中一条记录采用了前缀匹配的uri，那么这条记录对应的可能就不止一个接口了。</p><h4 id="2-缓存设计"><a href="#2-缓存设计" class="headerlink" title="2. 缓存设计"></a>2. 缓存设计</h4><h5 id="2-1-redis缓存"><a href="#2-1-redis缓存" class="headerlink" title="2.1 redis缓存"></a>2.1 redis缓存</h5><p>TokenFilter拿到roleId之后，需要去缓存中查询当前请求的权限，这里使用缓存，一是为了提高性能，二是为了解耦，权限管理的接口并不在网关中，使用缓存解耦可以减少服务间调用。这种情况下，权限管理服务需要保证权限记录的缓存数据库读写一致性的问题。</p><p>使用String类型数据类型来存储</p><p>redisKey 为  <code>passport:role:${roleId}</code></p><p>value值为jsonArray，如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">"POST:/passport/check/raise"</span>,</span><br><span class="line">  <span class="string">"POST:/passport/login"</span>,</span><br><span class="line">  <span class="string">"POST:/passport/check/code"</span>,</span><br><span class="line">  <span class="string">"POST:/passport/reset"</span>,</span><br><span class="line">  <span class="string">"POST:/passport/check/weixin"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h5 id="2-2-本地二级缓存"><a href="#2-2-本地二级缓存" class="headerlink" title="2.2 本地二级缓存"></a>2.2 本地二级缓存</h5><p>每次鉴权都需要访问缓存获取对应角色的ant表达式jason字串，然后解析成列表，所以可以将解析好的列表在本地进行缓存，生产环境中，角色对应的接口权限是一个读多写少的数据，所以使用本地缓存可以有效的提高效率。</p><p>需要考虑多级缓存一致性的问题：当redis中的缓存内容修改时，在redis中发布一个消息，网关服务监听到该消息，就将本地缓存中对应的roleId删除</p><p>由于redis消息是不可靠的通知机制，所以此处可以引入消息队列</p><p>此外还可以启动一个定时任务，定期清除本地缓存，但是这样一旦发生不一致的情况可能会有一个窗口期维持这种不一致。</p><h4 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h4><p>对于ant表达式，使用Spring自带的AntPathMatcher工具类进行匹配。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-需求分析&quot;&gt;&lt;a href=&quot;#1-需求分析&quot; class=&quot;headerlink&quot; title=&quot;1. 需求分析&quot;&gt;&lt;/a&gt;1. 需求分析&lt;/h4&gt;&lt;p&gt;难点在于，请求一个接口时，怎么确定当前请求的接口所对应的权限记录&lt;/p&gt;
&lt;p&gt;request对象如下图
      
    
    </summary>
    
      <category term="业务" scheme="http://yoursite.com/child/categories/%E4%B8%9A%E5%8A%A1/"/>
    
    
      <category term="鉴权" scheme="http://yoursite.com/child/tags/%E9%89%B4%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>数据库技术-liquibase使用和原理</title>
    <link href="http://yoursite.com/child/2020/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF-liquibase%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86%20/"/>
    <id>http://yoursite.com/child/2020/12/01/数据库技术-liquibase使用和原理 /</id>
    <published>2020-11-30T16:00:00.000Z</published>
    <updated>2020-12-14T08:05:18.597Z</updated>
    
    <content type="html"><![CDATA[<p>LiquiBase是一个用于数据库重构和迁移的开源工具，通过日志文件的形式记录数据库的变更，然后执行日志文件中的修改，将数据库更新或回滚到一致的状态。</p><p>LiquiBase的主要特点有：</p><ul><li>支持几乎所有主流的数据库，如MySQL, PostgreSQL, Oracle, Sql Server, DB2等；</li><li>支持多开发者的协作维护；</li><li>日志文件支持多种格式，如XML, YAML, JSON, SQL等；</li><li>支持多种运行方式，如命令行、Spring集成、Maven插件、Gradle插件等；</li></ul><p>本文首先简单介绍一下LiquiBase的changelog文件的常用标签配置，然后介绍在Maven中集成并运行LiquiBase。</p><h3 id="1-changelog文件格式"><a href="#1-changelog文件格式" class="headerlink" title="1. changelog文件格式"></a>1. changelog文件格式</h3><p>changelog是LiquiBase用来记录数据库的变更，一般放在<code>CLASSPATH</code>下，然后配置到执行路径中。</p><p>changelog支持多种格式，主要有XML/JSON/YAML/SQL，其中XML/JSON/YAML除了具体格式语法不同，节点配置很类似，SQL格式中主要记录SQL语句，这里仅给出XML格式和SQL格式的示例，更多的格式示例请参考文档</p><p>changelog.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">changeSet</span> <span class="attr">id</span>=<span class="string">"2"</span> <span class="attr">author</span>=<span class="string">"daniel"</span> <span class="attr">runOnChange</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">tableName</span>=<span class="string">"contest_info"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">column</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"title"</span>&gt;</span>title 3<span class="tag">&lt;/<span class="name">column</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"content"</span>&gt;</span>content 3<span class="tag">&lt;/<span class="name">column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">changeSet</span>&gt;</span></span><br></pre></td></tr></table></figure><p>changelog.sql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--liquibase formatted sql</span></span><br><span class="line"><span class="comment">--changeset daniel:16040707</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`role_authority_sum`</span> (</span><br><span class="line">  <span class="string">`row_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'自增id'</span>,</span><br><span class="line">  <span class="string">`role_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'关联role的role_id'</span>,</span><br><span class="line">  <span class="string">`authority_sum`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'perms的值的和'</span>,</span><br><span class="line">  <span class="string">`data_type_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'关联data_type的id'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`row_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'角色的权限值的和，如角色有RD权限，则和为2+8=10'</span>;</span><br></pre></td></tr></table></figure><h3 id="2-常用的标签及命令"><a href="#2-常用的标签及命令" class="headerlink" title="2. 常用的标签及命令"></a>2. 常用的标签及命令</h3><h4 id="2-1-标签"><a href="#2-1-标签" class="headerlink" title="2.1 标签"></a>2.1 标签</h4><p>　　一个<code>&lt;changeSet&gt;</code>标签对应一个变更集，由id、name、以及changelog的文件路径组成唯一标识。changelog在执行的时候并不是按照id的顺序，而是按照changeSet在changelog中出现的顺序。</p><p>LiquiBase在执行changelog时，会在数据库中插入两张表：<code>DATABASECHANGELOG</code>和<code>DATABASECHANGELOGLOCK</code>，分别记录changelog的执行日志和锁日志。</p><p>LiquiBase在执行changelog中的changeSet时，会首先查看<code>DATABASECHANGELOG</code>表，如果已经执行过，则会跳过（除非changeSet的<code>runAlways</code>属性为true，后面会介绍），如果没有执行过，则执行并记录changelog日志；</p><p>changelog中的一个changeSet对应一个事务，在changeSet执行完后commit，如果出现错误则rollback；</p><p><code>&lt;changeSet&gt;</code>标签的主要属性有：</p><ul><li>runAlways：即使已经执行过，仍然每次都执行；<strong>注意</strong>: 由于<code>DATABASECHANGELOG</code>表中还记录了changeSet的MD5校验值MD5SUM，如果changeSet的<code>id</code>和<code>name</code>没变，而内容变了，则由于MD5值变了，即使runAlways的值为True，执行也是失败的，会报错。这种情况应该使用<code>runOnChange</code>属性。</li><li>runOnChange：第一次的时候执行以及当changeSet的内容发生变化时执行。不受MD5校验值的约束。</li><li>runInTransaction：是否作为一个事务执行，默认为true。设置为false时需要<strong>小心</strong>：如果执行过程中出错了则不会rollback，数据库很可能处于不一致的状态；</li></ul><p><code>&lt;changeSet&gt;</code>下有一个重要的子标签<code>&lt;rollback&gt;</code>，即定义回滚的SQL语句。对于<code>create table</code>, <code>rename column</code>和<code>add column</code>等，LiquiBase会自动生成对应的rollback语句，而对于<code>drop table</code>、<code>insert data</code>等则需要显示定义rollback语句。</p><h4 id="2-2-lt-include-gt-与-lt-includeAll-gt-标签"><a href="#2-2-lt-include-gt-与-lt-includeAll-gt-标签" class="headerlink" title="2.2 &lt;include&gt;与&lt;includeAll&gt;标签"></a>2.2 <code>&lt;include&gt;</code>与<code>&lt;includeAll&gt;</code>标签</h4><p>当changelog文件越来越多时，可以使用<code>&lt;include&gt;</code>将文件管理起来，如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">databaseChangeLog</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">"http://www.liquibase.org/xml/ns/dbchangelog"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.liquibase.org/xml/ns/dbchangelog</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"logset-20160408/0001_authorization_init.sql"</span> <span class="attr">relativeToChangelogFile</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">databaseChangeLog</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;include&gt;</code>的<strong>file</strong>属性表示要包含的changelog文件的路径，这个文件可以是LiquiBase支持的任意格式，<strong>relativeToChangelogFile</strong>如果为true，则表示<strong>file</strong>属性表示的文件路径是相对于根changelog而不是<strong>CLASSPATH</strong>的，默认为false。</p><p><code>&lt;includeAll&gt;</code>指定的是changelog的目录，而不是为文件，如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">includeAll</span> <span class="attr">path</span>=<span class="string">"com/example/changelogs/"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-3-diff命令"><a href="#2-3-diff命令" class="headerlink" title="2.3 diff命令"></a>2.3 diff命令</h4><p>diff命令用于比较数据库之间的异同。比如通过命令行执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java -jar liquibase.jar --driver=com.mysql.jdbc.Driver \</span><br><span class="line">    --classpath=./mysql-connector-java-5.1.29.jar \</span><br><span class="line">    --url=jdbc:mysql://127.0.0.1:3306/<span class="built_in">test</span> \</span><br><span class="line">    --username=root --password=passwd \</span><br><span class="line">    diff \</span><br><span class="line">    --referenceUrl=jdbc:mysql://127.0.0.1:3306/authorization \</span><br><span class="line">    --referenceUsername=root --referencePassword=passwd</span><br></pre></td></tr></table></figure><h4 id="2-4-generateChangeLog"><a href="#2-4-generateChangeLog" class="headerlink" title="2.4 generateChangeLog"></a>2.4 generateChangeLog</h4><p>在已有的项目上使用LiquiBase，要生成当前数据库的changeset，可以采用两种方式，一种是使用数据库工具导出SQL数据，然后changelog文件以SQL格式记录即可；另一种方式就是用<code>generateChangeLog</code>命令，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">liquibase --driver=com.mysql.jdbc.Driver \</span><br><span class="line">      --classpath=./mysql-connector-java-5.1.29.jar \</span><br><span class="line">      --changeLogFile=liquibase/db.changelog.xml \</span><br><span class="line">      --url=<span class="string">"jdbc:mysql://127.0.0.1:3306/test"</span> \</span><br><span class="line">      --username=root \</span><br><span class="line">      --password=yourpass \</span><br><span class="line">      generateChangeLog</span><br></pre></td></tr></table></figure><p>不过<code>generateChangeLog</code>不支持以下功能：存储过程、函数以及触发器</p><h3 id="3-Maven集成LiquiBase"><a href="#3-Maven集成LiquiBase" class="headerlink" title="3. Maven集成LiquiBase"></a>3. Maven集成LiquiBase</h3><h4 id="3-1-liquibase-maven-plugin的配置"><a href="#3-1-liquibase-maven-plugin的配置" class="headerlink" title="3.1 liquibase-maven-plugin的配置"></a>3.1 <code>liquibase-maven-plugin</code>的配置</h4><p>Maven中集成LiquiBase，主要是配置<code>liquibase-maven-plugin</code>，首先给出一个示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.liquibase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>liquibase-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">changeLogFile</span>&gt;</span>src/main/resources/liquibase/test_changelog.xml<span class="tag">&lt;/<span class="name">changeLogFile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">driver</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">driver</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>jdbc:mysql://127.0.0.1:3306/test<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">username</span>&gt;</span>root<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">password</span>&gt;</span>passwd<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">phase</span>&gt;</span>process-resources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">goal</span>&gt;</span>update<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中<code>&lt;configuration&gt;</code>节点中的配置可以放在单独的配置文件里。</p><p>如果需要在父项目中配置子项目共享的LiquiBase配置，而各个子项目可以定义自己的配置，并覆盖父项目中的配置，则只需要在父项目的pom中将<code>propertyFileWillOverride</code>设置为true即可，如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.liquibase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>liquibase-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">propertyFileWillOverride</span>&gt;</span>true<span class="tag">&lt;/<span class="name">propertyFileWillOverride</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">propertyFile</span>&gt;</span>liquibase/liquibase.properties<span class="tag">&lt;/<span class="name">propertyFile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-2-liquibase-update"><a href="#3-2-liquibase-update" class="headerlink" title="3.2 liquibase:update"></a>3.2 <code>liquibase:update</code></h4><p>执行changelog中的变更：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mvn liquibase:update</span><br></pre></td></tr></table></figure><h4 id="3-3-liquibase-rollback"><a href="#3-3-liquibase-rollback" class="headerlink" title="3.3 liquibase:rollback"></a>3.3 <code>liquibase:rollback</code></h4><p>rollback有3中形式，分别是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- rollbackCount: 表示rollback的changeset的个数；</span><br><span class="line">- rollbackDate：表示rollback到指定的日期；</span><br><span class="line">- rollbackTag：表示rollback到指定的tag，需要使用LiquiBase在具体的时间点打上tag；</span><br></pre></td></tr></table></figure><p><code>rollbackCount</code>比较简单，示例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mvn liquibase:rollback -Dliquibase.rollbackCount=3</span><br></pre></td></tr></table></figure><p> <code>rollbackDate</code>需要注意日期的格式，必须匹配当前平台上执行<code>DateFormat.getDateInstance()</code>得到的格式，比如我的格式为<code>MMM d, yyyy</code>，示例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mvn liquibase:rollback -Dliquibase.rollbackDate=&quot;Apr 10, 2016&quot;</span><br></pre></td></tr></table></figure><p><code>rollbackTag</code>使用tag标识，所以需要先打tag，示例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mvn liquibase:tag -Dliquibase.tag=tag20160410</span><br></pre></td></tr></table></figure><p>然后rollback到tag20160410，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mvn liquibase:rollback -Dliquibase.rollbackTag=tag20160410</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;LiquiBase是一个用于数据库重构和迁移的开源工具，通过日志文件的形式记录数据库的变更，然后执行日志文件中的修改，将数据库更新或回滚到一致的状态。&lt;/p&gt;
&lt;p&gt;LiquiBase的主要特点有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持几乎所有主流的数据库，如MySQL, Pos
      
    
    </summary>
    
      <category term="数据库技术" scheme="http://yoursite.com/child/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="liquibase" scheme="http://yoursite.com/child/tags/liquibase/"/>
    
  </entry>
  
  <entry>
    <title>任务调度-使用quartz</title>
    <link href="http://yoursite.com/child/2020/10/07/%E5%88%86%E5%B8%83%E5%BC%8F-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6quartz/"/>
    <id>http://yoursite.com/child/2020/10/07/分布式-任务调度quartz/</id>
    <published>2020-10-06T16:00:00.000Z</published>
    <updated>2020-11-15T09:43:53.761Z</updated>
    
    <content type="html"><![CDATA[<p>文章目标：</p><p>1、了解任务调度的应用场景和 Quartz 的基本特性 </p><p>2、掌握 Quartz Java 编程和 Spring 集成的使用</p><p>3、掌握 Quartz 动态调度和集群部署的实现</p><h3 id="1、任务调度场景"><a href="#1、任务调度场景" class="headerlink" title="1、任务调度场景"></a>1、任务调度场景</h3><p>在业务系统中有很多这样的场景:</p><p>1、账单日或者还款日上午 10 点，给每个信用卡客户发送账单通知，还款通知。如 何判断客户的账单日、还款日，完成通知的发送</p><p>2、银行业务系统，夜间要完成跑批的一系列流程，清理数据，下载文件，解析文件， 对账清算、切换结算日期等等。如何触发一系列流程的执行</p><p>3、金融机构跟人民银行二代支付系统对接，人民银行要求低于 5W 的金额(小额支付)半个小时打一次包发送，以缓解并发压力。所以，银行的跨行转账分成了多个流程: 录入、复核、发送。如何把半个小时以内的所有数据一次性发送</p><p>类似于这种 </p><ul><li>基于准确的时刻或者固定的时间间隔触发的任务</li><li>有批量数据需要处理</li><li>要实现两个动作解耦的场景</li></ul><p>我们都可以用任务调度来实现。</p><h3 id="2、任务调度需求分析"><a href="#2、任务调度需求分析" class="headerlink" title="2、任务调度需求分析"></a>2、任务调度需求分析</h3><ol><li>可以定义触发的规则，比如基于时刻、时间间隔、表达式。</li><li>可以定义需要执行的任务。比如执行一个脚本或者一段代码。任务和规则是 分开的。</li><li>集中管理配置，持久配置。不用把规则写在代码里面，可以看到所有的任务 配置，方便维护。重启之后任务可以再次调度——配置文件或者配置中心。</li><li>支持任务的串行执行，例如执行 A 任务后再执行 B 任务再执行 C 任务。</li><li>支持多个任务并发执行，互不干扰(例如 ScheduledThreadPoolExecutor)。</li><li>有自己的调度器，可以启动、中断、停止任务。</li><li>容易集成到 Spring。</li></ol><h3 id="3、任务调度工具和框架"><a href="#3、任务调度工具和框架" class="headerlink" title="3、任务调度工具和框架"></a>3、任务调度工具和框架</h3><ul><li><p>Linux crontab，Windows 计划任务</p></li><li><p>MySQL、Oracle</p></li><li><p>Kettle </p></li><li><p>jdk自带的Timer、ScheduledThreadPool</p></li><li>Spring Task--@Scheduled  也是使用ScheduledThreadPool实现的</li><li>quartz，XXL-JOB，Elastic-Job</li></ul><h3 id="4、Quartz使用入门"><a href="#4、Quartz使用入门" class="headerlink" title="4、Quartz使用入门"></a>4、Quartz使用入门</h3><h4 id="4-1-基本介绍"><a href="#4-1-基本介绍" class="headerlink" title="4.1 基本介绍"></a>4.1 基本介绍</h4><p><a href="http://www.quartz-scheduler.org/" target="_blank" rel="noopener">官网</a></p><p>Quartz 的意思是石英，像石英表一样精确。</p><p>Quartz 是一个老牌的任务调度系统，98 年构思，01 年发布到 sourceforge。现在更新比较慢，因为已经非常成熟了。</p><p>Quartz 的目的就是让任务调度更加简单，开发人员只需要关注业务即可。他是用 Java 语言编写的(也有.NET 的版本)。Java 代码能做的任何事情，Quartz 都可以调度。</p><p>特点：</p><ul><li>精确到毫秒级别的调度</li><li>可以独立运行，也可以集成到容器中</li><li>支持事务(JobStoreCMT )</li><li>支持集群</li><li>支持持久化</li></ul><h4 id="4-2-API使用"><a href="#4-2-API使用" class="headerlink" title="4.2 API使用"></a>4.2 API使用</h4><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.quartz-scheduler<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>quartz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>默认配置：</p><p>org.quartz.core 包下，有一个默认的配置文件，quartz.properties。当我们没有 定义一个同名的配置文件的时候，就会使用默认配置文件里面的配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">org.quartz.scheduler.instanceName: DefaultQuartzScheduler </span><br><span class="line">org.quartz.scheduler.rmi.export: false</span><br><span class="line">org.quartz.scheduler.rmi.proxy: false </span><br><span class="line">org.quartz.scheduler.wrapJobExecutionInUserTransaction: false </span><br><span class="line">org.quartz.threadPool.class: org.quartz.simpl.SimpleThreadPool </span><br><span class="line">org.quartz.threadPool.threadCount: 10</span><br><span class="line">org.quartz.threadPool.threadPriority: 5 </span><br><span class="line">org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread: true </span><br><span class="line">org.quartz.jobStore.misfireThreshold: 60000</span><br><span class="line">org.quartz.jobStore.class: org.quartz.simpl.RAMJobStore</span><br></pre></td></tr></table></figure><p>创建三大对象：</p><ul><li>创建Job：任务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"假发在哪里买的"</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用到 Job时，需要进一步包装成 JobDetail。必须要指定 JobName 和 groupName，两个合起    来是唯一标识符。可以携带 KV 的数据(JobDataMap)，用于扩展属性，在运行的时候可以从context    获取到。</p><ul><li><p>创建Trigger：就是调度策略</p></li><li><p>创建Scheduler：调度器</p></li></ul><p>通过 Factory 获取调度器的实例，把 JobDetail 和 Trigger 绑定，注册到容器中。Scheduler 先启动后启动无所谓，只要有 Trigger 到达触发条件，就会执行任务。</p><p>详细代码请见：</p><h4 id="4-3-体系结构总结"><a href="#4-3-体系结构总结" class="headerlink" title="4.3 体系结构总结"></a>4.3 体系结构总结</h4><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/quartz/quratz%E7%BB%93%E6%9E%84%E6%80%BB%E5%9B%BE.png" alt="总体架构" style="zoom:60%;"></p><h5 id="4-3-1-JobDetail"><a href="#4-3-1-JobDetail" class="headerlink" title="4.3.1 JobDetail"></a>4.3.1 JobDetail</h5><p>我们创建一个实现 Job 接口的类，使用 JobBuilder 包装成 JobDetail，它可以携带 KV 的数据。</p><h5 id="4-3-2-Trigger"><a href="#4-3-2-Trigger" class="headerlink" title="4.3.2 Trigger"></a>4.3.2 Trigger</h5><p>定义任务的触发规则，Trigger，使用 TriggerBuilder 来构建。</p><p>JobDetail 跟 Trigger 是 1:N 的关系。</p><p>思考：为什么任务和规则要解耦？</p><p>因为任务调度规则复杂的时候可以配置多个trigger来实现。</p><p>Trigger 接口在 Quartz 有 4 个继承的子接口:</p><table><thead><tr><th>子接口</th><th>描述</th><th style="text-align:left">特点</th></tr></thead><tbody><tr><td>SimpleTrigger</td><td>简单触发器</td><td style="text-align:left">固定时刻或时间间隔，毫秒</td></tr><tr><td>CalendarIntervalTrigger</td><td>基于日历的触发器</td><td style="text-align:left">比简单触发器更多时间单位，支持非固定时 间的触发，例如一年可能 365/366，一个月 可能28/29/30/31</td></tr><tr><td>DailyTimeIntervalTrigger</td><td>基于日期的触发器</td><td style="text-align:left">每天的某个时间段</td></tr><tr><td>CronTrigger</td><td>基于 Cron 表达式的触发器</td><td style="text-align:left">最常用的</td></tr></tbody></table><ul><li><p>SimpleTrigger</p><p>SimpleTrigger 可以定义固定时刻或者固定时间间隔的调度规则(精确到毫秒)。 例如:每天 9 点钟运行;每隔 30 分钟运行一次。</p></li><li><p>CalendarIntervalTrigger</p><p>CalendarIntervalTrigger 可以定义更多时间单位的调度需求，精确到秒。 好处是不需要去计算时间间隔，比如 1 个小时等于多少毫秒。 例如每年、每个月、每周、每天、每小时、每分钟、每秒。 每年的月数和每个月的天数不是固定的，这种情况也适用。</p></li><li><p>DailyTimeIntervalTrigger</p><p>每天的某个时间段内，以一定的时间间隔执行任务。</p><p>例如:每天早上 9 点到晚上 9 点，每隔半个小时执行一次，并且只在周一到周六执 行。</p></li><li><p>CronTrigger</p><p>CronTirgger 可以定义基于 Cron 表达式的调度规则，是最常用的触发器类型。 </p></li></ul><p><a href="https://github.com/zzkenyon/thinking/tree/master/quartz-demo/quartz-standalone/src/main/java/com/panda/trigger/" target="_blank" rel="noopener">Trigger示例代码</a></p><p><strong>Cron 表达式</strong></p><table><thead><tr><th>位置</th><th>时间域</th><th>取值范围</th><th>特殊值</th></tr></thead><tbody><tr><td>1</td><td>秒</td><td>0-59</td><td>,-*/</td></tr><tr><td>2</td><td>分钟</td><td>0-59</td><td>,-*/</td></tr><tr><td>3</td><td>小时</td><td>0-23</td><td>,-*/</td></tr><tr><td>4</td><td>日期</td><td>1-31</td><td>,-*?/ L W C</td></tr><tr><td>5</td><td>月份</td><td>1-12</td><td>,-*/</td></tr><tr><td>6</td><td>星期</td><td>1-7</td><td>,-*?/ L W C</td></tr><tr><td>7</td><td>年份（可选）</td><td>1-31</td><td>,-*/</td></tr></tbody></table><blockquote><p>星号(*):可用在所有字段中，表示对应时间域的每一个时刻，例如，在分钟字段时，表示“每分钟”; </p><p>问号(?):该字符只在日期和星期字段中使用，它通常指定为“无意义的值”，相当于点位符; </p><p>减号(-):表达一个范围，如在小时字段中使用“10-12”，则表示从 10 到 12 点，即 10,11,12; </p><p>逗号(,):表达一个列表值，如在星期字段中使用“MON,WED,FRI”，则表示星期一，星期三和星期五;</p><p> 斜杠(/):x/y 表达一个等步长序列，x 为起始值，y 为增量步长值。如在分钟字段中使用 0/15，则表示为 0,15,30 和45 秒，而 5/15 在分钟字段中表示 5,20,35,50，你也可以使用*/y，它等同于 0/y;</p><p>L:该字符只在日期和星期字段中使用，代表“Last”的意思，但它在两个字段中意思不同。L 在日期字段中，表示 这个月份的最后一天，如一月的 31 号，非闰年二月的 28 号;如果 L 用在星期中，则表示星期六，等同于 7。但是，如 果 L 出现在星期字段里，而且在前面有一个数值 X，则表示“这个月的最后 X 天”，例如，6L 表示该月的最后星期五;</p><p>W:该字符只能出现在日期字段里，是对前导日期的修饰，表示离该日期最近的工作日。例如 15W 表示离该月 15 号最近的工作日，如果该月 15 号是星期六，则匹配 14 号星期五;如果 15 日是星期日，则匹配 16 号星期一;如果 15 号是星期二，那结果就是 15 号星期二。但必须注意关联的匹配日期不能够跨月，如你指定 1W，如果 1 号是星期六， 结果匹配的是 3 号星期一，而非上个月最后的那天。W 字符串只能指定单一日期，而不能指定日期范围;</p><p>LW 组合:在日期字段可以组合使用 LW，它的意思是当月的最后一个工作日;</p><p>井号(#):该字符只能在星期字段中使用，表示当月某个工作日。如 6#3 表示当月的第三个星期五(6 表示星期五， #3 表示当前的第三个)，而 4#5 表示当月的第五个星期三，假设当月没有第五个星期三，忽略不触发;</p><p>C:该字符只在日期和星期字段中使用，代表“Calendar”的意思。它的意思是计划所关联的日期，如果日期没有 被关联，则相当于日历中所有日期。例如 5C 在日期字段中就相当于日历 5 日以后的第一天。1C 在星期字段中相当于 星期日后的第一天。</p><p>Cron 表达式对特殊字符的大小写不敏感，对代表星期的缩写英文大小写也不敏感。</p></blockquote><p>上面我们定义的都是在什么时间执行，但是我们有一些在什么时间不执行的需求， 比如:理财周末和法定假日购买不计息;证券公司周末和法定假日休市。</p><p><strong>基于 Calendar 的排除规则</strong></p><p>如果要在触发器的基础上，排除一些时间区间不执行任务，就要用到 Quartz 的 Calendar 类(注意不是 JDK 的 Calendar)。可以按年、月、周、日、特定日期、Cron 表达式排除。</p><p>调用 Trigger 的 <code>modifiedByCalendar()</code>添加到触发器中，并且调用调度器的 addCalendar()方法注册排除规则。</p><p>Calendar的种类：</p><ul><li>BaseCalendar  为高级的 Calendar 实现了基本的功能，实现了 org.quartz.Calendar 接口</li><li>AnnualCalendar  排除年中一天或多天</li><li>CronCalendar  日历的这种实现排除了由给定的 CronExpression 表达的时间集合。 例如， 您可以使用此日历使用表达式“<code>* * 0-7,18-23?* *</code>”每天排除所有营业时间(上午 8 点至下午 5 点)。 如果 CronTrigger 具有给定的 cron 表达式并且与具有相同表达式的 CronCalendar 相关联，则日历将排除触发器包含的所有时间，并且它们将彼此抵消。</li><li>DailyCalendar  您可以使用此日历来排除营业时间(上午 8 点 - 5 点)每天。 每个 DailyCalendar 仅允许指定单个时间范围，并且该时间范围可能不会跨越每 日边界(即，您不能指定从上午 8 点至凌晨 5 点的时间范围)。 如果属 性 invertTimeRange 为 false(默认)，则时间范围定义触发器不允许触发 的时间范围。 如果 invertTimeRange 为 true，则时间范围被反转 - 也就是 排除在定义的时间范围之外的所有时间。</li><li>HolidayCalendar  特别的用于从 Trigger 中排除节假日</li><li>MonthlyCalendar  排除月份中的指定数天，例如，可用于排除每月的最后一天</li><li>WeeklyCalendar  排除星期中的任意周几，例如，可用于排除周末，默认周六和周日</li></ul><p><a href="https://github.com/zzkenyon/thinking/tree/master/quartz-demo/quartz-standalone/src/main/java/com/panda/calendar/" target="_blank" rel="noopener">Calendar示例代码</a></p><h5 id="4-3-3-Scheduler"><a href="#4-3-3-Scheduler" class="headerlink" title="4.3.3 Scheduler"></a>4.3.3 Scheduler</h5><p>调度器，是 Quartz 的指挥官，由 StdSchedulerFactory 产生。它是单例的。</p><p>并且是 Quartz 中最重要的 API，默认是实现类是 StdScheduler，里面包含了一个 QuartzScheduler。QuartzScheduler 里面又包含了一个 QuartzSchedulerThread。</p><p>Scheduler 中的方法主要分为三大类:</p><ol><li>操作调度器本身，例如调度器的启动 start()、调度器的关闭 shutdown()。 </li><li>操作 Trigger，例如 pauseTriggers()、resumeTrigger()。</li><li>操作 Job，例如 scheduleJob()、unscheduleJob()、rescheduleJob()</li></ol><p>这些方法非常重要，可以实现任务的动态调度。</p><p><a href="https://github.com/zzkenyon/thinking/tree/master/quartz-demo/quartz-standalone/src/main/java/com/panda/scheduler" target="_blank" rel="noopener">Scheduler示例代码</a></p><h5 id="4-3-4-Listener"><a href="#4-3-4-Listener" class="headerlink" title="4.3.4 Listener"></a>4.3.4 Listener</h5><p>我们有这么一种需求，在每个任务运行结束之后发送通知给运维管理员。那是不是 要在每个任务的最后添加一行代码呢?这种方式对原来的代码造成了入侵，不利于维护。 如果代码不是写在任务代码的最后一行，怎么知道任务执行完了呢?或者说，怎么监测 到任务的生命周期呢?</p><p>观察者模式:定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则 所有依赖它的对象都会得到通知并自动更新。</p><p>Quartz 中提供了三种 Listener，监听 Scheduler 的，监听 Trigger 的，监听 Job 的。 只需要创建类实现相应的接口，并在 Scheduler 上注册 Listener，便可实现对核心对象的监听。</p><ol><li>JobListener</li></ol><p>定义了4个方法：</p><table><thead><tr><th>方法</th><th>作用或执行实际</th></tr></thead><tbody><tr><td>getName()</td><td>返回 JobListener 的名称</td></tr><tr><td>jobToBeExecuted()</td><td>Scheduler 在 JobDetail 将要被执行时调用这个方法</td></tr><tr><td>jobExecutionVetoed()</td><td>Scheduler 在 JobDetail 即将被执行，但又被 TriggerListener 否决了时调用这个 方法</td></tr><tr><td>jobWasExecuted()</td><td>Scheduler 在 JobDetail 被执行之后调用这个方法</td></tr></tbody></table><ol start="2"><li>TriggerListener</li></ol><table><thead><tr><th>方法</th><th>作用或执行实际</th></tr></thead><tbody><tr><td>getName()</td><td>获取名称</td></tr><tr><td>triggerFired()</td><td>Trigger 被触发，Job 上的 execute() 方法将要被执行时，Scheduler 就调用这个 方法</td></tr><tr><td>vetoJobExecution()</td><td>在 Trigger 触发后，Job 将要被执行时由 Scheduler 调用这个方法。 TriggerListener 给了一个选择去否决 Job 的执行。假如这个方法返回 true，这 个 Job 将不会为此次 Trigger 触发而得到执行</td></tr><tr><td>triggerMisfired()</td><td>Trigger 错过触发时调用</td></tr><tr><td>triggerComplete()</td><td>Trigger 被触发并且完成了 Job 的执行时，Scheduler 调用这个方法</td></tr></tbody></table><ol start="3"><li>SchedulerListener</li></ol><p>方法很多，省略</p><p><a href="https://github.com/zzkenyon/thinking/tree/master/quartz-demo/quartz-standalone/src/main/java/com/panda/listeners" target="_blank" rel="noopener">Listener示例代码</a></p><h5 id="4-3-5-JobStore"><a href="#4-3-5-JobStore" class="headerlink" title="4.3.5 JobStore"></a>4.3.5 JobStore</h5><p>Jobstore 用来存储任务和触发器相关的信息，例如所有任务的名称、数量、状态等 等。Quartz 中有两种存储任务的方式，一种在内存，一种是在数据库。</p><ul><li>RAMJobStore</li></ul><p>Quartz 默认的 JobStore 是 RAMJobstore，也就是把任务和触发器信息运行的信息 存储在内存中，用到了 HashMap、TreeSet、HashSet 等等数据结构。</p><p>如果程序崩溃或重启，所有存储在内存中的数据都会丢失。所以我们需要把这些数 据持久化到磁盘。</p><ul><li>JDBCJobStore</li></ul><p>JDBCJobStore 可以通过 JDBC 接口，将任务运行数据保存在数据库中。</p><p>JDBC 的实现方式有两种，JobStoreSupport 类的两个子类: </p><p>JobStoreTX:在独立的程序中使用，自己管理事务，不参与外部事务。</p><p>JobStoreCMT:(Container Managed Transactions (CMT)，如果需要容器管理事务时，使用它。</p><p>使用 JDBCJobSotre 时，需要配置数据库信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">org.quartz.jobStore.class:org.quartz.impl.jdbcjobstore.JobStoreTX </span><br><span class="line">org.quartz.jobStore.driverDelegateClass:org.quartz.impl.jdbcjobstore.StdJDBCDelegate</span><br><span class="line"># 使用 quartz.properties，不使用默认配置</span><br><span class="line">org.quartz.jobStore.useProperties:true</span><br><span class="line">#数据库中 quartz 表的表名前缀</span><br><span class="line">org.quartz.jobStore.tablePrefix:QRTZ_</span><br><span class="line">org.quartz.jobStore.dataSource:myDS</span><br><span class="line"></span><br><span class="line">#配置数据源</span><br><span class="line">org.quartz.dataSource.myDS.driver:com.mysql.jdbc.Driver </span><br><span class="line">org.quartz.dataSource.myDS.URL:jdbc:mysql://localhost:3306/quartz?useUnicode=true&amp;characterEncoding=utf8 org.quartz.dataSource.myDS.user:root</span><br><span class="line">org.quartz.dataSource.myDS.password:123456</span><br><span class="line">org.quartz.dataSource.myDS.validationQuery=select 0 from dual</span><br></pre></td></tr></table></figure><p>问题来了?需要建什么表?表里面有什么字段?字段类型和长度是什么? </p><p>在官网的 Downloads 链接中，提供了 11 张表的建表语句: quartz-2.2.3-distribution\quartz-2.2.3\docs\dbTables</p><p>2.3 的版本在这个路径下:src\org\quartz\impl\jdbcjobstore</p><p>表名与作用:</p><table><thead><tr><th>表名</th><th>作用</th></tr></thead><tbody><tr><td>QRTZ_BLOB_TRIGGERS</td><td>Trigger 作为 Blob 类型存储</td></tr><tr><td>QRTZ_CALENDARS</td><td>存储 Quartz 的 Calendar 信息</td></tr><tr><td>QRTZ_CRON_TRIGGERS</td><td>存储 CronTrigger，包括 Cron 表达式和时区信息</td></tr><tr><td>QRTZ_FIRED_TRIGGERS</td><td>存储与已触发的 Trigger 相关的状态信息，以及相关 Job 的执行信息</td></tr><tr><td>QRTZ_JOB_DETAILS</td><td>存储每一个已配置的 Job 的详细信息</td></tr><tr><td>QRTZ_LOCKS</td><td>存储程序的悲观锁的信息</td></tr><tr><td>QRTZ_PAUSED_TRIGGER_GRPS</td><td>存储已暂停的 Trigger 组的信息</td></tr><tr><td>QRTZ_SCHEDULER_STATE</td><td>存储少量的有关 Scheduler 的状态信息，和别的 Scheduler 实例</td></tr><tr><td>QRTZ_SIMPLE_TRIGGERS</td><td>存储 SimpleTrigger 的信息，包括重复次数、间隔、以及已触的次数</td></tr><tr><td>QRTZ_SIMPROP_TRIGGERS</td><td>存储 CalendarIntervalTrigger 和 DailyTimeIntervalTrigger 两种类型的触发器</td></tr><tr><td>QRTZ_TRIGGERS</td><td>存储已配置的 Trigger 的信息</td></tr></tbody></table><h3 id="5、与spring集成"><a href="#5、与spring集成" class="headerlink" title="5、与spring集成"></a>5、与spring集成</h3><p>Spring-quartz 工程</p><p>Spring 在 spring-context-support.jar 中直接提供了对 Quartz 的支持。</p><p>使用三个FactoryBean配置核心对象</p><ul><li>JobDetailFactoryBean 实现的是FactoryBean<jobdetail></jobdetail></li><li>FactoryBean<trigger>  对不同的Trigger实现有不同的FactoryBean</trigger></li><li>SchedulerFactoryBean  实现的是FactoryBean<scheduler></scheduler></li></ul><p>配置方式可以选择xml方式或者java注解配置。</p><h3 id="6、动态调度"><a href="#6、动态调度" class="headerlink" title="6、动态调度"></a>6、动态调度</h3><p>传统的 Spring 方式集成，由于任务信息全部配置在 xml 文件中，如果需要操作任务 或者修改任务运行频率，只能重新编译、打包、部署、重启，如果有紧急问题需要处理， 会浪费很多的时间。</p><p>有没有可以动态调度任务的方法?比如停止一个 Job?启动一个 Job?修改 Job 的 触发频率?</p><p>读取配置文件、写入配置文件、重启 Scheduler 或重启应用明显是不可取的。 对于这种频繁变更并且需要实时生效的配置信息，我们可以放到哪里?</p><p>ZK、Redis、DB tables。</p><p> 并且，可以提供一个界面，实现对数据表的轻松操作。</p><h4 id="6-1-配置管理"><a href="#6-1-配置管理" class="headerlink" title="6.1 配置管理"></a>6.1 配置管理</h4><p>这里我们用最简单的数据库的实现。</p><p>建一张什么样的表?参考 JobDetail 的属性。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`sys_job`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'ID'</span>,</span><br><span class="line"><span class="string">`job_name`</span> <span class="built_in">varchar</span>(<span class="number">512</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'任务名称'</span>,</span><br><span class="line"><span class="string">`job_group`</span> <span class="built_in">varchar</span>(<span class="number">512</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'任务组名'</span>,</span><br><span class="line"><span class="string">`job_cron`</span> <span class="built_in">varchar</span>(<span class="number">512</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'时间表达式'</span>, </span><br><span class="line">  <span class="string">`job_class_path`</span> <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'类路径,全类型'</span>, </span><br><span class="line">  <span class="string">`job_data_map`</span> <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'传递 map 参数'</span>, </span><br><span class="line">  <span class="string">`job_status`</span> <span class="built_in">int</span>(<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'状态:1 启用 0 停用'</span>, </span><br><span class="line">  <span class="string">`job_describe`</span> <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'任务功能描述'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">25</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><h4 id="6-2-数据操作与任务调度"><a href="#6-2-数据操作与任务调度" class="headerlink" title="6.2 数据操作与任务调度"></a>6.2 数据操作与任务调度</h4><p>操作数据表非常简单，SSM 增删改查。 但是在修改了表的数据之后，怎么让调度器知道呢?</p><p>调度器的接口：Scheduler 在我们的需求中，我们需要做的事情:</p><p>1、 新增一个任务<br> 2、 删除一个任务<br> 3、 启动、停止一个任务<br> 4、 修改任务的信息(包括调度规律)</p><p>因此可以把相关的操作封装到一个工具类中。 <a href>代码</a></p><h4 id="6-3-容器启动与Service注入"><a href="#6-3-容器启动与Service注入" class="headerlink" title="6.3 容器启动与Service注入"></a>6.3 容器启动与Service注入</h4><h5 id="6-3-1-容器启动"><a href="#6-3-1-容器启动" class="headerlink" title="6.3.1 容器启动"></a>6.3.1 容器启动</h5><p>因为任务没有定义在 ApplicationContext.xml 中，而是放到了数据库中，Spring Boot 启动时，怎么读取任务信息?</p><p>或者，怎么在 Spring 启动完成的时候做一些事情? </p><p>创建一个类，实现 CommandLineRunner 接口，实现 run 方法。 </p><p>从表中查出状态是 1 的任务，然后构建。</p><h5 id="6-3-2-Service-类注入到-Job-中"><a href="#6-3-2-Service-类注入到-Job-中" class="headerlink" title="6.3.2 Service 类注入到 Job 中"></a>6.3.2 Service 类注入到 Job 中</h5><p>Spring的 Bean 如何注入到实现了 Job 接口的类中?</p><p>例如在 SendMailTask 中，需要注入 ISysJobService，查询数据库发送邮件。 如果没有任何配置，注入会报空指针异常。</p><p>原因:</p><p>因为定时任务 Job 对象的实例化过程是在 Quartz 中进行的，而 Service Bean 是由Spring 容器管理的，Quartz 察觉不到 Service Bean 的存在，所以无法将 Service Bean 装配到 Job 对象中。</p><p>分析:</p><p>Quartz 集成到 Spring 中，用到 SchedulerFactoryBean，其实现了 InitializingBean 方法，在唯一的方法 afterPropertiesSet()在 Bean 的属性初始化后调用。</p><p>调度器用 AdaptableJobFactory 对 Job 对象进行实例化。所以，如果我们可以把这 个 JobFactory 指定为我们自定义的工厂的话，就可以在 Job 实例化完成之后，把 Job 纳入到 Spring 容器中管理。</p><p>解决这个问题的步骤:</p><p>1、定义一个 AdaptableJobFactory，实现 JobFactory 接口，实现接口定义的newJob 方法，在这里面返回 Job 实例</p><p>2、定义一个 MyJobFactory，继承 AdaptableJobFactory。使用 Spring 的 AutowireCapableBeanFactory，把 Job 实例注入到容器中。</p><p>3、指定 Scheduler 的 JobFactory 为自定义的 JobFactory。</p><h3 id="7、集群部署"><a href="#7、集群部署" class="headerlink" title="7、集群部署"></a>7、集群部署</h3><p><strong>为什么需要集群?</strong></p><p>1、防止单点故障，减少对业务的影响</p><p>2、减少节点的压力，例如在 10 点要触发 1000 个任务，如果有 10 个节点，则每个 节点之需要执行 100 个任务</p><p><strong>集群需要解决的问题?</strong></p><p>1、任务重跑，因为节点部署的内容是一样的，到 10 点的时候，每个节点都会执行 相同的操作，引起数据混乱。比如跑批，绝对不能执行多次。</p><p>2、任务漏跑，假如任务是平均分配的，本来应该在某个节点上执行的任务，因为节 点故障，一直没有得到执行。</p><p>3、水平集群需要注意时间同步问题</p><p>4、Quartz 使用的是随机的负载均衡算法，不能指定节点执行</p><p><strong>如何解决？</strong></p><p>所以必须要有一种共享数据或者通信的机制。在分布式系统的不同节点中，我们可 以采用什么样的方式，实现数据共享?</p><p>两两通信，或者基于分布式的服务，实现数据共享。</p><p>例如:ZK、Redis、DB。</p><p>在 Quartz 中，提供了一种简单的方式，基于数据库共享任务执行信息。也就是说，一个节点执行任务的时候，会操作数据库，其他的节点查询数据库，便可以感知到了。 </p><p>同样的问题:建什么表?哪些字段?</p><p>依旧使用quartz系统自带的 11 张表。</p><p><strong>集群配置与验证</strong></p><p>quartz.properties 配置</p><p>四个配置:集群实例 ID、集群开关、数据库持久化、数据源信息</p><p>注意先清空 quartz 所有表、改端口、两个任务频率改成一样 </p><p>验证 1:先后启动 2 个节点，任务是否重跑</p><p>验证 2:停掉一个节点，任务是否漏跑</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文章目标：&lt;/p&gt;
&lt;p&gt;1、了解任务调度的应用场景和 Quartz 的基本特性 &lt;/p&gt;
&lt;p&gt;2、掌握 Quartz Java 编程和 Spring 集成的使用&lt;/p&gt;
&lt;p&gt;3、掌握 Quartz 动态调度和集群部署的实现&lt;/p&gt;
&lt;h3 id=&quot;1、任务调度场景&quot;&gt;
      
    
    </summary>
    
      <category term="分布式架构技术" scheme="http://yoursite.com/child/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="quartz" scheme="http://yoursite.com/child/tags/quartz/"/>
    
  </entry>
  
  <entry>
    <title>netty源码分析之executionMask</title>
    <link href="http://yoursite.com/child/2020/09/08/nio-netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BexecutionMask/"/>
    <id>http://yoursite.com/child/2020/09/08/nio-netty源码分析之executionMask/</id>
    <published>2020-09-07T16:00:00.000Z</published>
    <updated>2020-09-08T03:12:42.670Z</updated>
    
    <content type="html"><![CDATA[<p>老版本的netty，<code>AbstractChannelHandlerContext</code> 有两个bool属性<code>InBound</code> 和outBound，<code>InBound=true</code>表示该节点是inBound，<code>outBound=true</code>表示该节点是outBound，当然也可能同时为true。在我阅读的源代码版本（4.1.50）中已经删除了这两个属性，取而代之的是属性<strong><em>executionMask</em></strong>，通过使用该属性可以在事件传播时，快速的判断出该节点中的Handler在inBound方向和outBound方向有没有重载某事件处理逻辑。</p><p>之前分析过Pipeline的源码，在向Pipeline添加节点的时候，会创建<code>DefaultChannelHandlerContext</code>对象，调用其父类构造函数时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> io.netty.channel.ChannelHandlerMask.mask;</span><br><span class="line"></span><br><span class="line">AbstractChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor,</span><br><span class="line">                              String name, Class&lt;? extends ChannelHandler&gt; handlerClass) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = ObjectUtil.checkNotNull(name, <span class="string">"name"</span>);</span><br><span class="line">    <span class="keyword">this</span>.pipeline = pipeline;</span><br><span class="line">    <span class="keyword">this</span>.executor = executor; <span class="comment">// null</span></span><br><span class="line">    <span class="keyword">this</span>.executionMask = mask(handlerClass); <span class="comment">// 生成一个掩码 可以快读判断这个Handler重载了哪些方法</span></span><br><span class="line">    <span class="comment">// Its ordered if its driven by the EventLoop or the given Executor is an instanceof OrderedEventExecutor.</span></span><br><span class="line">    ordered = executor == <span class="keyword">null</span> || executor <span class="keyword">instanceof</span> OrderedEventExecutor; <span class="comment">// ture</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会用mask方法给其成员executionMask赋值，mask是<code>ChannelHandlerMask</code>类的静态方法，本文主要分析这类的源码，该类的源码并不复杂，之所以要拿出来分析，完全是因为这种设计思想还是值得借鉴的。</p><p>首先看这个类定义了许多的int型静态变量，作为标记，每一个事件处理方法对应了17位中的一位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASK_EXCEPTION_CAUGHT = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASK_CHANNEL_REGISTERED = <span class="number">1</span> &lt;&lt; <span class="number">1</span>; <span class="comment">//2  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASK_CHANNEL_UNREGISTERED = <span class="number">1</span> &lt;&lt; <span class="number">2</span>; <span class="comment">//4</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASK_CHANNEL_ACTIVE = <span class="number">1</span> &lt;&lt; <span class="number">3</span>; <span class="comment">//8</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASK_CHANNEL_INACTIVE = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">//16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASK_CHANNEL_READ = <span class="number">1</span> &lt;&lt; <span class="number">5</span>; <span class="comment">//32</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASK_CHANNEL_READ_COMPLETE = <span class="number">1</span> &lt;&lt; <span class="number">6</span>; <span class="comment">//64</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASK_USER_EVENT_TRIGGERED = <span class="number">1</span> &lt;&lt; <span class="number">7</span>; <span class="comment">//128</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASK_CHANNEL_WRITABILITY_CHANGED = <span class="number">1</span> &lt;&lt; <span class="number">8</span>; <span class="comment">//256</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASK_BIND = <span class="number">1</span> &lt;&lt; <span class="number">9</span>; <span class="comment">//512</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASK_CONNECT = <span class="number">1</span> &lt;&lt; <span class="number">10</span>; <span class="comment">//1024</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASK_DISCONNECT = <span class="number">1</span> &lt;&lt; <span class="number">11</span>; <span class="comment">//2048</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASK_CLOSE = <span class="number">1</span> &lt;&lt; <span class="number">12</span>; <span class="comment">//4096</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASK_DEREGISTER = <span class="number">1</span> &lt;&lt; <span class="number">13</span>; <span class="comment">//8192</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASK_READ = <span class="number">1</span> &lt;&lt; <span class="number">14</span>; <span class="comment">//16384</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASK_WRITE = <span class="number">1</span> &lt;&lt; <span class="number">15</span>; <span class="comment">//32768</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASK_FLUSH = <span class="number">1</span> &lt;&lt; <span class="number">16</span>; <span class="comment">//65536</span></span><br></pre></td></tr></table></figure><p>根据以上的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASK_ONLY_INBOUND =  MASK_CHANNEL_REGISTERED |</span><br><span class="line">        MASK_CHANNEL_UNREGISTERED | MASK_CHANNEL_ACTIVE | MASK_CHANNEL_INACTIVE | MASK_CHANNEL_READ |</span><br><span class="line">        MASK_CHANNEL_READ_COMPLETE | MASK_USER_EVENT_TRIGGERED | MASK_CHANNEL_WRITABILITY_CHANGED;</span><br></pre></td></tr></table></figure><p>计算出纯纯的In事件方法掩码为<strong>510</strong>（1 1111 1110）</p><p>加上异常处理方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASK_ALL_INBOUND = MASK_EXCEPTION_CAUGHT | MASK_ONLY_INBOUND;</span><br></pre></td></tr></table></figure><p>所有的In事件方法掩码为<strong>511</strong> （1 1111 1111）</p><p>同理计算纯纯的out事件方法掩码为：<strong>130559</strong> （1 1111 1111 0000 0000）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASK_ONLY_OUTBOUND =  MASK_BIND | MASK_CONNECT | MASK_DISCONNECT |</span><br><span class="line">        MASK_CLOSE | MASK_DEREGISTER | MASK_READ | MASK_WRITE | MASK_FLUSH;</span><br></pre></td></tr></table></figure><p>加上异常处理方法为: 130560 (1 1111 1111 0000 0001)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASK_ALL_OUTBOUND = MASK_EXCEPTION_CAUGHT | MASK_ONLY_OUTBOUND;</span><br></pre></td></tr></table></figure><p>重要的线程私有对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> FastThreadLocal&lt;Map&lt;Class&lt;? extends ChannelHandler&gt;, Integer&gt;&gt; MASKS =</span><br><span class="line">        <span class="keyword">new</span> FastThreadLocal&lt;Map&lt;Class&lt;? extends ChannelHandler&gt;, Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> Map&lt;Class&lt;? extends ChannelHandler&gt;, Integer&gt; initialValue() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> WeakHashMap&lt;Class&lt;? extends ChannelHandler&gt;, Integer&gt;(<span class="number">32</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>很显然这个对象是用来存储<code>ChannelHandler</code>和其掩码之间的映射，注意线程私有属性。</p><p>mask方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mask</span><span class="params">(Class&lt;? extends ChannelHandler&gt; clazz)</span> </span>&#123;</span><br><span class="line">    Map&lt;Class&lt;? extends ChannelHandler&gt;, Integer&gt; cache = MASKS.get();</span><br><span class="line">    Integer mask = cache.get(clazz);</span><br><span class="line">    <span class="keyword">if</span> (mask == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mask = mask0(clazz);</span><br><span class="line">        cache.put(clazz, mask);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先尝试从map中获取掩码，求而不得再调用mask0方法计算掩码，存入map并返回</p><p>mask0方法</p><p>假设某Handler实现了两个方法<code>MASK_CHANNEL_ACTIVE</code>  和<code>MASK_CHANNEL_REGISTERED</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mask0</span><span class="params">(Class&lt;? extends ChannelHandler&gt; handlerType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mask = MASK_EXCEPTION_CAUGHT;   <span class="comment">// mask=1</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ChannelInboundHandler.class.isAssignableFrom(handlerType)) &#123;</span><br><span class="line">            mask |= MASK_ALL_INBOUND;   <span class="comment">//mask= 0 0000 0001 | 1 1111 1111 = 1 1111 1111</span></span><br><span class="line">            <span class="comment">// isSkippable的逻辑就是 如果我在Handler中重写了channelRegistered方法 则返回false</span></span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"channelRegistered"</span>, ChannelHandlerContext.class)) &#123;       </span><br><span class="line">              <span class="comment">// 由于重载了channelRegistered，这里不执行 后面同理</span></span><br><span class="line">                mask &amp;= ~MASK_CHANNEL_REGISTERED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"channelUnregistered"</span>, ChannelHandlerContext.class)) &#123;               </span><br><span class="line">              <span class="comment">// mask = 1 1111 1111 &amp; 1 1111 1011 = 1 1111 1011</span></span><br><span class="line">                mask &amp;= ~MASK_CHANNEL_UNREGISTERED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"channelActive"</span>, ChannelHandlerContext.class)) &#123;、</span><br><span class="line">              <span class="comment">// 跳过</span></span><br><span class="line">                mask &amp;= ~MASK_CHANNEL_ACTIVE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"channelInactive"</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">              <span class="comment">// mask = 1 1111 1011 &amp; 1 1110 1111 = 1 1110 1011</span></span><br><span class="line">                mask &amp;= ~MASK_CHANNEL_INACTIVE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"channelRead"</span>, ChannelHandlerContext.class, Object.class)) &#123;</span><br><span class="line">              <span class="comment">// mask = 1 1110 1011 &amp; 1 1101 1111 = 1 1100 1011</span></span><br><span class="line">                mask &amp;= ~MASK_CHANNEL_READ; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"channelReadComplete"</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">              <span class="comment">// mask = 1 1100 1011 &amp; 1 1011 1111 = 1 1000 1011</span></span><br><span class="line">                mask &amp;= ~MASK_CHANNEL_READ_COMPLETE; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"channelWritabilityChanged"</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">              <span class="comment">// mask = 1 1000 1011 &amp; 1 0111 1111 = 1 0000 1011</span></span><br><span class="line">                mask &amp;= ~MASK_CHANNEL_WRITABILITY_CHANGED; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"userEventTriggered"</span>, ChannelHandlerContext.class, Object.class)) &#123;</span><br><span class="line">              <span class="comment">// mask = 1 0000 1011 &amp; 0 1111 1111 = 0 0000 1011</span></span><br><span class="line">                mask &amp;= ~MASK_USER_EVENT_TRIGGERED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最终得到的 mask 是重写的所有方法对应位为1的一个int值</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ChannelOutboundHandler.class.isAssignableFrom(handlerType)) &#123;</span><br><span class="line">            mask |= MASK_ALL_OUTBOUND;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"bind"</span>, ChannelHandlerContext.class,</span><br><span class="line">                    SocketAddress.class, ChannelPromise.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_BIND;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"connect"</span>, ChannelHandlerContext.class, SocketAddress.class,</span><br><span class="line">                    SocketAddress.class, ChannelPromise.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_CONNECT;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"disconnect"</span>, ChannelHandlerContext.class, ChannelPromise.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_DISCONNECT;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"close"</span>, ChannelHandlerContext.class, ChannelPromise.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_CLOSE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"deregister"</span>, ChannelHandlerContext.class, ChannelPromise.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_DEREGISTER;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"read"</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_READ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"write"</span>, ChannelHandlerContext.class,</span><br><span class="line">                    Object.class, ChannelPromise.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_WRITE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"flush"</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_FLUSH;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">"exceptionCaught"</span>, ChannelHandlerContext.class, Throwable.class)) &#123;</span><br><span class="line">            mask &amp;= ~MASK_EXCEPTION_CAUGHT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// Should never reach here.</span></span><br><span class="line">        PlatformDependent.throwException(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在pipeline节点中，有两个方法，用于查找重载了指定方法的下一个或前一个节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextInbound</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</span><br><span class="line">    EventExecutor currentExecutor = executor();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ctx = ctx.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (skipContext(ctx, currentExecutor, mask, MASK_ONLY_INBOUND));</span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mask 是需要匹配的方法的mask</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextOutbound</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</span><br><span class="line">    EventExecutor currentExecutor = executor();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ctx = ctx.prev;</span><br><span class="line">    &#125; <span class="keyword">while</span> (skipContext(ctx, currentExecutor, mask, MASK_ONLY_OUTBOUND));</span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入的参数mask是指定方法的掩码，例如<code>ChannelHandlerMask.MASK_CHANNEL_ACTIVE</code></p><p>重要的逻辑还是在<code>skipContext()</code>方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">skipContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        AbstractChannelHandlerContext ctx, EventExecutor currentExecutor, <span class="keyword">int</span> mask, <span class="keyword">int</span> onlyMask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ctx.executionMask &amp; (onlyMask | mask)) == <span class="number">0</span> ||</span><br><span class="line">            (ctx.executor() == currentExecutor &amp;&amp; (ctx.executionMask &amp; mask) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mask = 0 0000 1000</p><p>onlyMask = 1 1111 1110</p><p> mask | onlyMask = 1 1111 1110</p><p>此处假设handler重载了channelActive方法</p><p>executionMask = 0 0000 1011 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0000 1011  &amp;  </span><br><span class="line">1 1111 1110  =  </span><br><span class="line">0 0000 1010</span><br></pre></td></tr></table></figure><p>第一个判断0 0000 1010   == 0 为 false</p><p>第二次判断主要看后面</p><p>executionMask &amp; mask</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0000 1011 &amp;</span><br><span class="line">0 0000 1000 = </span><br><span class="line">0 0000 1000</span><br></pre></td></tr></table></figure><p>0 0000 1000 == 0 也为 false</p><p>此时skipContext方法可以返回 false</p><p>findContextInbound结束循环。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;老版本的netty，&lt;code&gt;AbstractChannelHandlerContext&lt;/code&gt; 有两个bool属性&lt;code&gt;InBound&lt;/code&gt; 和outBound，&lt;code&gt;InBound=true&lt;/code&gt;表示该节点是inBound，&lt;code
      
    
    </summary>
    
      <category term="I/O和网络编程" scheme="http://yoursite.com/child/categories/I-O%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="netty" scheme="http://yoursite.com/child/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>Nacos(三)心跳与服务更新</title>
    <link href="http://yoursite.com/child/2020/08/22/Nacos(3)%E5%BF%83%E8%B7%B3%E4%B8%8E%E6%9C%8D%E5%8A%A1%E6%9B%B4%E6%96%B0/"/>
    <id>http://yoursite.com/child/2020/08/22/Nacos(3)心跳与服务更新/</id>
    <published>2020-08-21T16:00:00.000Z</published>
    <updated>2021-01-13T05:53:13.225Z</updated>
    
    <content type="html"><![CDATA[<p>nacos通过pull+push结合的方式，来保证服务状态的更新，大致流程如下图所示</p><p><img src="/Users/zhaozhengkang/Desktop/截屏2021-01-13 10.30.52.png" alt></p><ul><li><p>消费者应用启动时，会开启一个UpdateTask，每隔10s会向nacos-server发送一个pull请求，拉取最新的服务实例信息</p></li><li><p>服务提供者，注册时与nacos-server建立了心跳检查，默认是5s发送一次心跳，nacos-server会开启一个心跳检查任务，不停的检查服务心跳，超过15秒没有收到心跳，则将对应实例设置为非健康状态，超过30秒还没有收到心跳，做下线处理，删除实例。</p></li></ul><p>下面，分别对以上两个流程进行源码分析</p><h3 id="1-pull请求更新"><a href="#1-pull请求更新" class="headerlink" title="1 pull请求更新"></a>1 pull请求更新</h3><p>在上一篇笔记《Nacos(二)注册中心核心源码分析》中，讲到<code>HostReactor.getServiceInfo()</code>方法，在获取到nacos-server的服务实例信息之后，通过一套事件发送响应机制，将实例信息注入到Spring-Boot中，那么在首次获取到实例信息之后，考虑到服务端的实例信息可能会发生改变，所以要建立一个任务，定时的pull服务端信息。</p><p><strong>HostReactor.getServiceInfo</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServiceInfo <span class="title">getServiceInfo</span><span class="params">(<span class="keyword">final</span> String serviceName, <span class="keyword">final</span> String clusters)</span> </span>&#123;</span><br><span class="line">    NAMING_LOGGER.debug(<span class="string">"failover-mode: "</span> + failoverReactor.isFailoverSwitch());</span><br><span class="line">    String key = ServiceInfo.getKey(serviceName, clusters);</span><br><span class="line">    <span class="keyword">if</span> (failoverReactor.isFailoverSwitch()) &#123;</span><br><span class="line">        <span class="keyword">return</span> failoverReactor.getService(key);</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">//从本地缓存中取</span></span><br><span class="line">    ServiceInfo serviceObj = getServiceInfo0(serviceName, clusters);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == serviceObj) &#123;<span class="comment">// 本地没有，两步走</span></span><br><span class="line">        <span class="comment">// 1、创建一个空的ServiceInfo放入缓存</span></span><br><span class="line">        serviceObj = <span class="keyword">new</span> ServiceInfo(serviceName, clusters);</span><br><span class="line">        serviceInfoMap.put(serviceObj.getKey(), serviceObj);</span><br><span class="line">          <span class="comment">// 2、将远程服务信息更新到ServiceInfo中，updatingMap看来只是其到标记作用的</span></span><br><span class="line">        updatingMap.put(serviceName, <span class="keyword">new</span> Object());</span><br><span class="line">        <span class="comment">// &gt;&gt; 关键点</span></span><br><span class="line">        updateServiceNow(serviceName, clusters); </span><br><span class="line">        updatingMap.remove(serviceName); <span class="comment">//更新完毕删除标记</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (updatingMap.containsKey(serviceName)) &#123;</span><br><span class="line">        ... <span class="comment">// 若有其他线程已经创建了标记说明其他线程正在更新，同步等待</span></span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 开启定时更新任务</span></span><br><span class="line">    scheduleUpdateIfAbsent(serviceName, clusters);</span><br><span class="line">    <span class="keyword">return</span> serviceInfoMap.get(serviceObj.getKey());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码已经分析过了，直接看到倒数第二行：</p><p><strong>scheduleUpdateIfAbsent(serviceName, clusters)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleUpdateIfAbsent</span><span class="params">(String serviceName, String clusters)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (futureMap.get(ServiceInfo.getKey(serviceName, clusters)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (futureMap) &#123;</span><br><span class="line">        <span class="keyword">if</span> (futureMap.get(ServiceInfo.getKey(serviceName, clusters)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ScheduledFuture&lt;?&gt; future = addTask(<span class="keyword">new</span> UpdateTask(serviceName, clusters));</span><br><span class="line">        futureMap.put(ServiceInfo.getKey(serviceName, clusters), future);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>futureMap</code>是存放serviceName与定时更新任务异步结果Future映射关系的地方，<code>futureMap</code>中要是存在serviceName对应的Future说明定时任务已经开启了，直接返回，这里做了双重校验。</p><p>调用<code>addTask</code>添加一个UpdateTask给定时任务执行，看主要看UpdateTask的run函数做了些什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 从本地缓存获取ServiceInfo</span></span><br><span class="line">        ServiceInfo serviceObj = serviceInfoMap.get(ServiceInfo.getKey(serviceName, clusters));</span><br><span class="line"><span class="comment">// 本地没有，立即执行更新</span></span><br><span class="line">        <span class="keyword">if</span> (serviceObj == <span class="keyword">null</span>) &#123;</span><br><span class="line">            updateServiceNow(serviceName, clusters);</span><br><span class="line">            <span class="comment">// DEFAULT_DELAY = 1000L ，1s后再次执行这个任务</span></span><br><span class="line">            executor.schedule(<span class="keyword">this</span>, DEFAULT_DELAY, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 本地有但是过期了，立即更新 lastRefTime默认值是MaxValue</span></span><br><span class="line">        <span class="keyword">if</span> (serviceObj.getLastRefTime() &lt;= lastRefTime) &#123;</span><br><span class="line">            updateServiceNow(serviceName, clusters);</span><br><span class="line">            serviceObj = serviceInfoMap.get(ServiceInfo.getKey(serviceName, clusters));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// if serviceName already updated by push, we should not override it</span></span><br><span class="line">            <span class="comment">// since the push data may be different from pull through force push</span></span><br><span class="line">          <span class="comment">// 如果服务被基于push机制的流程做了更新，那么我们不需要覆盖本地服务</span></span><br><span class="line">          <span class="comment">// 因为push过来的数据和pull来的数据不同，所以这里只是调用接口刷新服务</span></span><br><span class="line">            refreshOnly(serviceName, clusters);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 最后刷新时间</span></span><br><span class="line">        lastRefTime = serviceObj.getLastRefTime();</span><br><span class="line"><span class="comment">// 如果没有完成订阅或者futureMap中不包含指定服务信息，则中断更新</span></span><br><span class="line">        <span class="keyword">if</span> (!eventDispatcher.isSubscribed(serviceName, clusters) &amp;&amp;</span><br><span class="line">            !futureMap.containsKey(ServiceInfo.getKey(serviceName, clusters))) &#123;</span><br><span class="line">            <span class="comment">// abort the update task:</span></span><br><span class="line">            NAMING_LOGGER.info(<span class="string">"update task is stopped, service:"</span> + serviceName + <span class="string">", clusters:"</span> + clusters);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 10s后再次执行本任务</span></span><br><span class="line">        executor.schedule(<span class="keyword">this</span>, serviceObj.getCacheMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        NAMING_LOGGER.warn(<span class="string">"[NA] failed to update serviceName: "</span> + serviceName, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下两个更新接口</p><p><strong>updateServiceNow</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateServiceNow</span><span class="params">(String serviceName, String clusters)</span> </span>&#123;</span><br><span class="line">    ServiceInfo oldService = getServiceInfo0(serviceName, clusters);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 发送http请求获取实例信息列表</span></span><br><span class="line">        String result = serverProxy.queryList(serviceName, clusters, pushReceiver.getUDPPort(), <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(result)) &#123;</span><br><span class="line">            processServiceJSON(result); <span class="comment">// 处理结果，更新本地缓存</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        NAMING_LOGGER.error(<span class="string">"[NA] failed to update serviceName: "</span> + serviceName, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldService != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (oldService) &#123;</span><br><span class="line">                oldService.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>refreshOnly</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refreshOnly</span><span class="params">(String serviceName, String clusters)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        serverProxy.queryList(serviceName, clusters, pushReceiver.getUDPPort(), <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        NAMING_LOGGER.error(<span class="string">"[NA] failed to update serviceName: "</span> + serviceName, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>refreshOnly</code>并没有处理结果，那么这里好像唯一的作用，就是将pushReceiver.getUDPPort()传给了server</p><p>因为nacos-server不会永久存储消费者的udp信息，后面的分析会详细介绍。</p><h3 id="2-push推送更新"><a href="#2-push推送更新" class="headerlink" title="2. push推送更新"></a>2. push推送更新</h3><p>还记得上一篇笔记《Nacos(二)注册中心核心源码分析》分析过，在服务提供者发起服务注册时，nacos-server收到注册请求，处理请求时，会调用createEmptyService方法来创建一个空的服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerInstance</span><span class="params">(String namespaceId, String serviceName, Instance instance)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">    <span class="comment">// &gt;&gt;</span></span><br><span class="line">    createEmptyService(namespaceId, serviceName, instance.isEphemeral());</span><br><span class="line">    Service service = getService(namespaceId, serviceName);</span><br><span class="line">    <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NacosException(NacosException.INVALID_PARAM,</span><br><span class="line">                <span class="string">"service not found, namespace: "</span> + namespaceId + <span class="string">", service: "</span> + serviceName);</span><br><span class="line">    &#125;    </span><br><span class="line">    addInstance(namespaceId, serviceName, instance.isEphemeral(), instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createEmptyService方法最终会调用到<code>service.init()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 开启心跳检查任务</span></span><br><span class="line">    HealthCheckReactor.scheduleCheck(clientBeatCheckTask);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Cluster&gt; entry : clusterMap.entrySet()) &#123;</span><br><span class="line">        entry.getValue().setService(<span class="keyword">this</span>);</span><br><span class="line">        entry.getValue().init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面就来看一下这个健康检查任务时怎么执行的.</p><p><strong>lientBeatCheckTask.run</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        List&lt;Instance&gt; instances = service.allIPs(<span class="keyword">true</span>);   </span><br><span class="line">        <span class="comment">// first set health status of instances:</span></span><br><span class="line">        <span class="keyword">for</span> (Instance instance : instances) &#123; <span class="comment">// 遍历服务节点心跳检测</span></span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() - instance.getLastBeat() &gt; instance.getInstanceHeartBeatTimeOut()) &#123; <span class="comment">// getInstanceHeartBeatTimeOut 默认15秒</span></span><br><span class="line">                <span class="keyword">if</span> (!instance.isMarked()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (instance.isHealthy()) &#123;</span><br><span class="line">                        instance.setHealthy(<span class="keyword">false</span>);</span><br><span class="line">                        ..<span class="comment">//log</span></span><br><span class="line">                        getPushService().serviceChanged(service); <span class="comment">// 推送服务变更事件</span></span><br><span class="line">                        ApplicationUtils.publishEvent(<span class="keyword">new</span> InstanceHeartbeatTimeoutEvent(<span class="keyword">this</span>, instance));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!getGlobalConfig().isExpireInstance()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// then remove obsolete instances:</span></span><br><span class="line">        <span class="keyword">for</span> (Instance instance : instances) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance.isMarked()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() - instance.getLastBeat() &gt; instance.getIpDeleteTimeout()) &#123;  <span class="comment">// getIpDeleteTimeout 默认30s</span></span><br><span class="line">                <span class="comment">// delete instance</span></span><br><span class="line">                ...<span class="comment">//log</span></span><br><span class="line">                deleteIp(instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125; </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>getPushService().serviceChanged(service)</strong></p><p>监听服务状态变更事件，然后遍历所有的客户端，通过udp协议进行消息的广播通知</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceChanged</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// merge some change events to reduce the push frequency:</span></span><br><span class="line">    <span class="keyword">if</span> (futureMap</span><br><span class="line">            .containsKey(UtilsAndCommons.assembleFullServiceName(service.getNamespaceId(), service.getName()))) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.applicationContext.publishEvent(<span class="keyword">new</span> ServiceChangeEvent(<span class="keyword">this</span>, service));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发出了<code>ServiceChangeEvent</code>事件，该事件时Spring事件</p><p><code>PushService</code>既是事件发送方，也是事件监听方，所以定位到响应函数</p><p><code>clientMap</code>  nacos-client在调用queryList时，会传一个udp端口号给nacos-server，nacos-server会创建一个udp连接连接到nacos-client，存放在<code>clientMap</code>  中</p><p><code>clientMap</code>  是一个两层的map结构</p><p>第一层的key是：namespaceId##serviceName，将不同的namespace分开</p><p>第二层的key是：serviceName:xxx,clusters:xxx,address:xxx,agent:xxx，通过address能够定位到一个服务消费者的ip地址，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ServiceChangeEvent event)</span> </span>&#123;</span><br><span class="line">    Service service = event.getService();</span><br><span class="line">    String serviceName = service.getName();</span><br><span class="line">    String namespaceId = service.getNamespaceId();</span><br><span class="line">    </span><br><span class="line">    Future future = GlobalExecutor.scheduleUdpSender(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Loggers.PUSH.info(serviceName + <span class="string">" is changed, add it to push queue."</span>);</span><br><span class="line">          <span class="comment">//拿到服务对应的PushClient  key 是namespaceId##serviceName</span></span><br><span class="line">            ConcurrentMap&lt;String, PushClient&gt; clients = clientMap</span><br><span class="line">                    .get(UtilsAndCommons.assembleFullServiceName(namespaceId, serviceName));</span><br><span class="line">            <span class="keyword">if</span> (MapUtils.isEmpty(clients)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            Map&lt;String, Object&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">            <span class="keyword">long</span> lastRefTime = System.nanoTime();</span><br><span class="line">            <span class="keyword">for</span> (PushClient client : clients.values()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (client.zombie()) &#123; <span class="comment">// 距离上次推送超过10秒</span></span><br><span class="line">                    Loggers.PUSH.debug(<span class="string">"client is zombie: "</span> + client.toString());</span><br><span class="line">                    clients.remove(client.toString()); <span class="comment">//移除client</span></span><br><span class="line">                    Loggers.PUSH.debug(<span class="string">"client is zombie: "</span> + client.toString());</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                Receiver.AckEntry ackEntry;</span><br><span class="line">                Loggers.PUSH.debug(<span class="string">"push serviceName: &#123;&#125; to client: &#123;&#125;"</span>, serviceName, client.toString());</span><br><span class="line">                String key = getPushCacheKey(serviceName, client.getIp(), client.getAgent());</span><br><span class="line">                <span class="keyword">byte</span>[] compressData = <span class="keyword">null</span>;</span><br><span class="line">                Map&lt;String, Object&gt; data = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (switchDomain.getDefaultPushCacheMillis() &gt;= <span class="number">20000</span> &amp;&amp; cache.containsKey(key)) &#123;</span><br><span class="line">                    org.javatuples.Pair pair = (org.javatuples.Pair) cache.get(key);</span><br><span class="line">                    compressData = (<span class="keyword">byte</span>[]) (pair.getValue0());</span><br><span class="line">                    data = (Map&lt;String, Object&gt;) pair.getValue1();</span><br><span class="line">                    </span><br><span class="line">                    Loggers.PUSH.debug(<span class="string">"[PUSH-CACHE] cache hit: &#123;&#125;:&#123;&#125;"</span>, serviceName, client.getAddrStr());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 收到nacos-client的响应数据，</span></span><br><span class="line">                <span class="keyword">if</span> (compressData != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ackEntry = prepareAckEntry(client, compressData, data, lastRefTime);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ackEntry = prepareAckEntry(client, prepareHostsData(client), lastRefTime);</span><br><span class="line">                    <span class="keyword">if</span> (ackEntry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        cache.put(key, <span class="keyword">new</span> org.javatuples.Pair&lt;&gt;(ackEntry.origin.getData(), ackEntry.data));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                Loggers.PUSH.info(<span class="string">"serviceName: &#123;&#125; changed, schedule push for: &#123;&#125;, agent: &#123;&#125;, key: &#123;&#125;"</span>,</span><br><span class="line">                        client.getServiceName(), client.getAddrStr(), client.getAgent(),</span><br><span class="line">                        (ackEntry == <span class="keyword">null</span> ? <span class="keyword">null</span> : ackEntry.key));</span><br><span class="line">                </span><br><span class="line">                udpPush(ackEntry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Loggers.PUSH.error(<span class="string">"[NACOS-PUSH] failed to push serviceName: &#123;&#125; to client, error: &#123;&#125;"</span>, serviceName, e);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            futureMap.remove(UtilsAndCommons.assembleFullServiceName(namespaceId, serviceName));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    </span><br><span class="line">    futureMap.put(UtilsAndCommons.assembleFullServiceName(namespaceId, serviceName), future);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以了解到</p><p>nacos-server端保存的消费者udp连接，并不是一直存储的，当超过一定时间（10秒）没有更新（client请求queryList的时候会创建一个udp连接放到clientsMap中），就会被移除。</p><p>因此，面pull更新的时候，有一个refreshOnly接口，就是专门用于刷新server端的udp。</p><p>那么，server端push了数据之后，client端又是怎么处理的呢？</p><p>在Client端构造HostReactor的时候：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HostReactor</span><span class="params">(EventDispatcher eventDispatcher, NamingProxy serverProxy, String cacheDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> loadCacheAtStart, <span class="keyword">int</span> pollingThreadCount)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    executor = <span class="keyword">new</span> ScheduledThreadPoolExecutor(pollingThreadCount, <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(r);</span><br><span class="line">            thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            thread.setName(<span class="string">"com.alibaba.nacos.client.naming.updater"</span>);</span><br><span class="line">            <span class="keyword">return</span> thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.eventDispatcher = eventDispatcher;</span><br><span class="line">    <span class="keyword">this</span>.serverProxy = serverProxy;</span><br><span class="line">    <span class="keyword">this</span>.cacheDir = cacheDir;</span><br><span class="line">    <span class="keyword">if</span> (loadCacheAtStart) &#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceInfoMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ServiceInfo&gt;(DiskCache.read(<span class="keyword">this</span>.cacheDir));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceInfoMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ServiceInfo&gt;(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.updatingMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;();</span><br><span class="line">    <span class="keyword">this</span>.failoverReactor = <span class="keyword">new</span> FailoverReactor(<span class="keyword">this</span>, cacheDir);</span><br><span class="line">    <span class="keyword">this</span>.pushReceiver = <span class="keyword">new</span> PushReceiver(<span class="keyword">this</span>); <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到最后一行，创建了一个<code>PushReceiver</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PushReceiver</span><span class="params">(HostReactor hostReactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.hostReactor = hostReactor;</span><br><span class="line">        udpSocket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"><span class="comment">//创建了一个</span></span><br><span class="line">        executorService = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>, <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                Thread thread = <span class="keyword">new</span> Thread(r);</span><br><span class="line">                thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">                thread.setName(<span class="string">"com.alibaba.nacos.naming.push.receiver"</span>);</span><br><span class="line">                <span class="keyword">return</span> thread;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        executorService.execute(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        NAMING_LOGGER.error(<span class="string">"[NA] init udp socket failed"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PushReceiver中开启了一个线程池，任务逻辑就是PushReceiver的run函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// byte[] is initialized with 0 full filled by default</span></span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[UDP_MSS];</span><br><span class="line">            DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buffer, buffer.length);</span><br><span class="line"></span><br><span class="line">            udpSocket.receive(packet);</span><br><span class="line"></span><br><span class="line">            String json = <span class="keyword">new</span> String(IoUtils.tryDecompress(packet.getData()), <span class="string">"UTF-8"</span>).trim();</span><br><span class="line">            NAMING_LOGGER.info(<span class="string">"received push data: "</span> + json + <span class="string">" from "</span> + packet.getAddress().toString());</span><br><span class="line"></span><br><span class="line">            PushPacket pushPacket = JSON.parseObject(json, PushPacket.class);</span><br><span class="line">            String ack;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"dom"</span>.equals(pushPacket.type) || <span class="string">"service"</span>.equals(pushPacket.type)) &#123;</span><br><span class="line">                hostReactor.processServiceJSON(pushPacket.data);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// send ack to server</span></span><br><span class="line">                ack = <span class="string">"&#123;\"type\": \"push-ack\""</span></span><br><span class="line">                    + <span class="string">", \"lastRefTime\":\""</span> + pushPacket.lastRefTime</span><br><span class="line">                    + <span class="string">"\", \"data\":"</span> + <span class="string">"\"\"&#125;"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"dump"</span>.equals(pushPacket.type)) &#123;</span><br><span class="line">                <span class="comment">// dump data to server</span></span><br><span class="line">                ack = <span class="string">"&#123;\"type\": \"dump-ack\""</span></span><br><span class="line">                    + <span class="string">", \"lastRefTime\": \""</span> + pushPacket.lastRefTime</span><br><span class="line">                    + <span class="string">"\", \"data\":"</span> + <span class="string">"\""</span></span><br><span class="line">                    + StringUtils.escapeJavaScript(JSON.toJSONString(hostReactor.getServiceInfoMap()))</span><br><span class="line">                    + <span class="string">"\"&#125;"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// do nothing send ack only</span></span><br><span class="line">                ack = <span class="string">"&#123;\"type\": \"unknown-ack\""</span></span><br><span class="line">                    + <span class="string">", \"lastRefTime\":\""</span> + pushPacket.lastRefTime</span><br><span class="line">                    + <span class="string">"\", \"data\":"</span> + <span class="string">"\"\"&#125;"</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            udpSocket.send(<span class="keyword">new</span> DatagramPacket(ack.getBytes(Charset.forName(<span class="string">"UTF-8"</span>)),</span><br><span class="line">                ack.getBytes(Charset.forName(<span class="string">"UTF-8"</span>)).length, packet.getSocketAddress()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            NAMING_LOGGER.error(<span class="string">"[NA] error while receiving push data"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启了一个udp监听，收到DatagramPacket后进行反序列化，解析，通过<code>processServiceJSON()</code>方法进行处理，最后还响应出一个ack。</p><p>大致的流程就分析完了，一些细节部分略过了，有时间会继续跟。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;nacos通过pull+push结合的方式，来保证服务状态的更新，大致流程如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Users/zhaozhengkang/Desktop/截屏2021-01-13 10.30.52.png&quot; alt&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="SpringCloud" scheme="http://yoursite.com/child/categories/SpringCloud/"/>
    
    
      <category term="SpringCloud" scheme="http://yoursite.com/child/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>Nacos(四)集群选举与数据同步</title>
    <link href="http://yoursite.com/child/2020/08/20/Nacos(4)%E9%9B%86%E7%BE%A4%E9%80%89%E4%B8%BE%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/"/>
    <id>http://yoursite.com/child/2020/08/20/Nacos(4)集群选举与数据同步/</id>
    <published>2020-08-19T16:00:00.000Z</published>
    <updated>2021-01-12T07:38:16.489Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="SpringCloud" scheme="http://yoursite.com/child/categories/SpringCloud/"/>
    
    
      <category term="SpringCloud" scheme="http://yoursite.com/child/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>Nacos(二)注册中心核心源码分析</title>
    <link href="http://yoursite.com/child/2020/08/17/Nacos(2)%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/child/2020/08/17/Nacos(2)注册中心核心源码分析/</id>
    <published>2020-08-16T16:00:00.000Z</published>
    <updated>2021-01-13T02:39:29.296Z</updated>
    
    <content type="html"><![CDATA[<p>注册中心需要的核心功能：</p><ol><li>服务提供者将服务信息发布到注册中心，此处涉及到服务信息的数据结构设计及存储</li><li>服务消费者能够从注册中心获取所需服务的实例信息</li><li>注册中心需要感知服务的健康状况，心跳机制</li><li>服务消费者需要动态更新依赖的服务列表信息</li></ol><p>nacos服务信息数据结构设计与存储</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Map(namespace, Map(group::serviceName, Service)).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Map&lt;String, Service&gt;&gt; serviceMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>一个服务Service中，可以包含多个集群</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * map(clustrtName,Cluster)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Cluster&gt; clusterMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>一个集群Cluster中，可以包含多个实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonIgnore</span> <span class="comment">// 持久化节点</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;Instance&gt; persistentInstances = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonIgnore</span>  <span class="comment">//临时节点</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;Instance&gt; ephemeralInstances = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br></pre></td></tr></table></figure><p>一个实例Instance 中存储了该实例的所有信息。</p><h3 id="1-服务提供者注册服务"><a href="#1-服务提供者注册服务" class="headerlink" title="1. 服务提供者注册服务"></a>1. 服务提供者注册服务</h3><h4 id="1-1-时机"><a href="#1-1-时机" class="headerlink" title="1.1 时机"></a>1.1 时机</h4><ul><li>启动时注册，springboot启动时，会执行dubbo服务发布以及注册流程</li><li>启动后注册，此时使用的是事件监听机制，在 DubboServiceRegistrationNonWebApplicationAutoConfiguration 这个类中，会监听<code>ApplicationStartedEvent</code> 事件，这个事件是spring boot在2.0新增的，就是当spring boot应用启动完成之后会发布这个事件。而此时监听到这个事件之后，会触发注册的动作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DubboServiceRegistrationNonWebApplicationAutoConfiguration </span></span><br><span class="line"><span class="meta">@EventListener</span>(ApplicationStartedEvent.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   setServerPort();</span><br><span class="line">   register();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (registered) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   serviceRegistry.register(registration);</span><br><span class="line">   registered = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-流程"><a href="#1-2-流程" class="headerlink" title="1.2 流程"></a>1.2 流程</h4><p><strong>NacosServiceRegistry.register</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NacosServiceRegistry</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Registration registration)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (StringUtils.isEmpty(registration.getServiceId())) &#123;</span><br><span class="line">        log.warn(<span class="string">"No service to register for nacos client..."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   String serviceId = registration.getServiceId(); <span class="comment">//对应当前应用的application.name</span></span><br><span class="line">   String group = nacosDiscoveryProperties.getGroup();<span class="comment">//表示nacos上的分组配置</span></span><br><span class="line">   Instance instance = getNacosInstanceFromRegistration(registration);<span class="comment">//表示服务实例信息</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      namingService.registerInstance(serviceId, group, instance);</span><br><span class="line">      log.info(<span class="string">"nacos registry, &#123;&#125; &#123;&#125; &#123;&#125;:&#123;&#125; register finished"</span>, group, serviceId,</span><br><span class="line">            instance.getIp(), instance.getPort());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      log.error(<span class="string">"nacos registry, &#123;&#125; register failed...&#123;&#125;,"</span>, serviceId,</span><br><span class="line">            registration.toString(), e);</span><br><span class="line">      <span class="comment">// rethrow a RuntimeException if the registration is failed.</span></span><br><span class="line">      <span class="comment">// issue : https://github.com/alibaba/spring-cloud-alibaba/issues/1132</span></span><br><span class="line">      rethrowRuntimeException(e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>NamingService.registerInstance</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerInstance</span><span class="params">(String serviceName, String groupName, Instance instance)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance.isEphemeral()) &#123; <span class="comment">// 若是临时节点，需要构建心跳信息</span></span><br><span class="line">        BeatInfo beatInfo = <span class="keyword">new</span> BeatInfo();</span><br><span class="line">        beatInfo.setServiceName(NamingUtils.getGroupedName(serviceName, groupName));</span><br><span class="line">        beatInfo.setIp(instance.getIp());</span><br><span class="line">        beatInfo.setPort(instance.getPort());</span><br><span class="line">        beatInfo.setCluster(instance.getClusterName());</span><br><span class="line">        beatInfo.setWeight(instance.getWeight());</span><br><span class="line">        beatInfo.setMetadata(instance.getMetadata());</span><br><span class="line">        beatInfo.setScheduled(<span class="keyword">false</span>);</span><br><span class="line">        beatInfo.setPeriod(instance.getInstanceHeartBeatInterval());</span><br><span class="line"><span class="comment">// 添加心跳信息进行处理</span></span><br><span class="line">        beatReactor.addBeatInfo(NamingUtils.getGroupedName(serviceName, groupName), beatInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serverProxy.registerService(NamingUtils.getGroupedName(serviceName, groupName), groupName, instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>心跳是nacos客户端发送给nacos服务器的</p><p>serverProxy是一个NamingProxy类实例，封装了调用nacos server的api</p><p><code>BeatReactor</code> 心跳发送反应堆。</p><p><strong>NamingProxy.registerService</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String serviceName, String groupName, Instance instance)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, String&gt; params = <span class="keyword">new</span> HashMap&lt;String, String&gt;(<span class="number">9</span>);</span><br><span class="line">    params.put(CommonParams.NAMESPACE_ID, namespaceId);</span><br><span class="line">    params.put(CommonParams.SERVICE_NAME, serviceName);</span><br><span class="line">    params.put(CommonParams.GROUP_NAME, groupName);</span><br><span class="line">    params.put(CommonParams.CLUSTER_NAME, instance.getClusterName());</span><br><span class="line">    params.put(<span class="string">"ip"</span>, instance.getIp());</span><br><span class="line">    params.put(<span class="string">"port"</span>, String.valueOf(instance.getPort()));</span><br><span class="line">    params.put(<span class="string">"weight"</span>, String.valueOf(instance.getWeight()));</span><br><span class="line">    params.put(<span class="string">"enable"</span>, String.valueOf(instance.isEnabled()));</span><br><span class="line">    params.put(<span class="string">"healthy"</span>, String.valueOf(instance.isHealthy()));</span><br><span class="line">    params.put(<span class="string">"ephemeral"</span>, String.valueOf(instance.isEphemeral()));</span><br><span class="line">    params.put(<span class="string">"metadata"</span>, JSON.toJSONString(instance.getMetadata()));</span><br><span class="line"><span class="comment">// UtilAndComs.NACOS_URL_SERVICE  = /nacos/v1/ns/instance</span></span><br><span class="line">    reqAPI(UtilAndComs.NACOS_URL_INSTANCE, params, HttpMethod.POST);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册时请求的open api 是/nacos/v1/ns/instance  </p><p>构建的请求参数有：</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/nacos/nacos%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1.png" style="zoom:67%;"></p><p><strong>reqAPI</strong></p><p>reqAPI构建POST请求，发送给nacos-server</p><p>api: nacos server open api </p><p>params: 请求参数</p><p>body:</p><p>method: 请求方法类型 </p><p>servers: nacos server地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NamingProxy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reqAPI</span><span class="params">(String api, Map&lt;String, String&gt; params, String body, List&lt;String&gt; servers, String method)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">    params.put(CommonParams.NAMESPACE_ID, getNamespaceId());</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(servers) &amp;&amp; StringUtils.isEmpty(nacosDomain)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NacosException(NacosException.INVALID_PARAM, <span class="string">"no server available"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    NacosException exception = <span class="keyword">new</span> NacosException();</span><br><span class="line">  <span class="comment">// 如果nacos-server服务地址不为null，可能为列表</span></span><br><span class="line">    <span class="keyword">if</span> (servers != <span class="keyword">null</span> &amp;&amp; !servers.isEmpty()) &#123; </span><br><span class="line">        Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">int</span> index = random.nextInt(servers.size());<span class="comment">//随机获取一个nacos-server节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; servers.size(); i++) &#123;</span><br><span class="line">          <span class="comment">// 确定了server还要用循环处理，为了防止选定的server不靠谱</span></span><br><span class="line">            String server = servers.get(index);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 调用指定server的接口，一旦调用成功表示注册成功，返回</span></span><br><span class="line">                <span class="keyword">return</span> callServer(api, params, body, server, method);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">                exception = e;</span><br><span class="line">                <span class="keyword">if</span> (NAMING_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">                    NAMING_LOGGER.debug(<span class="string">"request &#123;&#125; failed."</span>, server, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            index = (index + <span class="number">1</span>) % servers.size(); <span class="comment">//调用失败则轮询调用其他server</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotBlank(nacosDomain)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; UtilAndComs.REQUEST_DOMAIN_RETRY_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> callServer(api, params, body, nacosDomain, method);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">                exception = e;</span><br><span class="line">                <span class="keyword">if</span> (NAMING_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">                    NAMING_LOGGER.debug(<span class="string">"request &#123;&#125; failed."</span>, nacosDomain, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 失败时 写日志。抛出异常</span></span><br><span class="line">    NAMING_LOGGER.error(<span class="string">"request: &#123;&#125; failed, servers: &#123;&#125;, code: &#123;&#125;, msg: &#123;&#125;"</span>,</span><br><span class="line">        api, servers, exception.getErrCode(), exception.getErrMsg());</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NacosException(exception.getErrCode(), <span class="string">"failed to req API:/api/"</span> + api + <span class="string">" after all servers("</span> + servers + <span class="string">") tried: "</span></span><br><span class="line">        + exception.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>callServer</strong></p><p>该方法用于发起nacos-server的api调用</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/nacos/nacos%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-2.png" style="zoom:67%;"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">callServer</span><span class="params">(String api, Map&lt;String, String&gt; params, String body, String curServer, String method)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> end = <span class="number">0</span>;</span><br><span class="line">    injectSecurityInfo(params); <span class="comment">// 添加签名，防止恶意篡改或者网络丢包</span></span><br><span class="line">    List&lt;String&gt; headers = builderHeaders(); <span class="comment">// 添加头信息</span></span><br><span class="line">    String url;  <span class="comment">// 拼接url</span></span><br><span class="line">    <span class="keyword">if</span> (curServer.startsWith(UtilAndComs.HTTPS) || curServer.startsWith(UtilAndComs.HTTP)) &#123;</span><br><span class="line">        url = curServer + api;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!curServer.contains(UtilAndComs.SERVER_ADDR_IP_SPLITER)) &#123;</span><br><span class="line">            curServer = curServer + UtilAndComs.SERVER_ADDR_IP_SPLITER + serverPort;</span><br><span class="line">        &#125;</span><br><span class="line">        url = HttpClient.getPrefix() + curServer + api;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//使用HttpClient发起请求</span></span><br><span class="line">    HttpClient.HttpResult result = HttpClient.request(url, headers, params, body, UtilAndComs.ENCODING, method);</span><br><span class="line">    end = System.currentTimeMillis();</span><br><span class="line">    MetricsMonitor.getNamingRequestMonitor(method, url, String.valueOf(result.code))</span><br><span class="line">        .observe(end - start); <span class="comment">// 埋点监控</span></span><br><span class="line">    <span class="keyword">if</span> (HttpURLConnection.HTTP_OK == result.code) &#123; <span class="comment">// 成功 返回服务端结果</span></span><br><span class="line">        <span class="keyword">return</span> result.content;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (HttpURLConnection.HTTP_NOT_MODIFIED == result.code) &#123;</span><br><span class="line">        <span class="keyword">return</span> StringUtils.EMPTY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NacosException(result.code, result.content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-nacos-处理注册请求"><a href="#2-nacos-处理注册请求" class="headerlink" title="2. nacos 处理注册请求"></a>2. nacos 处理注册请求</h3><p>处理注册请求的controller在naming子模块中，InstanceController类中的register方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CanDistro</span></span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="meta">@Secured</span>(parser = NamingResourceParser.class, action = ActionTypes.WRITE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">register</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String namespaceId = WebUtils</span><br><span class="line">            .optional(request, CommonParams.NAMESPACE_ID, Constants.DEFAULT_NAMESPACE_ID);</span><br><span class="line">    <span class="keyword">final</span> String serviceName = WebUtils.required(request, CommonParams.SERVICE_NAME);</span><br><span class="line">    NamingUtils.checkServiceNameFormat(serviceName);</span><br><span class="line">    <span class="keyword">final</span> Instance instance = parseInstance(request); <span class="comment">// 从请求中解析出Instance</span></span><br><span class="line">    serviceManager.registerInstance(namespaceId, serviceName, instance); <span class="comment">// 写内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ok"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ServiceManager.registerInstance</strong></p><p>serviceManager中有一map，就是文章开头介绍的用于存储服务实例信息的地方，这个map的名字是<code>serviceMap</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerInstance</span><span class="params">(String namespaceId, String serviceName, Instance instance)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">    <span class="comment">//serviceMap中如果没有该服务，则创建一个空的服务放进去</span></span><br><span class="line">    createEmptyService(namespaceId, serviceName, instance.isEphemeral());</span><br><span class="line">    <span class="comment">//从serviceMap中，根据namespaceId和serviceName得到一个服务对象</span></span><br><span class="line">    Service service = getService(namespaceId, serviceName);</span><br><span class="line">    <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NacosException(NacosException.INVALID_PARAM,</span><br><span class="line">                <span class="string">"service not found, namespace: "</span> + namespaceId + <span class="string">", service: "</span> + serviceName);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    addInstance(namespaceId, serviceName, instance.isEphemeral(), instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>createServiceIfAbsent</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createServiceIfAbsent</span><span class="params">(String namespaceId, String serviceName, <span class="keyword">boolean</span> local, Cluster cluster)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">   <span class="comment">//从serviceMap中获取namespaceId, serviceName指定的服务</span></span><br><span class="line">    Service service = getService(namespaceId, serviceName);</span><br><span class="line">    <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123; <span class="comment">// 没有的话就创建一个</span></span><br><span class="line">        Loggers.SRV_LOG.info(<span class="string">"creating empty service &#123;&#125;:&#123;&#125;"</span>, namespaceId, serviceName);</span><br><span class="line">        service = <span class="keyword">new</span> Service();</span><br><span class="line">        service.setName(serviceName);</span><br><span class="line">        service.setNamespaceId(namespaceId);</span><br><span class="line">        service.setGroupName(NamingUtils.getGroupName(serviceName));</span><br><span class="line">        <span class="comment">// now validate the service. if failed, exception will be thrown</span></span><br><span class="line">        service.setLastModifiedMillis(System.currentTimeMillis());</span><br><span class="line">        service.recalculateChecksum();</span><br><span class="line">        <span class="keyword">if</span> (cluster != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cluster.setService(service);</span><br><span class="line">            service.getClusterMap().put(cluster.getName(), cluster);</span><br><span class="line">        &#125;</span><br><span class="line">        service.validate();</span><br><span class="line">        <span class="comment">// &gt;&gt;</span></span><br><span class="line">        putServiceAndInit(service);</span><br><span class="line">        <span class="keyword">if</span> (!local) &#123;</span><br><span class="line">            addOrReplaceService(service);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>putServiceAndInit</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putServiceAndInit</span><span class="params">(Service service)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">    putService(service); <span class="comment">// 把服务信息保存到serviceMap集合</span></span><br><span class="line">    service.init(); <span class="comment">// 建立心跳检测机制</span></span><br><span class="line">  <span class="comment">// 实现数据一致性监听，ephemeral=true表示采用raft协议，false表示采用Distro</span></span><br><span class="line">    consistencyService </span><br><span class="line">            .listen(KeyBuilder.buildInstanceListKey(service.getNamespaceId(), service.getName(), <span class="keyword">true</span>), service);</span><br><span class="line">    consistencyService</span><br><span class="line">            .listen(KeyBuilder.buildInstanceListKey(service.getNamespaceId(), service.getName(), <span class="keyword">false</span>), service);</span><br><span class="line">    Loggers.SRV_LOG.info(<span class="string">"[NEW-SERVICE] &#123;&#125;"</span>, service.toJson());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里比较感兴趣的点就是心跳检测，将在进阶篇与客户端的心跳发送一起分析</p><p><strong>addInstance</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInstance</span><span class="params">(String namespaceId, String serviceName, <span class="keyword">boolean</span> ephemeral, Instance... ips)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    String key = KeyBuilder.buildInstanceListKey(namespaceId, serviceName, ephemeral);</span><br><span class="line">    Service service = getService(namespaceId, serviceName);</span><br><span class="line">    <span class="keyword">synchronized</span> (service) &#123;</span><br><span class="line">        List&lt;Instance&gt; instanceList = addIpAddresses(service, ephemeral, ips);</span><br><span class="line">        Instances instances = <span class="keyword">new</span> Instances();</span><br><span class="line">        instances.setInstanceList(instanceList);</span><br><span class="line">        <span class="comment">// nacos数据一致性put</span></span><br><span class="line">        consistencyService.put(key, instances);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果nacos-server是集群部署的话，服务注册的实例信息要同步到所有的nacos-server上，所以这里使用consistencyService来完成一致性需求，这里将在进阶篇分析</p><h3 id="3-服务消费者拉取服务列表"><a href="#3-服务消费者拉取服务列表" class="headerlink" title="3. 服务消费者拉取服务列表"></a>3. 服务消费者拉取服务列表</h3><p>服务注册成功之后，消费者就可以从nacos-server中获取到服务提供者的地址，然后进行服务的调用。</p><p>在服务消费中，有一个核心的类 NacosDiscoveryClient 来负责和nacos交互，去获得服务提供者的地 址信息。之前在分析dubbo源码的时候已经分析过服务的订阅过程。</p><p>NacosDiscoveryClient 中提供了一个 getInstances 方法用来根据服务提供者名称获取服务提供者的 url地址的方法。</p><h4 id="3-1-时机"><a href="#3-1-时机" class="headerlink" title="3.1 时机"></a>3.1 时机</h4><p>应用启动之时，会执行根据配置的依赖服务名称，进行远程服务代理创建并注入Ioc的流程。在创建代理对象时，会执行服务列表拉取的逻辑。详见《dubbo-服务消费过程分析》</p><h4 id="3-2-流程"><a href="#3-2-流程" class="headerlink" title="3.2 流程"></a>3.2 流程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ServiceInstance&gt; <span class="title">getInstances</span><span class="params">(String serviceId)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> serviceDiscovery.getInstances(serviceId);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Can not get hosts from nacos server. serviceId: "</span> + serviceId, e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ServiceInstance&gt; <span class="title">getInstances</span><span class="params">(String serviceId)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">String group = discoveryProperties.getGroup();</span><br><span class="line">List&lt;Instance&gt; instances = discoveryProperties.namingServiceInstance()</span><br><span class="line">.selectInstances(serviceId, group, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">return</span> hostToServiceInstanceList(instances, serviceId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用NamingService，根据serviceId、group获得服务实例列表。 然后把instance转化为ServiceInstance对象</p><p><strong>NacosNamingService.selectInstances</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Instance&gt; <span class="title">selectInstances</span><span class="params">(String serviceName, String groupName, List&lt;String&gt; clusters, <span class="keyword">boolean</span> healthy, <span class="keyword">boolean</span> subscribe)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line"></span><br><span class="line">    ServiceInfo serviceInfo;</span><br><span class="line">    <span class="keyword">if</span> (subscribe) &#123;</span><br><span class="line">        serviceInfo = hostReactor.getServiceInfo(NamingUtils.getGroupedName(serviceName, groupName), StringUtils.join(clusters, <span class="string">","</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serviceInfo = hostReactor.getServiceInfoDirectlyFromServer(NamingUtils.getGroupedName(serviceName, groupName), StringUtils.join(clusters, <span class="string">","</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> selectInstances(serviceInfo, healthy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>selectInstances首先从hostReactor获取serviceInfo，</p><p>然后再从serviceInfo.getHosts()剔除非healty、 非enabled、weight小于等于0的instance再返回;</p><p>如果subscribe为true，则执行 hostReactor.getServiceInfo获取serviceInfo</p><p>否则执行 hostReactor.getServiceInfoDirectlyFromServer获取serviceInfo</p><p><strong>HostReactor.getServiceInfo</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServiceInfo <span class="title">getServiceInfo</span><span class="params">(<span class="keyword">final</span> String serviceName, <span class="keyword">final</span> String clusters)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    NAMING_LOGGER.debug(<span class="string">"failover-mode: "</span> + failoverReactor.isFailoverSwitch());</span><br><span class="line">    String key = ServiceInfo.getKey(serviceName, clusters);</span><br><span class="line">    <span class="keyword">if</span> (failoverReactor.isFailoverSwitch()) &#123;</span><br><span class="line">        <span class="keyword">return</span> failoverReactor.getService(key);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//从本地缓存中取</span></span><br><span class="line">    ServiceInfo serviceObj = getServiceInfo0(serviceName, clusters);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == serviceObj) &#123;<span class="comment">// 本地没有，两步走</span></span><br><span class="line">        <span class="comment">// 1、创建一个空的ServiceInfo放入缓存</span></span><br><span class="line">        serviceObj = <span class="keyword">new</span> ServiceInfo(serviceName, clusters);</span><br><span class="line">        serviceInfoMap.put(serviceObj.getKey(), serviceObj);</span><br><span class="line"><span class="comment">// 2、将远程服务信息更新到ServiceInfo中，updatingMap看来只是其到标记作用的</span></span><br><span class="line">        updatingMap.put(serviceName, <span class="keyword">new</span> Object());</span><br><span class="line">      <span class="comment">// &gt;&gt; 关键点</span></span><br><span class="line">        updateServiceNow(serviceName, clusters); </span><br><span class="line">        updatingMap.remove(serviceName); <span class="comment">//更新完毕删除标记</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (updatingMap.containsKey(serviceName)) &#123;</span><br><span class="line">        ... <span class="comment">// 若有其他线程已经创建了标记说明其他线程正在更新，同步等待</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 开启定时更新任务</span></span><br><span class="line">    scheduleUpdateIfAbsent(serviceName, clusters);</span><br><span class="line">    <span class="keyword">return</span> serviceInfoMap.get(serviceObj.getKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>updateServiceNow(serviceName, clusters)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateServiceNow</span><span class="params">(String serviceName, String clusters)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取旧的服务信息，应用启动阶段为null</span></span><br><span class="line">    ServiceInfo oldService = getServiceInfo0(serviceName, clusters);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 拉取nacos-server上的实例信息，该方法传入的参数 pushReceiver.getUDPPort() 有讲究</span></span><br><span class="line">        String result = serverProxy.queryList(serviceName, clusters, pushReceiver.getUDPPort(), <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(result)) &#123;</span><br><span class="line">            processServiceJSON(result); <span class="comment">//&gt;&gt; 处理返回的结果</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>processServiceJSON</strong></p><p>很长的方法，大致逻辑就是，获取新信息，如果存在老信息，则进行比较，分别记录修改的，新增的，删除的实例信息，记录日志，并发出服务修改事件；若旧信息不存在，将新信息 添加到本地缓存并发出服务修改事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServiceInfo <span class="title">processServiceJSON</span><span class="params">(String json)</span> </span>&#123;</span><br><span class="line">    ServiceInfo serviceInfo = JSON.parseObject(json, ServiceInfo.class);<span class="comment">//解析json</span></span><br><span class="line">    ServiceInfo oldService = serviceInfoMap.get(serviceInfo.getKey());<span class="comment">//本地缓存获取旧服务</span></span><br><span class="line">    <span class="keyword">if</span> (serviceInfo.getHosts() == <span class="keyword">null</span> || !serviceInfo.validate()) &#123;</span><br><span class="line">        <span class="comment">//若nacos-server返回的信息为null或不合法，返回老信息</span></span><br><span class="line">        <span class="keyword">return</span> oldService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">// 旧信息不为null，更新阶段</span></span><br><span class="line">    <span class="keyword">if</span> (oldService != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldService.getLastRefTime() &gt; serviceInfo.getLastRefTime()) &#123;<span class="comment">//旧信息时间不能晚于新信息</span></span><br><span class="line">            NAMING_LOGGER.warn(<span class="string">"out of date data received, old-t: "</span> + oldService.getLastRefTime()</span><br><span class="line">                + <span class="string">", new-t: "</span> + serviceInfo.getLastRefTime());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 新信息入缓存</span></span><br><span class="line">        serviceInfoMap.put(serviceInfo.getKey(), serviceInfo);</span><br><span class="line"><span class="comment">// 获取旧信息中所有的实例对象</span></span><br><span class="line">        Map&lt;String, Instance&gt; oldHostMap = <span class="keyword">new</span> HashMap&lt;String, Instance&gt;(oldService.getHosts().size());</span><br><span class="line">        <span class="keyword">for</span> (Instance host : oldService.getHosts()) &#123;</span><br><span class="line">            oldHostMap.put(host.toInetAddr(), host);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 获取信息中所有的实例对象</span></span><br><span class="line">        Map&lt;String, Instance&gt; newHostMap = <span class="keyword">new</span> HashMap&lt;String, Instance&gt;(serviceInfo.getHosts().size());</span><br><span class="line">        <span class="keyword">for</span> (Instance host : serviceInfo.getHosts()) &#123;</span><br><span class="line">            newHostMap.put(host.toInetAddr(), host);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;Instance&gt; modHosts = <span class="keyword">new</span> HashSet&lt;Instance&gt;();</span><br><span class="line">        Set&lt;Instance&gt; newHosts = <span class="keyword">new</span> HashSet&lt;Instance&gt;();</span><br><span class="line">        Set&lt;Instance&gt; remvHosts = <span class="keyword">new</span> HashSet&lt;Instance&gt;();</span><br><span class="line"></span><br><span class="line">        List&lt;Map.Entry&lt;String, Instance&gt;&gt; newServiceHosts = <span class="keyword">new</span> ArrayList&lt;Map.Entry&lt;String, Instance&gt;&gt;(</span><br><span class="line">            newHostMap.entrySet());</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Instance&gt; entry : newServiceHosts) &#123;</span><br><span class="line">            Instance host = entry.getValue();</span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            <span class="keyword">if</span> (oldHostMap.containsKey(key) &amp;&amp; !StringUtils.equals(host.toString(),</span><br><span class="line">                oldHostMap.get(key).toString())) &#123;</span><br><span class="line">                modHosts.add(host); <span class="comment">// 记录前后不一致的实例</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!oldHostMap.containsKey(key)) &#123;</span><br><span class="line">                newHosts.add(host); <span class="comment">// 记录新增实例</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Instance&gt; entry : oldHostMap.entrySet()) &#123;</span><br><span class="line">            Instance host = entry.getValue();</span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            <span class="keyword">if</span> (newHostMap.containsKey(key)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!newHostMap.containsKey(key)) &#123;</span><br><span class="line">                remvHosts.add(host); <span class="comment">// 记录删除实例</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newHosts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            changed = <span class="keyword">true</span>;</span><br><span class="line">            NAMING_LOGGER.info(<span class="string">"new ips("</span> + newHosts.size() + <span class="string">") service: "</span></span><br><span class="line">                + serviceInfo.getKey() + <span class="string">" -&gt; "</span> + JSON.toJSONString(newHosts));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (remvHosts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            changed = <span class="keyword">true</span>;</span><br><span class="line">            NAMING_LOGGER.info(<span class="string">"removed ips("</span> + remvHosts.size() + <span class="string">") service: "</span></span><br><span class="line">                + serviceInfo.getKey() + <span class="string">" -&gt; "</span> + JSON.toJSONString(remvHosts));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (modHosts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            changed = <span class="keyword">true</span>;</span><br><span class="line">            NAMING_LOGGER.info(<span class="string">"modified ips("</span> + modHosts.size() + <span class="string">") service: "</span></span><br><span class="line">                + serviceInfo.getKey() + <span class="string">" -&gt; "</span> + JSON.toJSONString(modHosts));</span><br><span class="line">        &#125;</span><br><span class="line">        serviceInfo.setJsonFromServer(json);</span><br><span class="line">        <span class="keyword">if</span> (newHosts.size() &gt; <span class="number">0</span> || remvHosts.size() &gt; <span class="number">0</span> || modHosts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            eventDispatcher.serviceChanged(serviceInfo);</span><br><span class="line">            DiskCache.write(serviceInfo, cacheDir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 旧信息为null</span></span><br><span class="line">        changed = <span class="keyword">true</span>;</span><br><span class="line">        ...<span class="comment">//log</span></span><br><span class="line">        serviceInfoMap.put(serviceInfo.getKey(), serviceInfo); <span class="comment">// 新信息添加到缓存</span></span><br><span class="line">        eventDispatcher.serviceChanged(serviceInfo); <span class="comment">// 发布服务changed事件</span></span><br><span class="line">        serviceInfo.setJsonFromServer(json); </span><br><span class="line">        DiskCache.write(serviceInfo, cacheDir); <span class="comment">// 磁盘缓存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MetricsMonitor.getServiceInfoMapSizeMonitor().set(serviceInfoMap.size());</span><br><span class="line">    <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">        NAMING_LOGGER.info(<span class="string">"current ips:("</span> + serviceInfo.ipCount() + <span class="string">") service: "</span> + serviceInfo.getKey() +</span><br><span class="line">            <span class="string">" -&gt; "</span> + JSON.toJSONString(serviceInfo.getHosts()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> serviceInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：到此为止，服务信息已经拿到了，并存放在HostReactor的本地缓存中，但存在这里没用啊，应用要使用这些信息，还需要将其进行一些列处理后注入到spring容器中，所以这里需要发送一个事件通知spring，此处的数据已经进行了修改。</p><p>接下来我们看看事件是怎发出和处理的，非常巧妙</p><p>EventDispatcher.serviceChanged(serviceInfo)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceChanged</span><span class="params">(ServiceInfo serviceInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (serviceInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 仅仅只是将服务信息添加到了一个List中</span></span><br><span class="line">    changedServices.add(serviceInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>changedServices</code>是一个<code>LinkedBlockingQueue</code>阻塞对列，EventDispatcher在构造的时候啊，启动了一个线程来处理这个阻塞队列中的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Notifier</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ServiceInfo serviceInfo = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 取出元素</span></span><br><span class="line">                serviceInfo = changedServices.poll(<span class="number">5</span>, TimeUnit.MINUTES);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (serviceInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 从observerMap中取出监听器，并执行</span></span><br><span class="line">                List&lt;EventListener&gt; listeners = observerMap.get(serviceInfo.getKey());</span><br><span class="line">                <span class="keyword">if</span> (!CollectionUtils.isEmpty(listeners)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (EventListener listener : listeners) &#123;</span><br><span class="line">                        List&lt;Instance&gt; hosts = Collections.unmodifiableList(serviceInfo.getHosts());</span><br><span class="line">                        listener.onEvent(<span class="keyword">new</span> NamingEvent(serviceInfo.getName(), serviceInfo.getGroupName(), serviceInfo.getClusters(), hosts));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                NAMING_LOGGER.error(<span class="string">"[NA] notify error for service: "</span></span><br><span class="line">                    + serviceInfo.getName() + <span class="string">", clusters: "</span> + serviceInfo.getClusters(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>observerMap</code>中的监听器是什么时候加进去的呢？</p><p>在<code>DubboServiceDiscoveryAutoConfiguration.NacosConfiguration</code>中注册了一个事件监听，监听<code>SubscribedServicesChangedEvent</code>事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener</span>(SubscribedServicesChangedEvent.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribedServicesChangedEvent</span><span class="params">(SubscribedServicesChangedEvent event)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="comment">// subscribe EventListener for each service</span></span><br><span class="line">   event.getNewSubscribedServices().forEach(<span class="keyword">this</span>::subscribeEventListener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当接受到事件时，会执行<code>subscribeEventListener</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribeEventListener</span><span class="params">(String serviceName)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (listeningServices.add(serviceName)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         String group = nacosDiscoveryProperties.getGroup();</span><br><span class="line">         namingService.subscribe(serviceName, group, event -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (event <span class="keyword">instanceof</span> NamingEvent) &#123;</span><br><span class="line">               NamingEvent namingEvent = (NamingEvent) event;</span><br><span class="line">               List&lt;ServiceInstance&gt; serviceInstances = hostToServiceInstanceList(</span><br><span class="line">                     namingEvent.getInstances(), serviceName);</span><br><span class="line">               <span class="comment">// 将Changed事件转发给spring-boot</span></span><br><span class="line">               dispatchServiceInstancesChangedEvent(serviceName,serviceInstances); </span><br><span class="line">            &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">         ReflectionUtils.rethrowRuntimeException(e);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看subscribe方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span><span class="comment">//NacosNamingService</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(String serviceName, String groupName, List&lt;String&gt; clusters, EventListener listener)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">    eventDispatcher.addListener(hostReactor.getServiceInfo(NamingUtils.getGroupedName(serviceName, groupName),</span><br><span class="line">        StringUtils.join(clusters, <span class="string">","</span>)), StringUtils.join(clusters, <span class="string">","</span>), listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>subscribe做了两件事：</p><ol><li><p>主要的工作是将hostReactor中的服务实例信息取出来</p></li><li><p>兼职是向<code>eventDispatcher</code>添加了一个Listener，该Listener是通过lamda表达式定义的，见上上段代码。</p><p>这个Listener监听NamingEvent类型的事件。</p></li></ol><p>那我们再回到<code>EventDispatcher</code>的监听逻辑中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Notifier</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ServiceInfo serviceInfo = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 取出元素</span></span><br><span class="line">                serviceInfo = changedServices.poll(<span class="number">5</span>, TimeUnit.MINUTES);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (serviceInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 从observerMap中取出监听器，并执行</span></span><br><span class="line">                List&lt;EventListener&gt; listeners = observerMap.get(serviceInfo.getKey());</span><br><span class="line">                <span class="keyword">if</span> (!CollectionUtils.isEmpty(listeners)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (EventListener listener : listeners) &#123;</span><br><span class="line">                        List&lt;Instance&gt; hosts = Collections.unmodifiableList(serviceInfo.getHosts());</span><br><span class="line">                        <span class="comment">// 向监听器发出NamingEvent</span></span><br><span class="line">                        listener.onEvent(<span class="keyword">new</span> NamingEvent(serviceInfo.getName(), serviceInfo.getGroupName(), serviceInfo.getClusters(), hosts));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                NAMING_LOGGER.error(<span class="string">"[NA] notify error for service: "</span></span><br><span class="line">                    + serviceInfo.getName() + <span class="string">", clusters: "</span> + serviceInfo.getClusters(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>EventDispatcher</code>向监听器发出的正是<code>NamingEvent</code></p><p>这个<code>NamingEvent</code>被接收后，响应逻辑会创建出一个<code>SubscribedServicesChangedEvent</code>发出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchServiceInstancesChangedEvent</span><span class="params">(String serviceName,</span></span></span><br><span class="line"><span class="function"><span class="params">      Collection&lt;ServiceInstance&gt; serviceInstances)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (!hasText(serviceName) || serviceInstances == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 创建事件并发布</span></span><br><span class="line">   ServiceInstancesChangedEvent event = <span class="keyword">new</span> ServiceInstancesChangedEvent(serviceName,</span><br><span class="line">         serviceInstances);</span><br><span class="line">   。。。</span><br><span class="line">   applicationEventPublisher.publishEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后被Spring-boot接收到处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener</span>(SubscribedServicesChangedEvent.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribedServicesChangedEvent</span><span class="params">(SubscribedServicesChangedEvent event)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="comment">// subscribe EventListener for each service</span></span><br><span class="line">   event.getNewSubscribedServices().forEach(<span class="keyword">this</span>::subscribeEventListener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的事件发送监听形成了一个闭环。</p><p><strong>scheduleUpdateIfAbsent</strong></p><p>添加一个定时任务，更新服务信息，在下一篇笔记《Nacos(三)心跳与服务更新》中分析</p><h3 id="4-核心对象"><a href="#4-核心对象" class="headerlink" title="4. 核心对象"></a>4. 核心对象</h3><h4 id="NacosNamingService"><a href="#NacosNamingService" class="headerlink" title="NacosNamingService"></a>NacosNamingService</h4><p>NacosNamingService是NamingService接口的实现类。实现了上面提到的那些方法。<br>此外，NacosNamingService还起到了初始化其他核心类的作用，因为对外提供的方法都是委托给其他核心类处理的。按顺序将依次初始化EventDispatcher、NamingProxy、BeatReactor、HostReactor。<br>从NacosNamingService的构造函数我们也可以了解到，可以进行一些参数的自定义，总结如下（部分概念的含义可参考<a href="https://nacos.io/zh-cn/docs/concepts.html" target="_blank" rel="noopener">官方文档</a>）：</p><h4 id="EventDispatcher"><a href="#EventDispatcher" class="headerlink" title="EventDispatcher"></a>EventDispatcher</h4><p>EventDispatcher与其他事件分发的组件没什么不同，用于处理subscribe、unsubscribe等等与服务监听相关的方法，并分发NamingEvent到各Listener。<br>成员变量ConcurrentMap&lt;String, List<eventlistener>&gt; observerMap保存了注册的Listener，key为{服务名}@@{集群名}，value为各个EventListener的列表。<br>EventDispatcher会启动<strong>1</strong>个名为com.alibaba.nacos.naming.client.listener的线程用于处理事件的分发。</eventlistener></p><blockquote><p>注意点：</p><ul><li>分发NamingEvent时，按照subscribe(…)方法的调用顺序串行依次调用EventListener的onEvent(…)方法。</li><li>调用subscribe(…)方法会引起对应Service的事件分发。</li></ul></blockquote><h4 id="NamingProxy"><a href="#NamingProxy" class="headerlink" title="NamingProxy"></a>NamingProxy</h4><p>NamingProxy用于与Nacos服务端通信，注册服务、注销服务、发送心跳等都经由NamingProxy来请求服务端。<br>NamingProxy会启动<strong>1</strong>个名为com.alibaba.nacos.client.naming.serverlist.updater的线程，用于定期调用refreshSrvIfNeed()方法更新Nacos服务端地址，默认间隔为<strong>30秒</strong>，<br>对服务端API的调用将在后文总结。</p><blockquote><p>注意点：refreshSrvIfNeed()方法对Nacos服务端地址的更新仅在使用endpoint的时候才会进行实际更新，如果是通过serverAddr配置的Nacos服务端地址，refreshSrvIfNeed()方法将不会进行任何操作。</p></blockquote><h4 id="BeatReactor"><a href="#BeatReactor" class="headerlink" title="BeatReactor"></a>BeatReactor</h4><p>BeatReactor用于向Nacos服务端发送已注册服务的心跳。<br>成员变量Map&lt;String, BeatInfo&gt; dom2Beat中保存了需要发送的BeatInfo，key为{serviceName}#{ip}#{port}，value为对应的BeatInfo。<br>BeatReactor会启动名为com.alibaba.nacos.naming.beat.sender的线程来发送心跳，默认线程数为1~CPU核心数的一半，可由namingClientBeatThreadCount参数指定。<br>默认情况下每<strong>5秒</strong>发送一次心跳，可根据Nacos服务端返回的clientBeatInterval的值调整心跳间隔。</p><p>心跳请求的是nacos-server的注册接口，这也就是意味着，每隔5秒，服务都会重新注册一次。</p><h4 id="HostReactor"><a href="#HostReactor" class="headerlink" title="HostReactor"></a>HostReactor</h4><p>HostReactor用于获取、保存、更新各Service实例信息。<br>成员变量Map&lt;String, ServiceInfo&gt; serviceInfoMap中保存了已获取到的服务的信息，key为{服务名}@@{集群名}。<br>HostReactor会启动名为com.alibaba.nacos.client.naming.updater的线程来更新服务信息，默认线程数为1~CPU核心数的一半，可由namingPollingThreadCount参数指定。定时任务UpdateTask会根据服务的cacheMillis值定时更新服务信息，默认值为<strong>10秒</strong>。该定时任务会在获取某一服务信息时创建，保存在成员变量Map&lt;String, ScheduledFuture&lt;?&gt;&gt; futureMap中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;注册中心需要的核心功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务提供者将服务信息发布到注册中心，此处涉及到服务信息的数据结构设计及存储&lt;/li&gt;
&lt;li&gt;服务消费者能够从注册中心获取所需服务的实例信息&lt;/li&gt;
&lt;li&gt;注册中心需要感知服务的健康状况，心跳机制&lt;/li&gt;
&lt;li&gt;服
      
    
    </summary>
    
      <category term="SpringCloud" scheme="http://yoursite.com/child/categories/SpringCloud/"/>
    
    
      <category term="SpringCloud" scheme="http://yoursite.com/child/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>Nacos(一)部署及使用</title>
    <link href="http://yoursite.com/child/2020/08/10/Nacos(1)%E9%83%A8%E7%BD%B2%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/child/2020/08/10/Nacos(1)部署及使用/</id>
    <published>2020-08-09T16:00:00.000Z</published>
    <updated>2021-01-12T07:34:17.765Z</updated>
    
    <content type="html"><![CDATA[<h4 id="单节点部署"><a href="#单节点部署" class="headerlink" title="单节点部署"></a>单节点部署</h4><p>下载最新版本的nacos release包，官方给的百度云盘连接：</p><p><a href="https://pan.baidu.com/s/1186nmlqPGows9gUZKAx8Zw#list/path=%2F" target="_blank" rel="noopener">https://pan.baidu.com/s/1186nmlqPGows9gUZKAx8Zw#list/path=%2F</a></p><p>提取码： rest</p><p>下载tar.gz文件</p><p>解压：</p><p>tar -xvf nacos….</p><p>修改配置文件conf/application.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#*************** Config Module Related Configurations ***************#</span><br><span class="line">### If user MySQL as datasource:</span><br><span class="line">spring.datasource.platform=mysql</span><br><span class="line"></span><br><span class="line">### Count of DB:</span><br><span class="line">db.num=1</span><br><span class="line"></span><br><span class="line">### Connect URL of DB:</span><br><span class="line">db.url.0=jdbc:mysql://192.168.2.117:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span><br><span class="line">db.user=root</span><br><span class="line">db.password=pJp&amp;Zzk3213</span><br></pre></td></tr></table></figure><p>启动：</p><p>cd bin</p><p>sh startup.sh -m standalone</p><p>由于nacos没有依赖mysql8.0的driver包，所以启动时会报错，连接不上数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2020-08-09 13:07:15,048 INFO Root WebApplicationContext: initialization completed in 10238 ms</span><br><span class="line"></span><br><span class="line">org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is com.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: Could not create connection to database server. Attempted reconnect 3 times. Giving up.</span><br><span class="line">at org.springframework.jdbc.datasource.DataSourceUtils.getConnection(DataSourceUtils.java:81)</span><br><span class="line">at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:371)</span><br><span class="line">at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:523)</span><br></pre></td></tr></table></figure><p>解决办法：<br><strong>在nacos安装目录下新建plugins/mysql文件夹，并放入8.0+版本的mysql-connector-java-8.0.xx.jar，重启nacos即可。</strong><br>启动时会提示更换了mysql的driver-class类。</p><p>最后访问xxx.xxx.xxx.xxx:8848</p><p>用户名密码是： nacos nacos</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;单节点部署&quot;&gt;&lt;a href=&quot;#单节点部署&quot; class=&quot;headerlink&quot; title=&quot;单节点部署&quot;&gt;&lt;/a&gt;单节点部署&lt;/h4&gt;&lt;p&gt;下载最新版本的nacos release包，官方给的百度云盘连接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://
      
    
    </summary>
    
      <category term="SpringCloud" scheme="http://yoursite.com/child/categories/SpringCloud/"/>
    
    
      <category term="SpringCloud" scheme="http://yoursite.com/child/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>java-Reactor编程入门</title>
    <link href="http://yoursite.com/child/2020/07/21/java-reactor%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/child/2020/07/21/java-reactor编程入门/</id>
    <published>2020-07-20T16:00:00.000Z</published>
    <updated>2021-01-12T07:25:35.678Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.ibm.com/zh/articles/j-cn-with-reactor-response-encode/" target="_blank" rel="noopener">https://developer.ibm.com/zh/articles/j-cn-with-reactor-response-encode/</a></p><h3 id="1-理论基础"><a href="#1-理论基础" class="headerlink" title="1. 理论基础"></a>1. 理论基础</h3><p>反应式编程来源于数据流和变化的传播，意味着由底层的执行模型负责通过数据流来自动传播变化。比如求值一个简单的表达式 c=a+b，当 a 或者 b 的值发生变化时，传统的编程范式需要对 a+b 进行重新计算来得到 c 的值。如果使用反应式编程，当 a 或者 b 的值发生变化时，c 的值会自动更新。反应式编程最早由 .NET 平台上的 Reactive Extensions (Rx) 库来实现。后来迁移到 Java 平台之后就产生了著名的 RxJava 库，并产生了很多其他编程语言上的对应实现。在这些实现的基础上产生了后来的反应式流（Reactive Streams）规范。该规范定义了反应式流的相关接口，并将集成到 Java 9 中。</p><p>在传统的编程范式中，我们一般通过迭代器（Iterator）模式来遍历一个序列。这种遍历方式是由调用者来控制节奏的，采用的是拉的方式。每次由调用者通过 next()方法来获取序列中的下一个值。使用反应式流时采用的则是推的方式，即常见的发布者-订阅者模式。当发布者有新的数据产生时，这些数据会被推送到订阅者来进行处理。在反应式流上可以添加各种不同的操作来对数据进行处理，形成数据处理链。这个以声明式的方式添加的处理链只在订阅者进行订阅操作时才会真正执行。</p><p>反应式流中第一个重要概念是负压（backpressure）。在基本的消息推送模式中，当消息发布者产生数据的速度过快时，会使得消息订阅者的处理速度无法跟上产生的速度，从而给订阅者造成很大的压力。当压力过大时，有可能造成订阅者本身的奔溃，所产生的级联效应甚至可能造成整个系统的瘫痪。负压的作用在于提供一种从订阅者到生产者的反馈渠道。订阅者可以通过 request()方法来声明其一次所能处理的消息数量，而生产者就只会产生相应数量的消息，直到下一次 request()方法调用。这实际上变成了推拉结合的模式。</p><p>前面提到的 RxJava 库是 JVM 上反应式编程的先驱，也是反应式流规范的基础。RxJava 2 在 RxJava 的基础上做了很多的更新。不过 RxJava 库也有其不足的地方。RxJava 产生于反应式流规范之前，虽然可以和反应式流的接口进行转换，但是由于底层实现的原因，使用起来并不是很直观。RxJava 2 在设计和实现时考虑到了与规范的整合，不过为了保持与 RxJava 的兼容性，很多地方在使用时也并不直观。Reactor 则是完全基于反应式流规范设计和实现的库，没有 RxJava 那样的历史包袱，在使用上更加的直观易懂。Reactor 也是 Spring 5 中反应式编程的基础。学习和掌握 Reactor 可以更好地理解 Spring 5 中的相关概念。</p><p>在 Java 程序中使用 Reactor 库非常的简单，只需要通过 Maven 或 Gradle 来添加对 io.projectreactor:reactor-core 的依赖即可，目前的版本是 3.0.5.RELEASE。</p><h3 id="2-Flux-和-Mono"><a href="#2-Flux-和-Mono" class="headerlink" title="2. Flux 和 Mono"></a>2. Flux 和 Mono</h3><p>Flux 和 Mono 是 Reactor 中的两个基本概念z。Flux 表示的是包含 0 到 N 个元素的异步序列。在该序列中可以包含三种不同类型的消息通知：正常的包含元素的消息、序列结束的消息和序列出错的消息。当消息通知产生时，订阅者中对应的方法 onNext(), onComplete()和 onError()会被调用。Mono 表示的是包含 0 或者 1 个元素的异步序列。该序列中同样可以包含与 Flux 相同的三种类型的消息通知。Flux 和 Mono 之间可以进行转换。对一个 Flux 序列进行计数操作，得到的结果是一个 Mono对象。把两个 Mono 序列合并在一起，得到的是一个 Flux 对象。</p><h4 id="2-1-Mono创建"><a href="#2-1-Mono创建" class="headerlink" title="2.1 Mono创建"></a>2.1 Mono创建</h4><h5 id="2-1-1-静态创建方法"><a href="#2-1-1-静态创建方法" class="headerlink" title="2.1.1 静态创建方法"></a>2.1.1 静态创建方法</h5><ul><li>empty()：创建一个不包含任何元素，只发布结束消息的序列。</li><li>just()：可以指定序列中包含的全部元素。创建出来的 Mono序列在发布这些元素之后会自动结束。</li><li>justOrEmpty()：从一个 Optional 对象或可能为 null 的对象中创建 Mono。只有 Optional 对象中包含值或对象不为 null 时，Mono 序列才产生对应的元素。</li><li>error(Throwable error)：创建一个只包含错误消息的序列。</li><li>never()：创建一个不包含任何消息通知的序列。</li><li>fromCallable()、fromCompletionStage()、fromFuture()、fromRunnable()和 fromSupplier()：分别从 Callable、CompletionStage、CompletableFuture、Runnable 和 Supplier 中创建 Mono。</li><li>delay(Duration duration)和 delayMillis(long duration)：创建一个 Mono 序列，在指定的延迟时间之后，产生数字 0 作为唯一值。</li></ul><h5 id="2-1-2-动态创建方法"><a href="#2-1-2-动态创建方法" class="headerlink" title="2.1.2 动态创建方法"></a>2.1.2 动态创建方法</h5><p>通过 create()方法来使用 MonoSink 来创建 Mono。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">monoCreateTest_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Mono.create(sink -&gt; &#123;</span><br><span class="line">        SimpleRequest msg = <span class="keyword">new</span> SimpleRequest();</span><br><span class="line">        msg.setRequestMessage(<span class="string">"hello zzk"</span>);</span><br><span class="line">        String requestMessage = msg.getRequestMessage();</span><br><span class="line">        SimpleResponse response =</span><br><span class="line">                SimpleResponse.newBuilder().setResponseMessage(requestMessage).build();</span><br><span class="line">        sink.success(response);</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">monoCreateTest_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CityService cityService = <span class="keyword">new</span> CityService();</span><br><span class="line">    Mono.create(cityMonoSink -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">1</span>;</span><br><span class="line">        cityMonoSink.success(cityService.findCityById(id));  <span class="comment">// 此处可做增删改查</span></span><br><span class="line">    &#125;).subscribe(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-操作符"><a href="#3-操作符" class="headerlink" title="3. 操作符"></a>3. 操作符</h3><p>Reactor可以在反应式流上通过 声明 的方式添加多种不同的操作符。</p><h4 id="3-1-buffer-和-bufferTimeout"><a href="#3-1-buffer-和-bufferTimeout" class="headerlink" title="3.1 buffer 和 bufferTimeout"></a>3.1 buffer 和 bufferTimeout</h4><p>作用：将当前流中的元素收集到集合中，并将集合对象作为流中的新元素</p><p>在进行收集时可以指定不同的条件：</p><ul><li>所包含的元素的最大数量；</li><li>收集的时间间隔。（事件间隔使用Duration对象表示）</li></ul><p>方法buffer()仅使用一个条件，而bufferTimeout可以使用两个条件</p><p>除了元素数量和时间间隔之外，还可以通过bufferUntil和bufferWhile操作符来进行收集。这两个操作符的参数是表示每个集合中的元素所要满足的条件的predicate对象。</p><p>bufferUtils会一只手机知道predicate返回为true，使得predicate返回true的那个元素可以选择添加到当前集合或者下一个集合中</p><p>bufferWhile则至于当Predicate返回为true时才会收集，一旦返回false，会立即开始下一次收集。</p><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bufferTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Flux.range(<span class="number">1</span>,<span class="number">10</span>).bufferWhile(i-&gt;i&gt;<span class="number">5</span>).subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line">    Flux.range(<span class="number">1</span>,<span class="number">10</span>).bufferUntil(integer -&gt; integer % <span class="number">2</span> ==<span class="number">0</span>).subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line">    Flux.range(<span class="number">1</span>,<span class="number">10</span>).buffer().subscribe(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解：按一定的条件，将流中元素分类，聚合成新的集合元素</p><h4 id="3-2-filter"><a href="#3-2-filter" class="headerlink" title="3.2 filter"></a>3.2 filter</h4><p>作用：对流中包含的元素进行过滤，只满足Predicate指定条件的元素。</p><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filterTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Flux.range(<span class="number">1</span>,<span class="number">10</span>).filter(integer -&gt; integer%<span class="number">2</span>==<span class="number">0</span>).subscribe(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-window"><a href="#3-3-window" class="headerlink" title="3.3  window"></a>3.3  window</h4><p>作用：类似于buffer，不同的是window操作符吧当前流中的元素收集到另外的Flux序列中，因此返回值是</p><p>Flux<flux>。</flux></p><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">windowTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Flux.range(<span class="number">1</span>,<span class="number">100</span>).window(<span class="number">20</span>).subscribe(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中，输出结果分别是 5 个和 2 个 UnicastProcessor 字符。这是因为 window 操作符所产生的流中包含的是 UnicastProcessor 类的对象，而 UnicastProcessor 类的 toString 方法输出的就是 UnicastProcessor 字符。</p><h4 id="3-4-zipWith"><a href="#3-4-zipWith" class="headerlink" title="3.4 zipWith"></a>3.4 zipWith</h4><p>作用：把当前流中的元素与另一个流中的元素按照一对一的方式进行合并。</p><ul><li><p>在合并时，可以不作任何处理，由此得到的是一个元素类型为Tuple2的流</p></li><li><p>也可以通过一个BiFuction函数对合并的元素进行处理，的到的流元素为该函数的返回值</p></li></ul><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zipWithTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Flux.just(<span class="string">"a"</span>,<span class="string">"b"</span>).zipWith(Flux.just(<span class="string">"c"</span>,<span class="string">"d"</span>)).subscribe(System.out::println);</span><br><span class="line">    Flux.just(<span class="string">"a"</span>,<span class="string">"b"</span>).zipWith(Flux.just(<span class="string">"c"</span>,<span class="string">"d"</span>),(s1,s2)-&gt;s1+s2).subscribe(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-5-take"><a href="#3-5-take" class="headerlink" title="3.5 take"></a>3.5 take</h4><p>作用：用于从当提前流中提取元素，提取方式有多种：</p><ul><li>take(long n)，take(Duration timespan)：按照指定的数量或时间间隔来提取。</li><li>takeLast(long n)：提取流中的最后 N 个元素。</li><li>takeUntil(Predicate&lt;? super T&gt; predicate)：提取元素直到 Predicate 返回 true。</li><li>takeWhile(Predicate&lt;? super T&gt; continuePredicate)： 当 Predicate 返回 true 时才进行提取。</li><li>takeUntilOther(Publisher&lt;?&gt; other)：提取元素直到另外一个流开始产生元素。</li></ul><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">takeTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获取前10个元素</span></span><br><span class="line">    Flux.range(<span class="number">1</span>,<span class="number">1000</span>).take(<span class="number">10</span>).subscribe(System.out::println);</span><br><span class="line">    <span class="comment">// 获取后10个元素</span></span><br><span class="line">    Flux.range(<span class="number">1</span>,<span class="number">1000</span>).takeLast(<span class="number">10</span>).subscribe(System.out::println);</span><br><span class="line">    <span class="comment">// 提取元素直到Predicate返回true</span></span><br><span class="line">    Flux.range(<span class="number">1</span>,<span class="number">1000</span>).takeUntil(integer -&gt; integer==<span class="number">100</span>).subscribe(System.out::println);</span><br><span class="line">    <span class="comment">//当Predicate返回true时，提取元素</span></span><br><span class="line">    Flux.range(<span class="number">1</span>,<span class="number">100</span>).takeWhile(integer -&gt; integer&lt;<span class="number">10</span>).subscribe(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-6-reduce-和-reduceWith"><a href="#3-6-reduce-和-reduceWith" class="headerlink" title="3.6 reduce 和 reduceWith"></a>3.6 reduce 和 reduceWith</h4><p>作用：对流中包含的所有元素进行累积操作，得到一份包含计算结果的Mono序列。累积操作是通过一份BiFunction来表示的</p><p>在操作的时候可以指定一个初始值，如果没有初始值，序列中的第一个元素作为初始值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reduceTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 累加 返回5050</span></span><br><span class="line">    Flux.range(<span class="number">1</span>,<span class="number">100</span>).reduce((x,y)-&gt;x+y).subscribe(System.out::println);</span><br><span class="line">    <span class="comment">// 在50的基础上累加 返回5100</span></span><br><span class="line">    Flux.range(<span class="number">1</span>,<span class="number">100</span>).reduceWith(()-&gt;<span class="number">50</span>,(x,y)-&gt;x+y).subscribe(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-7-merge-和-mergeSequential"><a href="#3-7-merge-和-mergeSequential" class="headerlink" title="3.7 merge 和 mergeSequential"></a>3.7 merge 和 mergeSequential</h4><p>作用：用于把多个流合并成一个Flux序列。</p><ul><li><p>merge 按照所有流中元素的实际生产顺序进行合并</p></li><li><p>mergeSequential 按照所有流被订阅的顺序，以流为单位进行合并</p></li></ul><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Flux.merge(Flux.interval(Duration.of(<span class="number">1</span>, ChronoUnit.SECONDS)).take(<span class="number">10</span>),</span><br><span class="line">            Flux.interval(Duration.of(<span class="number">2</span>,ChronoUnit.SECONDS)).take(<span class="number">10</span>))</span><br><span class="line">    .toStream().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    Flux.mergeSequential(Flux.interval(Duration.of(<span class="number">1</span>, ChronoUnit.SECONDS)).take(<span class="number">10</span>),</span><br><span class="line">            Flux.interval(Duration.of(<span class="number">2</span>,ChronoUnit.SECONDS)).take(<span class="number">10</span>))</span><br><span class="line">            .toStream().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一句：两个序列交叉输出</p><p>第二句：先输出第一个序列，第二个序列虽然没输出但是已经发射的元素存在内存中了，序列一输出完成立即输出以发射的序列二元素，再继续按照序列二的节奏输出。</p><h4 id="3-8-flatMap-和-flatMapSequential"><a href="#3-8-flatMap-和-flatMapSequential" class="headerlink" title="3.8 flatMap 和 flatMapSequential"></a>3.8 flatMap 和 flatMapSequential</h4><p>作用：把流中的每个元素转换成一个流，再把所有流中的元素进行合并。</p><p>flatMap 与flatMapSequential的区别，和上文介绍的merge操作符一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">flatMapTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Flux.just(<span class="number">3</span>,<span class="number">5</span>).flatMap(x-&gt;Flux.interval(Duration.of(x,ChronoUnit.SECONDS)).take(x)).toStream()</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-9-concatMap"><a href="#3-9-concatMap" class="headerlink" title="3.9 concatMap"></a>3.9 concatMap</h4><p>作用：也是把流中的每个元素转换成一个流，再把所有流进行合并。</p><p>与 flatMap 不同的是，concatMap 会根据原始流中的元素顺序依次把转换之后的流进行合并；</p><p>与 flatMapSequential 不同的是，concatMap 对转换之后的流的订阅是动态进行的，而 flatMapSequential 在合并之前就已经订阅了所有的流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">concatMapTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Flux.just(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">            .concatMap(x -&gt; Flux.interval(Duration.of(x,ChronoUnit.SECONDS)).take(x))</span><br><span class="line">            .toStream()</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-10-combineLatest"><a href="#3-10-combineLatest" class="headerlink" title="3.10  combineLatest"></a>3.10  combineLatest</h4><p>作用：把所有流中的最新产生的元素合并成一个新的元素，作为返回结果流中的元素。只要其中任何一个流中产生了新的元素，合并操作就会被执行一次，结果流中就会产生新的元素。</p><p>在下面代码，流中最新产生的元素会被收集到一个数组中，通过 Arrays.toString 方法来把数组转换成 String。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">combineLatestTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Flux.combineLatest(</span><br><span class="line">            Arrays::toString,</span><br><span class="line">            Flux.interval(Duration.of(<span class="number">4</span>,ChronoUnit.SECONDS)).take(<span class="number">5</span>),</span><br><span class="line">            Flux.interval(Duration.of(<span class="number">8</span>,ChronoUnit.SECONDS)).take(<span class="number">5</span>)</span><br><span class="line">    ).toStream().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-11-defer"><a href="#3-11-defer" class="headerlink" title="3.11 defer"></a>3.11 defer</h4><p>mono defer方法创建数据源属于懒汉型，与Mono.just等创建数据源则是恶汉型，下面看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defer</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//声明阶段创建DeferClass对象</span></span><br><span class="line">Mono&lt;Date&gt; m1 = Mono.just(<span class="keyword">new</span> Date());</span><br><span class="line">Mono&lt;Date&gt; m2 = Mono.defer(()-&gt;Mono.just(<span class="keyword">new</span> Date()));</span><br><span class="line">m1.subscribe(System.out::println);</span><br><span class="line">m2.subscribe(System.out::println);</span><br><span class="line">        <span class="comment">//延迟5秒钟</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">m1.subscribe(System.out::println);</span><br><span class="line">m2.subscribe(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><p>Fri Feb 07 10:22:51 GMT+08:00 2020<br>Fri Feb 07 10:22:51 GMT+08:00 2020<br>Fri Feb 07 10:22:51 GMT+08:00 2020<br>Fri Feb 07 10:22:56 GMT+08:00 2020</p><p>我们可以看到，创建了两个数据源，一个使用Mono.just创建，一个用Mono.defer创建，然后分别通过lambda表达式订阅这两个publisher，可以看到两个输出的时间都是10:22：51，延迟5秒钟后重新订阅，Mono.just创建的数据源时间没变，但是Mono.defer创建的数据源时间相应的延迟了5秒钟，原因在于Mono.just会在声明阶段构造Date对象，只创建一次，但是Mono.defer却是在subscribe阶段才会创建对应的Date对象，每次调用subscribe方法都会创建Date对象，在webflux中</p><h3 id="4-消息处理"><a href="#4-消息处理" class="headerlink" title="4. 消息处理"></a>4. 消息处理</h3><p>当需要处理Flux和Mono中的消息时，可以通过subscribe方法来添加相应的订阅逻辑。在调用subscribe方法时可以指定需要处理的消息类型。可以只处理其中包含的正常消息，也可以同时处理错误消息和完成消息。</p><ul><li>通过subscribe()方法处理正常和错误消息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        .concatWith(Mono.error(<span class="keyword">new</span> IllegalStateException()))</span><br><span class="line">        .subscribe(System.out::println, System.err::println);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">java.lang.IllegalStateException</span><br></pre></td></tr></table></figure><ul><li>出现错误是返回默认值</li></ul><p>正常的消息处理相对简单。当出现错误时，有多种不同的处理策略。第一种策略是通过 onErrorReturn()方法返回一个默认值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        .concatWith(Mono.error(<span class="keyword">new</span> IllegalStateException()))</span><br><span class="line">        .onErrorReturn(-<span class="number">1</span>)</span><br><span class="line">        .subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://developer.ibm.com/zh/articles/j-cn-with-reactor-response-encode/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developer.ibm.c
      
    
    </summary>
    
      <category term="不知如何分类" scheme="http://yoursite.com/child/categories/%E4%B8%8D%E7%9F%A5%E5%A6%82%E4%BD%95%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="java" scheme="http://yoursite.com/child/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-事务源码分析</title>
    <link href="http://yoursite.com/child/2020/06/21/SpringBoot-%E4%BA%8B%E5%8A%A1%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/child/2020/06/21/SpringBoot-事务源码分析/</id>
    <published>2020-06-20T16:00:00.000Z</published>
    <updated>2020-07-16T09:30:33.512Z</updated>
    
    <content type="html"><![CDATA[<h3 id="复习总结："><a href="#复习总结：" class="headerlink" title="复习总结："></a>复习总结：</h3><ul><li>注解式事务是通过aop实现的，底层是cglib动态代理实现的<ul><li>事务aop场景中的Advice是<code>TransactionInterceptor</code></li><li>PointCut是<code>TransactionAttributeSourcePointcut</code>，它通过<code>TransactionAttributeSource</code>来检测@Transactional注解，因此注解可以理解为切面</li></ul></li><li><code>TransactionInterceptor</code>作为事务增强逻辑的封装类，需要持有逻辑事务管理器引用，不同的数据持久化平台都实现了自己的事务管理器</li><li>项目中使用多种持久化平台时，建议在事务注解中显示的指定事务管理器</li></ul><hr><h4 id="1-springboot事务自动装配"><a href="#1-springboot事务自动装配" class="headerlink" title="1. springboot事务自动装配"></a>1. springboot事务自动装配</h4><p>spring-boot-autoconfigurae 包中对事物有自动配置的支持，自动配置类为<code>TransactionAutoConfiguration</code>，在<code>spring.factories</code>文件中可以找到这条自动配置项，源码分析先从自动装配开始，看看spring-boot装配了哪些事务相关的bean。</p><p><code>TransactionAutoConfiguration</code>中只显示定义了以下的三个bean，辅助bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个PlatformTransactionManagerCustomizer列表</span></span><br><span class="line"><span class="comment"> * springboot提供的扩展点，使用它可以对事务管理器进行一些配置，</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">TransactionManagerCustomizers </span><br><span class="line">TransactionalOperator  <span class="comment">//简化程序化事务界定和事务异常处理的操作符类。</span></span><br><span class="line">TransactionTemplate <span class="comment">// 简化程序化事务界定和事务异常处理的模板类。</span></span><br></pre></td></tr></table></figure><p><code>TransactionAutoConfiguration</code>里的重点配置是在内部类<code>EnableTransactionManagementConfiguration</code>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(TransactionManager.class)</span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(AbstractTransactionManagementConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EnableTransactionManagementConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line">   <span class="meta">@EnableTransactionManagement</span>(proxyTargetClass = <span class="keyword">false</span>)</span><br><span class="line">   <span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.aop"</span>, name = <span class="string">"proxy-target-class"</span>, havingValue = <span class="string">"false"</span>,</span><br><span class="line">         matchIfMissing = <span class="keyword">false</span>)</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAutoProxyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line">   <span class="meta">@EnableTransactionManagement</span>(proxyTargetClass = <span class="keyword">true</span>)</span><br><span class="line">   <span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.aop"</span>, name = <span class="string">"proxy-target-class"</span>, havingValue = <span class="string">"true"</span>,</span><br><span class="line">         matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibAutoProxyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类对Jdk动态代理和CGlib动态代理两种方式分别作了配置，此类中并没有配置事务相关的bean，其关键是在<code>@EnableTransactionManagement</code>注解中</p><h5 id="1-1-EnableTransactionManagement"><a href="#1-1-EnableTransactionManagement" class="headerlink" title="1.1 EnableTransactionManagement"></a>1.1 EnableTransactionManagement</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(TransactionManagementConfigurationSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableTransactionManagement &#123;...&#125;</span><br></pre></td></tr></table></figure><p><code>EnableTransactionManagement</code>使用<code>@Import</code>注解导入了一个<code>TransactionManagementConfigurationSelector</code>，这种用法已经不陌生，常用于动态的装配bean，也就是根据应用的环境或配置装载不同类型的bean，进入该选择器代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `TransactionManagementConfigurationSelector`</span></span><br><span class="line"><span class="keyword">protected</span> String[] selectImports(AdviceMode adviceMode) &#123;</span><br><span class="line">   <span class="keyword">switch</span> (adviceMode) &#123;</span><br><span class="line">      <span class="keyword">case</span> PROXY:</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;AutoProxyRegistrar.class.getName(),</span><br><span class="line">               ProxyTransactionManagementConfiguration.class.getName()&#125;;</span><br><span class="line">      <span class="keyword">case</span> ASPECTJ:</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;determineTransactionAspectClass()&#125;;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>springboot启动时会执行者这段逻辑，当adviceMode是动态代理模式，装配的是<code>TransactionManagementConfiguration</code>，当adviceMode是aspectj织入模式，装配的是其他的，本文只讨论动态代理的情况。</p><p><code>TransactionManagementConfiguration</code>是此时真正的配置类，那么配置了哪些bean呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME)</span><br><span class="line"><span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanFactoryTransactionAttributeSourceAdvisor <span class="title">transactionAdvisor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      ...</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">@Bean</span></span></span><br><span class="line"><span class="function"><span class="params">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionAttributeSource <span class="title">transactionAttributeSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> AnnotationTransactionAttributeSource();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionInterceptor <span class="title">transactionInterceptor</span><span class="params">(TransactionAttributeSource transactionAttributeSource)</span> </span>&#123;</span><br><span class="line">   TransactionInterceptor interceptor = <span class="keyword">new</span> TransactionInterceptor();</span><br><span class="line">   interceptor.setTransactionAttributeSource(transactionAttributeSource);</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.txManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">      interceptor.setTransactionManager(<span class="keyword">this</span>.txManager);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个是<code>BeanFactoryTransactionAttributeSourceAdvisor</code>。它以Advisor结尾说明它是Spring AOP范畴里的东西。在AOP里，Advisor = Pointcut + Advice，Pointcut是切入点，表示要拦截的方法，Advice是增强，表示要加进去的事物功能。在<code>BeanFactoryTransactionAttributeSourceAdvisor</code>中有一个成员<code>TransactionAttributeSourcePointcut</code>，看名字就知道这是一个PointCut，它通过第三个bean—<code>TransactionAttributeSource</code>检测一个类的方法上是否有<code>@Transactional</code>注解，来确定该方法是否需要事物增强。</p><p>第二个bean是<code>TransactionInterceptor</code>，他就是一个Advice，因为它实现了Advice接口，包含了把事物加进去的逻辑。</p><h5 id="1-2-TransactionInterceptor"><a href="#1-2-TransactionInterceptor" class="headerlink" title="1.2 TransactionInterceptor"></a>1.2 TransactionInterceptor</h5><p>事务拦截器<code>TransactionInterceptor</code>用于拦截添加了事务注解的方法或类，对其执行事务管理器<code>txManager</code>的相关操作，那么事务管理器又是什么时候装载的呢？ 我们看到该配置类的父类中自动注入了一个<code>TransactionManager</code>，这里注入的是默认的事务管理器。当我们项目用到不止一个事务管理器的时候，开启事务时需要指定使用哪一个事务管理器，此时可以实现<code>TransactionManagementConfigurer</code>接口来指定一个默认的事务管理器，对有的系统，为了避免不必要的问题，在业务中必须要明确指定 <code>@Transactional</code> 的 value 值的情况下。不建议实现接口 <code>TransactionManagementConfigurer</code>，这样控制台会明确抛出异常，开发人员就不会忘记主动指定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTransactionManagementConfiguration</span> <span class="keyword">implements</span> <span class="title">ImportAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">protected</span> TransactionManager txManager;</span><br><span class="line">    <span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setConfigurers</span><span class="params">(Collection&lt;TransactionManagementConfigurer&gt; configurers)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (CollectionUtils.isEmpty(configurers)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (configurers.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Only one TransactionManagementConfigurer may exist"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      TransactionManagementConfigurer configurer = configurers.iterator().next();</span><br><span class="line">      <span class="keyword">this</span>.txManager = configurer.annotationDrivenTransactionManager();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当没有实现TransactionManagementConfigurer指定默认管理器时，上面的自动注入可能为空。</p><p>实时上关于事务管理器，不管是JPA还是JDBC等都实现自接口 PlatformTransactionManager 如果你添加的是 spring-boot-starter-jdbc 依赖，框架会默认注入 DataSourceTransactionManager 实例。如果你添加的是 spring-boot-starter-data-jpa 依赖，框架会默认注入 JpaTransactionManager 实例。</p><p><code>TransactionInterceptor</code>的核心逻辑是<code>invoke()</code>方法，具体的执行逻辑我会在下文执行流程中分析。</p><h4 id="2-spring事物的执行流程"><a href="#2-spring事物的执行流程" class="headerlink" title="2. spring事物的执行流程"></a>2. spring事物的执行流程</h4><p>spring-boot完成了事务bean的自动装配之后，下面来分析事务方法执行时，事务管理器的执行过程。</p><p>定义事务管理器的接口是<code>PlatformTransactionManager</code>，这个接口定义了三个方法，官方给出的注释很详细：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> <span class="keyword">extends</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line">  <span class="comment">//根据指定的传播行为，返回当前活动的事务或创建新的事务。</span></span><br><span class="line">  <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(@Nullable TransactionDefinition definition)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> TransactionException</span>;  </span><br><span class="line">  <span class="comment">//提交给定事务的状态。如果事务以编程方式标记为仅回滚，则执行回滚。</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>; </span><br><span class="line">  <span class="comment">//执行给定事务的回滚。</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口<code>PlatformTransactionManager</code>的一个抽象实现类就是<code>AbstractPlatformTransactionManager</code>，这个类实现了事务管理的整个逻辑关系流程，但是把与具体事务打交道的东西又定义为抽象方法让子类去实现（模板设计模式）。</p><h5 id="2-1-事务管理器涉及的关键对象"><a href="#2-1-事务管理器涉及的关键对象" class="headerlink" title="2.1 事务管理器涉及的关键对象"></a>2.1 事务管理器涉及的关键对象</h5><p><strong>事务定义 <code>TransactionDefinition</code></strong></p><p>这是一个接口，然而并没有需要实现的方法，接口中定义了spring事务支持的传播属性、隔离级别、超时时间、只读标记等事务属性的可选值，并制定了默认值。其派生接口为TransactionAttribute</p><p><strong>事务对象 <code>SmartTransactionObject</code></strong></p><p>不同数据源框架定义的事务对象不同，<code>SmartTransactionObject</code>只是spring-tx包定义的接口标准，不同框架对其都有自己的实现，这里我们以<code>DataSourceTransactionObject</code>为例，它是jdbc定义的事务对象</p><p><code>DataSourceTransactionObject</code>是<code>DataSourceTransactionManager</code>的内部类，看下面简单的类继承图</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/springboot/%E4%BA%8B%E5%8A%A1%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" style="zoom:67%;"></p><p>这个事务对象中最重要的成员是抽象类<code>JdbcTransactionObjectSupport</code>中定义的<code>ConnectionHolder</code>对象，它存储了该执行逻辑事务的数据库连接，也就是物理事务。</p><p><strong>事务状态 <code>TransactionStatus</code></strong></p><p><code>TransactionStatus</code>是一个接口，它继承了其他的三个接口：</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/springboot/%E4%BA%8B%E5%8A%A1%E7%8A%B6%E6%80%81%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" style="zoom:67%;"></p><p>常用的实现类是<code>DefaultTransactionStatus</code>，继承自<code>AbstractTransactionStatus</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultTransactionStatus</span> <span class="keyword">extends</span> <span class="title">AbstractTransactionStatus</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Object transaction;  <span class="comment">// 事务对象</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> newTransaction; <span class="comment">// 标记--是否为新创建的事务</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> newSynchronization; <span class="comment">// 标记--是否开启了新事务的同步</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> readOnly; <span class="comment">// 标记--是否为只读事务</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> debug; </span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Object suspendedResources; <span class="comment">// 当事务被挂起后存放挂起事务状态</span></span><br><span class="line">   <span class="comment">// 继承的属性</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> rollbackOnly = <span class="keyword">false</span>;  <span class="comment">//事务是否只支持回滚</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">boolean</span> completed = <span class="keyword">false</span>; <span class="comment">// 事务是否已完成</span></span><br><span class="line"> <span class="meta">@Nullable</span></span><br><span class="line"> <span class="keyword">private</span> Object savepoint; <span class="comment">// 保存点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重要的属性：</p><ul><li>持有一个事务对象的引用<code>Object transaction</code>，还记录了一些事务的状态信息</li><li><code>Object suspendedResources</code> ，保存被挂起事务的状态，后文会详细分析</li></ul><h5 id="2-2-事务执行流程分析"><a href="#2-2-事务执行流程分析" class="headerlink" title="2.2 事务执行流程分析"></a>2.2 事务执行流程分析</h5><h6 id="2-2-1-aop动态代理阶段"><a href="#2-2-1-aop动态代理阶段" class="headerlink" title="2.2.1 aop动态代理阶段"></a>2.2.1 aop动态代理阶段</h6><p>当调用的方法注解了事务，调用之前会通过cglib产生一个代理对象，cglib的动态代理的关键是实现<code>MethodInterceptor</code>接口，找到这个类，它是CglibAopProxy的一个私有的内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CglibAopProxy</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicAdvisedInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> AdvisedSupport advised;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">DynamicAdvisedInterceptor</span><span class="params">(AdvisedSupport advised)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.advised = advised;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    retVal = <span class="keyword">new</span> CglibMethodInvocation(proxy, target, method, args, </span><br><span class="line">                                       targetClass,  chain,  methodProxy).proceed();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>intercept() 是spring aop 进行拦截的方法，spring事务基于aop实现，所以事务增强会被aop拦截，执行intercept方法</p><p>intercept方法中不会直接开启事务或关闭事务，因为事务不一定是方法上唯一的增强点（可能存在其他增强，比如记录审计日志、开启分布式锁等等），所以事务增强逻辑肯定是封装成了一个Advisor，交给aop统一管理。</p><p>那么我们就去找这个Advisor</p><p>上面的代码创建了<code>CglibMethodInvocation</code>对象后执行了<code>proceed()</code>方法，进入该方法发现他调用了父类<code>ReflectiveMethodInvocation</code>的<code>proceed()</code>，这是一个反射方法调用器的执行过程，</p><p>由于在同一个切点可能会存在多个增强，所以动态代理也可能代理多次，每次代理都将增强的逻辑存放到一个容器中，在执行时逐个执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReflectiveMethodInvocation</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">   <span class="comment">// interceptorsAndDynamicMethodMatchers是拦截器链，同一个切点可能被多个advice拦截</span></span><br><span class="line">   <span class="comment">// currentInterceptorIndex初始为-1，这条判断其实是若拦截器链中没有拦截器，直接调用invokeJoinpoint</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">// currentInterceptorIndex先加1，再获取拦截器，此处获取到的就是事务拦截器</span></span><br><span class="line">   Object interceptorOrInterceptionAdvice =</span><br><span class="line">         <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line">   <span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">      ...</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 事务拦截会执行到这里</span></span><br><span class="line">      <span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟代码可以看到获取到的拦截器是<code>TransactionInterceptor</code>类型的，中间的判断都不满足，直接运行到代码的最后一行，调用<code>Invoke(this)</code></p><p>注意：<code>TransactionInterceptor</code> 实现的<code>MethodInterceptor</code>接口与上面cglib的不是同一个：</p><ul><li>cglib的<code>MethodInterceptor</code>接口是为了让代理对象执行代理逻辑，需要实现的是intercept方法</li><li>此处的<code>MethodInterceptor</code>接口是为了调用代理逻辑中的增强方法，需要实现的是invoke方法，因为增强逻辑是被封装过的。</li></ul><h6 id="2-2-2-TransactionInterceptor-invoke方法"><a href="#2-2-2-TransactionInterceptor-invoke方法" class="headerlink" title="2.2.2 TransactionInterceptor.invoke方法"></a>2.2.2 TransactionInterceptor.invoke方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TransactionInterceptor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">   <span class="comment">// 参数invocation就是上面创建的CglibMethodInvocation</span></span><br><span class="line">   <span class="comment">// 获取被代理对象的类型</span></span><br><span class="line">   Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="keyword">null</span> ? </span><br><span class="line">                           AopUtils.getTargetClass(invocation.getThis()) : <span class="keyword">null</span>);</span><br><span class="line">   <span class="comment">// 终于开始进入正题了,在事务中调用方法&gt;&gt;</span></span><br><span class="line">   <span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>invokeWithinTransaction</code>方法是定义在父类<code>TransactionAspectSupport</code>中的，此方法代码有点长，这里节选一些关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeWithinTransaction</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> InvocationCallback invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// 获取注解属性源，此处获取到的是AnnotationTransactionAttributeSource对象</span></span><br><span class="line">   TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line">   <span class="comment">// 从属性源中拿到事务的属性，RuleBasedTransactionAttribute对象</span></span><br><span class="line">   <span class="keyword">final</span> TransactionAttribute txAttr = (tas != <span class="keyword">null</span> ? </span><br><span class="line">                                        tas.getTransactionAttribute(method, targetClass) : <span class="keyword">null</span>);</span><br><span class="line">   <span class="comment">// 根据事务属性，创建事务管理器，如果没有配置事务管理器，自适应创建</span></span><br><span class="line">   <span class="keyword">final</span> PlatformTransactionManager tm = determineTransactionManager(txAttr);</span><br><span class="line">   <span class="comment">// com.pd.service.AccountService.transferAccount  就是方法的名称</span></span><br><span class="line">   <span class="keyword">final</span> String joinpointIdentification = methodIdentification(method, targetClass, txAttr);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || !(tm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">      <span class="comment">// 创建事务，开启事务 &gt;&gt;</span></span><br><span class="line">      TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line"></span><br><span class="line">      Object retVal;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 调用方法逻辑</span></span><br><span class="line">         retVal = invocation.proceedWithInvocation();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">         <span class="comment">// 目标方法抛出异常，结束事务。可能回滚，可能啥也不做</span></span><br><span class="line">         completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// 清理事务现场</span></span><br><span class="line">         cleanupTransactionInfo(txInfo);</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line"><span class="comment">// 提交事务</span></span><br><span class="line">      commitTransactionAfterReturning(txInfo);</span><br><span class="line">      <span class="keyword">return</span> retVal;</span><br><span class="line">   &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里找到事务创建的方法<code>createTransactionIfNecessary</code>，跟进方法：</p><p><code>DelegatingTransactionAttribute</code>是<code>TransactionAttribute</code>的代理实现类，这里用静态代理。为什么要用代理类？因为<code>TransactionAttribute</code>是接口，不能实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> TransactionInfo <span class="title">createTransactionIfNecessary</span><span class="params">(@Nullable PlatformTransactionManager tm,</span></span></span><br><span class="line"><span class="function"><span class="params">      @Nullable TransactionAttribute txAttr, <span class="keyword">final</span> String joinpointIdentification)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 事务如果没有指定名称，用之前生成的方法切入点id作为事务名称</span></span><br><span class="line">   <span class="keyword">if</span> (txAttr != <span class="keyword">null</span> &amp;&amp; txAttr.getName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      txAttr = <span class="keyword">new</span> DelegatingTransactionAttribute(txAttr) &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> joinpointIdentification;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   TransactionStatus status = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tm != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 就是在这里创建事务开启事务了，事务的属性传进去</span></span><br><span class="line">         status = tm.getTransaction(txAttr);</span><br><span class="line">      &#125;</span><br><span class="line">      ... <span class="comment">// 日志操作</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进方法<code>getTransaction</code>，该方法将返回一个<code>TransactionStatus</code>类型的结果，这个叫事务状态的返回结果持有创建的事务对象（逻辑事务），以及该事务对象的一些状态信息。</p><p>那我们来看一下这个获取事务的方法的整一个流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title">getTransaction</span><span class="params">(@Nullable TransactionDefinition definition)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">   TransactionDefinition def = (definition != <span class="keyword">null</span> ? definition : </span><br><span class="line">                                TransactionDefinition.withDefaults());</span><br><span class="line"><span class="comment">// doGetTransaction()从当前上下文中获取事务对象，这是一个抽象方法，子类实现 &gt;&gt;</span></span><br><span class="line">   Object transaction = doGetTransaction();</span><br><span class="line">   <span class="keyword">boolean</span> debugEnabled = logger.isDebugEnabled();</span><br><span class="line"> <span class="comment">//若被调用的事务方法已处于事务之中（事务方法A调用事务方法B）</span></span><br><span class="line">   <span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line">      <span class="comment">// 根据当前事务的传播属性，来决定下一步处理 &gt;&gt;</span></span><br><span class="line">      <span class="keyword">return</span> handleExistingTransaction(def, transaction, debugEnabled);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">//-----------------------当前还没有事务会往下走-----------------------</span></span><br><span class="line">   <span class="comment">// 检查超时设置是否合理</span></span><br><span class="line">   <span class="keyword">if</span> (def.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InvalidTimeoutException(<span class="string">"Invalid transaction timeout"</span>, def.getTimeout());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 若配置的事务传播属性是MANDATORY（该配置表示当前存在事务则加入，否则），抛异常</span></span><br><span class="line">   <span class="keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line">            <span class="string">"No existing transaction found for transaction marked with propagation 'mandatory'"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">         def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">         def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">      SuspendedResourcesHolder suspendedResources = suspend(<span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">         logger.debug(<span class="string">"Creating new transaction with name ["</span> + def.getName() + <span class="string">"]: "</span> + def);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">         DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">               def, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">         doBegin(transaction, def);  <span class="comment">//  开启一个新事务</span></span><br><span class="line">         prepareSynchronization(status, def);</span><br><span class="line">         <span class="keyword">return</span> status;</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">   &#125;<span class="keyword">else</span></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在分析以上代码之前，首先需要明白几个概念，最终要搞清楚几个问题：</p><ol><li>物理事务就是到数据库的一个物理链接（数据库连接），那么这个链接是什么时候获取的？建立连接后又是如何保存起来的？</li><li>逻辑事务就是一个带有spring事务注解的方法，它需要关联到一个物理事务上。那它们之间如何进行关联？</li><li>多个逻辑事务可以映射到一个物理事务上，逻辑事务是各自提交的，如何处理逻辑事务提交和物理事务提交间的关系呢，至少所有的逻辑事务都提交了才可以提交物理事务。</li></ol><hr><p>带着问题来分析获取事务的方法：</p><h6 id="2-2-3-doGetTransaction"><a href="#2-2-3-doGetTransaction" class="headerlink" title="2.2.3 doGetTransaction"></a>2.2.3 doGetTransaction</h6><p>接下来的分析都是以数据源事务管理器为列进行的，首先来看<code>doGetTransaction()</code>这个方法，这个方法首先会创建一个逻辑事务对象<code>DataSourceTransactionObject</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataSourceTransactionManager</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doGetTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 创建事务对象（逻辑事务）</span></span><br><span class="line">   DataSourceTransactionObject txObject = <span class="keyword">new</span> DataSourceTransactionObject();</span><br><span class="line">   txObject.setSavepointAllowed(isNestedTransactionAllowed());</span><br><span class="line">   <span class="comment">// 从线程私有变量中获取物理事务，没有事务嵌套，获取到的是null</span></span><br><span class="line">   ConnectionHolder conHolder =</span><br><span class="line">         (ConnectionHolder) TransactionSynchronizationManager.getResource(obtainDataSource());</span><br><span class="line">   <span class="comment">// 将获取到的物理事务 绑定给 逻辑事务对象 false表示这个物理事务不是新创建的</span></span><br><span class="line">   txObject.setConnectionHolder(conHolder, <span class="keyword">false</span>);</span><br><span class="line">   <span class="keyword">return</span> txObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑事务对象中到底有哪些内容呢</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceTransactionObject</span> <span class="keyword">extends</span> <span class="title">JdbcTransactionObjectSupport</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 新连接标志，当事务对象新获取一个数据库连接是，设为true </span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> newConnectionHolder;  </span><br><span class="line">  <span class="comment">// 当数据库连接开启自动提交，逻辑事务关闭它之前，会先保存这个状态</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> mustRestoreAutoCommit; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*------------- 继承到的属性----------------*/</span></span><br><span class="line">  <span class="meta">@Nullable</span>  <span class="comment">// 数据库连接封装类对象</span></span><br><span class="line"><span class="keyword">private</span> ConnectionHolder connectionHolder;</span><br><span class="line"><span class="meta">@Nullable</span>  <span class="comment">// 隔离级别</span></span><br><span class="line"><span class="keyword">private</span> Integer previousIsolationLevel;</span><br><span class="line">  <span class="comment">//是否允许设置保存点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> savepointAllowed = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据源事务对象中最重要的成员变量是就是<code>ConnectionHolder</code>，它是数据库连接的封装类，创建逻辑事务时，它为null。也就是说逻辑事务创建的时候并没有关联到物理事务（数据库连接）</p><p>现在回到<code>doGetTransaction</code>方法，接下来的关键点是尝试获取线程中已经获得的物理事务，在事务同步管理器<code>TransactionSynchronizationManager</code>中，有几个线程私有的变量（ThreadLocal）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionSynchronizationManager</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 存储事务资源 map的key是数据源DataSource，value是ConnectionHolder（内含数据库连接）</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources =</span><br><span class="line">         <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Transactional resources"</span>);</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt; synchronizations =</span><br><span class="line">         <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Transaction synchronizations"</span>);</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; currentTransactionName =</span><br><span class="line">         <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Current transaction name"</span>);</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; currentTransactionReadOnly =</span><br><span class="line">         <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Current transaction read-only status"</span>);</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; currentTransactionIsolationLevel =</span><br><span class="line">         <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Current transaction isolation level"</span>);</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; actualTransactionActive =</span><br><span class="line">         <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Actual transaction active"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>事务性资源是存储在Map&lt;Object, Object&gt;里，key就是DataSource对象，value就是ConnectionHolder对象，那么是怎么知道key和value的类型的呢？往下看会看到map的put操作</p></li><li><p>事务同步这个集合Set<transactionsynchronization>，只有在多个数据源的分布式事务时才使用。</transactionsynchronization></p></li><li><p>剩下的是四个和事务相关的变量，事务名称/是否只读/隔离级别/是否激活。</p></li></ul><p>此处重点关注叫<code>resources</code> 的ThreadLocal变量，该变量一个Map，key是<code>DataSource</code>对象，value是<code>ConnectionHolder</code>对象，那么这就意味着<strong><em>每个线程在同一个数据源上只能获取一个连接绑定到这个变量中</em></strong></p><p><code>TransactionSynchronizationManager.getResource(obtainDataSource())</code>这一句执行完如果能够获取到一个连接说明什么？说明当前已经有一个逻辑事务获取了同一个数据源的连接并绑定到了map中，说明现在正在获取的逻辑事务在另一个逻辑事务之中。</p><p>如果没有事务嵌套的话，这一句代码执行获取到的肯定是null。</p><hr><h6 id="2-2-4-handleExistingTransaction"><a href="#2-2-4-handleExistingTransaction" class="headerlink" title="2.2.4 handleExistingTransaction"></a>2.2.4 handleExistingTransaction</h6><p>获取事务对象之后，继续往下将执行<code>isExistingTransaction()</code>方法，该方法判断获取到的事务对象是否已经存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isExistingTransaction</span><span class="params">(Object transaction)</span> </span>&#123;</span><br><span class="line">   DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;</span><br><span class="line">   <span class="keyword">return</span> (txObject.hasConnectionHolder() &amp;&amp;  </span><br><span class="line">           txObject.getConnectionHolder().isTransactionActive());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要是检查事务对象中是否设置了<code>ConnectionHolder</code>，并判断该物理事务是不是已经被激活。</p><p>如果此方法返回true，表明当前获取到的物理事务已经存在，从而表明此处肯定存在逻辑事务的嵌套，这时候应该根据配置的事务传播属性来进行处理，<code>handleExistingTransaction</code>处理逻辑如下：</p><ul><li><p>如果此时事务传播特性是NEVER，则抛出异常。（<u>never表示以非事务的方式执行，存在事务则抛异常</u>）</p></li><li><p>如果此时事务的传播特性是NOT_SUPPORTED，则调用suspend(transaction)挂起当前事务，将被挂起的资源suspendedResources放入事务状态里。（<u>not_supported表示以非事务方式运行，若存在事务则挂起事务</u>）</p></li><li><p>如果此时事务状态是REQUIRES_NEW，则调用suspend(transaction)挂起当前事务，将事务对象transaction和被挂起的资源suspendedResources放入事务状态里。然后调用doBegin(transaction, definition)方法去真正打开事务。最后调用prepareSynchronization(status, definition)方法准备一下事务同步。</p></li><li><p>如果此时事务的传播特性是NESTED，又分三种情况：</p><ul><li>如果不允许嵌套事务，直接抛出异常。</li><li>如果使用保存点（Savepoint）来实现嵌套事务，那直接使用当前事务，创建一个保存点就可以了。</li><li>如果使用新的事务来实现嵌套事务，那就调用doBegin(transaction, definition)开启新的事务，此时不需要挂起当前事务。</li></ul></li><li><p>对于剩下三种传播特性REQUIRED/MANDATORY/SUPPORTS，则不需要创建新事务，直接使用当前事务就可以了。</p></li></ul><hr><h6 id="2-2-5-dobegin"><a href="#2-2-5-dobegin" class="headerlink" title="2.2.5 dobegin()"></a>2.2.5 dobegin()</h6><p>上面也分析了，在首次执行事务方法时，事务肯定是不存在的，因为从线程的ThreadLocal里没有取出<code>ConnectionHolder</code>对象。那此时就要新开一个物理事务，新开物理事务是在<code>doBegin()</code>方法中进行的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBegin</span><span class="params">(Object transaction, TransactionDefinition definition)</span> </span>&#123;</span><br><span class="line">   DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;</span><br><span class="line">   Connection con = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;  <span class="comment">// 若事务对象没有绑定物理资源  或者  持有的物理资源还没有和事务对象同步</span></span><br><span class="line">      <span class="keyword">if</span> (!txObject.hasConnectionHolder() ||</span><br><span class="line">            txObject.getConnectionHolder().isSynchronizedWithTransaction()) &#123;</span><br><span class="line">         <span class="comment">// 创建新连接，封装成物理资源赋值给事务对象</span></span><br><span class="line">         Connection newCon = obtainDataSource().getConnection();</span><br><span class="line">         txObject.setConnectionHolder(<span class="keyword">new</span> ConnectionHolder(newCon), <span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      txObject.getConnectionHolder().setSynchronizedWithTransaction(<span class="keyword">true</span>);</span><br><span class="line">      con = txObject.getConnectionHolder().getConnection();</span><br><span class="line"></span><br><span class="line">      Integer previousIsolationLevel = </span><br><span class="line">        DataSourceUtils.prepareConnectionForTransaction(con, definition);</span><br><span class="line">      txObject.setPreviousIsolationLevel(previousIsolationLevel);</span><br><span class="line"><span class="comment">// 若物理连接开启了自动提交（默认开启）</span></span><br><span class="line">      <span class="keyword">if</span> (con.getAutoCommit()) &#123;</span><br><span class="line">         txObject.setMustRestoreAutoCommit(<span class="keyword">true</span>);   <span class="comment">// 存储物理连接的自动提交状态</span></span><br><span class="line">         con.setAutoCommit(<span class="keyword">false</span>);  <span class="comment">// 关闭物理连接自动提交</span></span><br><span class="line">      &#125;</span><br><span class="line">      prepareTransactionalConnection(con, definition);</span><br><span class="line">      <span class="comment">// 激活物理事务</span></span><br><span class="line">      txObject.getConnectionHolder().setTransactionActive(<span class="keyword">true</span>);</span><br><span class="line">...</span><br><span class="line">      <span class="comment">// 将物理事务绑定到ThreadLocal变量，这里是map的put操作</span></span><br><span class="line">      <span class="keyword">if</span> (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line">         TransactionSynchronizationManager.bindResource</span><br><span class="line">           (obtainDataSource(), txObject.getConnectionHolder());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line">         DataSourceUtils.releaseConnection(con, obtainDataSource());</span><br><span class="line">         txObject.setConnectionHolder(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> CannotCreateTransactionException(</span><br><span class="line">        <span class="string">"Could not open JDBC Connection for transaction"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新事务开启之后，继续回到<code>getTransaction()</code>方法，这个方法返回的是一个事务状态对象，继续看返回值创建的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DefaultTransactionStatus <span class="title">newTransactionStatus</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      TransactionDefinition definition, @Nullable Object transaction, <span class="keyword">boolean</span> newTransaction,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> newSynchronization, <span class="keyword">boolean</span> debug, @Nullable Object suspendedResources)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">boolean</span> actualNewSynchronization = newSynchronization &amp;&amp;</span><br><span class="line">         !TransactionSynchronizationManager.isSynchronizationActive();</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> DefaultTransactionStatus(</span><br><span class="line">         transaction, newTransaction, actualNewSynchronization,</span><br><span class="line">         definition.isReadOnly(), debug, suspendedResources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个对象有很重要的三点：</p><ol><li><p>它需要包含逻辑事务对象（已关联了物理事务）。</p></li><li><p>它需要表明这个事务是一个新开启的物理事务，还是参与到已有的物理事务。</p></li><li><p>它需要包含被挂起的（上一个）物理事务连接（如果有的话）。</p></li></ol><h5 id="2-3-物理事务与逻辑事务的对应关系"><a href="#2-3-物理事务与逻辑事务的对应关系" class="headerlink" title="2.3 物理事务与逻辑事务的对应关系"></a>2.3 物理事务与逻辑事务的对应关系</h5><ul><li><p>当事务A调用事务B并且传播属性允许两个逻辑事务合并时，用一个物理事务执行就可以执行两个逻辑事务，此时物理事务与逻辑事务是<strong>1对多</strong>的关系。</p></li><li><p>事务A中调用事务B，B的传播属性为<strong><em>Propagation.REQUIRES_NEW</em></strong>，物理事务与逻辑事务是<strong>1对1</strong>的关系</p></li><li>不存在1个逻辑事务对应多个物理事务的情况。</li></ul><h5 id="2-4-事务的挂起"><a href="#2-4-事务的挂起" class="headerlink" title="2.4 事务的挂起"></a>2.4 事务的挂起</h5><p>在一些事务的传播模式下，可能会挂起当前的事务，举例：</p><p>事务A中调用事务B，B的传播属性为<strong><em>Propagation.REQUIRES_NEW</em></strong>，这时候需要将事务A挂起，创建事务B运行，创建事务B的时候会将挂起的事务A资源放到事务B的<code>TransactionStatus</code>对象中，事务B结束（提交或回滚）之后，恢复事务A继续执行</p><p>挂起做了哪些工作？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doSuspend</span><span class="params">(Object transaction)</span> </span>&#123;</span><br><span class="line">   DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;</span><br><span class="line">   txObject.setConnectionHolder(<span class="keyword">null</span>);</span><br><span class="line">   <span class="keyword">return</span> TransactionSynchronizationManager.unbindResource(obtainDataSource());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将事务对象中的ConnectionHolder清空</li><li>将ThreadLocal中的数据源对应的ConnectionHolder清除，并返回被清除的ConnectionHolder</li><li>将返回的ConnectionHolder封装成SuspendedResourcesHolder，保存到创建的新事务对象中</li></ul><p>为什么要这么做？</p><p>ThreadLocal资源虽然是一个map，但是这个map的数据源是key，这意味着每个线程在同一个数据源上只能使用一个连接（可以持有多个连接，但同一时间只能使用一个，单线程）。事务A在挂起的时候将物理连接保存起来，然后事务B再重新获取一个连接执行操作，事务B结束之后，再取出事务A对应的物理资源，继续执行事务A。</p><p>因此可以得出结论：逻辑事务没有结束之前，对应的物理事务是不能执行其他事务操作的，物理事务上应该是保存了事务的状态信息（未提交），不能串着用</p><p><a href="https://mp.weixin.qq.com/s/i0QmrEDZ6aTsZFFahYC_ow" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/i0QmrEDZ6aTsZFFahYC_ow</a>  </p><p><a href="https://mp.weixin.qq.com/s/sysm3AY7PG9MV9584UTasg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/sysm3AY7PG9MV9584UTasg</a>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;复习总结：&quot;&gt;&lt;a href=&quot;#复习总结：&quot; class=&quot;headerlink&quot; title=&quot;复习总结：&quot;&gt;&lt;/a&gt;复习总结：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;注解式事务是通过aop实现的，底层是cglib动态代理实现的&lt;ul&gt;
&lt;li&gt;事务aop场景中的Advi
      
    
    </summary>
    
      <category term="SpringBoot" scheme="http://yoursite.com/child/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/child/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>redis-高可用架构集解析</title>
    <link href="http://yoursite.com/child/2020/06/02/redis-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/child/2020/06/02/redis-高可用架构解析/</id>
    <published>2020-06-01T16:00:00.000Z</published>
    <updated>2020-11-27T07:32:38.442Z</updated>
    
    <content type="html"><![CDATA[<p>目标：</p><p>1、掌握redis主从复制的配置和原理</p><p>2、掌握redis哨兵机制的原理和实战</p><p>3、掌握redis分布式的各种方案对比，包括客户端sharding、代理Proxy、和redis cluster</p><p>为什么要分布式部署redis？</p><p>在分布式环境下，任何组件都要保证以下三点</p><ul><li>性能</li><li>高可用</li><li>可扩展</li></ul><p>要做到以上三点需要依赖两种关键技术，一种是分片，一种是冗余。</p><p>分片就是把所有数据拆分到多个节点存储。</p><p>冗余就是在每个节点都有一个或者多个副本。</p><p>那么redis必须要提供数据分片和主从复制的功能，副本有不同的角色，如果主节点发生故障，则把某个从节点自动升级为主节点</p><p>所以本文主要围绕三点进行讨论：</p><p>1、主从复制怎么实现</p><p>2、主从切换怎么实现</p><p>3、数据分片怎么实现</p><h3 id="1、redis主从复制"><a href="#1、redis主从复制" class="headerlink" title="1、redis主从复制"></a>1、redis主从复制</h3><p>跟kafka、rocketmq等分布式组件一样，redis支持集群架构，集群的节点有主从之分，主节点叫master，从节点叫slave。slave会通过复制技术，自动同步master的数据</p><h4 id="1-1-主从复制配置"><a href="#1-1-主从复制配置" class="headerlink" title="1.1 主从复制配置"></a>1.1 主从复制配置</h4><p>redis的主从复制配置非常简单，有三种方式，</p><p>第一种：只需要在从节点的配置文件redis.conf中添加一行配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicaof ip port</span><br></pre></td></tr></table></figure><p>从节点启动之后，就会自动的连接到master节点开始同步数据。</p><p>如果master节点宕机了，选举出了新的master，这个配置在内存中会被重写。</p><p>第二种方式，就是在启动redis服务时通过参数指定master节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-server --slaveof ip port</span><br></pre></td></tr></table></figure><p>一个正在运行中的节点，也可以变成其他节点的从节点，这就是第三种方式：在客户端执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof ip port</span><br></pre></td></tr></table></figure><p>需要注意的是，一个从节点也可以是其他从节点的主节点，形成级联复制的关系。</p><p>通过以下命令查看集群状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; info replication</span><br></pre></td></tr></table></figure><p>从节点是只读的，不能执行写操作，执行写命令会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（error）READONLY</span><br></pre></td></tr></table></figure><p>在主节点写入后，slave会自动从master同步数据</p><p>从节点也可以改变从属关系，自己单飞</p><p>将redis.conf中的replica of配置去掉并重启，或者在客户端直接断开复制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; slaveof no one</span><br></pre></td></tr></table></figure><p>MySql的主从复制原理我们是清楚地，依赖binglog文件，然后还有几个线程。那么redis呢？</p><p>接下来研究主从复制到底是怎么实现的</p><h4 id="1-2-主从复制原理"><a href="#1-2-主从复制原理" class="headerlink" title="1.2 主从复制原理"></a>1.2 主从复制原理</h4><p>主从复制分为两类：全量复制   和   增量复制。</p><p>全量复制就是一个从节点第一次连接到主节点，需同步全部的数据；</p><p>增量复制就是从节点网络断开了或者宕机了，重启之后缺了一部分数据需要同步。</p><h5 id="1-2-1-连接阶段"><a href="#1-2-1-连接阶段" class="headerlink" title="1.2.1 连接阶段"></a>1.2.1 连接阶段</h5><p>​    1、slave节点启动时，或者执行slaveof命令是，会在自己本地保存master节点的信息，包括master 节点的host和port</p><p>​    2、slave节点内部有个定时任务replicationCron，每隔1秒检查是否有新的master节点要连接和复制，见源码replication.c 3132line</p><p>​    如果发现有master节点，就跟master节点建立连接，如果连接成功，从节点就为连接，为了让主节点感知到slave节点的存活，从节点会定时给主节点发送ping请求</p><p>​    建立连接之后就可以同部署绝了，这里分为两个阶段</p><h5 id="2-2-2-数据同步阶段"><a href="#2-2-2-数据同步阶段" class="headerlink" title="2.2.2 数据同步阶段"></a>2.2.2 数据同步阶段</h5><p>​    如果是新加入的slave节点，那就需要全量复制。master通过bgsave命令在本地生成一份RDB快照文件，将快照发给slave节点（如果超时会重连，可以调大repl-timeout的值）</p><p>​    问题：如果slave几点自己本来有数据怎么办？</p><p>​    slave节点首先需要清除自己的旧数据，然后用RDB文件加载数据。</p><p>​    问题：master节点生成RDB期间，接收到的写命令怎么处理？</p><p>​    开始生成快照文件是，master会把所有的新命令缓存在内存中。在slave节点保存了RDB之后，再将新的写命令复制给slave节点（跟AOF重写rewrite期间接收到的命令处理思路是一样的）</p><p>​    第一次全量同步完了，主从已经保持一致了，后面的就是持续把接收到的命令发送给slave节点。</p><h5 id="2-2-3-命令传播阶段"><a href="#2-2-3-命令传播阶段" class="headerlink" title="2.2.3 命令传播阶段"></a>2.2.3 命令传播阶段</h5><p>​    主节点持续吧命令异步复制给从节点。</p><p>​    总结起来很简单，前面用RDM文件，后面吧命令发给slave节点，就实现了主从复制。</p><p>​    注意：一般情况下我们不会用redis做读写分离，因为redis的吞吐量已经够高了，做集群分片之后并发问题更少，所以不需要考虑主从延迟的问题</p><p>​    与Mysql一样，主从复制延迟是不可避免的，只能通过优化网络来改善</p><p>​    第二种情况技术增量复制了。</p><p>​    slave通过master_repl_offset记录的偏移量，来记录上次复制到哪里，用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt;info replication</span><br></pre></td></tr></table></figure><p>可以查看到这个偏移量属性。</p><p>​    redis从2.8.18版本开始支持无盘复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-diskless-sync=no</span><br></pre></td></tr></table></figure><p>​    为了降低主节点的磁盘开销，Redis支持无盘复制，master生成的RDB文件不保存到磁盘而是直接通过网络发送给从节点。无盘复制适用于主节点所在的机器磁盘性能较差但是带宽比较充裕的的场景。</p><h4 id="1-3-主从复制的不足"><a href="#1-3-主从复制的不足" class="headerlink" title="1.3 主从复制的不足"></a>1.3 主从复制的不足</h4><p>​    redis主从复制解决了数据备份和一部分性能的问题，但是没有解决高可用的问题，在一主一从或者一主多从的情况下，如果主服务器挂了，对外提供的服务就不可用了，单点问题没有得到解决。</p><p>​    如果每次都是手动把之前的从服务切换成主服务器，然后把剩余节点设置成它的从节点，太费时费力，还会造成一定时间服务器不可用。</p><h3 id="2、可用性保证之哨兵Sentinel"><a href="#2、可用性保证之哨兵Sentinel" class="headerlink" title="2、可用性保证之哨兵Sentinel"></a>2、可用性保证之哨兵Sentinel</h3><h4 id="2-1-Sentinel原理"><a href="#2-1-Sentinel原理" class="headerlink" title="2.1 Sentinel原理"></a>2.1 Sentinel原理</h4><p>怎么实现高可用呢？</p><p>对于服务起来说，能够实现主从自动切换</p><p>对于客户端来说，能够获取最新的master</p><p>要实现以上两点，我们就必须引入一个第三方来管理redis节点的存活状态，而且具备路由功能，例如rocketmq的nameserver</p><p>思路：</p><p>创建一台监控服务器监控所有的redis服务节点的状态，比如，master节点超过一定时间没有给监控服务发送心跳报文，酒吧master下线，然后把某一个slave编程master。应用每一次都是从这个监控服务器拿到master地址的。</p><p>问题：如果监控服务器出问题怎么办，那还要创建一个监控服务器来监控监控服务器吗。。。这似乎陷入了死循环。</p><p>redis的高可用是通过哨兵Sentinel来保证的。它的思路就是通过运行监控服务器来保证服务的可用性。</p><p>从redis2.8开始，redis就提供了一个稳定版本的Sentinel来解决高可用问题。</p><p>我们一般会启动奇数个的Sentinel服务</p><p>用脚本启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-sentinel ../sentinel.con</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-server ../sentinel.con --sentinel</span><br></pre></td></tr></table></figure><p>它本质上是一个运行在特殊模式下的redis。Sentinel通过info命令得到被监听Redis机器的master，slave信息。</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/redis/redis-sentinel-%E6%9E%B6%E6%9E%84.png" alt="Sentinel" style="zoom:67%;"></p><p>为了保证可用性，会对Sentinel最集群部署。Sentinel既监控所有的Redis服务，Sentinel之间也会互相监控。</p><p>注意：Sentinel本身没有主从之分</p><p>问题：Sentinel之间唯一的联系就是他们监控相同的redis节点，那他们怎么知道相互之间存在的？</p><p>答案是使用redis的发布订阅功能：</p><p>Sentinel上线时，给所有的Redis节点的<code>__sentinel__:hello</code>频道（channel）发送消息；</p><p>每个Sentinel都订阅了所有redis节点的<code>__sentinel__:hello</code>频道，所以能互相感知对方的存在。</p><h5 id="2-1-1-服务下线"><a href="#2-1-1-服务下线" class="headerlink" title="2.1.1 服务下线"></a>2.1.1 服务下线</h5><p>问题：Sentinel如何感知master下线了？</p><p>Sentinel默认每秒1次的频率向Redis服务节点发送Ping命令，如果指定时间没有收到回复（默认30秒。可配置）Sentinel将该节点标记为下线（主观下线）</p><p>时间配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span><br></pre></td></tr></table></figure><p>但是，自己发现master下线不能代表真的下线，万一是你自己网络问题呢，这时候Sentinel会询问其他的Sentinel节点，确认是否真的下线，如果多数Sentinel节点都认为该master下线了，那才真的下线（客观下线）</p><p>确认下线后，要重新选举master</p><h5 id="2-1-2-故障转移"><a href="#2-1-2-故障转移" class="headerlink" title="2.1.2 故障转移"></a>2.1.2 故障转移</h5><p>redis的选举和故障转移都是由Sentinel完成的。</p><p>问题：有这么多的Sentinel节点，谁来做呢？</p><p>故障转移的第一步就是在Sentinel集群选择一个Leader，有Leader完成故障转移流程、Sentinel通过Raft算法，实现leader选举的。</p><p>问题：那么Sentinel leader又是根据什么来选举redis的呢？</p><p>对于所有的slave节点，一共有四个因素会影响选举的结果，分别是断开连接时长，优先级排序，复制数量和进程id</p><ol><li>如果节点与哨兵连接断开的比较久，超过某个阈值，直接失去选举权</li><li>有选举全，再看谁的优先级高，这个在配置文件中可以配置（replica-priority 100），数字越小优先级越大</li><li>优先级相同，比较谁的偏移量大</li><li>最后在比较谁的进程id小</li></ol><p>master节点确定之后，要将其他的节点设置为他的从节点，</p><ol><li>Sentinel leader向master节点发送命令 slaveof no one</li><li>再向其他节点发送slaveof ip port，让他成为主节点的从节点，故障转移完成。</li></ol><h4 id="2-2-Sentinel功能总结"><a href="#2-2-Sentinel功能总结" class="headerlink" title="2.2 Sentinel功能总结"></a>2.2 Sentinel功能总结</h4><p>监控：Sentinel会不断检查节点是否正常运行</p><p>通知：若某节点被监控到出问题，Sentinel会通过api发出通知</p><p>自动故障转移</p><p>配置管理：客户端只需要连接到Sentinel集群，就能获取当前redis集群的master</p><p>哨兵机制的不足：</p><ol><li>主从切换过程会丢失数据，因为只有一个master</li><li>只能单点写，没有解决水平扩容</li></ol><p>如果数据量非常大，这时候就要对redis进行数据分片</p><p>这时候我们需要多个master-slave的group    ，把数据分布到不同的group中。</p><p>问题：怎么分片？分片后怎么路由？</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/redis/redis-shard.png" alt="redsi-groups" style="zoom:67%;"></p><h3 id="3、redis数据分片方案"><a href="#3、redis数据分片方案" class="headerlink" title="3、redis数据分片方案"></a>3、redis数据分片方案</h3><p>三种方案：</p><p>第一种：在客户端实现相关分片逻辑，例如用取模或者一致性哈希对key进行分片，查询和修改都先判断key路由</p><p>第二种：把做分片处理的逻辑抽取出来，运行一个独立的代理服务，客户端连接到这个代理服务，代理服务做请求的转发。</p><p>第三种：基于服务端实现。</p><h4 id="3-1-客户端分片"><a href="#3-1-客户端分片" class="headerlink" title="3.1 客户端分片"></a>3.1 客户端分片</h4><p>​    Jedis客户端中就支持分片功能，Jedis是Spring Boot 2.X版本之前默认的Redis客户端，RedisTemplate就是对Jedis的封装</p><h5 id="3-1-1-ShardedJedis"><a href="#3-1-1-ShardedJedis" class="headerlink" title="3.1.1 ShardedJedis"></a>3.1.1 ShardedJedis</h5><h5 id="3-1-2-一致性hash算法"><a href="#3-1-2-一致性hash算法" class="headerlink" title="3.1.2 一致性hash算法"></a>3.1.2 一致性hash算法</h5><p>把所有的哈希值空间组织成一个虚拟的圆环，整个空间按顺时针方向组织。因为是环形空间，0和2^32-1是重叠的。</p><p>每个节点在哈希环上都有一个位置，</p><p>先对key进行hash，根据hash值落在环上的位置按照顺时针的方向找，找到第一个节点就将该key存入。</p><p>虚拟节点–解决节点分布不均匀的问题</p><p>jedis对一致性hash的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-2-代理分片"><a href="#3-2-代理分片" class="headerlink" title="3.2 代理分片"></a>3.2 代理分片</h4><p>典型的代理分区方案有：</p><p>Twitter开源的Twemproxy</p><p>豌豆荚开源的codis</p><h5 id="3-2-1-Twemproxy"><a href="#3-2-1-Twemproxy" class="headerlink" title="3.2.1 Twemproxy"></a>3.2.1 Twemproxy</h5><p>优点：比较稳定，可用性高</p><p>不足：</p><ol><li>出现故障不能自动转移，架构复杂，需要借助其他组件实现高可用（LVS/HAProxy + Keepalived)</li><li>扩缩绒需要修改配置，不能实现平滑的扩缩绒</li></ol><h5 id="3-2-2-codis"><a href="#3-2-2-codis" class="headerlink" title="3.2.2 codis"></a>3.2.2 codis</h5><p>​    Codis是一个代理中间件，豌豆荚用GO语言开发，跟Mycat是一类的组件。</p><p>​    功能：客户端连接Codis和连接Redis没有区别</p><p>​    分片原理：Codis把所有的key分成了N个槽（例如1024），每个草对应一个分组，一个分组对应一个或者一组Redis实例。Codis对key进行CRC32运算，得到一个32位的数字，然后模以N，得到余数，这个余数就是key对应的槽，槽能对应道redis节点，跟Mycat的先取模后范围思想类似。</p><p>​    Codis的槽位映射关系是保存在proxy中的，如果要解决单点故障问题，Codis也要组集群部署，多个Codis节点要同步槽和节点映射关系需要运行一个zookeeper。</p><p>​    再新增节点的时候，可以为节点指定特定的槽位，Codis也提供了自动均衡策略。</p><p>​    Codis不支持事务，其他一些命令也不支持</p><p>​    获取数据原理：以mget为例，在各个节点中获取到符合的key，然后在汇总到Codis中返回给客户端</p><p>​    Codis是第三方提供的分布式解决方案，在官网的集群功能稳定前，Codis也得到了大量的应用。</p><h4 id="3-3-redis-cluster"><a href="#3-3-redis-cluster" class="headerlink" title="3.3 redis cluster"></a>3.3 redis cluster</h4><p>​    Redis Cluster是在Redis3.0的版本正式推出的，用来解决分布式的需求，同时也可以实现高可用。跟Codis不一样，它是去中心化的，客户端可以连接到任意一个可用的节点。</p><p>​    数据分片需要解决的问题：</p><pre><code>- 数据怎么相对均匀的分片- 客户端怎么访问到相应的节点- 重新分片的过程，怎么保证正常服务</code></pre><h5 id="3-3-1-架构"><a href="#3-3-1-架构" class="headerlink" title="3.3.1 架构"></a>3.3.1 架构</h5><p>Redis Cluster 可以看成由多个节点组成的数据集合。客户端不需要关注数据的子集到底存在哪个节点，只需要关注这个集合整体。</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/redis/redis-cluster-%E6%9E%B6%E6%9E%84.png" style="zoom:67%;"></p><h5 id="3-3-2-搭建"><a href="#3-3-2-搭建" class="headerlink" title="3.3.2 搭建"></a>3.3.2 搭建</h5><h5 id="3-3-3-数据分布"><a href="#3-3-3-数据分布" class="headerlink" title="3.3.3 数据分布"></a>3.3.3 数据分布</h5><p>使用虚拟槽位实现数据的分片</p><p>Redis创建了16384个槽（slot），每个redis group负责一定区间的slot</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/redis/redis-cluster.png" alt="redis-cluster架构" style="zoom:67%;"></p><p>对象分布到Redis节点上时，对Key用CRC16算法计算再模以16384，得到slot值，数据落到负责该槽位的节点上。</p><p>集群的每个master节点都会维护自己负责的slot，用一个bit序列实现，比如：序列的第0位是1，代表第一个sloat由他负责，为0表示不负责。</p><p>查看key属于哪个slot：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt;cluster keyslot zzk</span><br></pre></td></tr></table></figure><p>问题：如何让相关的数据落到一个节点上？</p><p>比如有些multi key操作是不能跨节点的，</p><p>在key里面加入<code>{hash tag}</code>即可。redis在计算slot时只会获取{}之间的字符串进行slot计算，</p><h5 id="3-3-4-客户端重定向"><a href="#3-3-4-客户端重定向" class="headerlink" title="3.3.4 客户端重定向"></a>3.3.4 客户端重定向</h5><p>问题：客户端连接到那一台服务器？访问的数据不再当前节点上怎么办？</p><p>jedis等客户端会在本地维护一份slot–node的映射关系，大部分时候不需要重定向，所以叫smart jedis（需要客户端支持）</p><h5 id="3-3-5-数据迁移"><a href="#3-3-5-数据迁移" class="headerlink" title="3.3.5 数据迁移"></a>3.3.5 数据迁移</h5><p>问题：新增或下线了master节点，数据如何迁移？</p><p>添加新节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster add-node localip localport  newip newport</span><br></pre></td></tr></table></figure><p>新增的节点没有hash槽，不能分配数据，在原来任意一个节点上执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster reshard localip localport</span><br></pre></td></tr></table></figure><p>输入需要分配的哈希槽的数量和哈希槽的来源节点</p><h5 id="3-3-6-高可用和主从切换原理"><a href="#3-3-6-高可用和主从切换原理" class="headerlink" title="3.3.6 高可用和主从切换原理"></a>3.3.6 高可用和主从切换原理</h5><p>当slave发现自己的master变为FAIL状态时，边仓石进行Failover，以期称为新的master。由于挂掉的master可能有多个slave，从而存在slave竞争上岗的过程：</p><ol><li>slave发现自己的master变为Fail</li><li>将自己记录的集群currentEpoch+1，并广播FAILOVER_AUTH_REQUEST信息</li><li>其他节点收到该信息，只有master（其他group的master）响应，判断请求者的合法性，并发送FAILOVER_AUTH_ACK,，对每个epoch只发送一个一次ack</li><li>尝试failover的slaver收集FAILOVER_AUTH_ACK</li><li>超过半数后变成新的master</li><li>广播PONG通知其他集群节点。</li></ol><p>总结：Redis Cluster既能实现主从角色分配，又能实现主从切换，相当于继承了Replication和Sentinel的功能</p><h5 id="3-3-7-总结"><a href="#3-3-7-总结" class="headerlink" title="3.3.7 总结"></a>3.3.7 总结</h5><p>redis cluster特点：</p><ol><li>无中心架构</li><li>数据按照slot存储分布在多个节点，节点间数据共享，可动态调整数据分布。</li><li>可扩展性，可线性扩展到1000个节点，官方推荐不超过1000个，节点可动态添加或删除</li><li>高可用性，部分节点不可用时，集群仍可用。通过增加slave做standby数据副本，能够实现故障自动failover，节点之间通过gossip协议贾环状态信息，用投票机制完成slave到master的角色提升</li><li>运维成本极低</li></ol><p><a href="https://www.cnblogs.com/ivictor/p/9762394.html" target="_blank" rel="noopener">深入理解Redis Cluster</a></p><p><a href="https://www.cnblogs.com/rjzheng/p/10360619.html" target="_blank" rel="noopener">那些年用过的Redis集群架构（含面试解析）</a>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目标：&lt;/p&gt;
&lt;p&gt;1、掌握redis主从复制的配置和原理&lt;/p&gt;
&lt;p&gt;2、掌握redis哨兵机制的原理和实战&lt;/p&gt;
&lt;p&gt;3、掌握redis分布式的各种方案对比，包括客户端sharding、代理Proxy、和redis cluster&lt;/p&gt;
&lt;p&gt;为什么要分布式部
      
    
    </summary>
    
      <category term="noSql" scheme="http://yoursite.com/child/categories/noSql/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/child/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud-分布式事务Seate-AT</title>
    <link href="http://yoursite.com/child/2020/05/17/SpringCloud-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1Seate-AT/"/>
    <id>http://yoursite.com/child/2020/05/17/SpringCloud-分布式事务Seate-AT/</id>
    <published>2020-05-16T16:00:00.000Z</published>
    <updated>2020-11-27T01:15:06.712Z</updated>
    
    <content type="html"><![CDATA[<p>Seata 是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布 式事务服务。在 Seata 开源之前，Seata 对应的内部版本在阿里经济体内部一直扮演着分布式一 致性中间件的角色，帮助经济体平稳的度过历年的双11，对各BU业务进行了有力的支撑。经过多 年沉淀与积累，商业化产品先后在阿里云、金融云进行售卖。2019.1 为了打造更加完善的技术生 态和普惠技术成果，Seata 正式宣布对外开源，未来 Seata 将以社区共建的形式帮助其技术更加 可靠与完备。</p><p>Seata 将 为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。</p><h3 id="1、基本流程"><a href="#1、基本流程" class="headerlink" title="1、基本流程"></a>1、基本流程</h3><p>Seata AT模式实际上是2PC协议的一种演变方式，也是通过两个阶段的提交或者回滚来保证多节点事务的一致性。</p><ul><li><p>第一个阶段， 应用系统会把一个业务数据的事务操作和回滚日志记录在同一个本地事务中提交， 在提交之前，会向TC(seata server)注册事务分支，并申请针对本次事务操作的表的全局锁。</p><p>接着提交本地事务，本地事务会提交业务数据的事务操作以及UNDO_LOG，放在一个事务中提交。</p></li><li><p>第二个阶段，这一个阶段会根据参与到同一个XID下所有事务分支在第一个阶段的执行结果来决定事务的提交或者回滚，这个回滚或者提交是TC来决定的，它会告诉当前XID下的所有事务分支，提交或者回滚。</p><ul><li>如果是提交， 则把提交请求放入到一个异步任务队列，并且马上返回提交成功给到TC，这样可以避免阻塞问题。而这个异步任务，只需要删除UNDO_LOG就行，因为原本的业务事务已经提交了。</li><li>如果是回滚，则开启一个本地事务，执行以下操作<ul><li>通过XID和Branch ID查找到响应的UNDO_LOG记录</li><li>数据校验，拿到UNDO_LOG中after image(修改之后的数据)和当前数据进行比较， 如果有不同，说明数据被当前全局事务之外的动作做了修改，这种情况需要根据配置策略来做处理。</li><li>根据UNDO_LOG中的before image和业务SQL的相关信息生成并执行回滚语句</li><li>提交本地事务，并把本地事务的执行结果上报给TC</li></ul></li></ul></li></ul><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/seata/AT%E6%A8%A1%E5%BC%8F.png" style="zoom:67%;"></p><h3 id="2、基本使用"><a href="#2、基本使用" class="headerlink" title="2、基本使用"></a>2、基本使用</h3><p>seata提供了各种环境中使用的样例，本文样例基于spring-cloud-alibaba</p><h4 id="2-1-seata-server部署"><a href="#2-1-seata-server部署" class="headerlink" title="2.1 seata server部署"></a>2.1 seata server部署</h4><p>下载seata-server</p><p><a href="https://github.com/seata/seata/releases" target="_blank" rel="noopener">seata-server</a></p><p>修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">registry &#123;</span><br><span class="line">  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa</span><br><span class="line">  type = &quot;nacos&quot;</span><br><span class="line"></span><br><span class="line">  nacos &#123;</span><br><span class="line">    serverAddr = &quot;localhost&quot;</span><br><span class="line">    namespace = &quot;piblic&quot;</span><br><span class="line">    cluster = &quot;default&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际中遇到问题，注册到nacos上时，默认获取到的是虚拟ip，不能跨网段访问，最终使用file方式配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-2-seata-client端配置"><a href="#2-2-seata-client端配置" class="headerlink" title="2.2 seata client端配置"></a>2.2 seata client端配置</h4><p>遇到的各种问题汇总：</p><p>1、【服务ip不稳定问题】使用dubbo作为微服务框架，服务注册时获取到的是ip地址是127.0.0.1，导致服务间不能互相调用</p><p>2、【seata-server注册到nacos，ip不稳定】发布的总是虚拟网段的ip地址，导致外域的服务不能访问seata-server</p><p>3、没有配置dubbo.scan属性，导致服务不能被dubbo发布</p><p>4、服务超时事件配置太短（或者没有配置），导致在一个调用链总是超时失败</p><p>5、数据库配置不正确，导致工程启动总是报一个错误：关键字importRegister</p><h4 id="2-3-AT运行原理"><a href="#2-3-AT运行原理" class="headerlink" title="2.3 AT运行原理"></a>2.3 AT运行原理</h4><p>AT模式属于强一致事务模型，工作时离不开几个表：</p><h4 id="3-1-undo-log"><a href="#3-1-undo-log" class="headerlink" title="3.1 undo_log"></a>3.1 undo_log</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> undo_log</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">id</span>            <span class="built_in">BIGINT</span>(<span class="number">20</span>)   <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    branch_id     <span class="built_in">BIGINT</span>(<span class="number">20</span>)   <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    xid           <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="keyword">context</span>       <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    rollback_info LONGBLOB     <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    log_status    <span class="built_in">INT</span>(<span class="number">11</span>)      <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    log_created   DATETIME     <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    log_modified  DATETIME     <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>),</span><br><span class="line">    <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> ux_undo_log (xid, branch_id)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span> AUTO_INCREMENT = <span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br></pre></td></tr></table></figure><p>该表每个业务库需要有一个，用于记录全局事务在提交之前，当前库的事务分支的处理前后的现场</p><h4 id="3-2-三表"><a href="#3-2-三表" class="headerlink" title="3.2 三表"></a>3.2 三表</h4><p>global_table  存储全局事务</p><p>branch_table 存储事务分支</p><p>lock_table  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- -------------------------------- The script used when storeMode is 'db' ---------------------------------- the table to store GlobalSession data</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`global_table`</span>(    </span><br><span class="line">  <span class="string">`xid`</span> <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,    </span><br><span class="line">  <span class="string">`transaction_id`</span>  <span class="built_in">BIGINT</span>,    </span><br><span class="line">  <span class="string">`status`</span> <span class="built_in">TINYINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,    </span><br><span class="line">  <span class="string">`application_id`</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>),    </span><br><span class="line">  <span class="string">`transaction_service_group`</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>),    </span><br><span class="line">  <span class="string">`transaction_name`</span> <span class="built_in">VARCHAR</span>(<span class="number">128</span>),    </span><br><span class="line">  <span class="string">`timeout`</span> <span class="built_in">INT</span>,    </span><br><span class="line">  <span class="string">`begin_time`</span> <span class="built_in">BIGINT</span>,    </span><br><span class="line">  <span class="string">`application_data`</span> <span class="built_in">VARCHAR</span>(<span class="number">2000</span>),    </span><br><span class="line">  <span class="string">`gmt_create`</span> DATETIME,    </span><br><span class="line">  <span class="string">`gmt_modified`</span> DATETIME,    </span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`xid`</span>), </span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_gmt_modified_status`</span> (<span class="string">`gmt_modified`</span>, <span class="string">`status`</span>),    </span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_transaction_id`</span> (<span class="string">`transaction_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- the table to store BranchSession data</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`branch_table`</span>(    </span><br><span class="line">  <span class="string">`branch_id`</span> <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,    </span><br><span class="line">  <span class="string">`xid`</span> <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,    </span><br><span class="line">  <span class="string">`transaction_id`</span>    <span class="built_in">BIGINT</span>,    </span><br><span class="line">  <span class="string">`resource_group_id`</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>),    </span><br><span class="line">  <span class="string">`resource_id`</span>       <span class="built_in">VARCHAR</span>(<span class="number">256</span>),    </span><br><span class="line">  <span class="string">`branch_type`</span>       <span class="built_in">VARCHAR</span>(<span class="number">8</span>),    </span><br><span class="line">  <span class="string">`status`</span>            <span class="built_in">TINYINT</span>,    </span><br><span class="line">  <span class="string">`client_id`</span>         <span class="built_in">VARCHAR</span>(<span class="number">64</span>),    </span><br><span class="line">  <span class="string">`application_data`</span>  <span class="built_in">VARCHAR</span>(<span class="number">2000</span>),    </span><br><span class="line">  <span class="string">`gmt_create`</span>        DATETIME(<span class="number">6</span>),    </span><br><span class="line">  <span class="string">`gmt_modified`</span>      DATETIME(<span class="number">6</span>),    </span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`branch_id`</span>),    </span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_xid`</span> (<span class="string">`xid`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- the table to store lock data</span></span><br><span class="line">  <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`lock_table`</span>(    </span><br><span class="line">    <span class="string">`row_key`</span>        <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,    </span><br><span class="line">    <span class="string">`xid`</span>            <span class="built_in">VARCHAR</span>(<span class="number">96</span>),    </span><br><span class="line">    <span class="string">`transaction_id`</span> <span class="built_in">BIGINT</span>,    </span><br><span class="line">    <span class="string">`branch_id`</span>      <span class="built_in">BIGINT</span>       <span class="keyword">NOT</span> <span class="literal">NULL</span>,    </span><br><span class="line">    <span class="string">`resource_id`</span>    <span class="built_in">VARCHAR</span>(<span class="number">256</span>),    </span><br><span class="line">    <span class="string">`table_name`</span>     <span class="built_in">VARCHAR</span>(<span class="number">32</span>),    </span><br><span class="line">    <span class="string">`pk`</span>             <span class="built_in">VARCHAR</span>(<span class="number">36</span>),    </span><br><span class="line">    <span class="string">`gmt_create`</span>     DATETIME,    </span><br><span class="line">    <span class="string">`gmt_modified`</span>   DATETIME,    </span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`row_key`</span>),    </span><br><span class="line">    <span class="keyword">KEY</span> <span class="string">`idx_branch_id`</span> (<span class="string">`branch_id`</span>)</span><br><span class="line">  ) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br></pre></td></tr></table></figure><p><a href="http://www.iocoder.cn/Dubbo/Seata/?self" target="_blank" rel="noopener">http://www.iocoder.cn/Dubbo/Seata/?self</a></p><h3 id="3、事务隔离"><a href="#3、事务隔离" class="headerlink" title="3、事务隔离"></a>3、事务隔离</h3><p>那这种事务的隔离级别是什么样的呢?我们在学习数据库的事务特性时，必须会涉及到的就是事务的隔 离级别，不同的隔离级别，会产生一些并发性的问题，比如</p><p>脏读  – A事务读到B事物update后未提交的数据，B事务回滚后，A读到的数据是脏数据</p><p>不可重复读 – A事务在第一次读后，B事务修改了数据，A事务继续第二次读，两次数据不一致</p><p>幻读 –与脏读类似，脏读针对的是同一条记录的更新，幻读是范围数据多了或少了</p><p>我们知道mysql的数据库隔离级别有4种</p><ul><li>读未提交 RU  – 会出现所有读一致性问题</li><li>读已提交 RC – 解决了脏读</li><li>可重复读 RR –解决了不可重复度</li><li>序列化读 </li></ul><h5 id="3-1-写隔离"><a href="#3-1-写隔离" class="headerlink" title="3.1 写隔离"></a>3.1 写隔离</h5><p>所谓的写隔离，就是多个事务对同一个表的同一条数据做修改的时候，需要保证对于这个数据更新操作的隔离性，在传统事务模型中，我们一般是采用锁（LBCC）的方式来实现。</p><p>那么在分布式事务中，如果存在多个全局事务对于同一个数据进行修改，为了保证写操作的隔离，也需要通过一种方式来实现隔离性，自然也是用到锁的方法，具体来说。</p><ul><li>在第一阶段本地事务提交之前，需要确保先拿到全局锁，如果拿不到全局锁，则不能提交本地事务</li><li>拿到全局锁的尝试会被限制在一定范围内，超出范围会被放弃并回滚本地事务并释放本地锁。</li></ul><p>举一个具体的例子，假设有两个全局事务tx1和tx2，分别对a表的m字段进行数据更新操作，m的初始 值是1000。</p><ol><li>tx1先开始执行，按照AT模式的流程，先开启本地事务，然后更新m=1000-100=900。在本地事务 更新之前，需要拿到这个记录的全局锁。</li><li>如果tx1拿到了全局锁，则提交本地事务并释放本地锁。</li></ol><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/seata/AT%E5%86%99%E9%9A%94%E7%A6%BB-1.png" style="zoom:67%;"></p><ol start="3"><li>接着tx2后开始执行，同样先开启本地事务拿到本地锁，并执行m=900-100的更新操作。在本地事 务提交之前，先尝试去获取这个记录的全局锁。而此时tx1全局事务还没提交之前，全局锁的持有 者是tx1，所以tx2拿不到全局锁，需要等待</li></ol><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/seata/AT%E5%86%99%E9%9A%94%E7%A6%BB-2.png" style="zoom: 67%;"></p><p>接着, tx1在第二阶段完成事务提交或者回滚，并释放全局锁。此时tx2就可以拿到全局锁来提交本地事务。</p><p>如果tx1的第二阶段是全局回滚，则tx1需要重新获取这个数据的本地锁， 然后进行反向补偿更新实现事务分支的回滚。此时，如果tx2仍然在等待这个数据的全局锁并且同时持有本地锁，那么tx1的分支事务回滚会失败，分支的回滚会一直重试直到tx2的<strong>全局锁等待超时</strong>，放弃全局锁并回滚本地事务并释放本地锁之后，tx1的 分支事务才能最终回滚成功。</p><p>由于在整个过程中, 全局锁在tx1结束之前一直被tx1持有，所以并不会发生脏写问题。</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/seata/AT%E5%86%99%E9%9A%94%E7%A6%BB-2.png" style="zoom:67%;"></p><h5 id="3-2-读隔离"><a href="#3-2-读隔离" class="headerlink" title="3.2 读隔离"></a>3.2 读隔离</h5><p>在数据库本地事务隔离级别 <strong>读已提交（Read Committed）</strong> 或以上的基础上，Seata（AT 模式）的默认全局隔离级别是 <strong>读未提交（Read Uncommitted）</strong> 。</p><p>如果应用在特定场景下，必需要求全局的 <strong>读已提交</strong> ，目前 Seata 的方式是通过 SELECT FOR UPDATE 语句的代理。</p><p>SELECT FOR UPDATE 语句的执行会申请 <strong>全局锁</strong> ，如果 <strong>全局锁</strong> 被其他事务持有，则释放本地锁（回滚 SELECT FOR UPDATE 语句的本地执行）并重试。这个过程中，查询是被 block 住的，直到 <strong>全局锁</strong> 拿到，即读取的相关数据是 <strong>已提交</strong> 的，才返回。</p><p>出于总体性能上的考虑，Seata 目前的方案并没有对所有 SELECT 语句都进行代理，仅针对 FOR UPDATE 的 SELECT 语句。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Seata 是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布 式事务服务。在 Seata 开源之前，Seata 对应的内部版本在阿里经济体内部一直扮演着分布式一 致性中间件的角色，帮助经济体平稳的度过历年的双11，对各BU业务进行了有力的支撑。
      
    
    </summary>
    
      <category term="SpringCloud" scheme="http://yoursite.com/child/categories/SpringCloud/"/>
    
    
      <category term="SpringCloud" scheme="http://yoursite.com/child/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>分库分表-mycat升华</title>
    <link href="http://yoursite.com/child/2020/05/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF-Mycat-mycat%E5%8D%87%E5%8D%8E/"/>
    <id>http://yoursite.com/child/2020/05/14/数据库技术-Mycat-mycat升华/</id>
    <published>2020-05-13T16:00:00.000Z</published>
    <updated>2020-11-15T09:47:43.376Z</updated>
    
    <content type="html"><![CDATA[<p>目标：</p><p>1、读写分离</p><p>2、XA事务</p><p>3、总计架构流程分析</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目标：&lt;/p&gt;
&lt;p&gt;1、读写分离&lt;/p&gt;
&lt;p&gt;2、XA事务&lt;/p&gt;
&lt;p&gt;3、总计架构流程分析&lt;/p&gt;

      
    
    </summary>
    
      <category term="数据库技术" scheme="http://yoursite.com/child/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Mycat" scheme="http://yoursite.com/child/tags/Mycat/"/>
    
  </entry>
  
  <entry>
    <title>分库分表-mycat进阶</title>
    <link href="http://yoursite.com/child/2020/05/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF-Mycat-mycat%E8%BF%9B%E9%98%B6/"/>
    <id>http://yoursite.com/child/2020/05/12/数据库技术-Mycat-mycat进阶/</id>
    <published>2020-05-11T16:00:00.000Z</published>
    <updated>2020-11-15T09:48:00.763Z</updated>
    
    <content type="html"><![CDATA[<p>目标：</p><p>1、掌握不同数据分片策略的配置方式与特点</p><p>2、Mycat扩缩容与数据导入导出</p><p>3、理解Mycat注解的作用于应用场景</p><h3 id="1-分片策略详解"><a href="#1-分片策略详解" class="headerlink" title="1. 分片策略详解"></a>1. 分片策略详解</h3><h4 id="1-1-Mycat分片策略详解"><a href="#1-1-Mycat分片策略详解" class="headerlink" title="1.1 Mycat分片策略详解"></a>1.1 Mycat分片策略详解</h4><p>总体上分为连续分片和离散分片，还有一种是连续分片和离散分片的结合，例如先范围后取模。比如范围分片(id 或者时间)就是典型的连续分片，单个分区的数量和边 界是确定的。离散分片的分区总数量和边界是确定的，例如对 key 进行哈希运算，或者再取模。</p><h5 id="1-1-1-连续分片"><a href="#1-1-1-连续分片" class="headerlink" title="1.1.1  连续分片"></a>1.1.1  连续分片</h5><p>缺点：会出现冷热数据，热数据分布在同一个节点，分库没有起到分摊数据访问压力的作用。</p><h6 id="示例1：按自然月分片"><a href="#示例1：按自然月分片" class="headerlink" title="示例1：按自然月分片"></a><strong>示例1：按自然月分片</strong></h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`sharding_by_month`</span> (</span><br><span class="line"> <span class="string">`create_time`</span> <span class="built_in">timestamp</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>, <span class="string">`db_nm`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span></span><br><span class="line"> ) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><p>mycat配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"sharding_by_month"</span> <span class="attr">dataNode</span>=<span class="string">"72-imall,74-imall,76-imall"</span> <span class="attr">rule</span>=<span class="string">"pd-sharding-by-month"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>分片规则：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"pd-sharding-by-month"</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">columns</span>&gt;</span>create_time<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>pd-partbymonth<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br></pre></td></tr></table></figure><p>分片算法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"pd-partbymonth"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByMonth"</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dateFormat"</span>&gt;</span>yyyy-MM-dd<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sBeginDate"</span>&gt;</span>2025-10-01<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sEndDate"</span>&gt;</span>2025-12-31<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>columns</code> 标识将要分片的表字段，字符串类型，与 dateFormat 格式一致。 </p><p><code>algorithm</code> 为分片函数。</p><p><code>dateFormat</code> 为日期字符串格式</p><p><code>sBeginDate</code> 为开始日期。</p><p><code>sEndDate</code> 为结束日期 </p><p>注意：节点个数要大于月份的个数</p><p>测试语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> sharding_by_month;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> sharding_by_month (create_time,db_nm) <span class="keyword">VALUES</span> (<span class="string">'2024-10-16'</span>, <span class="keyword">database</span>()); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> sharding_by_month (create_time,db_nm) <span class="keyword">VALUES</span> (<span class="string">'2025-10-27'</span>, <span class="keyword">database</span>()); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> sharding_by_month (create_time,db_nm) <span class="keyword">VALUES</span> (<span class="string">'2026-11-04'</span>, <span class="keyword">database</span>()); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> sharding_by_month (create_time,db_nm) <span class="keyword">VALUES</span> (<span class="string">'2027-11-11'</span>, <span class="keyword">database</span>()); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> sharding_by_month (create_time,db_nm) <span class="keyword">VALUES</span> (<span class="string">'2029-12-25'</span>, <span class="keyword">database</span>()); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> sharding_by_month (create_time,db_nm) <span class="keyword">VALUES</span> (<span class="string">'2030-12-31'</span>, <span class="keyword">database</span>());</span><br></pre></td></tr></table></figure><p>注意：以上跟年度没有关系，只跟月度有关。</p><p>问题：不在 10 月和 12 月之间的数据，路由到哪个节点？结果不一定。可以在本地 调试一下。</p><p>另外还有按天分片(可以指定多少天一个分片)、按小时分片</p><h5 id="1-1-2-离散分片"><a href="#1-1-2-离散分片" class="headerlink" title="1.1.2 离散分片"></a>1.1.2 离散分片</h5><p>特点：分布很均匀，但是节点扩容需要迁移已分片的数据</p><h6 id="示例1：十进制取模分片"><a href="#示例1：十进制取模分片" class="headerlink" title="示例1：十进制取模分片"></a><strong>示例1：十进制取模分片</strong></h6><p>根据分片键进行十进制求模运算。sharding_by_mod 表。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"mod-long"</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>mod-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"mod-long"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByMod"</span>&gt;</span> </span><br><span class="line">  <span class="comment">&lt;!-- how many data nodes --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"count"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> sharing_by_mod;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_mod`</span> (<span class="string">`id`</span>, <span class="string">`db_nm`</span>) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'1'</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_mod`</span> (<span class="string">`id`</span>, <span class="string">`db_nm`</span>) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">'2'</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_mod`</span> (<span class="string">`id`</span>, <span class="string">`db_nm`</span>) <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">'3'</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_mod`</span> (<span class="string">`id`</span>, <span class="string">`db_nm`</span>) <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">'4'</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_mod`</span> (<span class="string">`id`</span>, <span class="string">`db_nm`</span>) <span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="string">'5'</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_mod`</span> (<span class="string">`id`</span>, <span class="string">`db_nm`</span>) <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="string">'6'</span>);</span><br></pre></td></tr></table></figure><h6 id="示例2：枚举分片，根据年龄"><a href="#示例2：枚举分片，根据年龄" class="headerlink" title="示例2：枚举分片，根据年龄"></a><strong>示例2：枚举分片，根据年龄</strong></h6><p>将所有可能出现的值列举出来，指定分片。例如：全国 34 个省，要将不同的省的数 据存放在不同的节点，可用枚举的方式。</p><p>三个节点 imall 库创建 sharding_by_intfile 表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`sharding_by_intfile`</span> (</span><br><span class="line"><span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`db_nm`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><p>逻辑表：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"sharding_by_intfile"</span> <span class="attr">dataNode</span>=<span class="string">"72-imall,74-imall,76-imall"</span> <span class="attr">rule</span>=<span class="string">"pd-sharding-by-intfile"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>分片规则：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"pd-sharding-by-intfile"</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">columns</span>&gt;</span>age<span class="tag">&lt;/<span class="name">columns</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>hash-int<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rule</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br></pre></td></tr></table></figure><p>分片算法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"hash-int"</span> <span class="attr">class</span>=<span class="string">"org.opencloudb.route.function.PartitionByFileMap"</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapFile"</span>&gt;</span>partition-hash-int.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"type"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultNode"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><p>type：默认值为 0，0 表示 Integer，非零表示 String。 </p><p>PartitionByFileMap.java，通过 map 来实现。</p><p> 策略文件：partition-hash-int.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">16=0</span><br><span class="line">17=1</span><br><span class="line">18=2</span><br></pre></td></tr></table></figure><p>插入数据测试</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> sharding_by_intfile;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_intfile`</span> (age,db_nm) <span class="keyword">VALUES</span> (<span class="number">16</span>, <span class="keyword">database</span>()); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_intfile`</span> (age,db_nm) <span class="keyword">VALUES</span> (<span class="number">17</span>, <span class="keyword">database</span>()); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_intfile`</span> (age,db_nm) <span class="keyword">VALUES</span> (<span class="number">18</span>, <span class="keyword">database</span>());</span><br></pre></td></tr></table></figure><p>特点：适用于枚举值固定的场景。</p><h6 id="示例3：一致性哈希分片"><a href="#示例3：一致性哈希分片" class="headerlink" title="示例3：一致性哈希分片"></a><strong>示例3：一致性哈希分片</strong></h6><p>一致性 hash 有效解决了分布式数据的扩容问题，可以一定程度减少数据的迁移。</p><p>建表语句：</p><p>分片规则</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`sharding_by_murmur`</span> (</span><br><span class="line"> <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"> <span class="string">`db_nm`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span></span><br><span class="line"> ) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"sharding_by_murmurhash"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span> <span class="attr">dataNode</span>=<span class="string">"72-imall,74-imall,76-imall"</span> <span class="attr">rule</span>=<span class="string">"sharding-by-murmur"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>分片规则：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"pd-sharding-by-murmur"</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>pd-murmur<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br></pre></td></tr></table></figure><p>分片算法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"pd-murmur"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByMurmurHash"</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"seed"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"count"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"virtualBucketTimes"</span>&gt;</span>160<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> sharding_by_murmur;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_murmur`</span> (<span class="keyword">id</span>,db_nm) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="keyword">database</span>()); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_murmur`</span> (<span class="keyword">id</span>,db_nm) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_murmur`</span> (<span class="keyword">id</span>,db_nm) <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="keyword">database</span>()); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_murmur`</span> (<span class="keyword">id</span>,db_nm) <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="keyword">database</span>()); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_murmur`</span> (<span class="keyword">id</span>,db_nm) <span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="keyword">database</span>()); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_murmur`</span> (<span class="keyword">id</span>,db_nm) <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="keyword">database</span>()); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_murmur`</span> (<span class="keyword">id</span>,db_nm) <span class="keyword">VALUES</span> (<span class="number">7</span>, <span class="keyword">database</span>()); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_murmur`</span> (<span class="keyword">id</span>,db_nm) <span class="keyword">VALUES</span> (<span class="number">8</span>, <span class="keyword">database</span>()); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_murmur`</span> (<span class="keyword">id</span>,db_nm) <span class="keyword">VALUES</span> (<span class="number">9</span>, <span class="keyword">database</span>()); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_murmur`</span> (<span class="keyword">id</span>,db_nm) <span class="keyword">VALUES</span> (<span class="number">10</span>, <span class="keyword">database</span>()); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_murmur`</span> (<span class="keyword">id</span>,db_nm) <span class="keyword">VALUES</span> (<span class="number">11</span>, <span class="keyword">database</span>()); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_murmur`</span> (<span class="keyword">id</span>,db_nm) <span class="keyword">VALUES</span> (<span class="number">12</span>, <span class="keyword">database</span>()); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_murmur`</span> (<span class="keyword">id</span>,db_nm) <span class="keyword">VALUES</span> (<span class="number">13</span>, <span class="keyword">database</span>()); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_murmur`</span> (<span class="keyword">id</span>,db_nm) <span class="keyword">VALUES</span> (<span class="number">14</span>, <span class="keyword">database</span>()); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_murmur`</span> (<span class="keyword">id</span>,db_nm) <span class="keyword">VALUES</span> (<span class="number">15</span>, <span class="keyword">database</span>()); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_murmur`</span> (<span class="keyword">id</span>,db_nm) <span class="keyword">VALUES</span> (<span class="number">16</span>, <span class="keyword">database</span>()); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_murmur`</span> (<span class="keyword">id</span>,db_nm) <span class="keyword">VALUES</span> (<span class="number">17</span>, <span class="keyword">database</span>()); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_murmur`</span> (<span class="keyword">id</span>,db_nm) <span class="keyword">VALUES</span> (<span class="number">18</span>, <span class="keyword">database</span>()); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_murmur`</span> (<span class="keyword">id</span>,db_nm) <span class="keyword">VALUES</span> (<span class="number">19</span>, <span class="keyword">database</span>()); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_murmur`</span> (<span class="keyword">id</span>,db_nm) <span class="keyword">VALUES</span> (<span class="number">20</span>, <span class="keyword">database</span>());</span><br></pre></td></tr></table></figure><h6 id="示例4：固定分片哈希"><a href="#示例4：固定分片哈希" class="headerlink" title="示例4：固定分片哈希"></a><strong>示例4：固定分片哈希</strong></h6><p>这是先求模得到逻辑分片号，再根据逻辑分片号直接映射到物理分片的一种散列算法。</p><p>特点：在一定范围内 id 是连续分布的。</p><p>建表语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`sharding_by_long`</span> ( </span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`db_nm`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>逻辑表</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"sharding_by_long"</span> <span class="attr">dataNode</span>=<span class="string">"72-imall,74-imall,76-imall"</span> <span class="attr">rule</span>=<span class="string">"pd-sharding-by-long"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>分片规则：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"pd-sharding-by-long"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>pd-sharding-by-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br></pre></td></tr></table></figure><p>分片算法：平均分成 8片(%1024 的余数，1024=128*8)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"pd-sharding-by-long"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByLong"</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"partitionCount"</span>&gt;</span>8<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"partitionLength"</span>&gt;</span>128<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>partitionCount</code> 为指定分片个数列表。 </p><p><code>partitionLength</code> 为分片范围列表。</p><p>如果要不均匀的分布到不同节点，那就如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"pd-sharding-by-long"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByLong"</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"partitionCount"</span>&gt;</span>2,1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"partitionLength"</span>&gt;</span>256,512<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><p>参数表示前2个节点分片长度256，第三个节点分片长度512</p><p>测试语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> sharding_by_long;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_long`</span> (<span class="keyword">id</span>,db_nm) <span class="keyword">VALUES</span> (<span class="number">222</span>, <span class="keyword">database</span>()); <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_long`</span> (<span class="keyword">id</span>,db_nm) <span class="keyword">VALUES</span> (<span class="number">333</span>, <span class="keyword">database</span>()); <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_long`</span> (<span class="keyword">id</span>,db_nm) <span class="keyword">VALUES</span> (<span class="number">666</span>, <span class="keyword">database</span>());</span><br></pre></td></tr></table></figure><h6 id="示例5：取模范围分片"><a href="#示例5：取模范围分片" class="headerlink" title="示例5：取模范围分片"></a><strong>示例5：取模范围分片</strong></h6><p>先对键取模，然后按照结果所在范围进行分片</p><p>特点：可以调整节点的数据分布，适合存储能力不同的节点组成的集群</p><p>节点扩容需迁移数据</p><p>建表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`sharding_by_pattern`</span> ( </span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>, </span><br><span class="line">  <span class="string">`db_nm`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>逻辑表：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"sharding_by_pattern"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span> <span class="attr">dataNode</span>=<span class="string">"72-imall,74-imall,76-imall"</span> <span class="attr">rule</span>=<span class="string">"sharding-by-pattern"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>分片规则：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"sharding-by-pattern"</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>sharding-by-pattern<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br></pre></td></tr></table></figure><p>分片算法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"sharding-by-pattern"</span> <span class="attr">class</span>=<span class="string">" io.mycat.route.function.PartitionByPattern"</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"patternValue"</span>&gt;</span>100<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultNode"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapFile"</span>&gt;</span>partition-pattern.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><p>patternValue 取模基数，这里设置成 100 </p><p>partition-pattern.txt，一共 3 个节点 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id=19%100=19，在 dn1; </span><br><span class="line">id=222%100=22，dn2;</span><br><span class="line">id=371%100=71，dn3</span><br></pre></td></tr></table></figure><p>测试语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> sharding_by_pattern;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_pattern`</span> (<span class="keyword">id</span>,db_nm) <span class="keyword">VALUES</span> (<span class="number">19</span>, <span class="keyword">database</span>()); <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_pattern`</span> (<span class="keyword">id</span>,db_nm) <span class="keyword">VALUES</span> (<span class="number">222</span>, <span class="keyword">database</span>()); <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_pattern`</span> (<span class="keyword">id</span>,db_nm) <span class="keyword">VALUES</span> (<span class="number">371</span>, <span class="keyword">database</span>());</span><br></pre></td></tr></table></figure><h6 id="示例6：范围取模分片"><a href="#示例6：范围取模分片" class="headerlink" title="示例6：范围取模分片"></a><strong>示例6：范围取模分片</strong></h6><p>先范围后取模</p><p>特点：扩容的时候旧数据无需迁移</p><p>建表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`sharding_by_rang_mod`</span> ( </span><br><span class="line"><span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`db_nm`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>逻辑表配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"sharding_by_rang_mod"</span> <span class="attr">dataNode</span>=<span class="string">"72-imall,74-imall,76-imall"</span> <span class="attr">rule</span>=<span class="string">"pd-sharding-by-rang-mod"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>分片规则：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"pd-sharding-by-rang-mod"</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>pd-rang-mod<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br></pre></td></tr></table></figure><p>分片算法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"pd-rang-mod"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByRangeMod"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapFile"</span>&gt;</span>partition-range-mod.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><p>partition-range-mod.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># range start-end ,data node group size</span><br><span class="line">0-20000=1 </span><br><span class="line">20001-40000=2</span><br></pre></td></tr></table></figure><p>Id 在 20000 以内的，全部分布到 dn1。Id 在 20001-40000 的，%2 分布到 dn2,dn3。</p><p>测试语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> sharding_by_rang_mod;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_rang_mod`</span> (<span class="keyword">id</span>,db_nm) <span class="keyword">VALUES</span> (<span class="number">666</span>, <span class="keyword">database</span>()); <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_rang_mod`</span> (<span class="keyword">id</span>,db_nm) <span class="keyword">VALUES</span> (<span class="number">6667</span>, <span class="keyword">database</span>()); <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_rang_mod`</span> (<span class="keyword">id</span>,db_nm) <span class="keyword">VALUES</span> (<span class="number">16666</span>, <span class="keyword">database</span>()); <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_rang_mod`</span> (<span class="keyword">id</span>,db_nm) <span class="keyword">VALUES</span> (<span class="number">21111</span>, <span class="keyword">database</span>()); <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_rang_mod`</span> (<span class="keyword">id</span>,db_nm) <span class="keyword">VALUES</span> (<span class="number">22222</span>, <span class="keyword">database</span>());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_rang_mod`</span> (<span class="keyword">id</span>,db_nm) <span class="keyword">VALUES</span> (<span class="number">23333</span>, <span class="keyword">database</span>()); <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sharding_by_rang_mod`</span> (<span class="keyword">id</span>,db_nm) <span class="keyword">VALUES</span> (<span class="number">24444</span>, <span class="keyword">database</span>());</span><br></pre></td></tr></table></figure><h6 id="其他分片规则"><a href="#其他分片规则" class="headerlink" title="其他分片规则"></a><strong>其他分片规则</strong></h6><ul><li>应用指定分片 PartitionDirectBySubString</li><li>日期范围哈希 PartitionByRangeDateHash</li><li>冷热数据分片 PartitionByHotDate</li><li>也可以自定义分片规则：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extends AbstractPartitionAlgorithm implements RuleAlgorithm。</span><br></pre></td></tr></table></figure><h5 id="1-1-3-连续和离散的特点"><a href="#1-1-3-连续和离散的特点" class="headerlink" title="1.1.3 连续和离散的特点"></a>1.1.3 连续和离散的特点</h5><p>连续分片优点：</p><ol><li>范围查询消耗资源少，不需要汇总数据</li><li>扩容无需迁移数据</li></ol><p>连续分片缺点：</p><p>​    存在热点数据导致并发访问能力受限于单一或少量节点</p><p>离散分片优点：</p><ol><li>并发访问能力强</li><li>范围条件查询性能提升（并行计算）</li></ol><p>离散分片缺点：</p><ol><li>数据扩容涉及数据迁移问题</li><li>数据库连接消耗大</li></ol><h5 id="1-1-4-切分规则的选择"><a href="#1-1-4-切分规则的选择" class="headerlink" title="1.1.4 切分规则的选择"></a>1.1.4 切分规则的选择</h5><p>步骤：</p><ol><li>找到需要切分的大表和关联的表</li><li>确定分片字段（尽量使用主键），一般用最频繁使用的查询条件</li><li>考虑单个分片的存储容量和请求、数据增长、扩容和数据迁移问题</li></ol><p>问题：</p><p>​    按照上面递增？序号还是日期？主键是否有业务意义？</p><p>举例：<br>3.7 亿的数据怎么分表？我是不是分成 3 台服务器？ </p><p>1、一年内到达多少？两年内到达多少？(数据的增长速度)？ </p><p>答：一台设备每秒钟往 3 张表各写入一条数据，一共 4 台设备。每张表一天86400*4=345600 条。每张表一个月 10368000 条。 </p><p>分析：增长速度均匀，可以用日期切分，每个月分一张表。 </p><p>2、什么业务？所有的数据都会访问，还是访问新数据为主？ </p><p>答：访问新数据为主，但是所有的数据都可能会访问到 </p><p>3、表结构和表数据是什么样的？一个月消耗多少空间？</p><p>答：字段不多，算过了，三年数据量有 3.7 亿，30G。</p><p>分析：30G 没必要分库，浪费磁盘空间。</p><p>4、访问量怎么样？并发压力大么？</p><p>答：并发有一点吧 </p><p>分析：如果并发量不大，不用分库，只需要在单库分表。不用引入 Mycat 中间件了。如果要自动路由的话可以用 Sharding-JDBC，否则就是自己拼装表名。 </p><p>5、3 张表有没有关联查询之类的操作？</p><p>答：没有。</p><p>分析：还是拼装表名简单一点。</p><p>如果从单库变成分库分表，或者节点数的增加和减少，都会涉及到数据迁移的问题。数据迁移有两种，一种是在线不停机的迁移，还有一种是停机的。</p><h3 id="2-Mycat扩缩容"><a href="#2-Mycat扩缩容" class="headerlink" title="2. Mycat扩缩容"></a>2. Mycat扩缩容</h3><h4 id="2-1-在线扩缩容思路"><a href="#2-1-在线扩缩容思路" class="headerlink" title="2.1 在线扩缩容思路"></a>2.1 在线扩缩容思路</h4><p>流程：</p><ol><li>把历史数据通过中间件迁移到新库</li><li>新的写请求，发送到消息队列，不消费</li><li>数据迁移完毕，迁移程序下线</li><li>消费信息，将增量数据写入新库</li><li>数据一致性验证</li><li>旧数据下线，切换到新库，重启应用。</li></ol><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/mycat/%E4%B8%8D%E4%B8%8B%E7%BA%BF%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB.png" alt="不下线数据迁移" style="zoom:50%;"></p><h4 id="2-2-mysqldump方式"><a href="#2-2-mysqldump方式" class="headerlink" title="2.2 mysqldump方式"></a>2.2 mysqldump方式</h4><p>系统第一次上线，把单张表迁移到 Mycat，可以用 mysqldump。 </p><p><strong>MySQL 导出命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p123456 -h127.0.0.1 -P3306 -c -t --skip-extended-insert imall &gt; mysql-1107.sql</span><br></pre></td></tr></table></figure><p>-c 代表带列名</p><p>-t 代表只要数据，不要建表语句</p><p>–skip-extended-insert 代表生成多行 insert(mycat childtable 不支持多行插入 ChildTable multi insert not provided)</p><p><strong>Mycat 导入命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p123456 -h127.0.0.1 -P8066 imall &lt; mysql-1107.sql</span><br></pre></td></tr></table></figure><h4 id="2-3-Mycat自带的离线扩缩容工具"><a href="#2-3-Mycat自带的离线扩缩容工具" class="headerlink" title="2.3 Mycat自带的离线扩缩容工具"></a>2.3 Mycat自带的离线扩缩容工具</h4><p>如果是已有分片表，可以用mycat自带的工具，实际上是对mysqldump进行了包装。</p><h5 id="2-3-1-准备工作"><a href="#2-3-1-准备工作" class="headerlink" title="2.3.1 准备工作"></a>2.3.1 准备工作</h5><ol><li>mycat所在环境安装mysql客户端程序</li><li>mycat的lib目录下添加mysql的jdbc驱动包</li><li>对扩容表的所有节点数据进行备份，以便前以失败后的数据恢复。</li></ol><h5 id="2-3-2-步骤"><a href="#2-3-2-步骤" class="headerlink" title="2.3.2 步骤"></a>2.3.2 步骤</h5><p>以取模分片表 sharding-by-mod 缩容为例。</p><table><thead><tr><th>时间</th><th>数据</th></tr></thead><tbody><tr><td>迁移前数据</td><td>72-imall 3, 6    74-imall 1,4    76-imall 2,5</td></tr><tr><td>迁移后数据</td><td>72-imall 2,4,6    74-imall 1,3,5</td></tr></tbody></table><p>1、复制 schema.xml、rule.xml 并重命名为 newSchema.xml、newRule.xml 放 于 conf 目录下。</p><p>2、修改 newSchema.xml 和 newRule.xml 配置文件为扩容缩容后的 mycat 配 置参数(表的节点数、数据源、路由规则)。</p><p><strong>注意：</strong></p><p>只有节点变化的表才会进行迁移。仅分片配置变化不会迁移。</p><p>newSchema.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"sharding_by_mod"</span> <span class="attr">dataNode</span>=<span class="string">"72-imall,74-imall,76-imall"</span> <span class="attr">rule</span>=<span class="string">"pd-sharding-by-mod"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>改成：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"sharding_by_mod"</span> <span class="attr">dataNode</span>=<span class="string">"72-imall,74-imall"</span> <span class="attr">rule</span>=<span class="string">"pd-sharding-by-mod"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>newRule.xml 修改 count 个数</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"pd-sharding-by-mod-long"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByMod"</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"count"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、修改 conf 目录下的 migrateTables.properties 配置文件，告诉工具哪些表需 要进行扩容或缩容,没有出现在此配置文件的 schema 表不会进行数据迁移，格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imall=sharding-by-mod</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>1)不迁移的表，不要修改 dn 个数，否则会报错。 </p><p>2)ER 表，因为只有主表有分片规则，子表不会迁移。</p><p>4、dataMigrate.sh 中这个必须要配置</p><p>通 过 命 令 “find / -name mysqldump” 查 找 mysqldump 路 径 为 “/usr/bin/mysqldump”，指定#mysql bin 路径为”/usr/bin/“</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#mysql bin 路径</span></span><br><span class="line">RUN_CMD=<span class="string">"<span class="variable">$RUN_CMD</span> -mysqlBin= /usr/bin/"</span></span><br></pre></td></tr></table></figure><p>5、停止 mycat 服务</p><p>6、执行执行 bin/dataMigrate.sh 脚本，注意：必须要配置 Java 环境变量，不能用 openjdk</p><p>7、脚本执行完成，如果最后的数据迁移验证通过，就可以将之前的 newSchema.xml 和 newRule.xml 替换之前的 schema.xml 和 rule.xml 文件，并重启 mycat 即可。</p><h5 id="2-3-3-注意事项"><a href="#2-3-3-注意事项" class="headerlink" title="2.3.3 注意事项"></a>2.3.3 注意事项</h5><ol><li>保证分片表迁移数据前后路由规则一致(取模——取模)。 </li><li>保证分片表迁移数据前后分片字段一致。 </li><li>全局表将被忽略。</li><li>不要将非分片表配置到 migrateTables.properties 文件中。</li><li>暂时只支持分片表使用 MySQL 作为数据源的扩容缩容。</li></ol><p>migrate 限制比较多，还可以使用 mysqldump。</p><p>总结：离线或者在线，主要看数据量，和对于业务的影响程度决定。</p><h3 id="3-Mysql-主从复制"><a href="#3-Mysql-主从复制" class="headerlink" title="3. Mysql 主从复制"></a>3. Mysql 主从复制</h3><p>用 mycat 实现了 MySQL 数据的分片存储，第一个可以实现负载 均衡，不同的读写发生在不同的节点上。第二可以实现横向扩展，如果数据持续增加， 加机器就 OK 了。</p><p>当然，一个分片只有一台机器还不够。为了防止节点宕机或者节点损坏，都要用副本机制来实现。MySQL 数据库同样可以集群部署，有了多个节点之后，节点之间数据又是个大问题。</p><h4 id="3-1-主从复制的含义"><a href="#3-1-主从复制的含义" class="headerlink" title="3.1 主从复制的含义"></a>3.1 主从复制的含义</h4><p>在 MySQL 多服务器的架构中，主节点，也就是产生数据的节点叫 master 节点。其 他的副本，向主节点同步数据的节点，叫做 slave(默认是异步的，客户端的数据在 master 刷盘就返回)。一个集群里面至少要有一个 master。slave 可以有多个。</p><h4 id="3-2-主从复制的用途"><a href="#3-2-主从复制的用途" class="headerlink" title="3.2 主从复制的用途"></a>3.2 主从复制的用途</h4><p>数据备份：把数据复制到不同的机器上，以免单台服务器发生故障时数据丢失。 </p><p>负载均衡：结合负载的机制，均摊所有的应用访问请求，降低单机 IO。</p><p>高可用 HA：当节点故障时，自动转移到其他节点，提高可用性。 </p><p>主从复制的架构可以有多种</p><h4 id="3-3-主从复制的形式"><a href="#3-3-主从复制的形式" class="headerlink" title="3.3 主从复制的形式"></a>3.3 主从复制的形式</h4><ul><li>一主一从/一主多从</li><li>双主复制(互为主从)</li><li>级联复制</li></ul><p>不过在，MySQL 自身并没有自动选举和故障转移的功能，需要依赖其他的中间件或架构实现，比如 MMM，MHA，percona，mycat。</p><p> 主从复制是怎么实现的呢？</p><h4 id="3-4-binlog"><a href="#3-4-binlog" class="headerlink" title="3.4 binlog"></a>3.4 binlog</h4><p>客户端对 MySQL 数据库进行操作的时候，包括 DDL 和 DML 语句，服务端会在日 志文件中用事件的形式记录所有的操作记录，这个文件就是 binlog 文件(属于逻辑日志， 跟 Redis 的 AOF 文件类似)。Binary log，二进制日志。</p><p>基于 binlog，我们可以实现主从复制和数据恢复。</p><p>binlog 默认是不开启的，需要在服务端手动配置。注意有一定的性能损耗。</p><h5 id="3-4-1-binlog配置"><a href="#3-4-1-binlog配置" class="headerlink" title="3.4.1  binlog配置"></a>3.4.1  binlog配置</h5><p>编辑 /etc/my.cnf</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log-bin=/var/lib/mysql/mysql-bin </span><br><span class="line">server-id=1</span><br></pre></td></tr></table></figure><p>重启 MySQL 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">service mysqld stop </span><br><span class="line">service mysqld start</span><br><span class="line"><span class="comment">## 如果出错查看日志 </span></span><br><span class="line">vi /var/<span class="built_in">log</span>/mysqld.log </span><br><span class="line"><span class="built_in">cd</span> /var/lib/mysql</span><br></pre></td></tr></table></figure><p>是否开启 binlog</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'log_bin%'</span>;</span><br></pre></td></tr></table></figure><h5 id="3-4-2-binlog-格式"><a href="#3-4-2-binlog-格式" class="headerlink" title="3.4.2 binlog 格式"></a>3.4.2 binlog 格式</h5><p><strong>STATEMENT</strong>：记录每一条修改数据的 SQL 语句(减少日志量，节约 IO)。</p><p><strong>ROW</strong>：记录哪条数据被修改了，修改成什么样子了(5.7 以后默认)。 </p><p><strong>MIXED</strong>：结合两种方式，一般的语句用 STATEMENT，函数之类的用 ROW。</p><p>查看 binlog 格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%binlog_format%'</span>;</span><br></pre></td></tr></table></figure><p>Binlog 文件超过一定大小就会产生一个新的，查看 binlog 列表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="built_in">binary</span> <span class="keyword">logs</span>;</span><br></pre></td></tr></table></figure><p>大小：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">binlog</span> <span class="keyword">events</span> <span class="keyword">in</span> <span class="string">'mysql-bin.000001'</span>;</span><br></pre></td></tr></table></figure><p>用 mysqlbinlog 工具，基于时间查看 binlog (注意这个是 Linux 命令, 不是 SQL)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/mysqlbinlog --start-datetime=<span class="string">'2025-08-22 13:30:00'</span> --stop-datetime=<span class="string">'2025-08-22 14:01:01'</span> -d gupao /var/lib/mysql/mysql-bin.000001</span><br></pre></td></tr></table></figure><h4 id="3-5-主从复制的原理"><a href="#3-5-主从复制的原理" class="headerlink" title="3.5 主从复制的原理"></a>3.5 主从复制的原理</h4><h5 id="3-5-1-主从复制配置"><a href="#3-5-1-主从复制配置" class="headerlink" title="3.5.1 主从复制配置"></a>3.5.1 主从复制配置</h5><ol><li><p>主库开启binlog，设置server-id</p></li><li><p>在主库创建具有复制权限的用户，允许从库连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">REPLICATION</span> <span class="keyword">SLAVE</span>, <span class="keyword">REPLICATION</span> <span class="keyword">CLIENT</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'repl'</span>@<span class="string">'10.0.12.77'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'123456'</span>;</span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</span><br></pre></td></tr></table></figure></li><li><p>从库配置/etc/my.cnf ，并重启数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server-id=2 </span><br><span class="line">log-bin=mysql-bin </span><br><span class="line">relay-log=mysql-relay-bin </span><br><span class="line">read-only=1 </span><br><span class="line">log-slave-updates=1</span><br></pre></td></tr></table></figure><p>开启log-slave-updates参数后，从库从主库复制的数据会写入从库的log-bin日志文件里，这样可以实现互为主备或者级联复制</p></li><li><p>在从库执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">stop</span> <span class="keyword">slave</span>;</span><br><span class="line"><span class="keyword">change</span> <span class="keyword">master</span> <span class="keyword">to</span> master_host=<span class="string">'10.0.12.78'</span>,master_user=<span class="string">'repl'</span>,master_password=<span class="string">'123456'</span>,master_log_file=<span class="string">'mysql-bin.00000 1'</span>, master_log_pos=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>;</span><br></pre></td></tr></table></figure></li></ol><p>5、查看同步状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW SLAVE STATUS \G</span><br></pre></td></tr></table></figure><p>Slave_IO_Running 和 Slave SQL Running 都为 yes 为正常。</p><h5 id="3-5-2-主从复制原理"><a href="#3-5-2-主从复制原理" class="headerlink" title="3.5.2 主从复制原理"></a>3.5.2 主从复制原理</h5><p>这里面涉及到几个线程：</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/mycat/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.png" alt="主从复制原理" style="zoom:50%;"></p><p>1、slave 服务器执行 start slave，开启主从复制开关， slave 服务器的 IO 线程请 求从 master 服务器读取 binlog(如果该线程追赶上了主库，会进入睡眠状态)。</p><p>2、master 服务器创建 Log Dump 线程，把 binlog 发送给 slave 服务器。slave 服 务器把读取到的 binlog 日志内容写入中继日志 relay log(会记录位置信息，以便下次继 续读取)。</p><p>3、slave 服务器的 SQL 线程会实时检测 relay log 中新增的日志内容，把 relay log 解析成 SQL 语句，并执行。</p><p>为什么需要 relay log？为什么不把接收到的 binlog 数据直接写入从库？</p><p>同步转异步，Relay log 相当于一个中转站，也记录了 master 和 slave 的同步信息。</p><h5 id="3-5-3-mycat-读写分离配置"><a href="#3-5-3-mycat-读写分离配置" class="headerlink" title="3.5.3 mycat 读写分离配置"></a>3.5.3 mycat 读写分离配置</h5><p>添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">"host122"</span> <span class="attr">maxCon</span>=<span class="string">"1000"</span> <span class="attr">minCon</span>=<span class="string">"10"</span> <span class="attr">balance</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag"><span class="attr">writeType</span>=<span class="string">"0"</span> <span class="attr">dbType</span>=<span class="string">"mysql"</span> <span class="attr">dbDriver</span>=<span class="string">"native"</span> <span class="attr">switchType</span>=<span class="string">"1"</span> <span class="attr">slaveThreshold</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">"hostM1"</span> <span class="attr">url</span>=<span class="string">"10.0.12.72:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span></span></span><br><span class="line"><span class="tag"><span class="attr">password</span>=<span class="string">"123456"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">"hostS1"</span> <span class="attr">url</span>=<span class="string">"10.0.12.78:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"123456"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目标：&lt;/p&gt;
&lt;p&gt;1、掌握不同数据分片策略的配置方式与特点&lt;/p&gt;
&lt;p&gt;2、Mycat扩缩容与数据导入导出&lt;/p&gt;
&lt;p&gt;3、理解Mycat注解的作用于应用场景&lt;/p&gt;
&lt;h3 id=&quot;1-分片策略详解&quot;&gt;&lt;a href=&quot;#1-分片策略详解&quot; class=&quot;head
      
    
    </summary>
    
      <category term="数据库技术" scheme="http://yoursite.com/child/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Mycat" scheme="http://yoursite.com/child/tags/Mycat/"/>
    
  </entry>
  
  <entry>
    <title>分库分表-mycat基础</title>
    <link href="http://yoursite.com/child/2020/05/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF-Mycat-mycat%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/child/2020/05/11/数据库技术-Mycat-mycat基础/</id>
    <published>2020-05-10T16:00:00.000Z</published>
    <updated>2020-11-15T09:48:08.797Z</updated>
    
    <content type="html"><![CDATA[<p>目标：</p><p>1、通过实际案例掌握 Mycat 特性与详细配置含义</p><p>2、了解 Mycat 监控与日志查看</p><h3 id="1-Mycat-概念与配置"><a href="#1-Mycat-概念与配置" class="headerlink" title="1. Mycat 概念与配置"></a>1. Mycat 概念与配置</h3><h4 id="1-1-Mycat介绍与核心概念"><a href="#1-1-Mycat介绍与核心概念" class="headerlink" title="1.1 Mycat介绍与核心概念"></a>1.1 Mycat介绍与核心概念</h4><h5 id="1-1-1-基本介绍"><a href="#1-1-1-基本介绍" class="headerlink" title="1.1.1 基本介绍"></a>1.1.1 基本介绍</h5><p>历史：从阿里 cobar 升级而来，由开源组织维护(兼职)。</p><p>定位：运行在应用和数据库之间，可以当做一个 MySQL 服务器使用(不论是在工具 还是在代码或者命令行中都可以直接连接)。实现对 MySQL 数据库的分库分表，也可以通过 JDBC 支持其他的数据库。</p><p>Mycat 的关键特性(<a href="http://www.mycat.org.cn" target="_blank" rel="noopener">官网首页</a>)</p><ol><li>可以当做一个 MySQL 数据库来使用</li><li>支持 MySQL 之外的数据库，通过 JDBC 实现</li><li>解决了我们提到的所有问题，多表 join、分布式事务、全局序列号、翻页排序</li><li>支持 ZK 配置，带监控 mycat-web(已经停止维护) </li><li>2.0 已经发布;文档许久没有更新</li></ol><blockquote><p>关键特性：</p><ul><li>只是SQL92标准</li><li>支持MySQL、Oracle、DB2、SQL Server、PostgreSQL</li><li>遵守MySQL原生协议，跨语言，跨平台，跨数据库的通用中间件代理</li><li>基于心跳的自动故障切换，支持读写分离，支持MySQL主从模式，以及galera cluster集群</li><li>支持Galera for MySQL集群，Percona Cluster或者MariaDB Cluster</li><li>基于Nio实现，有效管理线程，解决高并发问题。</li><li>支持数据库的多片自动路由与聚合，支持sum/count/max等常用的聚合函数，支持跨库分页。</li><li>支持单库内部任意join，支持跨库2表join，甚至基于caltlet的夺标join</li><li>支持通过全局表，ER关系的分片策略，实现了搞笑的夺标join查询。</li><li>支持多租户方案。</li><li>支持分布式事务（弱xa）</li><li>支持XA分布式事务（1.6.5）</li><li>支持全局id，解决分布式下的主键生成问题</li><li>分片规则丰富，插件化开发，易于扩展。</li></ul></blockquote><h5 id="1-1-2-核心概念"><a href="#1-1-2-核心概念" class="headerlink" title="1.1.2 核心概念"></a>1.1.2 核心概念</h5><table><thead><tr><th>概念</th><th>含义</th></tr></thead><tbody><tr><td>主机</td><td>物理主机，一台服务器，一个数据库服务，一个 3306 端口</td></tr><tr><td>物理数据库</td><td>真实的数据库，例如 146、150、151 的 gpcat 数据库</td></tr><tr><td>物理表</td><td>真实的表，例如 146、150、151 的 gpcat 数据库的 order_info 表</td></tr><tr><td>分片</td><td>将原来单个数据库的数据切分后分散存储在不同的数据库节点</td></tr><tr><td>分片节点</td><td>分片以后数据存储的节点</td></tr><tr><td>分片键</td><td>分片依据的字段，例如 order_info 表以 id 为依据分片,id 就是分片键，通常是主键</td></tr><tr><td>分片算法</td><td>分片的规则，例如随机、取模、范围、哈希、枚举以及各种组合算法</td></tr><tr><td>逻辑表</td><td>相对于物理表，是分片表聚合后的结果，对于客户端来说跟真实的表没有区别</td></tr><tr><td>逻辑数据库</td><td>相对于物理数据库，是数据节点聚合后的结果</td></tr></tbody></table><p>一个逻辑表可以映射到多个节点的一张表(分片表)，也可以映射到一个节点的表 (非分片表)，也可以映射到一个节点的多张表(单库分表)。</p><p>下载、解压 Mycat(有 Windows 版本，可以在本地数据库测试)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://dl.mycat.org.cn/1.6.7.3/20190927161129/Mycat-server-1.6.7.3-release-20190927161129-linux.tar.gz tar -xzvf Mycat-server-1.6.7.3-release-20190927161129-linux.tar.gz</span><br></pre></td></tr></table></figure><p>Mycat 解压以后有 5 个目录</p><table><thead><tr><th>目录</th><th>作用</th></tr></thead><tbody><tr><td>bin</td><td>启动目录</td></tr><tr><td>catlet</td><td>空目录</td></tr><tr><td>conf</td><td>配置目录</td></tr><tr><td>lib</td><td>jar 包依赖</td></tr><tr><td>logs</td><td>日志目录</td></tr></tbody></table><h4 id="1-2-Mycat配置详解"><a href="#1-2-Mycat配置详解" class="headerlink" title="1.2 Mycat配置详解"></a>1.2 Mycat配置详解</h4><p>主要的配置文件 server.xml、schema.xml、rule.xml 和具体的分片配置文件。</p><p>坑非常多，配置错误会导致无法启动，这个时候要看 wrapper 日志!</p><p>文件一定要注意备份，不知道什么时候就跑不起来了……</p><h5 id="1-2-1-server-xml"><a href="#1-2-1-server-xml" class="headerlink" title="1.2.1 server.xml"></a>1.2.1 server.xml</h5><p>包含系统配置信息。</p><p><system> 标签：例如字符集、线程数、心跳、分布式事务开关等等。 </system></p><p><user> 标签：配置登录用户和权限。</user></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">"root"</span> <span class="attr">defaultAccount</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"schemas"</span>&gt;</span>imall<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure><p>mycat 对密码加密：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp Mycat-server-1.6.7.3-release.jar io.mycat.util.DecryptUtil 0:root:123456</span><br></pre></td></tr></table></figure><h5 id="1-2-2-schema-xml"><a href="#1-2-2-schema-xml" class="headerlink" title="1.2.2 schema.xml"></a>1.2.2 schema.xml</h5><p>schema 在 MySQL 里面跟数据库是等价的。</p><p>schema.xml 包括逻辑库、表、分片规则、分片节点和数据源，可以定义多个 schema。 </p><p>这里面有三个主要的标签(table、dataNode、dataHost)</p><p>schema 在 MySQL 里面跟数据库是等价的。</p><table><p>表名和库名最好都用小写 定义了逻辑表，以及逻辑表分布的节点和分片规则</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">"imall"</span> <span class="attr">checkSQLschema</span>=<span class="string">"false"</span> <span class="attr">sqlMaxLimit</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"customer"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span> <span class="attr">dataNode</span>=<span class="string">"122-imall,123-imall,124-imall"</span> <span class="attr">rule</span>=<span class="string">"auto-sharding-long"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"order_info"</span> <span class="attr">dataNode</span>=<span class="string">"122-imall,123-imall,124-imall"</span> <span class="attr">rule</span>=<span class="string">"mod-long-order"</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">childTable</span> <span class="attr">name</span>=<span class="string">"order_detail"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span> <span class="attr">joinKey</span>=<span class="string">"order_id"</span> <span class="attr">parentKey</span>=<span class="string">"order_id"</span>/&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">"gupao"</span> <span class="attr">checkSQLschema</span>=<span class="string">"false"</span> <span class="attr">sqlMaxLimit</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"student"</span> <span class="attr">primaryKey</span>=<span class="string">"sid"</span> <span class="attr">dataNode</span>=<span class="string">"122-gupao,123-gupao,124-gupao"</span> <span class="attr">rule</span>=<span class="string">"mod-long"</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br></pre></td></tr></table></figure><p>属性：</p><p>checkSQLschema：在查询 SQL 中去掉逻辑库名</p><p>sqlMaxLimit：自动加上 limit 控制数据的返回</p><p>primaryKey：指定该逻辑表对应真实表的主键。MyCat 会缓存主键(通过 primaryKey 属性配置)与 具体 dataNode 的信息。当分片规则(rule)使用非主键进行分片时，那么在使用主键进行查询时，MyCat 就会通过缓存先确定记录在哪个 dataNode 上，然后再在该 dataNode 上执行查询。 如果没有缓存/缓存并没有命中的话，还是会发送语句给所有的 dataNode。</p><p>dataNode：数据分片的节点</p><p>autoIncrement：自增长(全局序列)，true 代表主键使用自增长策略</p><p>type：全局表：global。其他表：不配置</p><p><datanode>：数据节点与物理数据库的对应关系。</datanode></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"122-imall"</span> <span class="attr">dataHost</span>=<span class="string">"host122"</span> <span class="attr">database</span>=<span class="string">"imall"</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"123-imall"</span> <span class="attr">dataHost</span>=<span class="string">"host123"</span> <span class="attr">database</span>=<span class="string">"imall"</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"124-imall"</span> <span class="attr">dataHost</span>=<span class="string">"host124"</span> <span class="attr">database</span>=<span class="string">"imall"</span> /&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"122-gupao"</span> <span class="attr">dataHost</span>=<span class="string">"host122"</span> <span class="attr">database</span>=<span class="string">"gupao"</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"123-gupao"</span> <span class="attr">dataHost</span>=<span class="string">"host123"</span> <span class="attr">database</span>=<span class="string">"gupao"</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"124-gupao"</span> <span class="attr">dataHost</span>=<span class="string">"host124"</span> <span class="attr">database</span>=<span class="string">"gupao"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><datahost>：配置物理主机的信息，readhost 是从属于 writehost 的。</datahost></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">"host122"</span> <span class="attr">maxCon</span>=<span class="string">"1000"</span> <span class="attr">minCon</span>=<span class="string">"10"</span> <span class="attr">balance</span>=<span class="string">"0"</span> <span class="attr">writeType</span>=<span class="string">"0"</span> <span class="attr">dbType</span>=<span class="string">"mysql"</span> <span class="attr">dbDriver</span>=<span class="string">"native"</span> <span class="attr">switchType</span>=<span class="string">"1"</span> <span class="attr">slaveThreshold</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">"hostM1"</span> <span class="attr">url</span>=<span class="string">"192.168.44.122:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"123456"</span>&gt;</span><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span> <span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">"host123"</span> <span class="attr">maxCon</span>=<span class="string">"1000"</span> <span class="attr">minCon</span>=<span class="string">"10"</span> <span class="attr">balance</span>=<span class="string">"0"</span> <span class="attr">writeType</span>=<span class="string">"0"</span> <span class="attr">dbType</span>=<span class="string">"mysql"</span> <span class="attr">dbDriver</span>=<span class="string">"native"</span> <span class="attr">switchType</span>=<span class="string">"1"</span> <span class="attr">slaveThreshold</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">"hostM1"</span> <span class="attr">url</span>=<span class="string">"192.168.44.123:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"123456"</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- &lt;readHost host="hostS1"&gt;&lt;/readHost&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">"host124"</span> <span class="attr">maxCon</span>=<span class="string">"1000"</span> <span class="attr">minCon</span>=<span class="string">"10"</span> <span class="attr">balance</span>=<span class="string">"0"</span> <span class="attr">writeType</span>=<span class="string">"0"</span> <span class="attr">dbType</span>=<span class="string">"mysql"</span> <span class="attr">dbDriver</span>=<span class="string">"native"</span> <span class="attr">switchType</span>=<span class="string">"1"</span> <span class="attr">slaveThreshold</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">"hostM1"</span> <span class="attr">url</span>=<span class="string">"192.168.44.124:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"123456"</span>&gt;</span><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>balance</strong>：负载的配置，决定 select 语句的负载</p><ul><li>0：不开启读写分离机制，所有操作都会发送到当前可用的writeHost上。</li><li>1：所有读操作都随机发送到当前的writeHost对用的readHost和备用的writeHost上</li><li>2：所有读操作都随机发送到所有的writeHost，readHost上</li><li>3：所有读操作都只发送到writeHost的readHost上</li></ul><p><strong>writeType</strong>：读写分离的配置，决定 update、delete、insert 语句的负载</p><ul><li>0：所有写操作都发送到可用的writeHost上（默认第一个，第一个挂了以后发到第二个）</li><li>1：所有写操作都随机发送到writeHost上</li></ul><p><strong>switchType</strong>：主从切换配置</p><ul><li>-1： 表示不自动切换</li><li>1： 默认值，表示自动切换</li><li>2：基于MySQL主从同步的状态决定了是否切换，心跳语句为show slave status</li><li>3：基于MySQL galera cluster的切换机制（适合集群），心跳语句为show statu like ‘wsrep%’</li></ul><h5 id="1-2-3-rule-xml"><a href="#1-2-3-rule-xml" class="headerlink" title="1.2.3 rule.xml"></a>1.2.3 rule.xml</h5><p>定义了分片规则和算法<br>分片规则：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"rang-long-cust"</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>func-rang-long-cust<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br></pre></td></tr></table></figure><p>分片算法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"func-rang-long-cust"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.AutoPartitionByLong"</span>&gt;</span> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapFile"</span>&gt;</span>rang-long-cust.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><p>分片配置：rang-long-cust.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10001-20000=1 </span><br><span class="line">0-10000=0 </span><br><span class="line">20001-100000=2</span><br></pre></td></tr></table></figure><p>以上是最重要的三个配置文件。</p><h5 id="1-2-4-ZK-配置"><a href="#1-2-4-ZK-配置" class="headerlink" title="1.2.4 ZK 配置"></a>1.2.4 ZK 配置</h5><p>除了本地文件之外，Mycat 也支持 ZK 配置(管理配置和全局 ID)，用于实现集群扩展。</p><p>启用 ZK 配置： mycat/conf/myid.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">loadZk=true</span><br><span class="line">zkURL=127.0.0.1:2181</span><br><span class="line">clusterId=010</span><br><span class="line">myid=01001</span><br><span class="line">clusterSize=1</span><br><span class="line">clusterNodes=mycat_gp_01</span><br><span class="line">\#server booster ; booster install on db same server,will reset all minCon to 2 type=server</span><br><span class="line">boosterDataHosts=dataHost1</span><br></pre></td></tr></table></figure><p>执行 bin 目录下 init_zk_data.sh，会自动将 zkconf 下的所有配置文件上传到 zk(先 拷贝过去)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/soft/mycat/conf</span><br><span class="line">cp *.txt *.xml *.properties zkconf/ </span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/soft/mycat/bin ./init_zk_data.sh</span><br></pre></td></tr></table></figure><p>注意：如果执行 init_zk_data.sh 脚本报错的话，代表未写入成功，此时不要启用 ZK 配置并重启，否则本地文件会被覆盖。</p><p>启动时如果 loadzk=true 启动时，会自动从 zk 下载配置文件覆盖本地配置。</p><p>在这种情况下如果修改配置，需要先修改 conf 目录的配置，copy 到 zkconf，再执 行上传。</p><h5 id="1-2-5-启动停止"><a href="#1-2-5-启动停止" class="headerlink" title="1.2.5 启动停止"></a>1.2.5 启动停止</h5><p>检查环境变量配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conf/wrapper.conf </span><br><span class="line">wrapper.java.command=/usr/<span class="built_in">local</span>/soft/java/jdk1.8.0_40/bin/java</span><br></pre></td></tr></table></figure><p>进入 mycat/bin 目录(注意要先启动物理数据库)： </p><p>如果直接用解压包，需要对 bin 目录下所有执行文件 chmod777。</p><ul><li>启动命令：./mycat start</li><li>停止命令：./mycat stop</li><li>重启命令：./mycat restart</li><li>查看状态：./mycat status</li><li>前台运行：./mycat console</li></ul><p>应用连接：</p><p>mysql -uroot -p123456 -h 192.168.44.122 -P8066 imall</p><h4 id="1-3-Mycat分片验证"><a href="#1-3-Mycat分片验证" class="headerlink" title="1.3 Mycat分片验证"></a>1.3 Mycat分片验证</h4><p>准备三个数据库</p><p>customer：范围分片</p><p>student 表：取模分片</p><p>order_info order_detail ER 表。 </p><p>dict 表：全局表。</p><p>noshard 表：不分片表。</p><p>feedetail 表：库内分表</p><p>在三个数据库中建表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`customer`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`order_info`</span> (</span><br><span class="line"><span class="string">`order_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'订单 ID'</span>, </span><br><span class="line">  <span class="string">`uid`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户 ID'</span>,</span><br><span class="line">  <span class="string">`nums`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'商品数量'</span>,</span><br><span class="line"><span class="string">`state`</span> <span class="built_in">int</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'订单状态'</span>,</span><br><span class="line"><span class="string">`create_time`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'更新时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`order_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`order_detail`</span> (</span><br><span class="line"><span class="string">`order_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'订单号'</span>,</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'订单详情'</span>,</span><br><span class="line"><span class="string">`goods_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'货品 ID'</span>,</span><br><span class="line"><span class="string">`price`</span> <span class="built_in">decimal</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'价格'</span>,</span><br><span class="line"><span class="string">`is_pay`</span> <span class="built_in">int</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'支付状态'</span>,</span><br><span class="line"><span class="string">`is_ship`</span> <span class="built_in">int</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'是否发货'</span>,</span><br><span class="line"><span class="string">`status`</span> <span class="built_in">int</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'订单详情状态'</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`order_id`</span>,<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> (</span><br><span class="line"><span class="string">`sid`</span> <span class="built_in">int</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`qq`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`sid`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><p>非分片表，在第一个节点上创建：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`noshard`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8mb4_bin <span class="keyword">DEFAULT</span> <span class="literal">NULL</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_bin;</span><br></pre></td></tr></table></figure><h5 id="1-3-1-范围分片"><a href="#1-3-1-范围分片" class="headerlink" title="1.3.1 范围分片"></a>1.3.1 范围分片</h5><p>imall 库 customer 表：范围分片</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"customer"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span> <span class="attr">dataNode</span>=<span class="string">"72-imall,74-imall,76-imall"</span> <span class="attr">rule</span>=<span class="string">"auto-sharding-long"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>在rule.xml中可以查看到，名为<code>auto-sharding-long</code> 的分片规则使用的是rang-long算法，而该算法需要接收一个名为autopartition-long.txt的文件作为参数；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 来源 rule.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"auto-sharding-long"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>rang-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"rang-long"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.AutoPartitionByLong"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapFile"</span>&gt;</span>autopartition-long.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在conf目录创建autopartition-long.txt文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># range start-end ,data node index</span><br><span class="line"># K=1000,M=10000.</span><br><span class="line"># 未使用</span><br><span class="line">0-10000=0</span><br><span class="line">10001-20000=1</span><br><span class="line">20001-30000=2</span><br></pre></td></tr></table></figure><p>那么当在customer表中插入如下数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`customer`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>) <span class="keyword">VALUES</span> (<span class="number">6666</span>, <span class="string">'赵先生'</span>);  <span class="comment">--72-mall</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`customer`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>) <span class="keyword">VALUES</span> (<span class="number">7777</span>, <span class="string">'钱先生'</span>);  <span class="comment">--72-mall</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`customer`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>) <span class="keyword">VALUES</span> (<span class="number">16666</span>, <span class="string">'孙先生'</span>); <span class="comment">--74-mall</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`customer`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>) <span class="keyword">VALUES</span> (<span class="number">17777</span>, <span class="string">'李先生'</span>);  <span class="comment">--74-mall</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`customer`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>) <span class="keyword">VALUES</span> (<span class="number">26666</span>, <span class="string">'周先生'</span>);  <span class="comment">--76-mall</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`customer`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>) <span class="keyword">VALUES</span> (<span class="number">27777</span>, <span class="string">'吴先生'</span>);  <span class="comment">--76-mall</span></span><br></pre></td></tr></table></figure><p>问题：超过范围会怎么样？找不到节点。</p><h5 id="1-3-2-取模分片表"><a href="#1-3-2-取模分片表" class="headerlink" title="1.3.2 取模分片表"></a>1.3.2 取模分片表</h5><p>panda 数据库，student 表：取模分片</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"student"</span> <span class="attr">dataNode</span>=<span class="string">"72-panda,74-panda,76-panda"</span> <span class="attr">rule</span>=<span class="string">"mod-long"</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"mod-long"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">columns</span>&gt;</span>sid<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>mod-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"mod-long"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByMod"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- how many data nodes ,这里要根据实际需要进行配置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"count"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span> (<span class="string">`sid`</span>, <span class="string">`name`</span>, <span class="string">`qq`</span>) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'李大彪'</span>, <span class="string">'166669999'</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span> (<span class="string">`sid`</span>, <span class="string">`name`</span>, <span class="string">`qq`</span>) <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">'菜狗子'</span>, <span class="string">'655556666'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span> (<span class="string">`sid`</span>, <span class="string">`name`</span>, <span class="string">`qq`</span>) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">'等候那場雪'</span>, <span class="string">'466669999'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span> (<span class="string">`sid`</span>, <span class="string">`name`</span>, <span class="string">`qq`</span>) <span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="string">'猫老公'</span>, <span class="string">'265286999'</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span> (<span class="string">`sid`</span>, <span class="string">`name`</span>, <span class="string">`qq`</span>) <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">'tj-大白'</span>, <span class="string">'368828888'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span> (<span class="string">`sid`</span>, <span class="string">`name`</span>, <span class="string">`qq`</span>) <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="string">'大郎'</span>, <span class="string">'516895555'</span>);</span><br></pre></td></tr></table></figure><h5 id="1-3-3-取模分片（ER表）"><a href="#1-3-3-取模分片（ER表）" class="headerlink" title="1.3.3 取模分片（ER表）"></a>1.3.3 取模分片（ER表）</h5><p>我们有些表的数据是存在逻辑的主外键关系的，比如订单表 order_info，存的是汇 总的商品数，商品金额;订单明细表 order_detail，是每个商品的价格，个数等等。或者 叫做从属关系，父表和子表的关系。</p><p>他们之间会经常有关联查询的操作，如果父表的数据和子表的数据分别存储在不同的数据库，跨库关联查询也比较麻烦。所以我们能不能把父表和数据和从属于父表的数 据落到一个节点上呢？</p><p>比如 order_id=1001 的数据在 node1，它所有的明细数据也放到 node1; order_id=1002 的数据在 node2，它所有的明细数据都放到 node2，这样在关联查询的 时候依然是在一个数据库。</p><p>注意，这个也是一种避免跨库关联的重要手段。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"order_info"</span> <span class="attr">dataNode</span>=<span class="string">"72-imall,74-imall,76-imall"</span> <span class="attr">rule</span>=<span class="string">"mod-long-order"</span> &gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">childTable</span> <span class="attr">name</span>=<span class="string">"order_detail"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span> <span class="attr">joinKey</span>=<span class="string">"order_id"</span> <span class="attr">parentKey</span>=<span class="string">"order_id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>去rule.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"mod-long-order"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">columns</span>&gt;</span>order_id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span> <span class="comment">&lt;!--此处需配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>mod-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"mod-long"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByMod"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- how many data nodes ,这里要根据实际需要进行配置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"count"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><p>imall 库，order_info</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`order_info`</span> (<span class="string">`order_id`</span>, <span class="string">`uid`</span>, <span class="string">`nums`</span>, <span class="string">`state`</span>, <span class="string">`create_time`</span>, <span class="string">`update_time`</span>) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1000001</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'2025-9-23 14:35:37'</span>, <span class="string">'2025-9-23 14:35:37'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`order_info`</span> (<span class="string">`order_id`</span>, <span class="string">`uid`</span>, <span class="string">`nums`</span>, <span class="string">`state`</span>, <span class="string">`create_time`</span>, <span class="string">`update_time`</span>) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="number">1000002</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'2025-9-24 14:35:37'</span>, <span class="string">'2025-9-24 14:35:37'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`order_info`</span> (<span class="string">`order_id`</span>, <span class="string">`uid`</span>, <span class="string">`nums`</span>, <span class="string">`state`</span>, <span class="string">`create_time`</span>, <span class="string">`update_time`</span>) <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="number">1000003</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="string">'2025-9-25 11:35:49'</span>, <span class="string">'2025-9-25 11:35:49'</span>);</span><br></pre></td></tr></table></figure><p>imall库，order_detail</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`order_detail`</span> (<span class="string">`order_id`</span>, <span class="string">`id`</span>, <span class="string">`goods_id`</span>, <span class="string">`price`</span>, <span class="string">`is_pay`</span>, <span class="string">`is_ship`</span>, <span class="string">`status`</span>) <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="number">20180001</span>, <span class="number">85114752</span>, <span class="number">19.99</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`order_detail`</span> (<span class="string">`order_id`</span>, <span class="string">`id`</span>, <span class="string">`goods_id`</span>, <span class="string">`price`</span>, <span class="string">`is_pay`</span>, <span class="string">`is_ship`</span>, <span class="string">`status`</span>) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">20180002</span>, <span class="number">25411251</span>, <span class="number">1280.00</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`order_detail`</span> (<span class="string">`order_id`</span>, <span class="string">`id`</span>, <span class="string">`goods_id`</span>, <span class="string">`price`</span>, <span class="string">`is_pay`</span>, <span class="string">`is_ship`</span>, <span class="string">`status`</span>) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">20180003</span>, <span class="number">62145412</span>, <span class="number">288.00</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`order_detail`</span> (<span class="string">`order_id`</span>, <span class="string">`id`</span>, <span class="string">`goods_id`</span>, <span class="string">`price`</span>, <span class="string">`is_pay`</span>, <span class="string">`is_ship`</span>, <span class="string">`status`</span>) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="number">20180004</span>, <span class="number">21456985</span>, <span class="number">399.00</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`order_detail`</span> (<span class="string">`order_id`</span>, <span class="string">`id`</span>, <span class="string">`goods_id`</span>, <span class="string">`price`</span>, <span class="string">`is_pay`</span>, <span class="string">`is_ship`</span>, <span class="string">`status`</span>) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="number">20180005</span>, <span class="number">21457452</span>, <span class="number">1680.00</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`order_detail`</span> (<span class="string">`order_id`</span>, <span class="string">`id`</span>, <span class="string">`goods_id`</span>, <span class="string">`price`</span>, <span class="string">`is_pay`</span>, <span class="string">`is_ship`</span>, <span class="string">`status`</span>) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="number">20180006</span>, <span class="number">65214789</span>, <span class="number">9999.00</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h5 id="1-3-4-全局表"><a href="#1-3-4-全局表" class="headerlink" title="1.3.4 全局表"></a>1.3.4 全局表</h5><p>panda 数据库，dict 表：全局表</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"dict"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"global"</span> <span class="attr">dataNode</span>=<span class="string">"72-panda,74-panda,76-panda"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>注意没有配置rule属性，默认就是写到每个配置了的节点</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`dict`</span> (<span class="string">`id`</span>, <span class="string">`param_code`</span>, <span class="string">`param_name`</span>) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'0731'</span>, <span class="string">'长沙市'</span>);</span><br></pre></td></tr></table></figure><h5 id="1-3-5-非分片表"><a href="#1-3-5-非分片表" class="headerlink" title="1.3.5 非分片表"></a>1.3.5 非分片表</h5><p>panda数据库，noshard 表</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"noshard"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span> <span class="attr">autoIncrement</span>=<span class="string">"true"</span> <span class="attr">dataNode</span>=<span class="string">"72-panda"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>没有配置rule属性，并且只配置一个节点</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`noshard`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'这是一条没有分片的数据'</span>);</span><br></pre></td></tr></table></figure><h5 id="1-3-6-库内分表"><a href="#1-3-6-库内分表" class="headerlink" title="1.3.6 库内分表"></a>1.3.6 库内分表</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"fee"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span> <span class="attr">subTables</span>=<span class="string">"fee2025$1-3"</span> <span class="attr">dataNode</span>=<span class="string">"72-panda"</span> <span class="attr">rule</span>=<span class="string">"sharding-by-month"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>根据时间路由到不同的表中</p><p>注意，逻辑表也要创建，即使没有数据，否则会报错。<br>需要在 122-gupao 清空所有数据(bug，mycat 无法 truncate)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`fee`</span> (<span class="string">`id`</span>, <span class="string">`create_time`</span>) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'2025-1-1 14:46:19'</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`fee`</span> (<span class="string">`id`</span>, <span class="string">`create_time`</span>) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">'2025-2-1 14:46:19'</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`fee`</span> (<span class="string">`id`</span>, <span class="string">`create_time`</span>) <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">'2025-3-1 14:46:19'</span>);</span><br></pre></td></tr></table></figure><h4 id="1-4-Mycat全局ID"><a href="#1-4-Mycat全局ID" class="headerlink" title="1.4 Mycat全局ID"></a>1.4 Mycat全局ID</h4><p>Mycat 全局序列实现方式主要有 4 种：</p><ul><li>本地文件方式</li><li>数据库方式</li><li>本地时间戳算 法</li><li>ZK</li></ul><p>也可以自定义业务序列。</p><p>注意获取的前缀都是：MYCATSEQ_ </p><p><a href="https://blog.51cto.com/mynode/1910570" target="_blank" rel="noopener">参考资料</a></p><p>首先全局id实现方式的选择在server.xml中配置</p><p>配置sequnceHandlerType 值：<br>0-文件 </p><p>1-数据库 </p><p>2-本地时间戳 </p><p>3-ZK</p><h5 id="1-4-1-文件方式"><a href="#1-4-1-文件方式" class="headerlink" title="1.4.1 文件方式"></a>1.4.1 文件方式</h5><p>配置 conf/sequence_conf.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CUSTOMER.HISIDS= </span><br><span class="line">CUSTOMER.MINID=10000001 </span><br><span class="line">CUSTOMER.MAXID=20000000 </span><br><span class="line">CUSTOMER.CURID=10000001</span><br></pre></td></tr></table></figure><p>语法：select next value for MYCATSEQ_CUSTOMER;</p><p>在插入时使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`noshard`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>) <span class="keyword">VALUES</span> (<span class="number">8</span>, <span class="keyword">next</span> <span class="keyword">value</span> <span class="keyword">for</span> MYCATSEQ_CUSTOMER);</span><br></pre></td></tr></table></figure><p>优点：本地加载，读取速度较快。</p><p>缺点：当 Mycat 重新发布后，配置文件中的 sequence 需要替换(还原)。Mycat 不能做集群部署。</p><h5 id="1-4-2-数据库方式"><a href="#1-4-2-数据库方式" class="headerlink" title="1.4.2 数据库方式"></a>1.4.2 数据库方式</h5><p>这种方式需要一个表和 3 个存储过程。</p><p>配置： sequence_db_conf.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GLOBAL=72-imall </span><br><span class="line">COMPANY=72-imall </span><br><span class="line">CUSTOMER=72-imall </span><br><span class="line">ORDERS=72-imall</span><br></pre></td></tr></table></figure><p>把这张表创建在第一个节点(72)上，所以是 72-imall</p><p>在第一个数据库节点(72)imall 数据库上创建 MYCAT_SEQUENCE 表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> MYCAT_SEQUENCE; <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> MYCAT_SEQUENCE (</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">current_value <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">increment</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>, remark <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="keyword">name</span>)) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure><p>注：可以在 schema.xml 配置文件中配置这张表，供外部访问。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"mycat_sequence"</span> <span class="attr">dataNode</span>=<span class="string">"122-imall"</span> <span class="attr">autoIncrement</span>=<span class="string">"true"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>72-imall 数据库创建存储过程：获取当前 sequence 的值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`mycat_seq_currval`</span>;</span><br><span class="line">DELIMITER ;;</span><br><span class="line"><span class="keyword">CREATE</span> DEFINER=<span class="string">`root`</span>@<span class="string">`%`</span> <span class="keyword">FUNCTION</span> <span class="string">`mycat_seq_currval`</span>(seq_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>)) <span class="keyword">RETURNS</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">CHARSET</span> latin1</span><br><span class="line"><span class="keyword">DETERMINISTIC</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> retval <span class="built_in">VARCHAR</span>(<span class="number">64</span>);</span><br><span class="line"><span class="keyword">SET</span> retval=<span class="string">"-999999999,null"</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">concat</span>(<span class="keyword">CAST</span>(current_value <span class="keyword">AS</span> <span class="built_in">CHAR</span>),<span class="string">","</span>,<span class="keyword">CAST</span>(<span class="keyword">increment</span> <span class="keyword">AS</span> <span class="built_in">CHAR</span>) ) <span class="keyword">INTO</span> retval <span class="keyword">FROM</span> MYCAT_SEQUENCE <span class="keyword">WHERE</span> <span class="keyword">name</span> = seq_name;</span><br><span class="line">RETURN retval ;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">;;</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>72-imall 数据库创建存储过程：获取下一个 sequence</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`mycat_seq_nextval`</span>;</span><br><span class="line">DELIMITER ;;</span><br><span class="line"><span class="keyword">CREATE</span> DEFINER=<span class="string">`root`</span>@<span class="string">`%`</span> <span class="keyword">FUNCTION</span> <span class="string">`mycat_seq_nextval`</span>(seq_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>)) <span class="keyword">RETURNS</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">CHARSET</span> latin1</span><br><span class="line"><span class="keyword">DETERMINISTIC</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">UPDATE</span> MYCAT_SEQUENCE</span><br><span class="line"><span class="keyword">SET</span> current_value = current_value + <span class="keyword">increment</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = seq_name;</span><br><span class="line">RETURN mycat_seq_currval(seq_name);</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">;;</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>72-mall数据库创建存储过程：设置 sequence</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`mycat_seq_setval`</span>;</span><br><span class="line">DELIMITER ;;</span><br><span class="line"><span class="keyword">CREATE</span> DEFINER=<span class="string">`root`</span>@<span class="string">`%`</span> <span class="keyword">FUNCTION</span> <span class="string">`mycat_seq_setval`</span>(seq_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>), <span class="keyword">value</span> <span class="built_in">INTEGER</span>) <span class="keyword">RETURNS</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">CHARSET</span> latin1</span><br><span class="line"><span class="keyword">DETERMINISTIC</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">UPDATE</span> MYCAT_SEQUENCE</span><br><span class="line"><span class="keyword">SET</span> current_value = <span class="keyword">value</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">name</span> = seq_name;</span><br><span class="line">RETURN mycat_seq_currval(seq_name); <span class="keyword">END</span></span><br><span class="line">;;</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>72-imall 数据库插入记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> MYCAT_SEQUENCE(<span class="keyword">name</span>,current_value,<span class="keyword">increment</span>,remark) <span class="keyword">VALUES</span> (<span class="string">'GLOBAL'</span>, <span class="number">1</span>, <span class="number">100</span>,<span class="string">''</span>); <span class="keyword">INSERT</span> <span class="keyword">INTO</span> MYCAT_SEQUENCE(<span class="keyword">name</span>,current_value,<span class="keyword">increment</span>,remark) <span class="keyword">VALUES</span> (<span class="string">'ORDERS'</span>, <span class="number">1</span>, <span class="number">100</span>,<span class="string">' 订单表使用'</span>);</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">next</span> <span class="keyword">value</span> <span class="keyword">for</span> MYCATSEQ_ORDERS</span><br></pre></td></tr></table></figure><h5 id="1-4-3-本地时间戳方式"><a href="#1-4-3-本地时间戳方式" class="headerlink" title="1.4.3 本地时间戳方式"></a>1.4.3 本地时间戳方式</h5><p>ID= 64 位二进制 (42(毫秒)+5(机器 ID)+5(业务编码)+12(重复累加) ，长度为 18 位</p><p>配置文件 sequence_time_conf.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#sequence depend on TIME</span><br><span class="line">WORKID=01 </span><br><span class="line">DATAACENTERID=01</span><br></pre></td></tr></table></figure><p>验证：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">next</span> <span class="keyword">value</span> <span class="keyword">for</span> MYCATSEQ_GLOBAL</span><br></pre></td></tr></table></figure><h5 id="1-4-4-ZK-方式"><a href="#1-4-4-ZK-方式" class="headerlink" title="1.4.4 ZK 方式"></a>1.4.4 ZK 方式</h5><p>修改 conf/myid.properties</p><p>设置 loadZk=true(启动时会从 ZK 加载配置，一定要注意备份配置文件，并且先用 bin/init_zk_data.sh,把配置文件写入到 ZK)</p><p>配置文件：sequence_distributed_conf.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 代表使用 zk</span><br><span class="line">INSTANCEID=ZK</span><br><span class="line"># 与 myid.properties 中的 CLUSTERID 设置的值相同 CLUSTERID=010</span><br></pre></td></tr></table></figure><p>复制配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/soft/mycat/conf</span><br><span class="line">cp *.txt *.xml *.properties zkconf/ </span><br><span class="line">chown -R zkconf/</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/soft/mycat/bin </span><br><span class="line">./init_zk_data.sh</span><br></pre></td></tr></table></figure><p>验证：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">next</span> <span class="keyword">value</span> <span class="keyword">for</span> MYCATSEQ_GLOBAL</span><br></pre></td></tr></table></figure><h5 id="1-4-5-使用"><a href="#1-4-5-使用" class="headerlink" title="1.4.5 使用"></a>1.4.5 使用</h5><p>每次获取都要 next value 吗？可以自动自增吗？</p><p>在 schema.xml 的 table 标签上配置 autoIncrement=”true”，不需要获取和指定序 列的情况下，就可以使用全局 ID 了。</p><p>例如非分片表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`noshard`</span> (<span class="string">`name`</span>) <span class="keyword">VALUES</span> ( <span class="string">'自动获取自增值'</span>);</span><br></pre></td></tr></table></figure><h3 id="2-Mycat-监控与日志查看"><a href="#2-Mycat-监控与日志查看" class="headerlink" title="2. Mycat 监控与日志查看"></a>2. Mycat 监控与日志查看</h3><h4 id="2-1-监控"><a href="#2-1-监控" class="headerlink" title="2.1 监控"></a>2.1 监控</h4><h5 id="2-1-1-命令行监控"><a href="#2-1-1-命令行监控" class="headerlink" title="2.1.1 命令行监控"></a>2.1.1 命令行监控</h5><p>连接到管理端口 9066(注意不是 8066)，注意必须要带 IP </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -h127.0.0.1 -p123456 -P9066</span><br></pre></td></tr></table></figure><p>全部命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;show @@help;</span><br></pre></td></tr></table></figure><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>show @@server;</td><td>查看服务器状态，包括占用内存等</td></tr><tr><td>show @@database;</td><td>查看数据库</td></tr><tr><td>show @@datanode;</td><td>查看数据节点</td></tr><tr><td>show @@datasource;</td><td>查看数据源</td></tr><tr><td>show @@connection;</td><td>该命令用于获取 Mycat 的前端连接状态，即应用与 mycat 的连接</td></tr><tr><td>show @@backend;</td><td>查看后端连接状态</td></tr><tr><td>show @@cache;</td><td>查看缓存使用情况<br> SQLRouteCache:sql 路由缓存。<br> TableID2DataNodeCache : 缓存表主键与分片对应关系。 ER_SQL2PARENTID : 缓存 ER 分片中子表与父表关系</td></tr><tr><td>reload  @@config;</td><td>重新加载基本配置(热加载)，使用这个命令时 mycat 服务不可用</td></tr><tr><td>show @@sysparam;</td><td>查询 mycat 服务的系统参数</td></tr><tr><td>show @@sql.high;</td><td>执行频率高的 SQL</td></tr><tr><td>show @@sql.slow;</td><td>慢 SQL<br>设置慢 SQL 的命令:reload @@sqlslow=5 ;</td></tr><tr><td>show @@syslog limit=50;</td><td>查看最近 50 条系统日志</td></tr></tbody></table><p>##### </p><h5 id="2-1-2-命令行监控-mycatweb-监控"><a href="#2-1-2-命令行监控-mycatweb-监控" class="headerlink" title="2.1.2 命令行监控 mycatweb 监控"></a>2.1.2 命令行监控 mycatweb 监控</h5><p><a href="https://github.com/MyCATApache/Mycat-download/tree/master/mycat-web-1.0" target="_blank" rel="noopener">https://github.com/MyCATApache/Mycat-download/tree/master/mycat-web-1.0</a></p><p>Mycat-eye 是 mycat 提供的一个监控工具，它依赖于 ZK。 本地必须要运行一个 ZK，必须先启动 ZK。</p><p>参考:<a href="https://gper.club/articles/7e7e7f7ff7g59gc3g64" target="_blank" rel="noopener">https://gper.club/articles/7e7e7f7ff7g59gc3g64</a></p><p>下载 mycat-web</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/soft</span><br><span class="line"> wget http://dl.mycat.io/mycat-web-1.0/Mycat-web-1.0-SNAPSHOT-20170102153329-linux.tar.gz tar -xzvf Mycat-web-1.0-SNAPSHOT-20170102153329-linux.tar.gz</span><br></pre></td></tr></table></figure><p>启动 mycat-web</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd mycat-web nohup </span><br><span class="line">./start.sh &amp;</span><br></pre></td></tr></table></figure><p>停止:kill start.jar 相关的进程</p><p>访问端口 8082</p><p><a href="http://10.0.12.72:8082/mycat/" target="_blank" rel="noopener">http://10.0.12.72:8082/mycat/</a></p><p>mycat server.xml 配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1 为开启实时统计、0 为关闭 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"useSqlStat"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重启 mycat 服务生效</p><h4 id="2-2-日志"><a href="#2-2-日志" class="headerlink" title="2.2 日志"></a>2.2 日志</h4><p>log4j 的 level 配置要改成 debug</p><h5 id="2-2-1-wrapper-log-日志"><a href="#2-2-1-wrapper-log-日志" class="headerlink" title="2.2.1 wrapper.log 日志"></a>2.2.1 wrapper.log 日志</h5><p>wrapper 日志：mycat 启动，停止，添加为服务等都会记录到此日志文件，如果系 统环境配置错误或缺少配置时，导致 Mycat 无法启动，可以通过查看 wrapper.log 定位 具体错误原因。</p><h5 id="2-2-2-mycat-log-日志"><a href="#2-2-2-mycat-log-日志" class="headerlink" title="2.2.2 mycat.log 日志"></a>2.2.2 mycat.log 日志</h5><p>mycat.log 为 mycat 主要日志文件，记录了启动时分配的相关 buffer 信息，数据源 连接信息，连接池，动态类加载信息等等。</p><p>在 conf/log4j2.xml 文件中进行相关配置，如保留个数，大小，字符集，日志文件大 小等。</p></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目标：&lt;/p&gt;
&lt;p&gt;1、通过实际案例掌握 Mycat 特性与详细配置含义&lt;/p&gt;
&lt;p&gt;2、了解 Mycat 监控与日志查看&lt;/p&gt;
&lt;h3 id=&quot;1-Mycat-概念与配置&quot;&gt;&lt;a href=&quot;#1-Mycat-概念与配置&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="数据库技术" scheme="http://yoursite.com/child/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Mycat" scheme="http://yoursite.com/child/tags/Mycat/"/>
    
  </entry>
  
  <entry>
    <title>分库分表-为什么要分库分表</title>
    <link href="http://yoursite.com/child/2020/05/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF-Mycat-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <id>http://yoursite.com/child/2020/05/10/数据库技术-Mycat-为什么要分库分表/</id>
    <published>2020-05-10T02:56:23.000Z</published>
    <updated>2020-11-15T09:48:21.379Z</updated>
    
    <content type="html"><![CDATA[<p>目标：</p><p>1、理解分库分表的意义</p><p>2、理解数据切分的不同方式，以及带来的问题与解决方案</p><h3 id="1、为什么要分库分表"><a href="#1、为什么要分库分表" class="headerlink" title="1、为什么要分库分表"></a>1、为什么要分库分表</h3><p>随着业务变得越来越复杂，用户越来越多，集中式的架构性能会出现巨大的问题，比如系统会越来越慢，而且时不时会宕机，所以必须要解决高性能和可用性的问题。</p><p>不仅仅是应用，作为所有业务数据的管理者，数据库也会遇到一样的问题，而且很 多时候应用系统出现问题，就是数据库变慢了或者数据库挂掉了导致的。</p><h4 id="1-1-数据库瓶颈的出现"><a href="#1-1-数据库瓶颈的出现" class="headerlink" title="1.1 数据库瓶颈的出现"></a>1.1 数据库瓶颈的出现</h4><p>一般来说哦会出现哪些问题呢？比如在高并发的情况下连接数不够用；或者数据量太大，查询效率变得越来越低；或者是因为存储的问题，数据库所在的及其性能下降</p><p>这些问题归根到底都是收到了硬件的限制，cpu内存磁盘网络等等。在集中式架构里面，我们怎么解决硬件带来的性能瓶颈问题呢？加配置。换cpu，升级内存，扩展磁盘，升级带宽等等</p><p>这种优化方式有两个问题</p><ul><li>随着业务量变大容易遇到新的瓶颈</li><li>收效投入比太低</li></ul><p>那我们思考一下，把升级硬件放在一边，如果数据库的性能出现问题了，我们可以从哪些方面进行优化呢？有没有成本更低收效更好的方式？</p><h4 id="1-2-数据库优化方案对比"><a href="#1-2-数据库优化方案对比" class="headerlink" title="1.2 数据库优化方案对比"></a>1.2 数据库优化方案对比</h4><p>第一招：重启——重启是释放资源最好的方法</p><h5 id="1-2-1-SQL与索引"><a href="#1-2-1-SQL与索引" class="headerlink" title="1.2.1 SQL与索引"></a>1.2.1 SQL与索引</h5><p>当SQL写的非常复杂，比如关联的表非常多，条件非常多，查询消耗的事件非常长，这样的一个SQL就要慢SQL。以为SQL语句是我们自己写的，可控性最高，所以第一步就是检查SQL。在很多情况下我们优化的目标就是为了用到索引。</p><h5 id="1-2-2-表与存储引擎"><a href="#1-2-2-表与存储引擎" class="headerlink" title="1.2.2 表与存储引擎"></a>1.2.2 表与存储引擎</h5><p>如果sql语句没什么问题，那就接着检查我们查询的目标，也就是表结构的设计有没有问题。比如对于字段类型和长度的选择，或者表结构是不是需要拆分或者合并，不同的表应该选择什么存储引擎是不是需要分区等等。</p><h5 id="1-2-3-架构优化"><a href="#1-2-3-架构优化" class="headerlink" title="1.2.3 架构优化"></a>1.2.3 架构优化</h5><p>表结构也没问题了，就要上升到数据库服务的层面，从架构层面进行优化。</p><p>因为数据都是在磁盘上存储，如果加了索引还是很慢，干脆可以把数据在内存里面缓存起来，这个时候可以部署缓存中间件。</p><p>如果一台数据库服务器承受不了访问压力，可以部署集群做负载均衡。当然这些数据库节点用该有自动同步的机制。有了主从同步之后就可以主从复制实现读写分离。让写的服务都访问master节点，请的请求都访问slaver节点。</p><p>有了读写分离以后问题并没有完全解决：</p><p>1、只有一个master，写的压力没有得到分摊</p><p>2、所有的节点都存储相同的数据，在一个节点出现存储瓶颈的时候，磁盘不够用了，其他节点也一样会遇到这个问题。</p><p>所以这个时候无哦们要用到分布式环境中一个非常重要的手段：分片，每个节点都只是存储总体数据的一部分，那这个就是我们今天要讲的分库分表。分片以后为了提升可用性，可以对分片再做冗余。</p><h5 id="1-2-4-数据库配置"><a href="#1-2-4-数据库配置" class="headerlink" title="1.2.4 数据库配置"></a>1.2.4 数据库配置</h5><p>如果通过架构层面没有解决问题，或者机器虽然配置很高但是性能没有发挥到极致，还可以优化数据库的配置，比如连接数，缓冲池大小等等</p><h5 id="1-2-5-操作系统"><a href="#1-2-5-操作系统" class="headerlink" title="1.2.5 操作系统"></a>1.2.5 操作系统</h5><p>当然，因为数据库时安装在操作系统上的，所以操作西永的配置也有优化空间。最后才是硬件的优化，在单机的数据库上当然可以做。</p><p>我们先对数据库性能优化有了一个全局的认识，这个是非常重要的。我们清楚了分库分表在什么位置，也知道并不是数据库一慢，就要去做分库分表，可以优化的地方多的是。</p><p>OK，那么问题来了，这么多的优化方案，到底什么时候才需要分库分表呢?</p><p>评判标准是什么？</p><ul><li>如果是数据量的话，一张表存储了多少记录的时候，才需要考虑分库分表？</li><li>如果是数据增长速度的话，每天产生多少数据，才需要考虑分库分表？</li><li>如果是应用访问情况的话，查询超过几秒中，有多少请求无法获取连接，才需要考虑分库分表？</li></ul><p>先来看一下一个消费金融核心系统的架构演进过程。这个也是很多公司项目一般的演进过程。</p><h4 id="1-3-架构演进与分库分表"><a href="#1-3-架构演进与分库分表" class="headerlink" title="1.3 架构演进与分库分表"></a>1.3 架构演进与分库分表</h4><p>消费金融这个名字可能听起来比较陌生，但是跟大 家的生活息息相关。它主要是分成线上和线下两部分。线下的就是跟一些门店合作，提 供贷款服务，所以大家买手机买电脑买摩托车可以分期。线上的就是一些电商的场景， 比如花呗、京东白条，都属于消费金融。</p><h5 id="1-3-1-单应用单数据库"><a href="#1-3-1-单应用单数据库" class="headerlink" title="1.3.1 单应用单数据库"></a>1.3.1 单应用单数据库</h5><p>当时我们是直接采购了一套消费金融核心系统，这是一个典型的单体架构的应用。</p><p>单体架构应用的特点就是所有的代码都在一个工程里面，打成一个 war 包部署到 tomcat，最后运行在一个进程中。</p><p>有了这个系统以后，客户办理在门店办理贷款，也就是贷前贷中贷后的所有的流程 都可以通过这一套系统完成。这套消费金融的核心系统，用的是 Oracle 的数据库，初始 化以后有几百张表，比如客户信息表、账户表、商户表、产品表、放款表、还款表等等。</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/mycat/%E5%8D%95%E5%BA%94%E7%94%A8%E5%8D%95%E5%BA%93.png" style="zoom:50%;"></p><p>公司门店开到了全国几百个城市，基本上一个城市一个分公司。合作的商户有十几万家，门店数量二十几万家，客户数量到达了千万级别。</p><p>为了适应业务的发展，这一套核心系统不停地在修改，代码量越来越大，系统变得 越来越臃肿。</p><p>节假日做活动，订单暴增，结果系统宕机了几个小 时，导致全国的销售有几个小时都做不了单，干着急。</p><p>对于 IT 部来说，该做的事情全都做了，搭集群，负载均衡，加缓存，优化数据库，优化业务代码系统，但是都应对不了系统的访问压力。</p><p>所以这个时候系统拆分就势在必行了。也就是我们说的对计算进行分片。 另外一块其实也是管理上的问题，几百个人做一个项目肯定会有很多的冲突。我们把以前这一套采购的核心系统拆分出来很多的子系统，比如提单系统、商户管理系统、 信审系统、合同系统、代扣系统、催收系统，所有的系统都依旧共用一套 Oracle 数据库。</p><p>这个时候我们进入了多应用单数据库的阶段。</p><h5 id="1-3-2-多应用单数据库"><a href="#1-3-2-多应用单数据库" class="headerlink" title="1.3.2 多应用单数据库"></a>1.3.2 多应用单数据库</h5><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/mycat/%E5%A4%9A%E5%BA%94%E7%94%A8%E5%8D%95%E5%BA%93.png" style="zoom:50%;"></p><p>对代码进行了解耦，职责进行了拆分，我们的生产环境出现问题的时候，可以快速 地排查和解决。这是第一次改造，原来我们一个系统使用一个据库，现在多个子系统共 用一个 Oracle 的数据库。</p><p>但是这种多个子系统共用一个 DB 的架构，会出现一些问题，什么问题呢?</p><p>第一个就是所有的业务系统都共用一个 DB，无论是从性能还是存储的角度来说，都 是满足不了需求的。随着我们的业务继续膨胀，我们又会增加更多的系统来访问核心数 据库，但是一个物理数据库能够支撑的并发量是有限的，所有的业务系统之间还会产生 竞争，最终会导致应用的性能下降，甚至拖垮业务系统。</p><h5 id="1-3-3-多应用独立数据库"><a href="#1-3-3-多应用独立数据库" class="headerlink" title="1.3.3 多应用独立数据库"></a>1.3.3 多应用独立数据库</h5><p>所以这个时候，我们必须要对各个子系统的数据库也做一个拆分。这个时候每个业 务系统都有了自己的数据库，不同的业务系统就可以用不同的存储方案。</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/mycat/%E5%A4%9A%E5%BA%94%E7%94%A8%E5%A4%9A%E5%BA%93.png" style="zoom:50%;"></p><p>当然在一段时间之内核心数据库并没有下线，它依然是所有的 IT 系统交换数据的一 个中心，每个系统都会把自己的数据同步到核心系统，也是从核心系统同步其他系统的数据，后面我们也在逐步脱离这个核心系统。</p><p>所以，分库其实是我们在解决系统性能问题的过程中，对系统进行拆分的时候带来 的一个必然的结果。现在的微服务架构也是一样的，只拆应用不拆分数据库，不能解决根本的问题。</p><p>所以，对数据库进行分库，它一般是应用的服务拆分，模块的分解，或者子系统的 划分带来一个必然的结果。</p><h5 id="1-3-4-什么时候分表"><a href="#1-3-4-什么时候分表" class="headerlink" title="1.3.4 什么时候分表?"></a>1.3.4 什么时候分表?</h5><p>当我们对原来一个数据库的表做了分库以后，其中一些表的数据在快速地膨胀，比 如客户表已经超过 1000 万了，合同表也超过 5000 万了，还款历史表已经上亿了，而且还在以一个非常快的速度在增长，这个时候查询也已经出现了非常明显的效率下降。 所以，在分库之后，还需要进一步进行分表(单应用多数据库)。当然，我们最开 始想到的可能是在一个数据库里面拆分数据，分区或者分表，到后面才是切分到多个数据库中。 所以，分表主要是为了减少单张表的大小，解决单表数据量带来的性能问题。</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/mycat/%E5%8D%95%E5%BA%94%E7%94%A8%E5%A4%9A%E5%BA%93.png" style="zoom:50%;"></p><p>回到我们开始的问题，大家觉得一张表的存储的数量达到多少的时候，需 要做分表?</p><p>那么到底一张表数据量到达多少的时候，我们需要去做分库分表呢?200 万?300 万?500 万?</p><p>大家可能在网上看过一些数据库的规范，比如阿里巴巴 Java 开发手册，它推荐的理 论分表界线是 500 万。</p><blockquote><p>【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。 说明:如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。</p></blockquote><p>在阿里编程规约里面，它推荐的是超过 500 万才考虑分表。但是一段时间之内到不了这个数量级，不要先做分库分表。<br> 从这句话里面我们读出来两个信息: </p><p>1、第一，如果可以不用分库分表，我们尽量不要分库分表。因为它会大大地提升系统的复杂度，带来很多新的问题。如果对于一个很简单的项目，一上线就分库分表，这个就叫过度设计了，也不符合项目迭代和演进的规律。</p><p>2、第二，分库分表是一个长期的规划，要解决的不只是现在的问题。它不需要经常 性地去实施，但是一旦做了，在几年之内是不需要变动的。</p><p>到底是不是 500 万呢?这个也不一定，还是要以业务的实际的情况为准。如果我们 创建的表结构合理，字段不是太多，并且索引创建正确的情况下，单张表存储几千万的 数据是完全没有问题的，这个还是以应用的实际情况为准。</p><p>如果是真的慢了，而且其他的方案都用过了，性能还是跟不上，这个时候才考虑分 库分表。</p><p>那如果要做分库分表，分库分表到底有哪些类型?</p><h3 id="2-分库分表的类型和特点"><a href="#2-分库分表的类型和特点" class="headerlink" title="2. 分库分表的类型和特点"></a>2. 分库分表的类型和特点</h3><p>我们把前面的拆分方式归纳了一下，一共就两种，一种叫垂直拆分，一种叫水平拆分。</p><ul><li><p>垂直切分:基于表或字段划分，表结构不同。我们有单库的分表，也有多库的分库。</p></li><li><p>水平切分:基于数据划分，表结构相同，数据不同，也有同库的水平切分和多库的 切分。</p></li></ul><h4 id="2-1-垂直切分"><a href="#2-1-垂直切分" class="headerlink" title="2.1 垂直切分"></a>2.1 垂直切分</h4><p>垂直分表有两种，一种单库的，一种多库的。字段太多就要拆表，表太多就要拆库</p><h5 id="2-1-1-单库垂直分表"><a href="#2-1-1-单库垂直分表" class="headerlink" title="2.1.1 单库垂直分表"></a>2.1.1 单库垂直分表</h5><p>单库分表，比如:商户信息表，拆分成基本信息表，联系方式表，结算信息表，附 件表等等。</p><h5 id="2-1-2-多库垂直分表"><a href="#2-1-2-多库垂直分表" class="headerlink" title="2.1.2 多库垂直分表"></a>2.1.2 多库垂直分表</h5><p>多库垂直分表就是把原来存储在一个库的不同的表，拆分到不同的数据库。</p><p>比如:消费金融核心系统数据库，有很多客户相关的表，这些客户相关的表，全部 单独存放到客户的数据库里面。合同，放款，风控相关的业务表也是一样的。</p><p>当我们对原来的一张表做了分库的处理，如果某些业务系统的数据还是有一个非常 快的增长速度，比如说还款数据库的还款历史表，数据量达到了几个亿，这个时候硬件 限制导致的性能问题还是会出现，所以从这个角度来说垂直切分并没有从根本上解决单 库单表数据量过大的问题。在这个时候，我们还需要对我们的数据做一个水平的切分。 这个时候，一个应用需要多个数据库。</p><h4 id="2-2-水平切分"><a href="#2-2-水平切分" class="headerlink" title="2.2 水平切分"></a>2.2 水平切分</h4><p>水平切分就是按照数据的维度分布不同的表中，可以是单库的，也可以是多库的。</p><h5 id="2-2-1-单库水平分表"><a href="#2-2-1-单库水平分表" class="headerlink" title="2.2.1 单库水平分表"></a>2.2.1 单库水平分表</h5><p>两个案例:</p><p>银行的交易流水表，所有进出的交易都需要登记这张表，因为绝大部分时候客户都 是查询当天的交易和一个月以内的交易数据，所以我们根据使用频率把这张表拆分成三 张表:</p><p>当天表 channel_transaction:只存储当天的数据。</p><p>当月表 channel_transaction_month:我们在夜间运行一个定时任务，前一天 的数据，全部迁移到当月表。用的是 insert into select，然后 delete。</p><p>历史表 channel_transaction_history:同样是通过定时任务，把登记时间超过 30 天的数据，迁移到 history 历史表(历史表的数据非常大，我们按照月度，每个 月建立分区)。</p><p>费用明细表:</p><p>消费金融公司跟线下商户合作，给客户办理了贷款以后，消费金融公司要给商户返 费用，或者叫提成，每天都会产生很多的费用的数据。为了方便管理，我们每个月建立 一张费用表，例如 fee_detail_202501……fee_detail_202512。</p><p>但是注意，跟分区一样，在一个数据库分表的方式虽然可以一定程度解决单表查询 性能的问题，但是并不能解决单机存储瓶颈的问题，因为所有的表占用的是相同的磁盘 存储空间。</p><h5 id="2-2-2-多库水平分表"><a href="#2-2-2-多库水平分表" class="headerlink" title="2.2.2 多库水平分表"></a>2.2.2 多库水平分表</h5><p>另一种是多库的水平分表。比如客户表，我们拆分到多个库存储，表结构是完全一 样的。</p><p>一般我们说的分库分表都是跨库的分表。</p><p>既然分库分表能够帮助我们解决性能的问题，那我们是不是马上动手去做，甚至在 项目设计的时候就先给它分几个库呢?先冷静一下，我们来看一下分库分表会带来哪些 问题，也就是我们前面说的分库分表之后带来的复杂性。</p><h4 id="2-3-分库分表带来的问题"><a href="#2-3-分库分表带来的问题" class="headerlink" title="2.3 分库分表带来的问题"></a>2.3 分库分表带来的问题</h4><h5 id="2-3-1-跨库关联查询"><a href="#2-3-1-跨库关联查询" class="headerlink" title="2.3.1 跨库关联查询"></a>2.3.1 跨库关联查询</h5><p>比如查询在合同信息的时候要关联客户数据，由于是合同数据和客户数据是在不同的数据库，那么我们肯定不能直接使用join这种方式去做关联查询</p><p>我们有几种主要的解决方案：</p><ol><li><p>字段冗余</p></li><li><p>数据同步 ： 比如商户系统要查询产品系统的产品表，我们干脆在商户系统创建一张产品表，通过 ETL、MQ 或者 canal 定时同步产品数据。</p></li><li><p>全局表：有一些基础信息表，比如行名行号表、行政区划表，被很多业务系统用到，如果我们放在核心系统，每个系统都要调接口去查询，这个时候我们可 以在所有的数据库都存储相同的基础数据，各个系统自己维护，保持同步。</p><p>上面的思路都是通过合理的业务设计避免跨库关联查询，实际上在我们的系统中， 尽量不要用跨库关联查询。如果最后无法避免跨库关联的情况，那我们就只能用最后一 种办法。</p></li><li><p>系统业务层组装：在不同的数据库节点，各自利用查询条件，把符合条件数据的数据查询出来，然后在内存中重新组装，返回给客户端。</p></li></ol><h5 id="2-3-2-分布式事务"><a href="#2-3-2-分布式事务" class="headerlink" title="2.3.2 分布式事务"></a>2.3.2 分布式事务</h5><p>比如在一个贷款的流程里面，合同系统登记了数据，放款系统也必须生成放款记录， 如果两个操作不是同时成功或者同时失败，就会出现数据一致性的问题。</p><p>如果实在一个数据库里面，我们可以使用本第十五来控制，但是在不同的数据库里面就不行了。这里必须要出现一个协调者的角色，大家统一行动，而且要分成多个阶段。一般是是先确定都能成功才能保证成功，只要有一个不成功，就要全部失败。</p><p>核心思想其实是在预先提交能够恒公的情况下，尽量缩短同时提交的时间差，来提升成功的概率。</p><p>分布式事务，在微服务篇有文章详细介绍。</p><h5 id="2-3-3-排序、翻页、函数计算问题"><a href="#2-3-3-排序、翻页、函数计算问题" class="headerlink" title="2.3.3 排序、翻页、函数计算问题"></a>2.3.3 排序、翻页、函数计算问题</h5><p>跨节点多苦进行查询时没会出现limit分页，order by排序的问题。比如有两个节点： 节点 1 存的是奇数 id=1,3,5,7,9……;节点 2 存的是偶数 id=2,4,6,8,10……</p><p>如果查询语句是查出第一页的 10 条数据:<br> select * from user_info order by id limit 0,10</p><p>需要在两个节点上各取出 10 条(为什么都要查 10 条?假设 10 条都在第 2 个节点上?)，然后合并数据，重新排序，节点多的话就更麻烦了。</p><p>max、min、sum、count 之类的函数在进行计算的时候，也需要先在每个分片上执行相应的函数，然后将各个分片的结果集进行汇总和再次计算，最终将结果返回。</p><h5 id="2-3-4-全局ID避重"><a href="#2-3-4-全局ID避重" class="headerlink" title="2.3.4 全局ID避重"></a>2.3.4 全局ID避重</h5><p>MySQL 的数据库里面字段有一个自增的属性，Oracle 也有 Sequence 序列。如果 是一个数据库，那么可以保证 ID 是不重复的，但是水平分表以后，每个表都按照自己的 规律自增，不同的表之间肯定会出现 ID 重复的问题。</p><p>全局ID也有单独文章进行介绍。</p><p>当然还有一个非常关键的问题。 原来你的应用系统只需要连接到一个数据库，配置一个数据源，现在要配置多个。</p><p>配置就配置吧，问题就来了:<br> 我们在执行一条 SQL 语句的时候，比如插入，它应该是在哪个数据节点上面执行呢?</p><p>又比如查询，1 条数据只在其中的一个节点上面，我怎么知道在哪个节点?如果是列表查询，数据分布在多个节点，是不是要在所有的数据库节点里面都查询一遍，才能拿到结 果?</p><p>这个问题我们把它叫做:多数据源的问题，或者动态数据源的问题。</p><p>我们可以从查询的整个流程来分析一下，哪些环节是我们可以下手的。</p><h4 id="2-4-多数据源-动态数据源的解决方案"><a href="#2-4-多数据源-动态数据源的解决方案" class="headerlink" title="2.4 多数据源/动态数据源的解决方案"></a>2.4 多数据源/动态数据源的解决方案</h4><p>在 SSM 的项目里面，查询一般要经过这些流程: DAO——Mapper(ORM)——JDBC——代理——数据库服务</p><h5 id="2-4-1-DAO层"><a href="#2-4-1-DAO层" class="headerlink" title="2.4.1 DAO层"></a>2.4.1 DAO层</h5><p>第一个就是在我们的客户端的代码，比如 DAO 层，在我们连接到某一个数据源之前， 我们先根据配置的分片规则，判断需要连接到哪些节点，再建立连接。</p><p>Spring 中提供了一个抽象类 AbstractRoutingDataSource，可以实现数据源的动态切换。</p><p><a href="https://github.com/zzkenyon/thinking/tree/master/mycat/src/main/java/com/panda/datasource" target="_blank" rel="noopener">详见代码</a></p><p>在 DAO 层实现的<strong>优势</strong>:不需要依赖 ORM 框架，即使替换了 ORM 框架也不受影响。实现简单(不需要解析 SQL 和路由规则)，可以灵活地定制。</p><p> 在 DAO 层实现的<strong>缺点</strong>:不能复用，不能跨语言。</p><h5 id="2-4-2-ORM-框架层"><a href="#2-4-2-ORM-框架层" class="headerlink" title="2.4.2 ORM 框架层"></a>2.4.2 ORM 框架层</h5><p>第二个是在框架层，比如我们用 MyBatis 连接数据库，也可以指定数据源。我们可以基于 MyBatis 插件的拦截机制(拦截 query 和 update 方法)，实现数据源的选择。</p><p>例如:</p><p>Mybatis 分片:可以插件通过设置 Statement 的 Connection，或者使用不同的 SqlSessionFactory 实现。</p><h5 id="2-4-3-驱动层"><a href="#2-4-3-驱动层" class="headerlink" title="2.4.3 驱动层"></a>2.4.3 驱动层</h5><p>不管是 MyBatis 还是 Hibernate，还是 Spring 的 JdbcTemplate，本质上都是对 JDBC 的封装，所以第三层就是驱动层。比如 Sharding-JDBC，就是对 JDBC 的对象进行了封 装。JDBC 里面有两个核心对象，一个是 Connection，是一个连接的封装，一个是 DataSource，是对一个数据库的封装。</p><p>我们可以自己实现一个 DataSource，在项目中配置多个数据源，这样就可以随心所 欲地切换 datasource 了(Sharding-JDBC 就是这样实现的)。</p><h5 id="2-4-4-代理层"><a href="#2-4-4-代理层" class="headerlink" title="2.4.4 代理层"></a>2.4.4 代理层</h5><p>前面三种都是在客户端实现的。也就是说，如果你有 10 个项目，那就要对 10 个项 目进行改造，当然这种情况下我们会把逻辑抽取出来打成 jar 包，直接依赖使用。但如果不是 Java 的项目呢?那就麻烦了，同样的逻辑还是要实现一遍。</p><p>所以我们干脆把它做成一个服务，这样不同语言的项目都可以直接连接，使用这个逻辑了。它应该提供跟数据库一样的协议，减少客户端的变动，比如我原来用的 Spring、MyBatis、Druid，都不要让我去改，只要改数据库的 IP 和连接规则就行了。</p><p>到了这个时候，因为提供了一个代理服务，帮我们去查数据，再把数据返回，我们就把它叫代理层。Mycat 和 Sharding-Proxy，都是属于这一层。</p><h5 id="2-4-5-数据库服务"><a href="#2-4-5-数据库服务" class="headerlink" title="2.4.5 数据库服务"></a>2.4.5 数据库服务</h5><p>最后一层就是在数据库服务上实现。以非关系型数据库 Redis 为例，Redis Cluster 分片，产品多个连接以后，能够自动路由。MySQL 可以吗?不可以，那我就去改一下 MySQL 的源码，让它变成一个分布式的数据库。在数据库服务前面加一个路由层，后面 支持多个数据源。</p><p>腾讯云现在主推的 TDSQL，就是这样一种实现。不过，这样的数据库在部署的时候， 多了很多的节点需要部署。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目标：&lt;/p&gt;
&lt;p&gt;1、理解分库分表的意义&lt;/p&gt;
&lt;p&gt;2、理解数据切分的不同方式，以及带来的问题与解决方案&lt;/p&gt;
&lt;h3 id=&quot;1、为什么要分库分表&quot;&gt;&lt;a href=&quot;#1、为什么要分库分表&quot; class=&quot;headerlink&quot; title=&quot;1、为什么要分库
      
    
    </summary>
    
      <category term="数据库技术" scheme="http://yoursite.com/child/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Mycat" scheme="http://yoursite.com/child/tags/Mycat/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis-给源码加中文注释(转)</title>
    <link href="http://yoursite.com/child/2020/04/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF-MyBatis-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E4%BB%8E%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BA/"/>
    <id>http://yoursite.com/child/2020/04/24/数据库技术-MyBatis-源码分析之从源码构建/</id>
    <published>2020-04-23T16:00:00.000Z</published>
    <updated>2020-05-22T11:54:43.915Z</updated>
    
    <content type="html"><![CDATA[<p>我们在看框架源码的时候，如果没有注释，看起来会比较吃力。所以如果能够一边看源码一边自己加中文注释，下次阅读的时候就会轻松很多。</p><p>问题是：通过maven下载的jar，查看源码，实际上看到的是经过反编译的class文件，是不能够修改的（提示：file is read only）。<br>如果把当前maven下载的jar包强行关联到自己下载的源码，又有可能会出现字节码跟源码文件不一致的情况（提示：Library source does not match the bytecode for class），导致debug的时候无法进入代码。</p><p>如果要保证源码和字节码一致，最好的办法当然是在本地把下载的源码编译生成jar包，上传到本地maven仓库，再引用这个jar。</p><p>以MyBatis为例，如果我们要给MyBatis源码加上中文注释（以IDEA操作为例）</p><p><a href="https://mp.weixin.qq.com/s/v0ihaPsuyGufdc_ImEqX8A" target="_blank" rel="noopener">原文连接</a></p><h4 id="1、配置Maven"><a href="#1、配置Maven" class="headerlink" title="1、配置Maven"></a>1、配置Maven</h4><p>因为需要用Maven打包编译源代码，所以第一步是检查Maven的配置。</p><p>第一个是环境变量，需要在系统变量中添加MAVEN_HOME，配置Maven主路径，例如“E:\dev\apache-maven-3.5.4”，确保mvn命令可以使用。</p><p>第二个是检查Maven的配置。Maven运行时，默认会使用conf目录下的settings.xml配置，例如：E:\dev\apache-maven-3.5.4\conf\settings.xml。</p><p>为了保证下载速度，建议配置成国内的aliyun中央仓库（此处需要自行搜索）。</p><p>并且，settings.xml中的localRepository应该和IDEA中打开的项目设置中的Local repository保持一致（例如：E:\repository）。否则项目引入依赖时，无法读取到编译后的jar包。</p><h4 id="2、下载编译MyBatis源码"><a href="#2、下载编译MyBatis源码" class="headerlink" title="2、下载编译MyBatis源码"></a>2、下载编译MyBatis源码</h4><p>因为MyBatis源码编译依赖parent项目的源码，所以第一步是编译parent项目。</p><p>先从git clone两个工程的项目（截止2020年4月，最新版本是3.5.4）。</p><p>以在E盘根目录下载为例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/mybatis/parent</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/mybatis/mybatis-3</span><br></pre></td></tr></table></figure><p>打开mybatis-3中的pom.xml文件，查看parent的版本号，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>31<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>确定parent版本是31（记住这个数字）。</p><p>把mybatis版本号改成自定义的版本号，避免跟官方版本号冲突（加上了-snapshot）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.4-snapshot<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><p>进入parent目录，切换项目分支（不能在默认的master分支中编译），工程名后面的数字就是前面看到的parent版本号。</p><p>开始编译parent项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> parent</span><br><span class="line"></span><br><span class="line">git checkout mybatis-parent-31</span><br><span class="line"></span><br><span class="line">mvn install</span><br></pre></td></tr></table></figure><p>接下来编译mybatis工程，进入mybatis-3目录，切换到最新3.5.4分支（不能在默认的master分支中编译）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd ../mybatis-3</span><br><span class="line"></span><br><span class="line">git checkout mybatis-3.5.4</span><br><span class="line"></span><br><span class="line">mvn clean</span><br><span class="line"></span><br><span class="line">mvn install -DskipTests=true -Dmaven.test.skip=true -Dlicense.skip=true</span><br></pre></td></tr></table></figure><p>编译完毕，本地仓库就会出现一个编译后的jar包，例如：E:\repository\org\mybatis\mybatis\3.5.4-snapshot\mybatis-3.5.4-snapshot.jar</p><p>在我们的项目中就可以引入这个jar包了（version是自定义的version）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.4-snapshot<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3、关联jar包到源码"><a href="#3、关联jar包到源码" class="headerlink" title="3、关联jar包到源码"></a>3、关联jar包到源码</h4><p>本地编译的jar包已经有了，接下来是把jar包和源码关联起来。</p><p>Project Structure —— Libries —— Maven: org.mybatis:mybatis:3.5.4-snapshot —— 在原来的Sources上面点+（加号） —— 选择到下载的源码路径，例如：E:\mybatis-3\src\main\java，点击OK</p><p>关联好之后，开始打断点debug，就会进入到本地的源码，可以给本地的源码加上注释了。</p><h4 id="4、注意"><a href="#4、注意" class="headerlink" title="4、注意"></a>4、注意</h4><p>1、如果之前打开过类的字节码文件，本地可能有缓存，一样会有“Library source does not match the bytecode for class”的提示。解决办法：File —— Invalidate Caches and Restart（IDEA会重启）。</p><p>2、如果添加注释导致了debug的当前行跟实际行不一致，再把mybatis3工程编译一次即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们在看框架源码的时候，如果没有注释，看起来会比较吃力。所以如果能够一边看源码一边自己加中文注释，下次阅读的时候就会轻松很多。&lt;/p&gt;
&lt;p&gt;问题是：通过maven下载的jar，查看源码，实际上看到的是经过反编译的class文件，是不能够修改的（提示：file is rea
      
    
    </summary>
    
      <category term="ORM框架" scheme="http://yoursite.com/child/categories/ORM%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Mybatis" scheme="http://yoursite.com/child/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>RPC-手写RPC调用过程</title>
    <link href="http://yoursite.com/child/2020/04/19/%E5%88%86%E5%B8%83%E5%BC%8F-%E6%89%8B%E5%86%99RPC%E8%B0%83%E7%94%A8/"/>
    <id>http://yoursite.com/child/2020/04/19/分布式-手写RPC调用/</id>
    <published>2020-04-18T16:00:00.000Z</published>
    <updated>2020-05-22T11:45:12.708Z</updated>
    
    <content type="html"><![CDATA[<p>rpc 全称remote procedure call 远程过程调用，是一种分布式服务调用协议。</p><p>需求：分布式环境下，服务A想要调用服务B的某方法，就像调用自己本地的方法一样</p><p>分析：</p><ul><li>首先，服务A需要知道服务B提供了哪些方法，并且知道这些方法的调用方式（参数列表，返回类型）</li><li>其次，服务A需要将调用的方法和参数发送给服务B，B接收到之后本地调用获得结果，再将结果发送给服务A</li></ul><p>设计：</p><ul><li>要提供一套统一的接口让调用方服务A知道有哪些方法可供调用，服务B作为接口的实现方。</li><li>服务A要提供接口的代理类工厂，本地调用接口方法时，代理类能将调用请求发送出去。</li><li>数据传输方面，暂不考虑性能，使用BIO以及JDK序列化方式</li></ul><p>开始编码：</p><p>提供一套接口：创建maven项目rpc-api，项目中添加接口文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHelloService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口中还需要指定一个简要的rpc协议，调用方和服务方都要遵循此协议</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcRequest</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="keyword">private</span> Object[] args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将rpc-api install到本地仓库。</p><p>调用方服务A：创建maven项目rpc-client，pom中添加依赖rpc-api</p><p>先来写main方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">        RpcProxyFactory rpcProxyFactory = <span class="keyword">new</span> RpcProxyFactory();</span><br><span class="line">        IHelloService helloService = </span><br><span class="line">          rpcProxyFactory.newProxyInstance(IHelloService.class,<span class="string">"localhost"</span>,<span class="number">8080</span>);</span><br><span class="line">        Object o = helloService.sayHello(<span class="string">"zzk"</span>);</span><br><span class="line">        System.out.println((String) o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程很清晰：</p><ol><li>创建代理工厂<code>RpcProxyFactory</code></li><li>使用代理工厂类生成指定接口的代理对象</li><li>调用接口方法获取结果</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">newProxyInstance</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; interfaceClass, <span class="keyword">final</span> String host, <span class="keyword">final</span> <span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T)Proxy.newProxyInstance(interfaceClass.getClassLoader(),<span class="keyword">new</span> Class&lt;?&gt;[] &#123;interfaceClass&#125;,</span><br><span class="line">                <span class="keyword">new</span> RemoteInvocationHandler(host,port));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理方式我选用的是jdk的动态代理，创建代理对象需要传进三个参数</p><ul><li>类加载器</li><li>需要代理的接口</li><li>触发管理类</li></ul><p>前两个参数都是现成的，编写触发管理类代码，实现<code>InvocationHandler</code>接口，通过代理对象调用接口方法都会进到invoke方法中来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RemoteInvocationHandler</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        RpcRequest rpcRequest = <span class="keyword">new</span> RpcRequest();</span><br><span class="line">        rpcRequest.setClassName(method.getDeclaringClass().getName());</span><br><span class="line">        rpcRequest.setMethodName(method.getName());</span><br><span class="line">        rpcRequest.setArgs(args);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RpcNetTransport(host,port).send(rpcRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>invoke 方法负责将请求参数序列化，并发送出去，这里使用一个类专门负责发送：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcNetTransport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcNetTransport</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">send</span><span class="params">(RpcRequest rpcRequest)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(Socket socket = <span class="keyword">new</span> Socket(host,port);</span><br><span class="line">            ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream());</span><br><span class="line">            ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream())) &#123;</span><br><span class="line">            out.writeObject(rpcRequest);</span><br><span class="line">            <span class="keyword">return</span> in.readObject();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此调用发代码完成</p><p>再来看服务方B的代码编写：创建maven项目，引入依赖rpc-api、spring-context来管理对象</p><p>首先服务方应该实现接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">IHelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"request sayHello from : "</span> + content);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Response: hello, "</span> + content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器需要接收请求，代码思想：启动监听指定端口，这里使用了spring的<code>InitializingBean</code>接口，创建RpcServer时，当port设置成功之后会执行<code>afterPropertiesSet()</code>方法启动监听。</p><p>此外，我们将对象交给spring管理后，当请求进来我们需要找到正确service去执行，我的做法是让<code>RpcServer</code>实现<code>ApplicationContextAware</code>接口，这样RpcServer可以在<code>setApplicationContext</code>方法中，将所有的service对象取出来缓存，请求进来直接在缓存中找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcServer</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>,<span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; serviceObjs = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// socket 通信 发布服务</span></span><br><span class="line">        <span class="keyword">try</span> (ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(port))&#123;</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                Socket socket = serverSocket.accept();</span><br><span class="line">                pool.execute(<span class="keyword">new</span> ProcessorHandler(socket,serviceObjs));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取容器中的服务bean 封装成map</span></span><br><span class="line">        Map&lt;String,Object&gt; beans = </span><br><span class="line">          applicationContext.getBeansWithAnnotation(RpcService.class);</span><br><span class="line">        <span class="keyword">for</span>(Object service : beans.values())&#123;</span><br><span class="line">            Class&lt;?&gt; clazz = service.getClass();</span><br><span class="line">            String serviceKey = rpcService.value().getName();</span><br><span class="line">            serviceObjs.put(serviceKey,service);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当获取请求之后，丢给线程池进行执行，那我继续编写线程池执行任务代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessorHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; serviceObj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProcessorHandler</span><span class="params">(Socket socket,Map&lt;String,Object&gt; serviceObj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        <span class="keyword">this</span>.serviceObj = serviceObj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</span><br><span class="line">             ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream()))&#123;</span><br><span class="line"></span><br><span class="line">            RpcRequest rpcRequest = (RpcRequest) in.readObject();</span><br><span class="line">            Object result = invoke(rpcRequest);</span><br><span class="line">            out.writeObject(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">invoke</span><span class="params">(RpcRequest rpcRequest)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        Object[] args = rpcRequest.getArgs();</span><br><span class="line">        Class&lt;?&gt;[] types = <span class="keyword">new</span> Class[args.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++)&#123;</span><br><span class="line">            types[i]= args[i].getClass();</span><br><span class="line">        &#125;</span><br><span class="line">        Class clazz = Class.forName(rpcRequest.getClassName());</span><br><span class="line">        Method method = clazz.getMethod(rpcRequest.getMethodName(),types);</span><br><span class="line">        String serviceKey = rpcRequest.getClassName() + rpcRequest.getVersion();</span><br><span class="line">        <span class="keyword">return</span> method.invoke(serviceObj.get(serviceKey),args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然是线程池执行的任务，肯定是Runnable对象，run方法的逻辑很清晰：从socket中获取请求对象，丢给invoke返回结果，在通过socket发送出去。</p><p>重点在invoke方法：通过反射的方式对方法进行调用</p><p>还有spring的最后一步，配置和启动:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"com.pd"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RpcServer <span class="title">rpcServer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RpcServer(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context =</span><br><span class="line">                <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line">        context.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p>先启动rpc-server  再启动rpc-client</p><p>结果：<code>Response: hello, zzk</code></p><p>总结流程图示：</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/rpc/rpc%E5%9F%BA%E7%A1%80%E8%B0%83%E7%94%A8.png" alt="rpc-基础流程"></p><p><a href="https://github.com/zzkenyon/rpc-learn.git" target="_blank" rel="noopener">参考代码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;rpc 全称remote procedure call 远程过程调用，是一种分布式服务调用协议。&lt;/p&gt;
&lt;p&gt;需求：分布式环境下，服务A想要调用服务B的某方法，就像调用自己本地的方法一样&lt;/p&gt;
&lt;p&gt;分析：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，服务A需要知道服务B提供了哪些
      
    
    </summary>
    
      <category term="分布式架构技术" scheme="http://yoursite.com/child/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="RPC" scheme="http://yoursite.com/child/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>CSRF攻击与防御（转）</title>
    <link href="http://yoursite.com/child/2020/04/14/%E5%85%B6%E4%BB%96-CSRF%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1/"/>
    <id>http://yoursite.com/child/2020/04/14/其他-CSRF攻击与防御/</id>
    <published>2020-04-13T16:00:00.000Z</published>
    <updated>2020-06-12T00:32:49.804Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.phpddt.com/reprint/csrf.html" target="_blank" rel="noopener">转载地址</a></p><p><strong>CSRF概念：</strong>CSRF跨站点请求伪造(Cross—Site Request Forgery)，跟XSS攻击一样，存在巨大的危害性，你可以这样来理解：攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 如下：其中Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。</p><h4 id="CSRF攻击攻击原理及过程如下："><a href="#CSRF攻击攻击原理及过程如下：" class="headerlink" title="CSRF攻击攻击原理及过程如下："></a>CSRF攻击攻击原理及过程如下：</h4><ol><li><p>用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；</p></li><li><p>在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；</p></li><li><p>用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；</p></li><li><p>网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；</p></li><li><p>浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 </p></li></ol><h4 id="CSRF攻击实例"><a href="#CSRF攻击实例" class="headerlink" title="CSRF攻击实例"></a>CSRF攻击实例</h4><p>受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求 <a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2" target="_blank" rel="noopener">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2</a> 可以使 Bob 把 1000000 的存款转到 bob2 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。</p><p>黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行：<a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory。但是这个请求来自" target="_blank" rel="noopener">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory。但是这个请求来自</a> Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。</p><p>这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码： src=”<a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory" target="_blank" rel="noopener">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</a> ”，并且通过广告等诱使 Bob 来访问他的网站。当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。 </p><h4 id="CSRF漏洞检测："><a href="#CSRF漏洞检测：" class="headerlink" title="CSRF漏洞检测："></a>CSRF漏洞检测：</h4><p>检测CSRF漏洞是一项比较繁琐的工作，最简单的方法就是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。</p><p>随着对CSRF漏洞研究的不断深入，不断涌现出一些专门针对CSRF漏洞进行检测的工具，如CSRFTester，CSRF Request Builder等。</p><p>以CSRFTester工具为例，CSRF漏洞检测工具的测试原理如下：使用CSRFTester进行测试时，首先需要抓取我们在浏览器中访问过的所有链接以及所有的表单等信息，然后通过在CSRFTester中修改相应的表单等信息，重新提交，这相当于一次伪造客户端请求。如果修改后的测试请求成功被网站服务器接受，则说明存在CSRF漏洞，当然此款工具也可以被用来进行CSRF攻击。</p><h4 id="防御CSRF攻击："><a href="#防御CSRF攻击：" class="headerlink" title="防御CSRF攻击："></a>防御CSRF攻击：</h4><h4 id="（1）验证-HTTP-Referer-字段"><a href="#（1）验证-HTTP-Referer-字段" class="headerlink" title="（1）验证 HTTP Referer 字段"></a>（1）验证 HTTP Referer 字段</h4><p>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 <a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory，用户必须先登陆" target="_blank" rel="noopener">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory，用户必须先登陆</a> bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。</p><p>这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。</p><p>然而，这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。</p><p>即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。</p><h4 id="（2）在请求地址中添加-token-并验证"><a href="#（2）在请求地址中添加-token-并验证" class="headerlink" title="（2）在请求地址中添加 token 并验证"></a>（2）在请求地址中添加 token 并验证</h4><p>CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p><p>这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 <a href="http://url?csrftoken=tokenvalue。" target="_blank" rel="noopener">http://url?csrftoken=tokenvalue。</a> 而对于 POST 请求来说，要在 form 的最后加上 <input type="hidden" name="csrftoken" value="tokenvalue">，这样就把 token 以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。</p><p>该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。</p><h4 id="（3）在-HTTP-头中自定义属性并验证"><a href="#（3）在-HTTP-头中自定义属性并验证" class="headerlink" title="（3）在 HTTP 头中自定义属性并验证"></a>（3）在 HTTP 头中自定义属性并验证</h4><p>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</p><p>然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.phpddt.com/reprint/csrf.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;转载地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CSRF概念：&lt;/strong&gt;CSRF跨站点请求伪造(Cros
      
    
    </summary>
    
      <category term="其他" scheme="http://yoursite.com/child/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/child/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
