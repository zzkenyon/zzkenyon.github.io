<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>黑风雅过吟</title>
  
  <subtitle>不积跬步无以至千里</subtitle>
  <link href="/zzkenyon.github.io/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/child/"/>
  <updated>2019-09-02T09:49:42.854Z</updated>
  <id>http://yoursite.com/child/</id>
  
  <author>
    <name>Zhao Zhengkang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redis-总结精讲</title>
    <link href="http://yoursite.com/child/2019/09/02/reids-%E6%80%BB%E7%BB%93%E7%B2%BE%E8%AE%B2/"/>
    <id>http://yoursite.com/child/2019/09/02/reids-总结精讲/</id>
    <published>2019-09-01T16:00:00.000Z</published>
    <updated>2019-09-02T09:49:42.854Z</updated>
    
    <content type="html"><![CDATA[<p>本文围绕以下几个主题：</p><p>1、为什么使用redis<br>2、使用redis有什么缺点<br>3、单线程的redis为什么这么快<br>4、redis的数据类型，以及每种数据类型的使用场景<br>5、redis的过期策略以及内存淘汰机制<br>6、redis和数据库双写一致性问题<br>7、如何应对缓存穿透和缓存雪崩问题<br>8、如何解决redis的并发竞争问题</p><h3 id="1、为什么使用redis"><a href="#1、为什么使用redis" class="headerlink" title="1、为什么使用redis"></a>1、为什么使用redis</h3><p>在项目中使用redis，主要是从两个角度去考虑:<strong>性能</strong>和<strong>并发</strong>。当然redis还具备可以做分布式锁等其他功能，但是如果只是为了分布式锁这些其他功能，完全还有其他中间件(如zookpeer等)代替，并不是非要使用redis。因此，这个问题主要从性能和并发两个角度去答。</p><h4 id="1-1-性能"><a href="#1-1-性能" class="headerlink" title="1.1 性能"></a>1.1 性能</h4><p>如下图所示，我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够<strong>迅速响应</strong>。</p><p><strong>题外话：</strong>忽然想聊一下这个<strong>迅速响应</strong>的标准。其实根据交互效果的不同，这个响应时间没有固定标准。不过曾经有人这么告诉我:”在理想状态下，我们的页面跳转需要在<strong>瞬间</strong>解决，对于页内操作则需要在<strong>刹那</strong>间解决。另外，超过<strong>一弹指</strong>的耗时操作要有进度提示，并且可以随时中止或取消，这样才能给用户最好的体验。”<br>那么<strong>瞬间、刹那、一弹指</strong>具体是多少时间呢？<br>根据《摩诃僧祗律》记载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一刹那者为一念，二十念为一瞬，二十瞬为一弹指，二十弹指为一罗预，二十罗预为一须臾，一日一夜有三十须臾。</span><br></pre></td></tr></table></figure><p>那么，经过周密的计算，一<strong>瞬间</strong>为0.36 秒,一<strong>刹那</strong>有 0.018 秒.一<strong>弹指</strong>长达 7.2 秒。</p><h4 id="1-2-并发"><a href="#1-2-并发" class="headerlink" title="1.2 并发"></a>1.2 并发</h4><p>在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。</p><h3 id="2、使用redis有什么缺点"><a href="#2、使用redis有什么缺点" class="headerlink" title="2、使用redis有什么缺点"></a>2、使用redis有什么缺点</h3><p>基本上使用redis都会碰到一些问题，常见的也就几个。</p><ul><li>缓存和数据库双写一致性问题</li><li>缓存雪崩问题</li><li>缓存击穿问题</li><li>缓存的并发竞争问题</li></ul><p>这四个问题项目中比较常遇见，具体解决方案，后文给出。</p><h3 id="3、单线程的redis为什么这么快"><a href="#3、单线程的redis为什么这么快" class="headerlink" title="3、单线程的redis为什么这么快"></a>3、单线程的redis为什么这么快</h3><p>这个问题其实是对redis内部机制的一个考察，主要是以下三点</p><ul><li>纯内存操作</li><li>单线程操作，避免了频繁的上下文切换</li><li>采用了非阻塞<strong>I/O多路复用</strong></li></ul><h3 id="4、redis的数据类型，以及每种数据类型的使用场景"><a href="#4、redis的数据类型，以及每种数据类型的使用场景" class="headerlink" title="4、redis的数据类型，以及每种数据类型的使用场景"></a>4、redis的数据类型，以及每种数据类型的使用场景</h3><ol><li>String<br>这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做<strong>一些复杂的计数功能的缓存。</strong></li><li>hash<br>这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。在做<strong>单点登录</strong>的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。</li><li>list<br>使用List的数据结构，可以<strong>做简单的消息队列的功能</strong>。另外还有一个就是，可以利用lrange命令，<strong>做基于redis的分页功能</strong>，性能极佳，用户体验好。</li><li>set<br>因为set堆放的是一堆不重复值的集合。所以可以做<strong>全局去重的功能</strong>。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。<br>另外，就是利用交集、并集、差集等操作，可以<strong>计算共同喜好，全部的喜好，自己独有的喜好等功能</strong>。</li><li>sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做<strong>排行榜应用，取TOP N操作</strong>、<strong>延时任务</strong>、<strong>范围查找</strong>等。</li></ol><h3 id="5、redis的过期策略以及内存淘汰机制"><a href="#5、redis的过期策略以及内存淘汰机制" class="headerlink" title="5、redis的过期策略以及内存淘汰机制"></a>5、redis的过期策略以及内存淘汰机制</h3><p>redis采用的是<u><strong>定期删除+惰性删除</strong></u>策略。</p><h4 id="5-1-为什么不用定时删除策略"><a href="#5-1-为什么不用定时删除策略" class="headerlink" title="5.1 为什么不用定时删除策略"></a>5.1 为什么不用定时删除策略</h4><p>定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.</p><h4 id="5-2-定期删除-惰性删除是如何工作的"><a href="#5-2-定期删除-惰性删除是如何工作的" class="headerlink" title="5.2 定期删除+惰性删除是如何工作的"></a>5.2 定期删除+惰性删除是如何工作的</h4><p>定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。<br>于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。</p><h4 id="5-2-定期删除-惰性删除的问题"><a href="#5-2-定期删除-惰性删除的问题" class="headerlink" title="5.2 定期删除+惰性删除的问题"></a>5.2 定期删除+惰性删除的问题</h4><p>如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。</p><p>解决方法：采用<strong>内存淘汰机制</strong>。<br>在redis.conf中有一行配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-policy volatile-lru</span><br></pre></td></tr></table></figure><p>该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)</p><ul><li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。<strong>不推荐</strong></li><li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。<strong>推荐使用</strong></li><li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。<strong>不推荐</strong></li><li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。<strong>这种情况一般是把redis既当缓存，又做持久化存储的时候才用。</strong></li><li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。<strong>不推荐</strong></li><li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。<strong>不推荐</strong></li></ul><h3 id="6、redis和数据库双写一致性问题"><a href="#6、redis和数据库双写一致性问题" class="headerlink" title="6、redis和数据库双写一致性问题"></a>6、redis和数据库双写一致性问题</h3><p> 一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。答这个问题，先明白一个前提。就是<strong>如果对数据有强一致性要求，不能放缓存。</strong>我们所做的一切，只能保证最终一致性。另外，我们所做的方案其实从根本上来说，只能说<strong>降低不一致发生的概率</strong>，无法完全避免。因此，有强一致性要求的数据，不能放缓存。</p><p>首先，采取正确更新策略，<strong>先更新数据库，再删缓存</strong>。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。</p><h3 id="7、如何应对缓存穿透、缓存击穿和缓存雪崩问题"><a href="#7、如何应对缓存穿透、缓存击穿和缓存雪崩问题" class="headerlink" title="7、如何应对缓存穿透、缓存击穿和缓存雪崩问题"></a>7、如何应对缓存穿透、缓存击穿和缓存雪崩问题</h3><h4 id="7-1-缓存穿透"><a href="#7-1-缓存穿透" class="headerlink" title="7.1 缓存穿透"></a>7.1 缓存穿透</h4><p>缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大</p><p>解决方案：</p><ol><li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</li><li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</li></ol><h4 id="7-2-缓存击穿"><a href="#7-2-缓存击穿" class="headerlink" title="7.2 缓存击穿"></a>7.2 缓存击穿</h4><p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力</p><p>解决方案：</p><ol><li>设置热点数据永远不过期。</li><li>加互斥锁</li></ol><h4 id="7-3-缓存雪崩"><a href="#7-3-缓存雪崩" class="headerlink" title="7.3 缓存雪崩"></a>7.3 缓存雪崩</h4><p>缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，        缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p><p>解决方案：</p><ol><li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li><li>如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。</li><li>设置热点数据永远不过期。</li></ol><h3 id="8、如何解决redis的并发竞争问题"><a href="#8、如何解决redis的并发竞争问题" class="headerlink" title="8、如何解决redis的并发竞争问题"></a>8、如何解决redis的并发竞争问题</h3><p>这个问题大致就是，同时有多个子系统去set一个key。这个时候要注意什么呢？大家思考过么。需要说明一下，博主提前百度了一下，发现答案基本都是推荐用redis事务机制。博主<strong>不推荐使用redis的事务机制。</strong>因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，<strong>redis的事务机制，十分鸡肋。</strong></p><ol><li>如果对这个key操作，<strong>不要求顺序</strong><br>这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。</li><li>如果对这个key操作，<strong>要求顺序</strong><br>假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC.<br>期望按照key1的value值按照 valueA–&gt;valueB–&gt;valueC的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。假设时间戳如下</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">系统A key 1 &#123;valueA  3:00&#125;</span><br><span class="line">系统B key 1 &#123;valueB  3:05&#125;</span><br><span class="line">系统C key 1 &#123;valueC  3:10&#125;</span><br></pre></td></tr></table></figure><p>那么，假设系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。</p><p>其他方法，比如利用队列，将set方法变成串行访问也可以。总之，灵活变通。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文围绕以下几个主题：&lt;/p&gt;
&lt;p&gt;1、为什么使用redis&lt;br&gt;2、使用redis有什么缺点&lt;br&gt;3、单线程的redis为什么这么快&lt;br&gt;4、redis的数据类型，以及每种数据类型的使用场景&lt;br&gt;5、redis的过期策略以及内存淘汰机制&lt;br&gt;6、redis和数
      
    
    </summary>
    
    
      <category term="redis" scheme="http://yoursite.com/child/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis-缓存数据库双写一致性方案解析</title>
    <link href="http://yoursite.com/child/2019/09/02/redis-%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>http://yoursite.com/child/2019/09/02/redis-缓存数据库双写一致性/</id>
    <published>2019-09-01T16:00:00.000Z</published>
    <updated>2019-09-04T07:03:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>从理论上来说，设置过期时间是保证缓存数据库最终一致性的解决方案。在这种方案下，我们可以对存入缓存的数据设置过期时间，所有写操作以数据库为准，对缓存操作知识尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，后面的请求自然会从数据库中读取新值然后填回缓存。因此，接下来讨论的思路不依赖于给缓存设置过期时间这个方案。</p><p>本文讨论三种更新策略：</p><ul><li>先更新数据库，再更新缓存</li><li>先删除缓存，再更新数据库</li><li>先更新数据库，再删除缓存</li></ul><p>没有先更新缓存再更新数据库的方案，因为所有的写操作要以数据库为准，这种情况下若更新数据库失败，缓存失效后再次读数据库将取得旧值。</p><h3 id="1、先更新数据库，再更新缓存"><a href="#1、先更新数据库，再更新缓存" class="headerlink" title="1、先更新数据库，再更新缓存"></a>1、先更新数据库，再更新缓存</h3><p>该方案从<strong>线程安全角度</strong>看</p><p>假设同时有请求A和请求B进行更新操作，如下图所示的情况下最终数据库中的数据是B请求的数据，缓存中的数据数A请求的数据，最终出现了不一致的情况。这种情况因为网络情况等原因是可能出现的</p><p><img src="https://wx2.sinaimg.cn/large/87c9e458ly1g6nhtih33dj20fj05aq2v.jpg" alt="更更"></p><p>该方案从<strong>业务场景角度</strong>看</p><ol><li>如果是一个写多读少的场景，使用这种方案会导致数据压根没读到，缓存就被频繁的更新，浪费性能</li><li>如果写入db的值需要经过一系列复杂的计算再写入缓存，那么每次写入缓存前都需要计算缓存值，无疑是在浪费性能</li></ol><p>所以，更新缓存不可取，删除缓存更合适。</p><h3 id="2、先删除缓存，再更新数据库"><a href="#2、先删除缓存，再更新数据库" class="headerlink" title="2、先删除缓存，再更新数据库"></a>2、先删除缓存，再更新数据库</h3><p>首先看该方案会导致不一致的情况：</p><p><img src="https://ws1.sinaimg.cn/large/87c9e458ly1g6nhu1u8qjj20fs0663yi.jpg" alt="删更"></p><p>这种情况就会导致不一致的情形出现，而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。</p><p>那么，<strong>如何解决呢？</strong></p><p><strong>延时双删策略</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String key,Object data)</span></span>&#123;</span><br><span class="line">        redis.delKey(key);</span><br><span class="line">        db.updateData(data);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        redis.delKey(key);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：<br>（1）先淘汰缓存<br>（2）再写数据库<br>（3）休眠1秒，再次淘汰缓存<br>这么做，可以将1秒内所造成的缓存脏数据，再次删除。<br><strong>那么，这个1秒怎么确定的，具体该休眠多久呢？</strong><br>针对上面的情形，读者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p><h3 id="3、先更新数据库，再删除缓存"><a href="#3、先更新数据库，再删除缓存" class="headerlink" title="3、先更新数据库，再删除缓存"></a>3、先更新数据库，再删除缓存</h3><p>首先，先说一下。老外提出了一个缓存更新套路，名为<a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside" target="_blank" rel="noopener">《Cache-Aside pattern》</a>。其中就指出</p><ul><li><strong>失效</strong>：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li><li><strong>命中</strong>：应用程序从cache中取数据，取到后返回。</li><li><strong>更新</strong>：先把数据存到数据库中，成功后，再让缓存失效。</li></ul><p>另外，知名社交网站facebook也在论文<a href="https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf" target="_blank" rel="noopener">《Scaling Memcache at Facebook》</a>中提出，他们用的也是先更新数据库，再删缓存的策略。</p><p><strong>这种情况不存在并发问题么？</strong><br>不是的。假设这会有两个请求，一个请求A做更新操作，一个请求B做查询操作，那么会有如下情形产生<br><img src="https://wx1.sinaimg.cn/large/87c9e458ly1g6nhuewolbj20fs066dfv.jpg" alt="更删"><br>如果发生上述情况，确实是会发生脏数据。</p><p><strong>然而，发生这种情况的必要条件是</strong><br>1、B读db时A还没有完成写db，这样B才能读到旧数据</p><p>2、A写db比B读db先完成，这样A才会在B更新缓存之前删缓存</p><p>因此只有在B请求读db成功但还没有更新缓存之前，A请求更新db结束并执行了删缓存操作，才有可能发生以上的情况，这个方案较第二种方案产生不一致的概率低很多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从理论上来说，设置过期时间是保证缓存数据库最终一致性的解决方案。在这种方案下，我们可以对存入缓存的数据设置过期时间，所有写操作以数据库为准，对缓存操作知识尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，后面的请求自然会从数据库中读取新值然后填回
      
    
    </summary>
    
    
      <category term="redis" scheme="http://yoursite.com/child/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis-键空间通知</title>
    <link href="http://yoursite.com/child/2019/08/02/redis-%E9%94%AE%E7%A9%BA%E9%97%B4%E9%80%9A%E7%9F%A5/"/>
    <id>http://yoursite.com/child/2019/08/02/redis-键空间通知/</id>
    <published>2019-08-01T16:00:00.000Z</published>
    <updated>2019-09-03T14:46:33.736Z</updated>
    
    <content type="html"><![CDATA[<p>需求：redis中缓存了一些状态量，业务需要时刻关注状态量变化</p><p>方案一：轮询检查（各方面性能太差）</p><p>方案二：redis提供的键空间通知机制（redis主动推送，优选）</p><h3 id="1、发布与订阅"><a href="#1、发布与订阅" class="headerlink" title="1、发布与订阅"></a>1、发布与订阅</h3><p><a href="http://doc.redisfans.com/pub_sub/subscribe.html#subscribe" target="_blank" rel="noopener"><em>SUBSCRIBE</em></a> 、 <a href="http://doc.redisfans.com/pub_sub/unsubscribe.html#unsubscribe" target="_blank" rel="noopener"><em>UNSUBSCRIBE</em></a> 和 <a href="http://doc.redisfans.com/pub_sub/publish.html#publish" target="_blank" rel="noopener"><em>PUBLISH</em></a> 三个命令实现了<a href="http://en.wikipedia.org/wiki/Publish/subscribe" target="_blank" rel="noopener">发布与订阅信息泛型</a>（Publish/Subscribe messaging paradigm）， 在这个实现中， 发送者（发送信息的客户端）不是将信息直接发送给特定的接收者（接收信息的客户端）， 而是将信息发送给频道（channel）， 然后由频道将信息转发给所有对这个频道感兴趣的订阅者。</p><p>发送者无须知道任何关于订阅者的信息， 而订阅者也无须知道是那个客户端给它发送信息， 它只要关注自己感兴趣的频道即可。</p><p>对发布者和订阅者进行解构（decoupling）， 可以极大地提高系统的扩展性（scalability）， 并得到一个更动态的网络拓扑（network topology）。</p><p>比如说， 要订阅频道 <code>foo</code> 和 <code>bar</code> ， 客户端可以使用频道名字作为参数来调用 <a href="http://doc.redisfans.com/pub_sub/subscribe.html#subscribe" target="_blank" rel="noopener"><em>SUBSCRIBE</em></a> 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE foo bar</span><br></pre></td></tr></table></figure><p>当有客户端发送信息到这些频道时， Redis 会将传入的信息推送到所有订阅这些频道的客户端里面。</p><p>正在订阅频道的客户端不应该发送除 <a href="http://doc.redisfans.com/pub_sub/subscribe.html#subscribe" target="_blank" rel="noopener"><em>SUBSCRIBE</em></a> 和 <a href="http://doc.redisfans.com/pub_sub/unsubscribe.html#unsubscribe" target="_blank" rel="noopener"><em>UNSUBSCRIBE</em></a> 之外的其他命令。 其中， <a href="http://doc.redisfans.com/pub_sub/subscribe.html#subscribe" target="_blank" rel="noopener"><em>SUBSCRIBE</em></a> 可以用于订阅更多频道， 而 <a href="http://doc.redisfans.com/pub_sub/unsubscribe.html#unsubscribe" target="_blank" rel="noopener"><em>UNSUBSCRIBE</em></a> 则可以用于退订已订阅的一个或多个频道。</p><p><a href="http://doc.redisfans.com/pub_sub/subscribe.html#subscribe" target="_blank" rel="noopener"><em>SUBSCRIBE</em></a> 和 <a href="http://doc.redisfans.com/pub_sub/unsubscribe.html#unsubscribe" target="_blank" rel="noopener"><em>UNSUBSCRIBE</em></a> 的执行结果会以信息的形式返回， 客户端可以通过分析所接收信息的第一个元素， 从而判断所收到的内容是一条真正的信息， 还是 <a href="http://doc.redisfans.com/pub_sub/subscribe.html#subscribe" target="_blank" rel="noopener"><em>SUBSCRIBE</em></a> 或 <a href="http://doc.redisfans.com/pub_sub/unsubscribe.html#unsubscribe" target="_blank" rel="noopener"><em>UNSUBSCRIBE</em></a> 命令的操作结果。</p><h4 id="1-1-信息格式"><a href="#1-1-信息格式" class="headerlink" title="1.1 信息格式"></a>1.1 信息格式</h4><p>频道转发的每条信息都是一条带有三个元素的多条批量回复（multi-bulk reply）。</p><p>第一个元素标识了信息的类型，有以下三种类型：</p><ul><li><code>subscribe</code> ： 表示当前客户端成功地订阅了信息第二个元素所指示的频道， 而此时信息的第三个元素则记录了目前客户端已订阅频道的总数。</li><li><code>unsubscribe</code> ： 表示当前客户端成功地退订了信息第二个元素所指示的频道，而此时信息的第三个元素记录了客户端目前仍在订阅的频道数量。 当客户端订阅的频道数量降为 <code>0</code> 时， 客户端不再订阅任何频道， 它可以像往常一样， 执行任何 Redis 命令。</li><li><code>message</code> ： 表示这条信息是由某个客户端执行 <a href="http://doc.redisfans.com/pub_sub/publish.html#publish" target="_blank" rel="noopener"><em>PUBLISH</em></a> 命令所发送的， 真正的信息。 </li></ul><p>第二个元素是信息来源的频道。</p><p>第三个元素则是信息的内容。</p><h4 id="1-2-订阅模式"><a href="#1-2-订阅模式" class="headerlink" title="1.2 订阅模式"></a>1.2 订阅模式</h4><p>Redis 的发布与订阅实现支持模式匹配（pattern matching）： 客户端可以订阅一个带 <code>*</code> 号的模式， 如果某个/某些频道的名字和这个模式匹配， 那么当有信息发送给这个/这些频道的时候， 客户端也会收到这个/这些频道的信息。</p><p>比如说，执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PSUBSCRIBE news.*</span><br></pre></td></tr></table></figure><p>的客户端将收到来自 <code>news.art.figurative</code> 、 <code>news.music.jazz</code> 等频道的信息。</p><p>客户端订阅的模式里面可以包含多个 glob 风格的通配符， 比如 <code>*</code> 、 <code>?</code> 和 <code>[...]</code> ， 等等。</p><p>执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUNSUBSCRIBE news.*</span><br></pre></td></tr></table></figure><p>将退订 <code>news.*</code> 模式， 其他已订阅的模式不会被影响。</p><p>通过订阅模式接收到的信息， 和通过订阅频道接收到的信息， 两者的格式不太一样：</p><p>通过订阅模式而接收到的信息的类型为 <code>pmessage</code> ： 这代表有某个客户端通过 <a href="http://doc.redisfans.com/pub_sub/publish.html#publish" target="_blank" rel="noopener"><em>PUBLISH</em></a> 向某个频道发送了信息， 而这个频道刚好匹配了当前客户端所订阅的某个模式。 信息的第二个元素记录了被匹配的模式， 第三个元素记录了被匹配的频道的名字， 最后一个元素则记录了信息的实际内容。</p><p>客户端处理 <a href="http://doc.redisfans.com/pub_sub/psubscribe.html#psubscribe" target="_blank" rel="noopener"><em>PSUBSCRIBE</em></a> 和 <a href="http://doc.redisfans.com/pub_sub/punsubscribe.html#punsubscribe" target="_blank" rel="noopener"><em>PUNSUBSCRIBE</em></a> 返回值的方式， 和客户端处理 <a href="http://doc.redisfans.com/pub_sub/subscribe.html#subscribe" target="_blank" rel="noopener"><em>SUBSCRIBE</em></a> 和 <a href="http://doc.redisfans.com/pub_sub/unsubscribe.html#unsubscribe" target="_blank" rel="noopener"><em>UNSUBSCRIBE</em></a> 的方式类似： 通过对信息的第一个元素进行分析， 客户端可以判断接收到的信息是一个真正的信息， 还是 <a href="http://doc.redisfans.com/pub_sub/psubscribe.html#psubscribe" target="_blank" rel="noopener"><em>PSUBSCRIBE</em></a> 或 <a href="http://doc.redisfans.com/pub_sub/punsubscribe.html#punsubscribe" target="_blank" rel="noopener"><em>PUNSUBSCRIBE</em></a> 命令的返回值。</p><h3 id="2、发布什么"><a href="#2、发布什么" class="headerlink" title="2、发布什么"></a>2、发布什么</h3><p>键空间通知使得客户端可以通过订阅频道或模式， 来接收那些以某种方式改动了 Redis 数据集的事件。</p><p>以下是一些键空间通知发送的事件的例子：</p><ul><li>所有修改键的命令。</li><li>所有接收到 <a href="http://doc.redisfans.com/list/lpush.html#lpush" target="_blank" rel="noopener"><em>LPUSH</em></a> 命令的键。</li><li><code>0</code> 号数据库中所有已过期的键。</li></ul><p>事件通过 Redis 的订阅与发布功能（pub/sub）来进行分发， 因此所有支持订阅与发布功能的客户端都可以在无须做任何修改的情况下， 直接使用键空间通知功能。</p><p>因为 Redis 目前的订阅与发布功能采取的是发送即忘（fire and forget）策略， 所以如果你的程序需要可靠事件通知（reliable notification of events）， 那么目前的键空间通知可能并不适合你： 当订阅事件的客户端断线时， 它会丢失所有在断线期间分发给它的事件。</p><p>未来将会支持更可靠的事件分发， 这种支持可能会通过让订阅与发布功能本身变得更可靠来实现， 也可能会在 Lua 脚本中对消息（message）的订阅与发布进行监听， 从而实现类似将事件推入到列表这样的操作。</p><h4 id="2-1-通知类型"><a href="#2-1-通知类型" class="headerlink" title="2.1 通知类型"></a>2.1 通知类型</h4><p>对于每个修改数据库的操作，键空间通知都会发送两种不同类型的事件。</p><p>比如说，对 <code>0</code> 号数据库的键 <code>mykey</code> 执行 <a href="http://doc.redisfans.com/key/del.html#del" target="_blank" rel="noopener"><em>DEL</em></a> 命令时， 系统将分发两条消息， 相当于执行以下两个 <a href="http://doc.redisfans.com/pub_sub/publish.html#publish" target="_blank" rel="noopener"><em>PUBLISH</em></a> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH __keyspace@0__:mykey del</span><br><span class="line">PUBLISH __keyevent@0__:del mykey</span><br></pre></td></tr></table></figure><p>订阅第一个频道 <code>__keyspace@0__:mykey</code> 可以接收 <code>0</code> 号数据库中所有修改键 <code>mykey</code> 的事件， 而订阅第二个频道 <code>__keyevent@0__:del</code>则可以接收 <code>0</code> 号数据库中所有执行 <code>del</code> 命令的键。</p><p>以 <code>keyspace</code> 为前缀的频道被称为键空间通知（key-space notification）， 而以 <code>keyevent</code> 为前缀的频道则被称为键事件通知（key-event notification）。</p><p>当 <code>del mykey</code> 命令执行时：</p><ul><li>键空间频道的订阅者将接收到被执行的事件的名字，在这个例子中，就是 <code>del</code> 。</li><li>键事件频道的订阅者将接收到被执行事件的键的名字，在这个例子中，就是 <code>mykey</code> 。</li></ul><h4 id="2-2-配置"><a href="#2-2-配置" class="headerlink" title="2.2 配置"></a>2.2 配置</h4><p>因为开启键空间通知功能需要消耗一些 CPU ， 所以在默认配置下， 该功能处于关闭状态。</p><p>可以通过修改 <code>redis.conf</code> 文件（<strong>重启生效且一直有效</strong>）， 或者直接使用 <code>CONFIG SET</code> 命令（<strong>立即生效且重启失效</strong>）来开启或关闭键空间通知功能：</p><ul><li>当 <code>notify-keyspace-events</code> 选项的参数为空字符串时，功能关闭。</li><li>另一方面，当参数不是空字符串时，功能开启。</li></ul><p><code>notify-keyspace-events</code> 的参数可以是以下字符的任意组合， 它指定了服务器该发送哪些类型的通知：</p><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">发送的通知</th></tr></thead><tbody><tr><td style="text-align:left"><code>K</code></td><td style="text-align:left">键空间通知，所有通知以 <code>__keyspace@&lt;db&gt;__</code> 为前缀</td></tr><tr><td style="text-align:left"><code>E</code></td><td style="text-align:left">键事件通知，所有通知以 <code>__keyevent@&lt;db&gt;__</code> 为前缀</td></tr><tr><td style="text-align:left"><code>g</code></td><td style="text-align:left"><code>DEL</code> 、 <code>EXPIRE</code> 、 <code>RENAME</code> 等类型无关的通用命令的通知</td></tr><tr><td style="text-align:left"><code>$</code></td><td style="text-align:left">字符串命令的通知</td></tr><tr><td style="text-align:left"><code>l</code></td><td style="text-align:left">列表命令的通知</td></tr><tr><td style="text-align:left"><code>s</code></td><td style="text-align:left">集合命令的通知</td></tr><tr><td style="text-align:left"><code>h</code></td><td style="text-align:left">哈希命令的通知</td></tr><tr><td style="text-align:left"><code>z</code></td><td style="text-align:left">有序集合命令的通知</td></tr><tr><td style="text-align:left"><code>x</code></td><td style="text-align:left">过期事件：每当有过期键被删除时发送</td></tr><tr><td style="text-align:left"><code>e</code></td><td style="text-align:left">驱逐(evict)事件：每当有键因为 <code>maxmemory</code> 政策而被删除时发送</td></tr><tr><td style="text-align:left"><code>A</code></td><td style="text-align:left">参数 <code>g$lshzxe</code> 的别名</td></tr></tbody></table><p>输入的参数中至少要有一个 <code>K</code> 或者 <code>E</code> ， 否则的话， 不管其余的参数是什么， 都不会有任何通知被分发。</p><p>举个例子， 如果只想订阅键空间中和列表相关的通知， 那么参数就应该设为 <code>Kl</code> ， 诸如此类。</p><p>将参数设为字符串 <code>&quot;AKE&quot;</code> 表示发送所有类型的通知。</p><h4 id="2-3-命令产生的通知"><a href="#2-3-命令产生的通知" class="headerlink" title="2.3 命令产生的通知"></a>2.3 命令产生的通知</h4><p>以下列表记录了不同命令所产生的不同通知：</p><ul><li><a href="http://doc.redisfans.com/key/del.html#del" target="_blank" rel="noopener"><em>DEL</em></a> 命令为每个被删除的键产生一个 <code>del</code> 通知。</li><li><a href="http://doc.redisfans.com/key/rename.html#rename" target="_blank" rel="noopener"><em>RENAME</em></a> 产生两个通知：为来源键（source key）产生一个 <code>rename_from</code> 通知，并为目标键（destination key）产生一个 <code>rename_to</code> 通知。</li><li><a href="http://doc.redisfans.com/key/expire.html#expire" target="_blank" rel="noopener"><em>EXPIRE</em></a> 和 <a href="http://doc.redisfans.com/key/expireat.html#expireat" target="_blank" rel="noopener"><em>EXPIREAT</em></a> 在键被正确设置过期时间时产生一个 <code>expire</code> 通知。当 <a href="http://doc.redisfans.com/key/expireat.html#expireat" target="_blank" rel="noopener"><em>EXPIREAT</em></a> 设置的时间已经过期，或者 <a href="http://doc.redisfans.com/key/expire.html#expire" target="_blank" rel="noopener"><em>EXPIRE</em></a> 传入的时间为负数值时，键被删除，并产生一个 <code>del</code> 通知。</li><li>每当一个键因为过期而被删除时，产生一个 <code>expired</code> 通知。</li><li><a href="http://doc.redisfans.com/key/sort.html#sort" target="_blank" rel="noopener"><em>SORT</em></a> 在命令带有 <code>STORE</code> 参数时产生一个 <code>sortstore</code> 事件。如果 <code>STORE</code> 指示的用于保存排序结果的键已经存在，那么程序还会发送一个 <code>del</code> 事件。</li><li><a href="http://doc.redisfans.com/string/set.html#set" target="_blank" rel="noopener"><em>SET</em></a> 以及它的所有变种（<a href="http://doc.redisfans.com/string/setex.html#setex" target="_blank" rel="noopener"><em>SETEX</em></a> 、 <a href="http://doc.redisfans.com/string/setnx.html#setnx" target="_blank" rel="noopener"><em>SETNX</em></a> 和 <a href="http://doc.redisfans.com/string/getset.html#getset" target="_blank" rel="noopener"><em>GETSET</em></a>）都产生 <code>set</code> 通知。其中 <a href="http://doc.redisfans.com/string/setex.html#setex" target="_blank" rel="noopener"><em>SETEX</em></a> 还会产生 <code>expire</code> 通知。</li><li><a href="http://doc.redisfans.com/string/mset.html#mset" target="_blank" rel="noopener"><em>MSET</em></a> 为每个键产生一个 <code>set</code> 通知。</li><li><a href="http://doc.redisfans.com/string/setrange.html#setrange" target="_blank" rel="noopener"><em>SETRANGE</em></a> 产生一个 <code>setrange</code> 通知。</li><li><a href="http://doc.redisfans.com/string/incr.html#incr" target="_blank" rel="noopener"><em>INCR</em></a> 、 <a href="http://doc.redisfans.com/string/decr.html#decr" target="_blank" rel="noopener"><em>DECR</em></a> 、 <a href="http://doc.redisfans.com/string/incrby.html#incrby" target="_blank" rel="noopener"><em>INCRBY</em></a> 和 <a href="http://doc.redisfans.com/string/decrby.html#decrby" target="_blank" rel="noopener"><em>DECRBY</em></a> 都产生 <code>incrby</code> 通知。</li><li><a href="http://doc.redisfans.com/string/incrbyfloat.html#incrbyfloat" target="_blank" rel="noopener"><em>INCRBYFLOAT</em></a> 产生 <code>incrbyfloat</code> 通知。</li><li><a href="http://doc.redisfans.com/string/append.html#append" target="_blank" rel="noopener"><em>APPEND</em></a> 产生 <code>append</code> 通知。</li><li><a href="http://doc.redisfans.com/list/lpush.html#lpush" target="_blank" rel="noopener"><em>LPUSH</em></a> 和 <a href="http://doc.redisfans.com/list/lpushx.html#lpushx" target="_blank" rel="noopener"><em>LPUSHX</em></a> 都产生单个 <code>lpush</code> 通知，即使有多个输入元素时，也是如此。</li><li><a href="http://doc.redisfans.com/list/rpush.html#rpush" target="_blank" rel="noopener"><em>RPUSH</em></a> 和 <a href="http://doc.redisfans.com/list/rpushx.html#rpushx" target="_blank" rel="noopener"><em>RPUSHX</em></a> 都产生单个 <code>rpush</code> 通知，即使有多个输入元素时，也是如此。</li><li><a href="http://doc.redisfans.com/list/rpop.html#rpop" target="_blank" rel="noopener"><em>RPOP</em></a> 产生 <code>rpop</code> 通知。如果被弹出的元素是列表的最后一个元素，那么还会产生一个 <code>del</code> 通知。</li><li><a href="http://doc.redisfans.com/list/lpop.html#lpop" target="_blank" rel="noopener"><em>LPOP</em></a> 产生 <code>lpop</code> 通知。如果被弹出的元素是列表的最后一个元素，那么还会产生一个 <code>del</code> 通知。</li><li><a href="http://doc.redisfans.com/list/linsert.html#linsert" target="_blank" rel="noopener"><em>LINSERT</em></a> 产生一个 <code>linsert</code> 通知。</li><li><a href="http://doc.redisfans.com/list/lset.html#lset" target="_blank" rel="noopener"><em>LSET</em></a> 产生一个 <code>lset</code> 通知。</li><li><a href="http://doc.redisfans.com/list/ltrim.html#ltrim" target="_blank" rel="noopener"><em>LTRIM</em></a> 产生一个 <code>ltrim</code> 通知。如果 <a href="http://doc.redisfans.com/list/ltrim.html#ltrim" target="_blank" rel="noopener"><em>LTRIM</em></a> 执行之后，列表键被清空，那么还会产生一个 <code>del</code> 通知。</li><li><a href="http://doc.redisfans.com/list/rpoplpush.html#rpoplpush" target="_blank" rel="noopener"><em>RPOPLPUSH</em></a> 和 <a href="http://doc.redisfans.com/list/brpoplpush.html#brpoplpush" target="_blank" rel="noopener"><em>BRPOPLPUSH</em></a> 产生一个 <code>rpop</code> 通知，以及一个 <code>lpush</code> 通知。两个命令都会保证 <code>rpop</code> 的通知在 <code>lpush</code> 的通知之前分发。如果从键弹出元素之后，被弹出的列表键被清空，那么还会产生一个 <code>del</code> 通知。</li><li><a href="http://doc.redisfans.com/hash/hset.html#hset" target="_blank" rel="noopener"><em>HSET</em></a> 、 <a href="http://doc.redisfans.com/hash/hsetnx.html#hsetnx" target="_blank" rel="noopener"><em>HSETNX</em></a> 和 <a href="http://doc.redisfans.com/hash/hmset.html#hmset" target="_blank" rel="noopener"><em>HMSET</em></a> 都只产生一个 <code>hset</code> 通知。</li><li><a href="http://doc.redisfans.com/hash/hincrby.html#hincrby" target="_blank" rel="noopener"><em>HINCRBY</em></a> 产生一个 <code>hincrby</code> 通知。</li><li><a href="http://doc.redisfans.com/hash/hincrbyfloat.html#hincrbyfloat" target="_blank" rel="noopener"><em>HINCRBYFLOAT</em></a> 产生一个 <code>hincrbyfloat</code> 通知。</li><li><a href="http://doc.redisfans.com/hash/hdel.html#hdel" target="_blank" rel="noopener"><em>HDEL</em></a> 产生一个 <code>hdel</code> 通知。如果执行 <a href="http://doc.redisfans.com/hash/hdel.html#hdel" target="_blank" rel="noopener"><em>HDEL</em></a> 之后，哈希键被清空，那么还会产生一个 <code>del</code> 通知。</li><li><a href="http://doc.redisfans.com/set/sadd.html#sadd" target="_blank" rel="noopener"><em>SADD</em></a> 产生一个 <code>sadd</code> 通知，即使有多个输入元素时，也是如此。</li><li><a href="http://doc.redisfans.com/set/srem.html#srem" target="_blank" rel="noopener"><em>SREM</em></a> 产生一个 <code>srem</code> 通知，如果执行 <a href="http://doc.redisfans.com/set/srem.html#srem" target="_blank" rel="noopener"><em>SREM</em></a> 之后，集合键被清空，那么还会产生一个 <code>del</code> 通知。</li><li><a href="http://doc.redisfans.com/set/smove.html#smove" target="_blank" rel="noopener"><em>SMOVE</em></a> 为来源键（source key）产生一个 <code>srem</code> 通知，并为目标键（destination key）产生一个 <code>sadd</code> 事件。</li><li><a href="http://doc.redisfans.com/set/spop.html#spop" target="_blank" rel="noopener"><em>SPOP</em></a> 产生一个 <code>spop</code> 事件。如果执行 <a href="http://doc.redisfans.com/set/spop.html#spop" target="_blank" rel="noopener"><em>SPOP</em></a> 之后，集合键被清空，那么还会产生一个 <code>del</code> 通知。</li><li><a href="http://doc.redisfans.com/set/sinterstore.html#sinterstore" target="_blank" rel="noopener"><em>SINTERSTORE</em></a> 、 <a href="http://doc.redisfans.com/set/sunionstore.html#sunionstore" target="_blank" rel="noopener"><em>SUNIONSTORE</em></a> 和 <a href="http://doc.redisfans.com/set/sdiffstore.html#sdiffstore" target="_blank" rel="noopener"><em>SDIFFSTORE</em></a> 分别产生 <code>sinterstore</code> 、 <code>sunionostore</code> 和 <code>sdiffstore</code> 三种通知。如果用于保存结果的键已经存在，那么还会产生一个 <code>del</code> 通知。</li><li><a href="http://doc.redisfans.com/sorted_set/zincrby.html#zincrby" target="_blank" rel="noopener"><em>ZINCRBY</em></a> 产生一个 <code>zincr</code> 通知。（译注：非对称，请注意。）</li><li><a href="http://doc.redisfans.com/sorted_set/zadd.html#zadd" target="_blank" rel="noopener"><em>ZADD</em></a> 产生一个 <code>zadd</code> 通知，即使有多个输入元素时，也是如此。</li><li><a href="http://doc.redisfans.com/sorted_set/zrem.html#zrem" target="_blank" rel="noopener"><em>ZREM</em></a> 产生一个 <code>zrem</code> 通知，即使有多个输入元素时，也是如此。如果执行 <a href="http://doc.redisfans.com/sorted_set/zrem.html#zrem" target="_blank" rel="noopener"><em>ZREM</em></a> 之后，有序集合键被清空，那么还会产生一个 <code>del</code> 通知。</li><li><a href="http://doc.redisfans.com/sorted_set/zremrangebyscore.html#zremrangebyscore" target="_blank" rel="noopener"><em>ZREMRANGEBYSCORE</em></a> 产生一个 <code>zrembyscore</code> 通知。（译注：非对称，请注意。）如果用于保存结果的键已经存在，那么还会产生一个 <code>del</code> 通知。</li><li><a href="http://doc.redisfans.com/sorted_set/zremrangebyrank.html#zremrangebyrank" target="_blank" rel="noopener"><em>ZREMRANGEBYRANK</em></a> 产生一个 <code>zrembyrank</code> 通知。（译注：非对称，请注意。）如果用于保存结果的键已经存在，那么还会产生一个 <code>del</code> 通知。</li><li><a href="http://doc.redisfans.com/sorted_set/zinterstore.html#zinterstore" target="_blank" rel="noopener"><em>ZINTERSTORE</em></a> 和 <a href="http://doc.redisfans.com/sorted_set/zunionstore.html#zunionstore" target="_blank" rel="noopener"><em>ZUNIONSTORE</em></a> 分别产生 <code>zinterstore</code> 和 <code>zunionstore</code> 两种通知。如果用于保存结果的键已经存在，那么还会产生一个 <code>del</code> 通知。</li><li>每当一个键因为 <code>maxmemory</code> 政策而被删除以回收内存时，产生一个 <code>evicted</code> 通知。</li></ul><p>所有命令都只在键<strong>真的</strong>被改动了之后，才会产生通知。</p><p>比如说，当 <a href="http://doc.redisfans.com/set/srem.html#srem" target="_blank" rel="noopener"><em>SREM</em></a> 试图删除不存在于集合的元素时，删除操作会执行失败，因为没有真正的改动键，所以这一操作不会发送通知。</p><p>如果对命令所产生的通知有疑问， 最好还是使用以下命令， 自己来验证一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli config set notify-keyspace-events KEA</span><br><span class="line">$ redis-cli --csv psubscribe &apos;__key*__:*&apos;</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">&quot;psubscribe&quot;,&quot;__key*__:*&quot;,1</span><br></pre></td></tr></table></figure><p>然后， 只要在其他终端里用 Redis 客户端发送命令， 就可以看到产生的通知了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;pmessage&quot;,&quot;__key*__:*&quot;,&quot;__keyspace@0__:foo&quot;,&quot;set&quot;</span><br><span class="line">&quot;pmessage&quot;,&quot;__key*__:*&quot;,&quot;__keyevent@0__:set&quot;,&quot;foo&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="2-4-过期通知的发送时间"><a href="#2-4-过期通知的发送时间" class="headerlink" title="2.4 过期通知的发送时间"></a>2.4 过期通知的发送时间</h4><p>我们已经了解了redis的键过期机制为 定期删除 + 惰性删除：</p><ul><li>当一个键被访问时，程序会对这个键进行检查，如果键已经过期，那么该键将被删除。</li><li>底层系统会在后台渐进地查找并删除那些过期的键，从而处理那些已经过期、但是不会被访问到的键。</li></ul><p>当过期键被以上两个程序的任意一个发现、 并且将键从数据库中删除时， Redis 会产生一个 <code>expired</code> 通知。</p><p>Redis 并不保证生存时间（TTL）变为 <code>0</code> 的键会立即被删除： 如果程序没有访问这个过期键， 或者带有生存时间的键非常多的话， 那么在键的生存时间变为 <code>0</code> ， 直到键真正被删除这中间， 可能会有一段比较显著的时间间隔。</p><p>因此， Redis 产生 <code>expired</code> 通知的时间为过期键被删除的时候， 而不是键的生存时间变为 <code>0</code> 的时候。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;需求：redis中缓存了一些状态量，业务需要时刻关注状态量变化&lt;/p&gt;
&lt;p&gt;方案一：轮询检查（各方面性能太差）&lt;/p&gt;
&lt;p&gt;方案二：redis提供的键空间通知机制（redis主动推送，优选）&lt;/p&gt;
&lt;h3 id=&quot;1、发布与订阅&quot;&gt;&lt;a href=&quot;#1、发布与订阅&quot;
      
    
    </summary>
    
    
      <category term="redis" scheme="http://yoursite.com/child/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis-数据持久化配置</title>
    <link href="http://yoursite.com/child/2019/08/01/redis-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/child/2019/08/01/redis-数据持久化配置/</id>
    <published>2019-07-31T16:00:00.000Z</published>
    <updated>2019-08-19T13:41:41.779Z</updated>
    
    <content type="html"><![CDATA[<p>redis的数据持久化功能默认是没有开启的，当我们kill掉redis-server进程并重启后，此前所有的缓存数据都会丢失，所以为了防止redis服务器宕机而造成数据丢失，我们应该打开redis的数据持久化功能。</p><p>redis持久化方式有两种：RDB 和 AOF，本文将围绕这两种持久化方式展开。</p><h3 id="1、持久化原理"><a href="#1、持久化原理" class="headerlink" title="1、持久化原理"></a>1、持久化原理</h3><ul><li>RDB的原理是生成当前数据集的快照文件dump.rdb，当服务器宕机重启后，服务器会根据该备份文件恢复数据，备份的是数据。</li><li>AOF的原理是维护一个数据写入日志（aof文件），在服务器执行写入命令的时候，在aof文件尾部添加命令。服务器宕机重启后，自动执行aof文件中的数据写入命令恢复数据。</li></ul><h3 id="2、运行过程"><a href="#2、运行过程" class="headerlink" title="2、运行过程"></a>2、运行过程</h3><h4 id="2-1-RDB方式"><a href="#2-1-RDB方式" class="headerlink" title="2.1 RDB方式"></a>2.1 RDB方式</h4><p>当 Redis 需要保存 <code>dump.rdb</code> 文件时， 服务器执行以下操作：</p><ol><li>Redis 调用 <code>fork()</code> ，同时拥有父进程和子进程。</li><li>子进程将数据集写入到一个临时 RDB 文件中。</li><li>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</li></ol><h4 id="2-2-AOF方式"><a href="#2-2-AOF方式" class="headerlink" title="2.2 AOF方式"></a>2.2 AOF方式</h4><p>每当 Redis 执行一个改变数据集的命令时（比如 <strong>SET</strong>、<strong>INCR</strong>）， 这个命令就会被追加到 AOF 文件的末尾， 当 Redis 重新启时， 程序就可以通过重新执行 AOF 文件中的命令来达到重建数据集的目的。</p><h5 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h5><p>举个例子， 如果你对一个计数器调用了 100 次<strong>INCR</strong> ， 那么仅仅是为了保存这个计数器的当前值， AOF 文件就需要使用 100 条记录。</p><p>然而在实际上， 只使用一条 <strong>SET</strong> 命令已经足以保存计数器的当前值了， 其余 99 条记录实际上都是多余的。</p><p>为了处理这种情况， Redis 支持一种有趣的特性： 可以在不打断服务客户端的情况下， 对 AOF 文件进行重建（rebuild）。</p><p>执行 <a href="http://doc.redisfans.com/server/bgrewriteaof.html#bgrewriteaof" target="_blank" rel="noopener"><em>BGREWRITEAOF</em></a> 命令， Redis 将生成一个新的 AOF 文件， 这个文件包含重建当前数据集所需的最少命令。</p><p>Redis 2.2 需要自己手动执行 <a href="http://doc.redisfans.com/server/bgrewriteaof.html#bgrewriteaof" target="_blank" rel="noopener"><em>BGREWRITEAOF</em></a> 命令； Redis 2.4 则可以自动触发 AOF 重写， 具体信息请查看 2.4 的示例配置文件。</p><h5 id="重写过程"><a href="#重写过程" class="headerlink" title="重写过程"></a>重写过程</h5><p>AOF 重写和 RDB 创建快照一样，都巧妙地利用了copy-on-write机制。</p><ol><li>Redis 执行 <code>fork()</code> ，现在同时拥有父进程和子进程。</li><li>子进程开始将新 AOF 文件的内容写入到临时文件。</li><li>对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾： 这样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。</li><li>当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。</li><li>现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。</li></ol><h3 id="3、优劣势对比"><a href="#3、优劣势对比" class="headerlink" title="3、优劣势对比"></a>3、优劣势对比</h3><table><thead><tr><th style="text-align:center">RDB</th><th style="text-align:center">AOF</th></tr></thead><tbody><tr><td style="text-align:center"><strong>备份策略灵活多样可配置</strong></td><td style="text-align:center"><em>只有三种持久化策略</em></td></tr><tr><td style="text-align:center"><strong>rdb文件内容紧凑，适合灾难恢复</strong></td><td style="text-align:center">-</td></tr><tr><td style="text-align:center"><strong>备份过程不影响redis性能</strong></td><td style="text-align:center"><em>持久化策略决定是否影响redis性能</em></td></tr><tr><td style="text-align:center"><strong>大数据集恢复速度快</strong></td><td style="text-align:center"><em>大数据量恢复速度较慢</em></td></tr><tr><td style="text-align:center"><em>可靠性地，丢失数据概率高</em></td><td style="text-align:center"><strong>持久化可靠性高，丢失数据概率低</strong></td></tr><tr><td style="text-align:center"><em>rdb文件不可读</em></td><td style="text-align:center"><strong>aof文件可读性高，易于分析</strong></td></tr><tr><td style="text-align:center"><em>每次生成快照都需要操作整个数据集</em></td><td style="text-align:center"><strong>aof文件只需要进行追加操作</strong></td></tr></tbody></table><p>总结来说：</p><p>RDB方式备份时费劲，恢复时很给力，持久化可靠性低；AOF方式备份简单，恢复时稍费力，持久化可靠性高。具体使用哪种方式，需要根据具体业务场景进行选择。</p><h3 id="4、配置方式"><a href="#4、配置方式" class="headerlink" title="4、配置方式"></a>4、配置方式</h3><h4 id="4-1-RDB配置"><a href="#4-1-RDB配置" class="headerlink" title="4.1 RDB配置"></a>4.1 RDB配置</h4><h5 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h5><p>RDB通过手动执行命令<strong>SAVE</strong>或者<strong>BGSAVE</strong>生成快照文件，SAVE会阻塞服务器进程直到成功生成备份，不推荐使用；使用BGSAVE，服务器进程会fork一个子进程，异步执行备份，此过程服务器只有在fork()的时候阻塞。</p><h5 id="自动触发-配置文件"><a href="#自动触发-配置文件" class="headerlink" title="自动触发(配置文件)"></a>自动触发(配置文件)</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 停用rdb</span><br><span class="line"><span class="meta">#</span>save ""</span><br><span class="line">save 900 1 #表示900 秒内如果至少有 1 个 key 的值变化，则保存</span><br><span class="line">save 300 10 #表示300 秒内如果至少有 10 个 key 的值变化，则保存</span><br><span class="line">save 60 10000 #表示60 秒内如果至少有 10000 个 key 的值变化，则保存</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>当启用了RDB且最后一次后台保存数据失败，Redis是否停止接收数据，默认yes</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>对于存储到磁盘中的快照，可以设置是否采用LZF进行压缩存储，默认yes</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验</span><br><span class="line"><span class="meta">#</span>但是这样做会增加大约10%的性能消耗，默认yes</span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>设置快照的文件名，默认是 dump.rdb</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名</span><br><span class="line">dir /var/redis/6379</span><br></pre></td></tr></table></figure><h4 id="4-2-AOF配置"><a href="#4-2-AOF配置" class="headerlink" title="4.2 AOF配置"></a>4.2 AOF配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 开启aof</span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> aof文件名称</span><br><span class="line">appendfilename "appendonly.aof"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 三种持久化策略</span><br><span class="line"><span class="meta">#</span> appendfsync always  # 每次修改数据集都会追加一次</span><br><span class="line">appendfsync everysec  # 每1秒追加一次 </span><br><span class="line"><span class="meta">#</span> appendfsync no  # 交给系统控制，linux 系统是30秒</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> If you have latency problems turn this to "yes". Otherwise leave it as</span><br><span class="line"><span class="meta">#</span> "no" that is the safest pick from the point of view of durability.</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 当aof文件增长量达到100%，自动重写（设为0则永不重写）</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"><span class="meta">#</span> 当aof文件小于这个值，不会自动重写</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> </span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> </span><br><span class="line">aof-use-rdb-preamble no</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;redis的数据持久化功能默认是没有开启的，当我们kill掉redis-server进程并重启后，此前所有的缓存数据都会丢失，所以为了防止redis服务器宕机而造成数据丢失，我们应该打开redis的数据持久化功能。&lt;/p&gt;
&lt;p&gt;redis持久化方式有两种：RDB 和 AO
      
    
    </summary>
    
    
      <category term="redis" scheme="http://yoursite.com/child/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>数据库-centos安装配置MySql8.0</title>
    <link href="http://yoursite.com/child/2019/07/31/%E6%95%B0%E6%8D%AE%E5%BA%93-centos%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEMySql8.0/"/>
    <id>http://yoursite.com/child/2019/07/31/数据库-centos安装配置MySql8.0/</id>
    <published>2019-07-31T00:36:00.173Z</published>
    <updated>2019-07-31T01:43:48.415Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL8.0和MySQL5.7具有众多不同之处，此处不述。这里，只简单讲讲在安装过程中遇到的问题之一和解决办法：<br> MySQL8.0安装完成之后的默认密码是多少？如何修改初始密码？</p><h3 id="1-安装MySQL8-0"><a href="#1-安装MySQL8-0" class="headerlink" title="1 安装MySQL8.0"></a>1 安装MySQL8.0</h3><ul><li>yum仓库下载MySQL：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">shell&gt;</span> yum localinstall https://repo.mysql.com//mysql80-community-release-el7-1.noarch.rpm</span><br></pre></td></tr></table></figure><ul><li>yum安装MySQL：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">shell&gt;</span> yum install mysql-community-server</span><br></pre></td></tr></table></figure><h3 id="2-启动MySQL服务"><a href="#2-启动MySQL服务" class="headerlink" title="2 启动MySQL服务"></a>2 启动MySQL服务</h3><ul><li>启动MySQL服务的命令：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">shell&gt;</span> service mysqld start</span><br><span class="line"></span><br><span class="line">Starting mysqld:[ OK ]</span><br></pre></td></tr></table></figure><ul><li>检查MySQL服务器的运行状态：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">shell&gt;</span> sudo service mysqld status</span><br><span class="line"></span><br><span class="line">● mysqld.service - MySQL Server</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/mysqld.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Sun 2018-06-03 18:31:51 CST; 6min ago</span><br><span class="line">     Docs: man:mysqld(8)</span><br><span class="line">           http://dev.mysql.com/doc/refman/en/using-systemd.html</span><br><span class="line">  Process: 5281 ExecStartPre=/usr/bin/mysqld_pre_systemd (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 5299 (mysqld)</span><br><span class="line">   Status: "SERVER_OPERATING"</span><br><span class="line">   CGroup: /system.slice/mysqld.service</span><br><span class="line">           └─5299 /usr/sbin/mysqld</span><br><span class="line"></span><br><span class="line">Jun 03 18:31:50 &#123;your-server-name&#125; systemd[1]: Starting MySQL Server...</span><br><span class="line">Jun 03 18:31:51 &#123;your-server-name&#125; systemd[1]: Started MySQL Server.</span><br></pre></td></tr></table></figure><p>以上信息表示MySQL服务启动成功。</p><h3 id="3-MySQL默认密码和修改密码"><a href="#3-MySQL默认密码和修改密码" class="headerlink" title="3 MySQL默认密码和修改密码"></a>3 MySQL默认密码和修改密码</h3><p>在启动MySQL服务的时候，主要会发生以下4件事</p><ul><li>MySQL Server初始化并启动起来；</li><li>MySQL的data文件夹中生成SSL证书和key文件；</li><li>密码验证组件被安装并且生效；</li><li>创建一个超级管用户<em>‘root‘@’localhost‘</em>。超级用户设置的密码被保存在错误日志文件中，可以通过以下命令查看：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">shell&gt;</span> sudo grep 'temporary password' /var/log/mysqld.log</span><br><span class="line"></span><br><span class="line">2018-06-03T10:15:57.448920Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: 0xxXxxXx?xXX</span><br></pre></td></tr></table></figure><p>通过默认密码登录MySQL服务器，并马上修改密码(<strong>强烈建议</strong>)！！！。</p><p>有些时候使用上面的筛选命令检索不到文件或内容，可以手动查看/var/log/mysqld.log文件获取初始密码。</p><p>用默认密码(0xxXxxXx?xXX)登录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; mysql -uroot -p</span><br></pre></td></tr></table></figure><p>修改密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span> ALTER USER 'root'@'localhost' IDENTIFIED BY 'your-password';</span><br></pre></td></tr></table></figure><h3 id="4-设置允许远程连接"><a href="#4-设置允许远程连接" class="headerlink" title="4 设置允许远程连接"></a>4 设置允许远程连接</h3><p>在终端登录mysql之后查看是否允许远程访问：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use mysql</span><br><span class="line">Reading table information for completion of table and column names</span><br><span class="line">You can turn off this feature to get a quicker startup with -A</span><br><span class="line"></span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select host,user,plugin from user;</span><br><span class="line">+-----------+------------------+-----------------------+</span><br><span class="line">| host      | user             | plugin                |</span><br><span class="line">+-----------+------------------+-----------------------+</span><br><span class="line">| localhost | mysql.infoschema | caching_sha2_password |</span><br><span class="line">| localhost | mysql.session    | caching_sha2_password |</span><br><span class="line">| localhost | mysql.sys        | caching_sha2_password |</span><br><span class="line">| localhost | root             | caching_sha2_password |</span><br><span class="line">+-----------+------------------+-----------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>可以看到最后一行root 用户的host为localhost，要远程访问，需要将它改成%</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update user set host=&apos;%&apos; where user =&apos;root&apos;;</span><br><span class="line">Query OK, 1 row affected (0.07 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select host,user,plugin from user;</span><br><span class="line">+-----------+------------------+-----------------------+</span><br><span class="line">| host      | user             | plugin                |</span><br><span class="line">+-----------+------------------+-----------------------+</span><br><span class="line">| %         | root             | caching_sha2_password |</span><br><span class="line">| localhost | mysql.infoschema | caching_sha2_password |</span><br><span class="line">| localhost | mysql.session    | caching_sha2_password |</span><br><span class="line">| localhost | mysql.sys        | caching_sha2_password |</span><br><span class="line">+-----------+------------------+-----------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>最后刷新权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br><span class="line">Query OK, 0 rows affected (0.10 sec)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MySQL8.0和MySQL5.7具有众多不同之处，此处不述。这里，只简单讲讲在安装过程中遇到的问题之一和解决办法：&lt;br&gt; MySQL8.0安装完成之后的默认密码是多少？如何修改初始密码？&lt;/p&gt;
&lt;h3 id=&quot;1-安装MySQL8-0&quot;&gt;&lt;a href=&quot;#1-安装M
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/child/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>nio-入门篇-应用案例讲解</title>
    <link href="http://yoursite.com/child/2019/05/26/nio-%E5%85%A5%E9%97%A8%E7%AF%87-%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B%E8%AE%B2%E8%A7%A3/"/>
    <id>http://yoursite.com/child/2019/05/26/nio-入门篇-应用案例讲解/</id>
    <published>2019-05-26T02:21:34.000Z</published>
    <updated>2019-06-09T12:14:33.240Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Buffer"><a href="#1-Buffer" class="headerlink" title="1. Buffer"></a>1. Buffer</h3><p>在channel中传输的是buffer中的数据，而不是buffer对象。</p><p>使用Buffer读写数据一般遵循以下四个步骤（buffer为读写主体）：</p><ol><li>写入数据到Buffer</li><li>调用flip()方法</li><li>从Buffer中读取数据</li><li>调用clear()方法或者compact()方法  </li></ol><p>说明：</p><ul><li>当向buffer写入数据时，buffer会记录下写了多少数据。一旦要读取数据，需要通过flip()方法将Buffer从写模式切换到读模式。在读模式下，可以读取之前写入到buffer的所有数据。</li><li>一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用clear()或compact()方法。clear()方法会清空整个缓冲区。compact()方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。<h4 id="1-1-Buffer抽象类"><a href="#1-1-Buffer抽象类" class="headerlink" title="1.1 Buffer抽象类"></a>1.1 Buffer抽象类</h4>Buffer抽象类中定义的常用方法：</li><li><strong>Buffer flip()</strong> flip方法将Buffer从写模式切换到读模式。调用flip()方法会将position设回0，并将limit设置成之前position的值。</li><li><strong>Buffer rewind()</strong> 将position设回0，所以你可以重读Buffer中的所有数据。limit保持不变，仍然表示能从Buffer中读取多少个元素（byte、char等）</li><li><strong>int remaining()</strong> 返回position到limit之间的元素个数（未读出元素个数）</li><li><strong>boolean hasRemaining()</strong> 返回是否还有未读出的数据</li><li><strong>boolean isReadOnly()</strong> 是否此buffer只能读出</li><li><strong>Buffer mark()</strong> 可以标记Buffer中的一个特定position，之后可以通过调用Buffer.reset()方法恢复到这个position。</li><li><strong>Buffer reset()</strong> 恢复到mark()标记的状态</li><li><strong>Buffer clear()</strong> 重置position、limit、capacity和mark，从读模式转换成写模式 </li></ul><p>此外Buffer还声明了几个抽象方法如下，这些方法都是在Buffer的子类中定义的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boolean hasArray();</span><br><span class="line">boolean isReadOnly();</span><br><span class="line">Object array();</span><br><span class="line">int arrayOffset();</span><br><span class="line">boolean isDirect();</span><br></pre></td></tr></table></figure></p><h4 id="1-2-Buffer的类型"><a href="#1-2-Buffer的类型" class="headerlink" title="1.2 Buffer的类型"></a>1.2 Buffer的类型</h4><p>Java NIO 有以下Buffer类型：</p><ul><li>ByteBuffer</li><li>MappedByteBuffer</li><li>CharBuffer</li><li>DoubleBuffer</li><li>FloatBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>ShortBuffer </li></ul><p>这些类都是Buffer的子类，其实也是抽象类，它们在Buffer抽象类的基础上扩展了与数据类型相关的功能，下面以ByteBuffer为例介绍</p><p>扩展的常用方法：</p><ul><li><strong>ByteBuffer compact()</strong> 将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样，设置成capacity。</li><li><strong>byte get()</strong> 获取position所指的byte，并且position加1</li><li><strong>byte get(int index)</strong> 获取指定位置的byte</li><li><strong>ByteBuffer put(byte b)</strong> 将指定的byte写入buffer</li><li><strong>ByteBuffer put(int index,byte b)</strong> 将指定的byte写入buffer的指定位置</li><li>…许多的不同类型的get/put操作</li></ul><h3 id="2-Channel"><a href="#2-Channel" class="headerlink" title="2. Channel"></a>2. Channel</h3><p>Java NIO的通道类似流，但又有些不同：</p><ul><li>既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。</li><li>通道可以异步地读写。</li><li>通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入。</li></ul><p>常见的channel：</p><ol><li>FileChannel 从文件中读写数据。</li><li>DatagramChannel 能通过UDP读写网络中的数据。</li><li>SocketChannel 能通过TCP读写网络中的数据。</li><li>ServerSocketChannel可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。</li></ol><p>本文暂不分析具体的Channel类型，将在下一篇博文中具体阐述。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reads a sequence of bytes from this channel into the given buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Writes a sequence of bytes to this channel from the given buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure></p><p>注意对Channel的read和write的理解容易让人懵圈：   </p><ul><li>channel.read(buffer) 意思是Read from this channel to buffer  </li><li>channel.write(buffer) 意思是Write to this channel from buffer</li></ul><h3 id="3-Selector"><a href="#3-Selector" class="headerlink" title="3. Selector"></a>3. Selector</h3><ol><li>创建：调用Selector类的静态方法open()创建selector对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><ol start="2"><li>注册通道：调用Channel的实例方法将通道注册到selector上<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key = channel.register(selector,Selectionkey.OP_READ);</span><br></pre></td></tr></table></figure></li></ol><p>与Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。</p><p>register()方法的第二个参数是一个“interest集合”，意思是在Selector监听该Channel时对什么事件感兴趣。可以监听四种不同类型的事件：</p><ul><li>connect </li><li>accept</li><li>read</li><li>write</li></ul><p>当以上四种事件就绪的时候，会触发对应的通道事件，通道事件会被selector发现。所以，某个channel成功连接到另一个服务器称为“连接就绪”。一个server socket channel准备好接收新进入的连接称为“接收就绪”。一个有数据可读的通道可以说是“读就绪”。通道等待写数据可以说是“写就绪”。</p><p>这四种事件用SelectionKey的四个常量来表示：</p><ul><li>SelectionKey.OP_CONNECT</li><li>SelectionKey.OP_ACCEPT</li><li>SelectionKey.OP_READ</li><li>SelectionKey.OP_WRITE</li></ul><p>如果对不止一种事件感兴趣，那么可以用“位或”操作符将常量连接起来，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure></p><h4 id="3-1-SelectionKey"><a href="#3-1-SelectionKey" class="headerlink" title="3.1 SelectionKey"></a>3.1 SelectionKey</h4><p>当向Selector注册Channel时，register()方法会返回一个SelectionKey对象。这个对象包含了一些有用的属性：</p><ul><li>interest集合</li><li>ready集合</li><li>Channel</li><li>Selector</li><li>附件对象（可选）</li></ul><p><strong>interest集合</strong><br>可以通过SelectionKey读写interest集合，像这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = selectionKey.interestOps();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isInterestedInAccept  = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT；</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInRead    = interestSet &amp; SelectionKey.OP_READ;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInWrite   = interestSet &amp; SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure></p><p>可以看到，用“位与”操作interest 集合和给定的SelectionKey常量，可以确定某个确定的事件是否在interest 集合中。</p><p><strong>ready集合</strong><br>ready 集合是通道已经准备就绪的操作的集合，是四个常量通过‘或’运算生成的。在一次选择(Selection)之后，你会首先访问这个ready set。Selection将在下一小节进行解释。可以这样访问ready集合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int readySet = selectionKey.readyOps();</span><br></pre></td></tr></table></figure></p><p>可以用像检测interest集合那样的方法，来检测channel中什么事件或操作已经就绪。但是，也可以使用以下四个方法，它们都会返回一个布尔类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.isAcceptable();</span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure><p><strong>Channel &amp; Selector</strong><br>从SelectionKey访问Channel和Selector很简单。如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Channel  channel  = selectionKey.channel();</span><br><span class="line">Selector selector = selectionKey.selector();</span><br></pre></td></tr></table></figure></p><p>在程序中需要对返回的channel做类型转换  </p><p><strong>附件对象</strong><br>可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个给定的通道。例如，可以附加 与通道一起使用的Buffer，或是包含聚集数据的某个对象。使用方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.attach(theObject);</span><br><span class="line">Object attachedObj = selectionKey.attachment();</span><br></pre></td></tr></table></figure></p><p>还可以在用register()方法向Selector注册Channel的时候附加对象。如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);</span><br></pre></td></tr></table></figure></p><h4 id="3-2-Selector选择通道"><a href="#3-2-Selector选择通道" class="headerlink" title="3.2 Selector选择通道"></a>3.2 Selector选择通道</h4><p><strong>select()</strong></p><p>一旦向Selector注册了一或多个通道，就可以调用几个重载的select()方法。这些方法返回你所感兴趣的事件（如连接、接受、读或写）已经准备就绪的那些通道。换句话说，如果你对“读就绪”的通道感兴趣，select()方法会返回读事件已经就绪的那些通道。</p><p>三种select：</p><ul><li>int select() 阻塞方法，阻塞到至少有一个通道在注册的事件上就绪。</li><li>int select(long timeout) 超时返回的阻塞方法</li><li>int selectNow() 非阻塞方法，不管是否有通道就绪，立即返回。如果自上次select之后没有通道就绪，直接返回0</li></ul><p>方法返回的int值表示有多少通道已经就绪。亦即，自上次调用select()方法后有多少通道变成就绪状态。例如第一次调用select()方法，有一个通道变成就绪状态，返回了1，若再次调用select()方法，如果另一个通道就绪了，它会再次返回1，即使对第一个就绪的channel没有做任何操作，现在有两个就绪的通道。</p><p><strong>selectedKeys()</strong></p><p>一旦调用了select()方法，并且返回值表明有一个或更多个通道就绪了，然后可以通过调用selector的selectedKeys()方法，访问“已选择键集（selected key set）”中的就绪通道。如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br></pre></td></tr></table></figure></p><p>可以遍历这个已选择的键集合来访问就绪通道，像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">    SelectionKey key = iter.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">        handleAccept(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">        handleRead(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(key.isWritable() &amp;&amp; key.isValid())&#123;</span><br><span class="line">        handleWrite(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(key.isConnectable())&#123;</span><br><span class="line">        System.out.println(<span class="string">"isConnectable = true"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    iter.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意每次迭代末尾需要调用remove()。Selector不会自己从已选择键集中移除SelectionKey实例，必须在处理完通道时自己移除。下次该通道变成就绪时，Selector会再次将其放入已选择键集中。</p><p><strong>wakeUp()</strong></p><p>某个线程调用select()方法后阻塞了，即使没有通道已经就绪，也有办法让其从select()方法返回。只要让其它线程在第一个线程调用select()方法的那个对象上调用Selector.wakeup()方法即可。阻塞在select()方法上的线程会立马返回。</p><p>如果有其它线程调用了wakeup()方法，但当前没有线程阻塞在select()方法上，下个调用select()方法的线程会立即“醒来（wake up）”。</p><p><strong>close()</strong></p><p>用完Selector后调用其close()方法会关闭该Selector，该方法使注册到该Selector上的所有SelectionKey实例无效，通道本身并不会关闭。</p><h3 id="4-一个完整的案例"><a href="#4-一个完整的案例" class="headerlink" title="4. 一个完整的案例"></a>4. 一个完整的案例</h3><p>客户端程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketChannelClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        client();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">client</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        SocketChannel socketChannel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            socketChannel = SocketChannel.open();</span><br><span class="line">            socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>,<span class="number">8080</span>));</span><br><span class="line">            <span class="keyword">if</span>(socketChannel.finishConnect()) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    String info = <span class="string">"I'm "</span> + i++ + <span class="string">"-th information from client"</span>;</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                    buffer.put(info.getBytes());</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                        System.out.println(buffer);</span><br><span class="line">                        socketChannel.write(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException | InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(socketChannel!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    socketChannel.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>服务器端程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOSocketServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUF_SIZE=<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">8080</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIMEOUT = <span class="number">3000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        selector();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Selector selector = <span class="keyword">null</span>;</span><br><span class="line">        ServerSocketChannel ssc = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            ssc= ServerSocketChannel.open();</span><br><span class="line">            ssc.socket().bind(<span class="keyword">new</span> InetSocketAddress(PORT));</span><br><span class="line">            ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(selector.select(TIMEOUT) == <span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"=="</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">                    SelectionKey key = iter.next();</span><br><span class="line">                    <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                        handleAccept(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                        handleRead(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(key.isWritable() &amp;&amp; key.isValid())&#123;</span><br><span class="line">                        handleWrite(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(key.isConnectable())&#123;</span><br><span class="line">                        System.out.println(<span class="string">"isConnectable = true"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    iter.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(selector!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    selector.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ssc!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    ssc.close();<span class="comment">//关闭ServerSocketChannel</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleAccept</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel ssChannel = (ServerSocketChannel)key.channel();</span><br><span class="line">        SocketChannel sc = ssChannel.accept();</span><br><span class="line">        sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        sc.register(key.selector(), SelectionKey.OP_READ, ByteBuffer.allocateDirect(BUF_SIZE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleRead</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        SocketChannel sc = (SocketChannel)key.channel();</span><br><span class="line">        ByteBuffer buf = (ByteBuffer)key.attachment();</span><br><span class="line">        <span class="keyword">long</span> bytesRead = sc.read(buf);</span><br><span class="line">        <span class="keyword">while</span>(bytesRead&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            buf.flip();</span><br><span class="line">            <span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>)buf.get());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            buf.clear();</span><br><span class="line">            bytesRead = sc.read(buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(bytesRead == -<span class="number">1</span>)&#123;</span><br><span class="line">            sc.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleWrite</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        ByteBuffer buf = (ByteBuffer)key.attachment();</span><br><span class="line">        buf.flip();</span><br><span class="line">        SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">        <span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">            sc.write(buf);</span><br><span class="line">        &#125;</span><br><span class="line">        buf.compact();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Buffer&quot;&gt;&lt;a href=&quot;#1-Buffer&quot; class=&quot;headerlink&quot; title=&quot;1. Buffer&quot;&gt;&lt;/a&gt;1. Buffer&lt;/h3&gt;&lt;p&gt;在channel中传输的是buffer中的数据，而不是buffer对象。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="nio" scheme="http://yoursite.com/child/tags/nio/"/>
    
  </entry>
  
  <entry>
    <title>nio-I/O模型</title>
    <link href="http://yoursite.com/child/2019/05/20/nio-IO%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/child/2019/05/20/nio-IO模型/</id>
    <published>2019-05-19T16:00:00.000Z</published>
    <updated>2019-07-14T13:34:22.634Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇我们讲到了关于TCP/IP协议的一些内容，这些是网络编程的必备知识。在了解NIO之前我们必须要了解一下对应的系统层IO模型，比如java的NIO对应是那种IO模型，阻塞和同步的差异在哪里，又是否相同。了解了这些更方便我们的后续的NIO探解。</p><h3 id="1-同步-异步、阻塞-非阻塞"><a href="#1-同步-异步、阻塞-非阻塞" class="headerlink" title="1. 同步/异步、阻塞/非阻塞"></a>1. 同步/异步、阻塞/非阻塞</h3><p>同步、异步，阻塞、非阻塞，这四种状态常有人分不清，主要是这四种状态的定义本身也不是很明确，所以各种解答的方式都有。常见的分类有以下:</p><ul><li>同步阻塞IO</li><li>同步非阻塞IO</li><li>异步非阻塞IO   </li></ul><p>阻塞是指执行I/O操作的线程，在I/O操作过程中能不能处理其他任务。同步指I/O操作过程中的消息通知机制。</p><p>同步：是否同步体现在消息通信机制上。</p><h4 id="1-1-如何分类"><a href="#1-1-如何分类" class="headerlink" title="1.1 如何分类"></a>1.1 如何分类</h4><p>针对某种IO模型，我们如何分类，可以基于POSIX对同步/异步的定义来判别：同步的I/O操作会导致请求进程阻塞，直到I/O操作完成；而异步的I/O操做则不会引起请求进程阻塞。</p><p>如果说以上的定义依然无法判别，我们可以从输入操作的两个阶段来看：</p><p>一般来说，一个输入操作通常包括两个不同阶段：</p><blockquote><p>（1）等待数据准备好；</p><p>（2）从内核向进程复制数据。</p></blockquote><p>是否同步的判断依据是：针对整个过程，也就是2个阶段，是否有阻塞。</p><p>是否阻塞的判断依据是：按程序（线程）等待消息通知时的状态角度来说的，也就是主要是针对第一阶段来说。</p><h4 id="1-2-举例说明"><a href="#1-2-举例说明" class="headerlink" title="1.2 举例说明"></a>1.2 举例说明</h4><p>我们举例来说：比如说做饭这件事，一般要分为连个步骤。</p><p>1、买菜，准备食材</p><p>2、炒菜，做出饭菜 </p><p><strong>方案一：自己动手。</strong></p><blockquote><p>1、去超市买菜，准备食材（阻塞，当前时段只能做一件事，且需要持续的等待）</p><p>2、回家切菜，炒菜，做饭菜（阻塞，还是自己来处理）</p></blockquote><p> 方案一同步阻塞。首先阶段一是阻塞的，所以认定为阻塞；两个阶段都是阻塞的，认定为同步的。</p><p><strong>方案二：网购食材，自己做饭</strong></p><blockquote><p>1、网上下单，配送食材。（非阻塞的，这期间你可以干其他事）</p><p>2、拿到菜，切菜、炒菜，做饭菜（阻塞）</p></blockquote><p>方案二为同步非阻塞。阶段一为非阻塞，认定为非阻塞。阶段二为阻塞，两阶段中有一个为阻塞，认定为同步。</p><p><strong>方案三：网购食材，请人做饭</strong></p><blockquote><p>1、网上下单，配送食材。（非阻塞的，这期间你可以干其他事）</p><p>2、请小时工，帮忙做这一餐，做好通知我。（非阻塞，期间可以干其他事）</p></blockquote><p>方案三为异步非阻塞。阶段一为非阻塞，认定为非阻塞。阶段二非阻塞，则两阶段中都没有阻塞，认定为异步。</p><p>那么是否有异步阻塞IO模型，没有，要记得异步状态是包含二个阶段的，如果有阻塞的过程，为何还叫异步？</p><h3 id="2-Unix-5种I-O模型"><a href="#2-Unix-5种I-O模型" class="headerlink" title="2. Unix 5种I/O模型"></a>2. Unix 5种I/O模型</h3><p>在<a href="https://link.zhihu.com/?target=http%3A//book.douban.com/subject/1500149/" target="_blank" rel="noopener">《UNIX网络编程：卷一》</a>的第六章书中列出了五种IO模型：</p><ul><li>阻塞式I/O</li><li>非阻塞式I/O</li><li>I/O复用（select，poll，epoll…）</li><li>信号驱动式I/O（SIGIO）</li><li>异步I/O（POSIX的aio_系列函数）</li></ul><h4 id="2-1-阻塞式I-O"><a href="#2-1-阻塞式I-O" class="headerlink" title="2.1 阻塞式I/O"></a>2.1 阻塞式I/O</h4><p>同步阻塞 IO 模型是最常用的一个模型，也是最简单的模型。在linux中，<code>默认情况下所有的socket都是blocking</code>。它符合人们最常见的思考逻辑。</p><p>在这个IO模型中，用户空间的应用程序执行一个系统调用（recvform），这会导致应用程序阻塞，什么也不干，直到数据准备好，等待kernel准备好从网络上接收到的数据报 + 等待收到的报文被从kernel复制到buf中，recvfrom方法才会返回，最后进程再处理数据。</p><p>这就是阻塞式IO模型</p><p><img src="http://wx1.sinaimg.cn/large/87c9e458ly1g48qy5z7m7j20ww0hygqd.jpg" alt="阻塞式I/O"></p><h4 id="2-2-非阻塞式I-O"><a href="#2-2-非阻塞式I-O" class="headerlink" title="2.2 非阻塞式I/O"></a>2.2 非阻塞式I/O</h4><p>非阻塞IO时对一个非阻塞描述符循环调用recvfrom，持续的轮询（polling）,以查看某个操作是否就绪。与阻塞IO不一样，”非阻塞将大的整片时间的阻塞分成N多的小的阻塞, 所以进程不断地有机会 ‘被’ CPU光顾”。</p><p>非阻塞的recvform系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error。进程在返回之后，可以干点别的事情，然后再发起recvform系统调用。如此循环的进行recvform系统调用，检查内核数据，直到数据准备好，再拷贝数据到进程。<strong>拷贝数据整个过程，进程仍然是属于阻塞的状态</strong>。</p><p>这就是非阻塞式IO模型</p><p><img src="http://wx4.sinaimg.cn/large/87c9e458ly1g48r29sz64j20wg0hqtfg.jpg" alt="非阻塞式    i/o"></p><h4 id="2-3-I-O复用"><a href="#2-3-I-O复用" class="headerlink" title="2.3 I/O复用"></a>2.3 I/O复用</h4><p>IO multiplexing就是我们说的select，poll，epoll 。为何叫多路复用，是因为它I/O多路复用可以同时监听多个fd，如此就减少了为每个需要监听的fd开启线程的开销。</p><p>select调用是内核级别的，可以等待多个socket，能实现同时对多个IO端口进行监听<code>，当其中任何一个socket的数据准好了，</code>就能返回进行可读<code>，</code>然后进程再进行recvform系统调用，将数据由内核拷贝到用户进程，这个过程是阻塞的。</p><p>I/O复用模型会用到select、poll、epoll函数，这几个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这几个函数可以同时阻塞多个I/O操作`。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时（不是等到socket数据全部到达再处理, 而是有了一部分数据就会调用用户进程来处理），才真正调用I/O操作函数。</p><p>IO复用有人把其成为同步非阻塞的，也有称为同步阻塞。其实这个是否阻塞还需要看第一个阶段，第一个阶段有的阻塞，有的不阻塞。主要也是阻塞在select阶段，属于用户主动等待阶段，我们且规范为阻塞状态，所以，<code>把IO多路复用归为同步阻塞模式</code>。</p><p>这是IO复用的模型:</p><p><img src="http://wx1.sinaimg.cn/large/87c9e458ly1g48r4580pyj20vc0gc0z0.jpg" alt></p><p>select、poll、epoll的不同</p><p><img src="http://wx3.sinaimg.cn/large/87c9e458ly1g48r54j7btj20wi0giace.jpg" alt="img"></p><h4 id="2-4-信号驱动式I-O"><a href="#2-4-信号驱动式I-O" class="headerlink" title="2.4 信号驱动式I/O"></a>2.4 信号驱动式I/O</h4><p>信号驱动式I/O：首先我们允许Socket进行信号驱动IO,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。</p><p>也就是说第一个阶段，完全是非阻塞的，等数据到达会给一个信号通知，第二个阶段recvfrom还是阻塞过程，和之上无差异。</p><p>信号驱动式I/O 过程如下:</p><p><img src="http://wx2.sinaimg.cn/large/87c9e458ly1g48r5ivr4qj20x40l2wj2.jpg" alt></p><h4 id="2-5-异步I-O"><a href="#2-5-异步I-O" class="headerlink" title="2.5 异步I/O"></a>2.5 异步I/O</h4><p>异步IO不是顺序执行,用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到socket数据准备好了，内核直接复制数据给进程，<code>然后从内核向进程发送通知</code>。<code>IO两个阶段，进程都是非阻塞的</code>。</p><p><img src="http://wx1.sinaimg.cn/large/87c9e458ly1g48r6uzcajj20wo0kkn1r.jpg" alt></p><h4 id="2-6-总结"><a href="#2-6-总结" class="headerlink" title="2.6 总结"></a>2.6 总结</h4><p>针对这5中IO模型，我采用一张图来总结一下。</p><p><img src="http://wx1.sinaimg.cn/large/87c9e458ly1g48r6zq1p4j20zg0mq49j.jpg" alt></p><h3 id="3-java-IO"><a href="#3-java-IO" class="headerlink" title="3. java IO"></a>3. java IO</h3><p>Unix中的五种I/O模型，除信号驱动I/O外，Java对其它四种I/O模型都有所支持。其中Java最早提供的blocking I/O即是同步阻塞I/O，而NIO即是同步非阻塞I/O，同时通过NIO实现的Reactor模式即是I/O复用模型的实现，通过AIO实现的Proactor模式即是异步I/O模型的实现。</p><p>所以说严格意义上来说，通过Reactor模式实现的NIO，和unix中的I/O多路复用是相同的概念，但这是一种编程模型，而不是原生支持。这也是我们下面所要进行的netty讲解的主要思想。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇我们讲到了关于TCP/IP协议的一些内容，这些是网络编程的必备知识。在了解NIO之前我们必须要了解一下对应的系统层IO模型，比如java的NIO对应是那种IO模型，阻塞和同步的差异在哪里，又是否相同。了解了这些更方便我们的后续的NIO探解。&lt;/p&gt;
&lt;h3 id=&quot;1
      
    
    </summary>
    
    
      <category term="nio" scheme="http://yoursite.com/child/tags/nio/"/>
    
  </entry>
  
  <entry>
    <title>源码分析-会用HashMap</title>
    <link href="http://yoursite.com/child/2018/07/21/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BC%9A%E7%94%A8HashMap/"/>
    <id>http://yoursite.com/child/2018/07/21/源码分析-会用HashMap/</id>
    <published>2018-07-21T12:41:36.000Z</published>
    <updated>2019-05-23T02:57:29.493Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一个问题引发的思考"><a href="#一个问题引发的思考" class="headerlink" title="一个问题引发的思考"></a>一个问题引发的思考</h3><p>如果确定只装载100个元素，new HashMap(?)多少是最佳的，why？<br>要弄解答这个问题，第一要知道HashMap的数据结构，第二再弄明白存取数据的逻辑。</p><h3 id="1-首先，我是一个数组"><a href="#1-首先，我是一个数组" class="headerlink" title="1.首先，我是一个数组"></a>1.首先，我是一个数组</h3><p>HashMap本质上是一个数组，数组的每个元素是一个单链表或者红黑树，由0个或多个节点组成。<br>java源码中的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><h4 id="1-1节点类Node-lt-K-V-gt"><a href="#1-1节点类Node-lt-K-V-gt" class="headerlink" title="1.1节点类Node&lt;K,V&gt;"></a>1.1节点类Node&lt;K,V&gt;</h4><p>Node类是HashMap的一个静态内部类，可以将其看成是一个独立的类，只是声明在HashMap类内部而已。下面是源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;//Entry是Map接口中的一个内部接口</span><br><span class="line">    final int hash;//此节点的哈希值，同一个链表上的哈希值不一定相同</span><br><span class="line">    final K key;//键，不能修改</span><br><span class="line">    V value;//值</span><br><span class="line">    Node&lt;K,V&gt; next;//指向下一个节点</span><br><span class="line"> </span><br><span class="line">    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        this.hash = hash;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public final K getKey()        &#123; return key; &#125;</span><br><span class="line">    public final V getValue()      &#123; return value; &#125;</span><br><span class="line">    public final String toString() &#123; return key + &quot;=&quot; + value; &#125;</span><br><span class="line"> </span><br><span class="line">    public final int hashCode() &#123;//此Node类的hashCode方法</span><br><span class="line">        return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public final V setValue(V newValue) &#123;//重新设置节点Value，返回旧Value</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public final boolean equals(Object o) &#123;//判断节点相等的方法，</span><br><span class="line">        if (o == this)//同一个对象，返回true</span><br><span class="line">            return true;</span><br><span class="line">        if (o instanceof Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                return true;//键和值都相等则返回true</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2为啥有链表还有树"><a href="#1-2为啥有链表还有树" class="headerlink" title="1.2为啥有链表还有树"></a>1.2为啥有链表还有树</h4><p>为了提高查询效率，当链表的长度达到阈值的时候会自动将链表树形化，源码中的三个阈值常量如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static final int TREEIFY_THRESHOLD = 8;</span><br><span class="line">static final int UNTREEIFY_THRESHOLD = 6;</span><br><span class="line">static final int MIN_TREEIFY_CAPACITY = 64;</span><br></pre></td></tr></table></figure><ul><li>TREEIFY_THRESHOLD 树形化阈值：当链表长度超过这个值的时候，将链表进行树形化改造</li><li>UNTREEIFY_THRESHOLD 链表化阈值：当节点数低于这个阈值，将红黑树改造成链表。这个值必须必树形化阈值小，避免频繁的转换。</li><li>MIN_TREEIFY_CAPACITY 最小树形化容量：当数组table的长度低于这个值，即使元素链表的长度超过树形化阈值，也不会进行树形化改造，而是对table进行扩容。这个值不能小于4*TREEIFY_THRESHOLD  <h3 id="2-怎么进行数据的存取呢"><a href="#2-怎么进行数据的存取呢" class="headerlink" title="2.怎么进行数据的存取呢"></a>2.怎么进行数据的存取呢</h3><h4 id="2-1hash方法"><a href="#2-1hash方法" class="headerlink" title="2.1hash方法"></a>2.1hash方法</h4>拿到一个&lt;Key,Value&gt;，要存在table的哪个位置呢，这就需要用hash方法来决定了。。。<br>从代码说起：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>key.hashCode()函数调用的是key键值类型自带的哈希函数（与HashMap的hashCode()函数不是同一个），它返回一个32位int类型的散列值。</li><li>考虑到hash值得取值范围太大，不可能创建一个如此大的hash table，因此定位到table的位置只使用hash值的后几位（具体位数与table长度有关）。</li><li>如果只取后几位，碰撞会比较严重，因此就有了扰动函数，将hash值右移16位（高16位移到低16位），再与自身亦或，得到的结果混合了原hash值得高位和低位，以此来加大低位的随机性。</li></ul><h4 id="2-2定位"><a href="#2-2定位" class="headerlink" title="2.2定位"></a>2.2定位</h4><p>最终得到的hash值，将由低位进行定位，定位操作如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n = tab.length</span><br><span class="line">tab[(n - 1) &amp; hash]</span><br></pre></td></tr></table></figure></p><ul><li>数组长度必为2的整数次幂，因此(n-1)相当于低位掩码，与h进行与操作，保留h低位，掩盖高位。</li><li>这里不做取余，是因为取余可能为负数（hashCode为负数的时候）</li><li>不对取余进行模运算，是因为最大的整数Math.abs()会返回负值</li><li>由此可知，对于HashMap的同一个链表的各个节点key值得hash值不一定相同（只是低位相同）</li></ul><h4 id="2-3扩容-resize"><a href="#2-3扩容-resize" class="headerlink" title="2.3扩容(resize)"></a>2.3扩容(resize)</h4><h5 id="默认容量是16"><a href="#默认容量是16" class="headerlink" title="默认容量是16"></a>默认容量是16</h5><p>16是2的整数次幂的原因，在小数据量的情况下16比15或20更能减少key之间的碰撞，而加快查询的效率。 </p><h5 id="容量是15会怎样？"><a href="#容量是15会怎样？" class="headerlink" title="容量是15会怎样？"></a>容量是15会怎样？</h5><p>当数组长度为15的时候，hashcode的值会与14（1110）进行“与”，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率（hash不均匀），降低了查询的效率！<br>所以，在存储大容量数据的时候，最好预先指定hashmap的size为2的整数次幂次方。就算不指定的话，也会以大于且最接近指定值大小的2次幂来初始化的，代码如下(HashMap的构造方法中)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int capacity = 1;  </span><br><span class="line">while (capacity &lt; initialCapacity)   </span><br><span class="line">    capacity &lt;&lt;= 1;  //乘以2</span><br></pre></td></tr></table></figure></p><h5 id="什么时候扩容-amp-怎么扩容"><a href="#什么时候扩容-amp-怎么扩容" class="headerlink" title="什么时候扩容&amp;怎么扩容"></a>什么时候扩容&amp;怎么扩容</h5><p>当hashmap中的元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对hashmap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，所以这是一个通用的操作，很多人对它的性能表示过怀疑，不过想想我们的“均摊”原理，就释然了，而在hashmap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。<br>那么hashmap什么时候进行扩容呢？当hashmap中的元素个数超过数组大小length x loadFactor时，就会进行数组扩容，==<strong>loadFactor的默认值为0.75</strong>==，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过16x0.75=12的时候，就把数组的大小扩展为2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以++如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能++。  </p><h5 id="回到开篇的问题"><a href="#回到开篇的问题" class="headerlink" title="回到开篇的问题"></a>回到开篇的问题</h5><p>当有100个元素new HashMap(100), 但是理论上来讲new HashMap(128)更合适，不过上面已经说过，即使是100，hashmap也自动会将其设置为128。 但是new HashMap(128)还不是更合适的，因为0.75x100 &lt; 100, 也就是说为了让0.75 x size &gt; 100, 我们必须这样new HashMap(256)才最合适，既考虑了&amp;的问题，也避免了resize的问题。 </p><h3 id="3-可以使用自定义的类作为key的类型吗"><a href="#3-可以使用自定义的类作为key的类型吗" class="headerlink" title="3.可以使用自定义的类作为key的类型吗"></a>3.可以使用自定义的类作为key的类型吗</h3><p>可以，但是必须改写key类型的hashcode与equals方法<br>首先计算key的hashcode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。所以，hashcode与equals方法对于找到对应元素是两个关键方法。<br>Hashmap的key可以是任何类型的对象，例如User这种对象，为了保证两个具有相同属性的user的hashcode相同，我们就需要改写hashcode方法，比方把hashcode值的计算与User对象的id关联起来，那么只要user对象拥有相同id，那么他们的hashcode也能保持一致了，这样就可以找到在hashmap数组中的位置了。如果这个位置上有多个元素，还需要用key的equals方法在对应位置的链表中找到需要的元素，所以只改写了hashcode方法是不够的，equals方法也是需要改写滴~当然啦，按正常思维逻辑，equals方法一般都会根据实际的业务内容来定义，例如根据user对象的id来判断两个user是否相等。  </p><hr><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://www.iteye.com/topic/539465" target="_blank" rel="noopener">深入理解HashMap</a><br><a href="https://blog.csdn.net/u010292561/article/details/80472555" target="_blank" rel="noopener">HashMap详解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一个问题引发的思考&quot;&gt;&lt;a href=&quot;#一个问题引发的思考&quot; class=&quot;headerlink&quot; title=&quot;一个问题引发的思考&quot;&gt;&lt;/a&gt;一个问题引发的思考&lt;/h3&gt;&lt;p&gt;如果确定只装载100个元素，new HashMap(?)多少是最佳的，why？&lt;br
      
    
    </summary>
    
    
      <category term="源码分析" scheme="http://yoursite.com/child/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-并发容器CopyOnWriteArrayList</title>
    <link href="http://yoursite.com/child/2018/05/26/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-CopyOnWrite%E5%AE%B9%E5%99%A8/"/>
    <id>http://yoursite.com/child/2018/05/26/并发编程-CopyOnWrite容器/</id>
    <published>2018-05-26T04:32:12.000Z</published>
    <updated>2019-05-28T14:59:58.865Z</updated>
    
    <content type="html"><![CDATA[<p>Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。</p><h3 id="1-什么是CopyOnWrite容器"><a href="#1-什么是CopyOnWrite容器" class="headerlink" title="1. 什么是CopyOnWrite容器"></a>1. 什么是CopyOnWrite容器</h3><p>CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p><h3 id="2-CopyOnWriteArrayList的实现原理"><a href="#2-CopyOnWriteArrayList的实现原理" class="headerlink" title="2. CopyOnWriteArrayList的实现原理"></a>2. CopyOnWriteArrayList的实现原理</h3><p>在使用CopyOnWriteArrayList之前，我们先阅读其源码了解下它是如何实现的。以下代码是向CopyOnWriteArrayList中add方法的实现（向CopyOnWriteArrayList里添加元素），可以发现在添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        int len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + 1);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读的时候不需要加锁，如果读的时候有多个线程正在向CopyOnWriteArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的CopyOnWriteArrayList。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    return get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK中并没有提供CopyOnWriteMap，我们可以参考CopyOnWriteArrayList来实现一个，基本代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Set;</span><br><span class="line"> </span><br><span class="line">public class CopyOnWriteMap&lt;K, V&gt; implements Map&lt;K, V&gt;, Cloneable &#123;</span><br><span class="line">    private volatile Map&lt;K, V&gt; internalMap;</span><br><span class="line"> </span><br><span class="line">    public CopyOnWriteMap() &#123;</span><br><span class="line">        internalMap = new HashMap&lt;K, V&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public V put(K key, V value) &#123;</span><br><span class="line"> </span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            Map&lt;K, V&gt; newMap = new HashMap&lt;K, V&gt;(internalMap);</span><br><span class="line">            V val = newMap.put(key, value);</span><br><span class="line">            internalMap = newMap;</span><br><span class="line">            return val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public V get(Object key) &#123;</span><br><span class="line">        return internalMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void putAll(Map&lt;? extends K, ? extends V&gt; newData) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            Map&lt;K, V&gt; newMap = new HashMap&lt;K, V&gt;(internalMap);</span><br><span class="line">            newMap.putAll(newData);</span><br><span class="line">            internalMap = newMap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现很简单，只要了解了CopyOnWrite机制，我们可以实现各种CopyOnWrite容器，并且在不同的应用场景中使用。</p><h3 id="3-CopyOnWrite的应用场景"><a href="#3-CopyOnWrite的应用场景" class="headerlink" title="3. CopyOnWrite的应用场景"></a>3. CopyOnWrite的应用场景</h3><p>CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Map;</span><br><span class="line"> </span><br><span class="line">import com.ifeve.book.forkjoin.CopyOnWriteMap;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 黑名单服务</span><br><span class="line"> *</span><br><span class="line"> * @author fangtengfei</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class BlackListServiceImpl &#123;</span><br><span class="line"> </span><br><span class="line">    private static CopyOnWriteMap&lt;String, Boolean&gt; blackListMap = new CopyOnWriteMap&lt;String, Boolean&gt;(</span><br><span class="line">            1000);</span><br><span class="line"> </span><br><span class="line">    public static boolean isBlackList(String id) &#123;</span><br><span class="line">        return blackListMap.get(id) == null ? false : true;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void addBlackList(String id) &#123;</span><br><span class="line">        blackListMap.put(id, Boolean.TRUE);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 批量添加黑名单</span><br><span class="line">     *</span><br><span class="line">     * @param ids</span><br><span class="line">     */</span><br><span class="line">    public static void addBlackList(Map&lt;String,Boolean&gt; ids) &#123;</span><br><span class="line">        blackListMap.putAll(ids);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，但是使用CopyOnWriteMap需要注意两件事情：</p><ol><li>减少扩容开销。根据实际需要，初始化CopyOnWriteMap的大小，避免写时CopyOnWriteMap扩容的开销。</li><li>使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。如使用上面代码里的addBlackList方法。  </li></ol><h3 id="4-CopyOnWrite的缺点"><a href="#4-CopyOnWrite的缺点" class="headerlink" title="4. CopyOnWrite的缺点"></a>4. CopyOnWrite的缺点</h3><p>CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。</p><ul><li>内存占用问题。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。</li></ul><p>针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。</p><ul><li>数据一致性问题。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</li></ul><h3 id="5-相关文章"><a href="#5-相关文章" class="headerlink" title="5. 相关文章"></a>5. 相关文章</h3><p><a href="http://blog.csdn.net/wind5shy/article/details/5396887" target="_blank" rel="noopener">CopyOnWriteArrayList和同步容器的性能验证</a></p><p><a href="http://blog.csdn.net/imzoer/article/details/9751591" target="_blank" rel="noopener">CopyOnWriteArrayList使用简介</a></p><p>　　</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用Co
      
    
    </summary>
    
    
      <category term="并发编程" scheme="http://yoursite.com/child/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-ConcurrentHashMap源码分析</title>
    <link href="http://yoursite.com/child/2018/05/25/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/child/2018/05/25/并发编程-ConcurrentHashMap源码分析/</id>
    <published>2018-05-25T04:35:45.000Z</published>
    <updated>2019-06-12T09:32:31.636Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-重要的属性"><a href="#1-重要的属性" class="headerlink" title="1.重要的属性"></a>1.重要的属性</h3><p>首先来看几个重要的属性，与HashMap相同的就不再介绍了，这里重点解释一下sizeCtl这个属性。可以说它是ConcurrentHashMap中出镜率很高的一个属性，因为它是一个控制标识符，在不同的地方有不同用途，而且它的取值不同，也代表不同的含义。</p><ul><li>负数代表正在进行初始化或扩容操作</li><li>-1代表正在初始化</li><li>-N 表示有N-1个线程正在进行扩容操作</li><li>正数或0代表hash表还没有被初始化，这个数值表示初始化或下一次进行扩容的大小，这一点类似于扩容阈值的概念。还后面可以看到，它的值始终是当前ConcurrentHashMap容量的0.75倍，这与loadfactor是对应的。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//盛装Node元素的数组,它的大小是2的整数次幂</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> hash表初始化或扩容时的一个控制位标识量。</span></span><br><span class="line"><span class="comment"> 负数代表正在进行初始化或扩容操作</span></span><br><span class="line"><span class="comment"> -1代表正在初始化</span></span><br><span class="line"><span class="comment"> -N 表示有N-1个线程正在进行扩容操作</span></span><br><span class="line"><span class="comment"> 正数或0代表hash表还没有被初始化，这个数值表示初始化或下一次进行扩容的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下两个是用来控制扩容的时候 单线程进入的变量</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of bits used for generation stamp in sizeCtl.</span></span><br><span class="line"><span class="comment"> * Must be at least 6 for 32bit arrays.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bit shift for recording size stamp in sizeCtl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span>- RESIZE_STAMP_BITS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>;<span class="comment">// hash值是-1，表示这是一个forwardNode节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>;<span class="comment">// hash值是-2  表示这时一个TreeBin节点</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-重要的类"><a href="#2-重要的类" class="headerlink" title="2.重要的类"></a>2.重要的类</h3><h4 id="2-1-Node"><a href="#2-1-Node" class="headerlink" title="2.1 Node"></a>2.1 Node</h4><p>Node是最核心的内部类，它包装了key-value键值对，所有插入ConcurrentHashMap的数据都包装在这里面。它与HashMap中的定义很相似，但是但是有一些差别它对value和next属性设置了volatile同步锁(与JDK7的Segment相同)，它不允许调用setValue方法直接改变Node的value域，它增加了find方法辅助map.get()方法。</p><h4 id="2-2-TreeNode"><a href="#2-2-TreeNode" class="headerlink" title="2.2 TreeNode"></a>2.2 TreeNode</h4><p>树节点类，另外一个核心的数据结构。当链表长度过长的时候，会转换为TreeNode。但是与HashMap不相同的是，它并不是直接转换为红黑树，而是把这些结点包装成TreeNode放在TreeBin对象中，由TreeBin完成对红黑树的包装。而且TreeNode在ConcurrentHashMap集成自Node类，而并非HashMap中的集成自LinkedHashMap.Entry&lt;K,V&gt;类，也就是说TreeNode带有next指针，这样做的目的是方便基于TreeBin的访问。</p><h4 id="2-3-TreeBin"><a href="#2-3-TreeBin" class="headerlink" title="2.3 TreeBin"></a>2.3 TreeBin</h4><p>这个类并不负责包装用户的key、value信息，而是包装的很多TreeNode节点。它代替了TreeNode的根节点，也就是说在实际的ConcurrentHashMap“数组”中，存放的是TreeBin对象，而不是TreeNode对象，这是与HashMap的区别。另外这个类还带有了读写锁。</p><p>这里仅贴出它的构造方法。可以看到在构造TreeBin节点时，仅仅指定了它的hash值为TREEBIN常量，这也就是个标识为。同时也看到我们熟悉的红黑树构造方法</p><h4 id="2-4-ForwardingNode"><a href="#2-4-ForwardingNode" class="headerlink" title="2.4 ForwardingNode"></a>2.4 ForwardingNode</h4><p>一个用于连接两个table的节点类。它包含一个nextTable指针，用于指向下一张表。而且这个节点的key value next指针全部为null，它的hash值为-1. 这里面定义的find的方法是从nextTable里进行查询节点，而不是以自身为头节点进行查找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A node inserted at head of bins during transfer operations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        <span class="keyword">super</span>(MOVED,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(inth, Object k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// loop to avoid arbitrarily deep recursion on forwarding nodes</span></span><br><span class="line">        outer:<span class="keyword">for</span>(Node&lt;K,V&gt;[] tab = nextTable;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; intn;</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="keyword">null</span>|| tab == <span class="keyword">null</span>|| (n = tab.length) == <span class="number">0</span>||</span><br><span class="line">                (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) == <span class="keyword">null</span>)</span><br><span class="line">                returnnull;</span><br><span class="line">            <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">                inteh; K ek;</span><br><span class="line">                <span class="keyword">if</span>((eh = e.hash) == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == k || (ek != <span class="keyword">null</span>&amp;&amp; k.equals(ek))))</span><br><span class="line">                    returne;</span><br><span class="line">                <span class="keyword">if</span>(eh &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(einstanceofForwardingNode) &#123;</span><br><span class="line">                        tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;</span><br><span class="line">                        continueouter;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        returne.find(h, k);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>((e = e.next) == <span class="keyword">null</span>)</span><br><span class="line">                    returnnull;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Unsafe与CAS"><a href="#3-Unsafe与CAS" class="headerlink" title="3.Unsafe与CAS"></a>3.Unsafe与CAS</h3><p>在ConcurrentHashMap中，随处可以看到U, 大量使用了U.compareAndSwapXXX的方法，这个方法是利用一个CAS算法实现无锁化的修改值的操作，他可以大大降低锁代理的性能消耗。这个算法的基本思想就是不断地去比较当前内存中的变量值与你指定的一个变量值是否相等，如果相等，则接受你指定的修改的值，否则拒绝你的操作。因为当前线程中的值已经不是最新的值，你的修改很可能会覆盖掉其他线程修改的结果。这一点与乐观锁，SVN的思想是比较类似的。</p><h4 id="3-1-unsafe静态块"><a href="#3-1-unsafe静态块" class="headerlink" title="3.1 unsafe静态块"></a>3.1 unsafe静态块</h4><p>unsafe代码块控制了一些属性的修改工作，比如最常用的SIZECTL 。在这一版本的concurrentHashMap中，大量应用来的CAS方法进行变量、属性的修改工作。利用CAS进行无锁操作，可以大大提高性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe U;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SIZECTL;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TRANSFERINDEX;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> BASECOUNT;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CELLSBUSY;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CELLVALUE;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ABASE;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ASHIFT;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">static</span>&#123;</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">           Class&lt;?&gt; k = ConcurrentHashMap.class;</span><br><span class="line">           SIZECTL = U.objectFieldOffset(k.getDeclaredField(<span class="string">"sizeCtl"</span>));</span><br><span class="line">           TRANSFERINDEX = U.objectFieldOffset(k.getDeclaredField(<span class="string">"transferIndex"</span>));</span><br><span class="line">           BASECOUNT = U.objectFieldOffset(k.getDeclaredField(<span class="string">"baseCount"</span>));</span><br><span class="line">           CELLSBUSY = U.objectFieldOffset(k.getDeclaredField(<span class="string">"cellsBusy"</span>));</span><br><span class="line">           Class&lt;?&gt; ck = CounterCell.class;</span><br><span class="line">           CELLVALUE = U.objectFieldOffset(ck.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">           Class&lt;?&gt; ak = Node[].class;</span><br><span class="line">           ABASE = U.arrayBaseOffset(ak);</span><br><span class="line">           intscale = U.arrayIndexScale(ak);</span><br><span class="line">           <span class="keyword">if</span>((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">               thrownewError(<span class="string">"data type scale not a power of two"</span>);</span><br><span class="line">           ASHIFT = <span class="number">31</span>- Integer.numberOfLeadingZeros(scale);</span><br><span class="line">       &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">           thrownewError(e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-三个核心方法"><a href="#3-2-三个核心方法" class="headerlink" title="3.2 三个核心方法"></a>3.2 三个核心方法</h4><p>ConcurrentHashMap定义了三个原子操作，用于对指定位置的节点进行操作。正是这些原子操作保证了ConcurrentHashMap的线程安全。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123;</span><br><span class="line">//获得在i位置上的Node节点</span><br><span class="line">    return(Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123;</span><br><span class="line">    //因此当前线程中的值并不是最新的值，这种修改可能会覆盖掉其他线程的修改结果有点类似于SVN</span><br><span class="line">    returnU.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static final &lt;K,V&gt; voidsetTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v) &#123;</span><br><span class="line">    //利用volatile方法设置节点位置的值</span><br><span class="line">    U.putObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-初始化方法initTable"><a href="#4-初始化方法initTable" class="headerlink" title="4 初始化方法initTable"></a>4 初始化方法initTable</h3><p>对于ConcurrentHashMap来说，调用它的构造方法仅仅是设置了一些参数而已。而整个table的初始化是在向ConcurrentHashMap中插入元素的时候发生的。如调用put、computeIfAbsent、compute、merge等方法的时候，调用时机是检查table==null。</p><p>初始化方法主要应用了关键属性sizeCtl 如果这个值〈0，表示其他线程正在进行初始化，就放弃这个操作。在这也可以看出ConcurrentHashMap的初始化只能由一个线程完成。如果获得了初始化权限，就用CAS方法将sizeCtl置为-1，防止其他线程进入。初始化数组后，将sizeCtl的值改为0.75*n。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; </span><br><span class="line">    int sc;</span><br><span class="line">    while((tab = table) == null|| tab.length == 0) &#123;</span><br><span class="line">        //sizeCtl表示有其他线程正在进行初始化操作，把线程挂起。对于table的初始化工作，只能有一个线程在进行。</span><br><span class="line">        if((sc = sizeCtl) &lt; 0)</span><br><span class="line">            Thread.yield();</span><br><span class="line">        else if(U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line">            //利用CAS方法把sizectl的值置为-1 表示本线程正在进行初始化</span><br><span class="line">            try&#123;</span><br><span class="line">                if((tab = table) == null|| tab.length == 0) &#123;</span><br><span class="line">                    intn = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])newNode&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; 2);//相当于0.75*n 设置一个扩容的阈值</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;finally&#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    returntab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-扩容方法-transfer"><a href="#5-扩容方法-transfer" class="headerlink" title="5 扩容方法 transfer"></a>5 扩容方法 transfer</h3><p>当ConcurrentHashMap容量不足的时候，需要对table进行扩容。这个方法的基本思想跟HashMap是很像的，但是由于它是支持并发扩容的，所以要复杂的多。原因是它支持多线程进行扩容操作，而并没有加锁。我想这样做的目的不仅仅是为了满足concurrent的要求，而是希望利用并发处理去减少扩容带来的时间影响。因为在扩容的时候，总是会涉及到从一个“数组”到另一个“数组”拷贝的操作，如果这个操作能够并发进行，那真真是极好的了。</p><p>整个扩容操作分为两个部分</p><ul><li>第一部分是构建一个nextTable,它的容量是原来的两倍，这个操作是单线程完成的。这个单线程的保证是通过RESIZE_STAMP_SHIFT这个常量经过一次运算来保证的，这个地方在后面会有提到；</li><li>第二个部分就是将原来table中的元素复制到nextTable中，这里允许多线程进行操作。  </li></ul><p>先来看一下单线程是如何完成的：<br>它的大体思想就是遍历、复制的过程。首先根据运算得到需要遍历的次数i，然后利用tabAt方法获得i位置的元素：</p><ol><li>如果这个位置为空，就在原table中的i位置放入forwardNode节点，这个也是触发并发扩容的关键点； </li><li>如果这个位置是Node节点（fh&gt;=0），如果它是一个链表的头节点，就构造一个反序链表，把他们分别放在nextTable的i和i+n的位置上</li><li>如果这个位置是TreeBin节点（fh&lt;0），也做一个反序处理，并且判断是否需要untreefi，把处理的结果分别放在nextTable的i和i+n的位置上</li><li>遍历过所有的节点以后就完成了复制工作，这时让nextTable作为新的table，并且更新sizeCtl为新容量的0.75倍 ，完成扩容。<br>再看一下多线程是如何完成的：</li></ol><p>在代码的69行有一个判断，如果遍历到的节点是forward节点，就向后继续遍历，再加上给节点上锁的机制，就完成了多线程的控制。多线程遍历节点，处理了一个节点，就把对应点的值set为forward，另一个线程看到forward，就向后遍历。这样交叉就完成了复制工作。而且还很好的解决了线程安全的问题。 这个方法的设计实在是让我膜拜。</p><h3 id="6-Put方法"><a href="#6-Put方法" class="headerlink" title="6 Put方法"></a>6 Put方法</h3><p>前面的所有的介绍其实都为这个方法做铺垫。ConcurrentHashMap最常用的就是put和get两个方法。现在来介绍put方法，这个put方法依然沿用HashMap的put方法的思想，根据hash值计算这个新插入的点在table中的位置i，如果i位置是空的，直接放进去，否则进行判断，如果i位置是树节点，按照树的方式插入新的节点，否则把i插入到链表的末尾。ConcurrentHashMap中依然沿用这个思想，有一个最重要的不同点就是ConcurrentHashMap不允许key或value为null值。另外由于涉及到多线程，put方法就要复杂一点。在多线程中可能有以下两个情况</p><ol><li>如果一个或多个线程正在对ConcurrentHashMap进行扩容操作，当前线程也要进入扩容的操作中。这个扩容的操作之所以能被检测到，是因为transfer方法中在空结点上插入forward节点，如果检测到需要插入的位置被forward节点占有，就帮助进行扩容；</li><li>如果检测到要插入的节点是非空且不是forward节点，就对这个节点加锁，这样就保证了线程安全。尽管这个有一些影响效率，但是还是会比hashTable的synchronized要好得多。  </li></ol><p>整体流程就是首先定义不允许key或value为null的情况放入  对于每一个放入的值，首先利用spread方法对key的hashcode进行一次hash计算，由此来确定这个值在table中的位置。</p><p>如果这个位置是空的，那么直接放入，而且不需要加锁操作。</p><p>如果这个位置存在结点，说明发生了hash碰撞，首先判断这个节点的类型。如果是链表节点（fh&gt;0）,则得到的结点就是hash值相同的节点组成的链表的头节点。需要依次向后遍历确定这个新加入的值所在位置。如果遇到hash值与key值都与新加入节点是一致的情况，则只需要更新value值即可。否则依次向后遍历，直到链表尾插入这个结点。如果加入这个节点以后链表长度大于8，就把这个链表转换成红黑树。如果这个节点的类型已经是树节点的话，直接调用树节点的插入方法进行插入新的值。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">publicV put(K key, V value) &#123;</span><br><span class="line">    return putVal(key, value, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** Implementation for put and putIfAbsent */</span><br><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    if(key == null|| value == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    //计算hash值</span><br><span class="line">    int hash = spread(key.hashCode());</span><br><span class="line">    int binCount = 0;</span><br><span class="line">    //死循环 何时插入成功 何时跳出</span><br><span class="line">    for(Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; </span><br><span class="line">        int n, i, fh;</span><br><span class="line">        //如果table为空的话，初始化table</span><br><span class="line">        if(tab == null|| (n = tab.length) == 0)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        //根据hash值计算出在table里面的位置</span><br><span class="line">        else if((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</span><br><span class="line">            //如果这个位置没有值 ，直接放进去，不需要加锁</span><br><span class="line">            if(casTabAt(tab, i, null,new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">                break;  // no lock when adding to empty bin</span><br><span class="line">        &#125;</span><br><span class="line">        //当遇到表连接点时，需要进行整合表的操作</span><br><span class="line">        else if((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        else&#123;</span><br><span class="line">            V oldVal = null;</span><br><span class="line">            //结点上锁  这里的结点可以理解为hash值相同组成的链表的头结点</span><br><span class="line">            synchronized(f) &#123;</span><br><span class="line">                if(tabAt(tab, i) == f) &#123;</span><br><span class="line">                    //fh〉0 说明这个节点是一个链表的节点 不是树的节点</span><br><span class="line">                    if(fh &gt;= 0) &#123;</span><br><span class="line">                        binCount = 1;</span><br><span class="line">                        //在这里遍历链表所有的结点</span><br><span class="line">                        for(Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            //如果hash值和key值相同  则修改对应结点的value值</span><br><span class="line">                            if(e.hash == hash &amp;&amp;((ek = e.key) == key ||(ek != null&amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                if(!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            //如果遍历到了最后一个结点，那么就证明新的节点需要插入 就把它插入在链表尾部</span><br><span class="line">                            if((e = e.next) == null) &#123;</span><br><span class="line">                                pred.next = newNode&lt;K,V&gt;(hash, key,value,null);</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //如果这个节点是树节点，就按照树的方式插入值</span><br><span class="line">                    else if(f instanceof TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = 2;</span><br><span class="line">                        if((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,value)) != null) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            if(!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(binCount != 0) &#123;</span><br><span class="line">                //如果链表长度已经达到临界值8 就需要把链表转换为树结构</span><br><span class="line">                if(binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                if(oldVal != null)</span><br><span class="line">                    return oldVal;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //将当前ConcurrentHashMap的元素数量+1</span><br><span class="line">    addCount(1L, binCount);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以发现JDK8中的实现也是锁分离的思想，只是锁住的是一个Node，而不是JDK7中的Segment，而锁住Node之前的操作是无锁的并且也是线程安全的，建立在之前提到的3个原子操作上。</p><h4 id="6-1-helpTransfer方法"><a href="#6-1-helpTransfer方法" class="headerlink" title="6.1 helpTransfer方法"></a>6.1 helpTransfer方法</h4><p>这是一个协助扩容的方法。这个方法被调用的时候，当前ConcurrentHashMap一定已经有了nextTable对象，首先拿到这个nextTable对象，调用transfer方法。回看上面的transfer方法可以看到，当本线程进入扩容方法的时候会直接进入复制阶段。</p><h4 id="6-2-treeifyBin方法"><a href="#6-2-treeifyBin方法" class="headerlink" title="6.2 treeifyBin方法"></a>6.2 treeifyBin方法</h4><p>这个方法用于将过长的链表转换为TreeBin对象。但是他并不是直接转换，而是进行一次容量判断，如果容量没有达到转换的要求，直接进行扩容操作并返回；如果满足条件才链表的结构抓换为TreeBin ，这与HashMap不同的是，它并没有把TreeNode直接放入红黑树，而是利用了TreeBin这个小容器来封装所有的TreeNode.</p><h3 id="7-get方法"><a href="#7-get方法" class="headerlink" title="7 get方法"></a>7 get方法</h3><p>get方法比较简单，给定一个key来确定value的时候，必须满足两个条件  key相同  hash值相同，对于节点可能在链表或树上的情况，需要分别去查找。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; </span><br><span class="line">    Node&lt;K,V&gt; e, p; </span><br><span class="line">    int n, eh; </span><br><span class="line">    K ek;</span><br><span class="line">    //计算hash值</span><br><span class="line">    int h = spread(key.hashCode());</span><br><span class="line">    //根据hash值确定节点位置</span><br><span class="line">    if((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123;</span><br><span class="line">        //如果搜索到的节点key与传入的key相同且不为null,直接返回这个节点 </span><br><span class="line">        if((eh = e.hash) == h) &#123;</span><br><span class="line">            if((ek = e.key) == key || (ek != null&amp;&amp; key.equals(ek)))</span><br><span class="line">                returne.val;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果eh&lt;0 说明这个节点在树上 直接寻找</span><br><span class="line">        else if(eh &lt; 0)</span><br><span class="line">             return (p = e.find(h, key)) != null ? p.val : null;</span><br><span class="line">         //否则遍历链表 找到对应的值并返回</span><br><span class="line">        while((e = e.next) != null) &#123;</span><br><span class="line">            if(e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != null&amp;&amp; key.equals(ek))))</span><br><span class="line">                return e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-Size相关的方法"><a href="#8-Size相关的方法" class="headerlink" title="8 Size相关的方法"></a>8 Size相关的方法</h3><p>对于ConcurrentHashMap来说，这个table里到底装了多少东西其实是个不确定的数量，因为不可能在调用size()方法的时候像GC的“stop the world”一样让其他线程都停下来让你去统计，因此只能说这个数量是个估计值。对于这个估计值，ConcurrentHashMap也是大费周章才计算出来的。</p><h4 id="8-1-辅助定义"><a href="#8-1-辅助定义" class="headerlink" title="8.1 辅助定义"></a>8.1 辅助定义</h4><p>为了统计元素个数，ConcurrentHashMap定义了一些变量和一个内部类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A padded cell for distributing counts.  Adapted from LongAdder</span><br><span class="line"> * and Striped64.  See their internal docs for explanation.</span><br><span class="line"> */</span><br><span class="line">@sun.misc.Contendedstaticfinalclass CounterCell &#123;</span><br><span class="line">    volatilelongvalue;</span><br><span class="line">    CounterCell(longx) &#123; value = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/******************************************/ </span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 实际上保存的是hashmap中的元素个数  利用CAS锁进行更新</span><br><span class="line"> 但它并不用返回当前hashmap的元素个数</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line">privatetransientvolatile long baseCount;</span><br><span class="line">/**</span><br><span class="line"> * Spinlock (locked via CAS) used when resizing and/or creating CounterCells.</span><br><span class="line"> */</span><br><span class="line">privatetransientvolatile int cellsBusy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Table of counter cells. When non-null, size is a power of 2.</span><br><span class="line"> */</span><br><span class="line">privatetransientvolatile CounterCell[] counterCells;</span><br></pre></td></tr></table></figure><h4 id="8-2-mappingCount与Size方法"><a href="#8-2-mappingCount与Size方法" class="headerlink" title="8.2 mappingCount与Size方法"></a>8.2 mappingCount与Size方法</h4><p>mappingCount与size方法的类似  从Java工程师给出的注释来看，应该使用mappingCount代替size方法 两个方法都没有直接返回basecount 而是统计一次这个值，而这个值其实也是一个大概的数值，因此可能在统计的时候有其他线程正在执行插入或删除操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">publicintsize() &#123;</span><br><span class="line">        longn = sumCount();</span><br><span class="line">        return((n &lt; 0L) ? 0:</span><br><span class="line">                (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">                (int)n);</span><br><span class="line">    &#125;</span><br><span class="line">     /**</span><br><span class="line">     * Returns the number of mappings. This method should be used</span><br><span class="line">     * instead of &#123;@link #size&#125; because a ConcurrentHashMap may</span><br><span class="line">     * contain more mappings than can be represented as an int. The</span><br><span class="line">     * value returned is an estimate; the actual count may differ if</span><br><span class="line">     * there are concurrent insertions or removals.</span><br><span class="line">     *</span><br><span class="line">     * @return the number of mappings</span><br><span class="line">     * @since 1.8</span><br><span class="line">     */</span><br><span class="line">    publiclongmappingCount() &#123;</span><br><span class="line">        longn = sumCount();</span><br><span class="line">        return(n &lt; 0L) ? 0L : n; // ignore transient negative values</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">     finallongsumCount() &#123;</span><br><span class="line">        CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">        longsum = baseCount;</span><br><span class="line">        if(as != null) &#123;</span><br><span class="line">            for(inti = 0; i &lt; as.length; ++i) &#123;</span><br><span class="line">                if((a = as[i]) != null)</span><br><span class="line">                    sum += a.value;//所有counter的值求和</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        returnsum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-addCount方法"><a href="#8-3-addCount方法" class="headerlink" title="8.3 addCount方法"></a>8.3 addCount方法</h4><p>在put方法结尾处调用了addCount方法，把当前ConcurrentHashMap的元素个数+1这个方法一共做了两件事,更新baseCount的值，检测是否进行扩容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">privatefinalvoid addCount(longx,intcheck) &#123;</span><br><span class="line">    CounterCell[] as; longb, s;</span><br><span class="line">    //利用CAS方法更新baseCount的值</span><br><span class="line">    if((as = counterCells) != null||</span><br><span class="line">        !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; longv;intm;</span><br><span class="line">        booleanuncontended = true;</span><br><span class="line">        if(as == null|| (m = as.length - 1) &lt; 0||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(check &lt;= 1)</span><br><span class="line">            return;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    //如果check值大于等于0 则需要检验是否需要进行扩容操作</span><br><span class="line">    if(check &gt;= 0) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; intn, sc;</span><br><span class="line">        while(s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null&amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            intrs = resizeStamp(n);</span><br><span class="line">            //</span><br><span class="line">            if(sc &lt; 0) &#123;</span><br><span class="line">                if((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null||</span><br><span class="line">                    transferIndex &lt;= 0)</span><br><span class="line">                    break;</span><br><span class="line">                 //如果已经有其他线程在执行扩容操作</span><br><span class="line">                if(U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            //当前线程是唯一的或是第一个发起扩容的线程  此时nextTable=null</span><br><span class="line">            elseif(U.compareAndSwapInt(this, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</span><br><span class="line">                transfer(tab,null);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>JDK6,7中的ConcurrentHashmap主要使用Segment来实现减小锁粒度，把HashMap分割成若干个Segment，在put的时候需要锁住Segment，get时候不加锁，使用volatile来保证可见性，当要统计全局时（比如size），首先会尝试多次计算modcount来确定，这几次尝试中，是否有其他线程进行了修改操作，如果没有，则直接返回size。如果有，则需要依次锁住所有的Segment来计算。</p><p>jdk7中ConcurrentHashmap中，当长度过长碰撞会很频繁，链表的增改删查操作都会消耗很长的时间，影响性能,所以jdk8 中完全重写了concurrentHashmap,代码量从原来的1000多行变成了 6000多 行，实现上也和原来的分段式存储有很大的区别。</p><p>主要设计上的变化有以下几点:</p><ol><li>不采用segment而采用node，锁住node来实现减小锁粒度。</li><li>设计了MOVED状态 当resize的中过程中 线程2还在put数据，线程2会帮助resize。</li><li>使用3个CAS操作来确保node的一些操作的原子性，这种方式代替了锁。</li><li>sizeCtl的不同值来代表不同含义，起到了控制的作用。  </li></ol><p>至于为什么JDK8中使用synchronized而不是ReentrantLock，我猜是因为JDK8中对synchronized有了足够的优化吧。</p><hr><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://blog.csdn.net/moakun/article/details/80203568" target="_blank" rel="noopener">JDK1.8 实现解读</a><br><a href="http://www.cnblogs.com/stateis0/p/9062086.html" target="_blank" rel="noopener">扩容源码分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-重要的属性&quot;&gt;&lt;a href=&quot;#1-重要的属性&quot; class=&quot;headerlink&quot; title=&quot;1.重要的属性&quot;&gt;&lt;/a&gt;1.重要的属性&lt;/h3&gt;&lt;p&gt;首先来看几个重要的属性，与HashMap相同的就不再介绍了，这里重点解释一下sizeCtl这个属性。
      
    
    </summary>
    
    
      <category term="并发编程" scheme="http://yoursite.com/child/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-并发工具类</title>
    <link href="http://yoursite.com/child/2018/05/17/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://yoursite.com/child/2018/05/17/并发编程-并发工具类/</id>
    <published>2018-05-17T12:36:12.000Z</published>
    <updated>2019-06-25T14:13:43.932Z</updated>
    
    <content type="html"><![CDATA[<p>在JDK的并发包中提供了几个非常有用的并发工具类。CountDownLatch、CyclicBarrier和Semaphore提供了并发流程控制手段，Exchanger提供了两个线程之间交换数据的手段，本文将配合应用场景介绍该如何使用这几个工具类。</p><h3 id="1-CountDownLatch"><a href="#1-CountDownLatch" class="headerlink" title="1. CountDownLatch"></a>1. CountDownLatch</h3><p>CountDownLatch是JDK 5+里面闭锁的一个实现，他允许一个或多个线程等待其他线程完成各自的工作后再执行。</p><p>闭锁（Latch）：一种同步方法，可以延迟线程的进度直到线程到达某个终点状态。</p><p>与CountDownLatch第一次交互是主线程等待其它的线程，主线程必须在启动其它线程后立即调用await方法，这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。</p><p>其他的N个线程必须引用闭锁对象，因为他们需要通知CountDownLatch对象，他们已经完成了各自的任务，这种机制就是通过调用countDown()方法来完成的。每调用一次这个方法，在构造函数中初始化的count值就减1，所以当N个线程都调用了这个方法count的值等于0，然后主线程就能通过await方法，恢复自己的任务。</p><p>与Join的区别：调用join方法需要等待thread执行完毕才能继续向下执行,而CountDownLatch只需要检查计数器的值为零就可以继续向下执行，相比之下，CountDownLatch更加灵活一些，可以实现一些更加复杂的业务场景。</p><h4 id="1-1-使用场景"><a href="#1-1-使用场景" class="headerlink" title="1.1 使用场景"></a>1.1 使用场景</h4><ol><li>开启多个线程分块下载一个大文件，每个线程只下载固定的一截，最后由另外一个线程来拼接所有的分段。</li><li>应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。</li><li>确保一个计算不会执行，直到所需要的资源被初始化。</li></ol><h4 id="1-2-主要方法"><a href="#1-2-主要方法" class="headerlink" title="1.2 主要方法"></a>1.2 主要方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//初始化计数的次数，不能重置</span><br><span class="line">public CountDownLatch(int count); </span><br><span class="line">//调用此方法则计数减1</span><br><span class="line">public void countDown();   </span><br><span class="line">//得到当前的计数</span><br><span class="line">Public Long getCount();           </span><br><span class="line">//调用此方法会一直阻塞当前线程，直到计时器的值为0，除非线程被中断。</span><br><span class="line">public void await() throws InterruptedException   </span><br><span class="line">//调用此方法会一直阻塞当前线程，直到计时器的值为0，除非线程被中断或者计数器超时，返回false代表计数器超时。</span><br><span class="line">Public boolean await(long timeout, TimeUnit unit)</span><br></pre></td></tr></table></figure><h4 id="1-3-使用案例"><a href="#1-3-使用案例" class="headerlink" title="1.3 使用案例"></a>1.3 使用案例</h4><ol><li>latch.countDown(); 建议放到finally语句里。</li><li>对这个计数器的操作都是原子操作，同时只能有一个线程去操作这个计数器。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class CountDownLatchTest &#123;</span><br><span class="line">    private final CountDownLatch latch = new CountDownLatch(3);</span><br><span class="line">    private final ReentrantLock lock = new ReentrantLock();</span><br><span class="line">    private int count;</span><br><span class="line"></span><br><span class="line">    public int getCount()&#123;</span><br><span class="line">        return this.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class RunnableTask implements Runnable&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                count += 100;</span><br><span class="line">            &#125;finally &#123;</span><br><span class="line">                latch.countDown();</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException&#123;</span><br><span class="line">        CountDownLatchTest demo = new CountDownLatchTest();</span><br><span class="line">        int i = 3;</span><br><span class="line">        while(i-- &gt; 0)&#123;</span><br><span class="line">            new Thread(demo.new RunnableTask()).start();</span><br><span class="line">        &#125;</span><br><span class="line">        demo.latch.await();</span><br><span class="line">        System.out.println(demo.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个线程分别对count加100，等三个线程执行完后，主线程输出count的值。输出300</p><h3 id="2-CyclicBarrier"><a href="#2-CyclicBarrier" class="headerlink" title="2. CyclicBarrier"></a>2. CyclicBarrier</h3><p>字面意思是可以循环使用的屏障。他要做的事情是让一组线程到达一个同步点时被阻塞，直到最后一个线程到达同步点，才会打开屏障，所有线程继续运行。</p><p>默认的构造方法 CyclicBarrier(int parties) ，参数代表屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier已经到达屏障，然后被阻塞。</p><h4 id="1-1-使用场景-1"><a href="#1-1-使用场景-1" class="headerlink" title="1.1 使用场景"></a>1.1 使用场景</h4><p>可用于多线程计算数据，最后合并计算结果</p><h4 id="1-2-主要方法-1"><a href="#1-2-主要方法-1" class="headerlink" title="1.2 主要方法"></a>1.2 主要方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//初始化</span><br><span class="line">public CyclicBarrier(int parties)</span><br><span class="line">//barrierAction表示被拦住的线程需要执行的任务</span><br><span class="line">public CyclicBarrier(int parties, Runnable barrierAction)</span><br><span class="line">//被拦住的线程调用次函数进入阻塞状态</span><br><span class="line">public int await()</span><br><span class="line">//被拦住的线程调用次函数进入阻塞状态，超时唤醒</span><br><span class="line">public int await(long timeout, TimeUnit unit)</span><br><span class="line">public void reset() </span><br><span class="line">//返回需要被拦住的线程数量</span><br><span class="line">public int getParties() </span><br><span class="line">//查询此屏障是否处于断开状态</span><br><span class="line">public boolean isBroken()</span><br><span class="line">//返回已被拦住的线程数量</span><br><span class="line">public int getNumberWaiting()</span><br></pre></td></tr></table></figure><h4 id="1-3-使用案例-1"><a href="#1-3-使用案例-1" class="headerlink" title="1.3 使用案例"></a>1.3 使用案例</h4><p>初始化线程数为2，加上主线程调用await()3次，所以得出结论主线程调用不计入await次数之内。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class CyclicBarrierTest &#123;</span><br><span class="line">    private static CyclicBarrier cb = new CyclicBarrier(2);</span><br><span class="line">    private static ReentrantLock lock = new ReentrantLock();</span><br><span class="line">    private static int count;</span><br><span class="line">    public static class RunnableTask implements Runnable&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                count += 100;</span><br><span class="line">                cb.await();</span><br><span class="line">            &#125;catch (Throwable e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        for(int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            new Thread(new RunnableTask()).start();</span><br><span class="line">        &#125;</span><br><span class="line">        cb.await();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出200</p><h4 id="1-4-与CountDownLatch的区别"><a href="#1-4-与CountDownLatch的区别" class="headerlink" title="1.4 与CountDownLatch的区别"></a>1.4 与CountDownLatch的区别</h4><ul><li>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置，可以使用多次，所以CyclicBarrier能够处理更为复杂的场景；</li><li>CyclicBarrier还提供了一些其他有用的方法，比如getNumberWaiting()方法可以获得CyclicBarrier阻塞的线程数量，isBroken()方法用来了解阻塞的线程是否被中断；</li><li>CountDownLatch允许一个或多个线程等待一组事件的产生，而CyclicBarrier用于等待其他线程运行到栅栏位置。</li></ul><h3 id="3-Semaphore"><a href="#3-Semaphore" class="headerlink" title="3. Semaphore"></a>3. Semaphore</h3><p>Semaphore是用来控制同事访问特定资源的线程数量，它通过协调各个线程以保证合理的使用公共资源。</p><h4 id="3-1-使用场景"><a href="#3-1-使用场景" class="headerlink" title="3.1 使用场景"></a>3.1 使用场景</h4><p>可用于做流量控制，特别是公用资源有限的场景，比如数据库连接。</p><h3 id="4-Exchanger"><a href="#4-Exchanger" class="headerlink" title="4. Exchanger"></a>4. Exchanger</h3><p>Exchanger类可用于两个线程之间交换信息。可简单地将Exchanger对象理解为一个包含两个格子的容器，通过exchanger方法可以向两个格子中填充信息。当两个格子中的均被填充时，该对象会自动将两个格子的信息交换，然后返回给线程，从而实现两个线程的信息交换。</p><p>Exchanger类仅可用作两个线程的信息交换，当超过两个线程调用同一个exchanger对象时，得到的结果是不确定的，exchanger对象仅关心其包含的两个“格子”是否已被填充数据，当两个格子都填充数据完成时，该对象就认为线程之间已经配对成功，然后开始执行数据交换操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class ExchangerTest &#123;</span><br><span class="line">    private static Exchanger&lt;String&gt; exgr = new Exchanger&lt;&gt;();</span><br><span class="line">    private static ExecutorService threadpool = Executors.newFixedThreadPool(3);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        threadpool.execute(() -&gt; &#123;</span><br><span class="line">            String a = &quot;银行流水A&quot;;</span><br><span class="line">            try &#123;</span><br><span class="line">                exgr.exchange(a);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadpool.execute(() -&gt; &#123;</span><br><span class="line">            String b = &quot;银行流水B&quot;;</span><br><span class="line">            try &#123;</span><br><span class="line">                String a = exgr.exchange(b);</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125; catch (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadpool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在JDK的并发包中提供了几个非常有用的并发工具类。CountDownLatch、CyclicBarrier和Semaphore提供了并发流程控制手段，Exchanger提供了两个线程之间交换数据的手段，本文将配合应用场景介绍该如何使用这几个工具类。&lt;/p&gt;
&lt;h3 id=&quot;
      
    
    </summary>
    
    
      <category term="并发编程" scheme="http://yoursite.com/child/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-线程池源码详解</title>
    <link href="http://yoursite.com/child/2018/05/15/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/child/2018/05/15/并发编程-线程池源码详解/</id>
    <published>2018-05-15T03:28:21.000Z</published>
    <updated>2019-06-09T01:21:43.793Z</updated>
    
    <content type="html"><![CDATA[<p>阿里巴巴Java手册有一条：<br>【强制】线程资源必须通过线程池提供，禁止在应用程序中显示创建线程。<br>说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程导致消耗完内存或者过度切换的问题。</p><p>简单来说使用线程池有以下几个目的：  </p><ul><li>避免频繁的创建。线程是稀缺资源。</li><li>解耦。线程的创建与执行分开，方便维护。</li><li>线程资源复用。</li></ul><h3 id="1-线程池原理"><a href="#1-线程池原理" class="headerlink" title="1. 线程池原理"></a>1. 线程池原理</h3><p>本文从线程池的创建开始说起，跟着源码分析一下线程池的工作原理，本文源码基于JDK1.8</p><h4 id="1-1-Executors"><a href="#1-1-Executors" class="headerlink" title="1.1 Executors"></a>1.1 Executors</h4><p>Executors有一个私有的默认构造函数，不能实例化，是一个工具类，主要用于提供各种类型线程池创建的静态方法。<br>提供的静态创建方法有：</p><ul><li>newSingleThreadExecutor 创建一个执行器，该执行器使用一个工作线程操作一个无界队列。(但是请注意，如果这个线程在关闭之前的执行过程中由于失败而终止，那么如果需要执行后续任务，将会有一个新的线程代替它。与 newFixedThreadPool(1)不同，返回的executor不能被其他线程重新配置。</li><li>newFixedThreadPool  创建一个线程池，该线程池重用固定数量的线，如果任何线程在关闭之前的执行过程中由于失败而终止，那么如果需要执行后续任务，则会替换一个新线程。池中的线程将一直存在，直到显式关闭为止<br>操作一个共享的无界队列。</li><li>newWorkStealingPool  创建一个线程池，该线程池维护足够的线程以支持给定的并行度级别，并且可以使用多个队列来减少争用。并行度级别对应于积极参与或可用参与任务处理的线程的最大数量。线程的实际数量可以动态地增长和收缩。工作窃取池不能保证所提交任务的执行顺序。</li><li>newCachedThreadPool  创建一个线程池，该线程池根据需要创建新线程，但在可用时将重用以前构造的线程。这些池通常会提高执行许多短期异步任务的程序的性能。如果可用，对execute的调用将重用以前构造的线程。如果没有可用的现有线程，将创建一个新线程并将其添加到池中。未使用60秒的线程将被终止并从缓存中删除。因此，长时间空闲的池不会消耗任何资源。注意，可以使用ThreadPoolExecutor构造函数创建具有相似属性但不同细节(例如超时参数)的池。</li><li>newSingleThreadScheduledExecutor  创建一个单线程执行器，该执行器可以安排命令在给定的延迟之后运行，或者定期执行。(但是请注意，如果这个线程在关闭之前的执行过程中由于失败而终止，那么如果需要执行后续任务，将会有一个新的线程代替它。)，与 newFixedThreadPool(1)不同，返回的executor不能被其他线程重新配置。</li><li>newScheduledThreadPool  创建一个线程池，该线程池可以在给定延迟之后调度命令运行，或者定期执行命令。</li></ul><p>Executors 返回的线程池对象的弊端如下：</p><ol><li>FixedThreadPool 和 SingleThreadPool: 允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。</li><li>CachedThreadPool 和 ScheduledThreadPool: 允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</li></ol><h4 id="1-2-ThreadPoolExecutor"><a href="#1-2-ThreadPoolExecutor" class="headerlink" title="1.2 ThreadPoolExecutor"></a>1.2 ThreadPoolExecutor</h4><p>首先看一下newFixedThreadPool创建方法的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>事实上，大多数类型的线程池创建都是调用new ThreadPoolExecutor(…)创建一个ThreadPoolExecutor对象，只不过初始化参数不同而已。newWorkStealingPool创建时构造的是ForkJoinPool对象，本文不述。</p><p>下面是ThreadPoolExecutor的其中一个构造方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>初始化参数的如下：</p><ul><li>corePoolSize 表示线程池的核心数,线程池保持alive状态的线程数，即使线程是空闲的。</li><li>maximumPoolSize 表示线程池支持的最大的线程个数。</li><li>keepAliveTime 表示池中线程空闲后的生存时间</li><li>unit 表示上一个时间参数的单位</li><li>workQueue 用于存放任务的阻塞队列</li><li>threadFactory 表示创建线程的工厂，一般使用默认的线程创建工厂Excutors.DefaultThreadFactor()</li><li>handler 当队列和最大线程池都满了之后的饱和策略，一般使用默认的handler—AbortPolicy（内部类）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">代码摘自：java.util.concurrent.ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler defaultHandler = <span class="keyword">new</span> AbortPolicy();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</span><br><span class="line">                                             <span class="string">" rejected from "</span> +</span><br><span class="line">                                             e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    handler.rejectedExecution(command, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户也可以自己实现RejectedExecutionHandler接口定义一个handler，当提交的任务因为各种原因被线程池拒绝，就会调用rejectedExecution方法。</p><h5 id="1-2-1-提交任务excute"><a href="#1-2-1-提交任务excute" class="headerlink" title="1.2.1 提交任务excute()"></a>1.2.1 提交任务excute()</h5><p>使用线程池时，通常我们用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threadPool.execute(<span class="keyword">new</span> Job());</span><br></pre></td></tr></table></figure></p><p>这样的方式提交一个任务到线程池中，所以线程池ThreadPoolExecutor的核心逻辑就是execute()函数了，这个方法是在Excutor接口中声明。</p><p>在分析核心逻辑之前，先了解一下线程池重定义的状态，这些状态都和线程的执行密切相关</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">代码摘自：java.util.concurrent.ThreadPoolExecutor</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPCITY = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;<span class="keyword">return</span> c &amp; ~CAPCITY;&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;<span class="keyword">return</span> c &amp; CAPCITY;&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span></span>&#123;<span class="keyword">return</span> rs | wc;&#125;</span><br></pre></td></tr></table></figure><p>分析上面的代码得到下表：</p><table><thead><tr><th>常量名</th><th>二进制</th></tr></thead><tbody><tr><td>CAPCITY</td><td>0001 1111 1111 1111 1111 1111 1111 1111</td></tr><tr><td>RUNNING</td><td>1110 0000 0000 0000 0000 0000 0000 0000</td></tr><tr><td>SHUTDOWN</td><td>0000 0000 0000 0000 0000 0000 0000 0000</td></tr><tr><td>STOP</td><td>0010 0000 0000 0000 0000 0000 0000 0000</td></tr><tr><td>TIDYING</td><td>0100 0000 0000 0000 0000 0000 0000 0000</td></tr><tr><td>TERMINATED</td><td>0110 0000 0000 0000 0000 0000 0000 0000</td></tr></tbody></table><p>由上表可以看出，原子对象ctl的前三位表示状态，后29位记录池中worker的个数，CAPCITY就像是一个掩码，通过掩码可以快速的从ctl中获得当前线程池的运行状态和池中的worker个数。  </p><p>JDK1.8的并发包中不再通过设置阻塞队列的长度来限制任务的提交。阻塞队列的长度初始化之后就不能改变，因此如果担心阻塞队列太大导致内存占用太多，可以从两方面入手：1、初始化的时候选择合适的阻塞队列大小；2、调高corePoolSize或maxmumPoolSize加快任务的处理速度。参数的动态调整见下文。</p><p>线程池状态简述：</p><ul><li>RUNNING 是运行状态，指可以接受任务，执行队列里的任务。</li><li>SHUTDOWN 是指调用了shutdown()函数，不再接受新任务，但是会把队列里的任务执行完毕。</li><li>STOP 是指调用了shutdownNow()函数，不再接受新任务，同时终端正在执行的任务并丢弃队列中的待执行任务。</li><li>TIDYING 指所用任务都执行完毕。</li><li>TERMINATED 终止状态，在调用shutdown()/shutdownNow()中都会尝试更新这个状态。</li></ul><p>下面分析核心代码excute()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">代码摘自：java.util.concurrent.ThreadPoolExecutor</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//1、获取当前线程池的状态</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">//2、当线程数量小于corePoolSize，创建新线程运行</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//线程池线程数大于核心线程数 或者 新增worker失败 会执行下面的代码</span></span><br><span class="line">    <span class="comment">//3、如果线程池处于运行状态，并且写入阻塞队列成功</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">//4、再次检查线程状态，若线程池状态改变（非运行状态），需要从阻塞队列移除该任务，并执行拒绝策略</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">//5、如果线程池状态没有发生变化，判断当前池是否为空，为空就创建一个没有指定具体任务的新线程</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6、如果第一次检查不通过（线程池不处于运行状态或者任务写入队列失败），尝试新建线程，如果失败则执行拒绝策略</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>疑问：addWorker(null, false) 添加了一个没有具体任务的worker，作用是什么？  </p><p>如果线程池中的线程数为0，但任务队列中有需要执行的任务，这时候新建一个没有任务的线程是为了去执行任务队列中的任务。</p><p>下图表示了当有任务提交到线程池后线程池的处理流程：<br><img src="https://wx3.sinaimg.cn/large/87c9e458ly1g3tvn4t29jj20p30qqjtq.jpg" alt="execute执行流程图1">  </p><h5 id="1-2-2-创建工人（线程）"><a href="#1-2-2-创建工人（线程）" class="headerlink" title="1.2.2 创建工人（线程）"></a>1.2.2 创建工人（线程）</h5><p><strong>addWorker(Runnable firstTask, boolean core)</strong></p><p>参数：</p><p>firstTask：    worker线程的初始任务，可以为空<br>core：           true：将corePoolSize作为上限，false：将maximumPoolSize作为上限</p><p>addWorker函数是execute函数的核心逻辑，线程池持有一个HashSet<worker>对象存放池中的workers，每个worker对应一个线程，addWorker的作用就是创建worker执行任务。</worker></p><p><strong>addWorker方法有4种调用方式：</strong></p><ul><li><p>addWorker(command, true)</p></li><li><p>addWorker(command, false)</p></li><li><p>addWorker(null, false)</p></li><li><p>addWorker(null, true)</p></li></ul><p>在execute方法中就使用了前3种，结合这个方法进行以下分析</p><ol><li>线程数小于corePoolSize时，放一个需要处理的task进Workers Set。如果Workers Set长度超过corePoolSize，就返回false</li><li>当队列被放满时，就尝试将这个新来的task直接放入Workers Set，而此时Workers Set的长度限制是maximumPoolSize。如果线程池也满了的话就返回false</li><li>放入一个空的task进workers Set，长度限制是maximumPoolSize。这样一个task为空的worker在线程执行的时候会去任务队列里拿任务，这样就相当于创建了一个新的线程，只是没有马上分配任务</li><li>这个方法就是放一个null的task进Workers Set，而且是在小于corePoolSize时，如果此时Set中的数量已经达到corePoolSize那就返回false，什么也不干。实际使用中是在prestartAllCoreThreads()方法，这个方法用来为线程池预先启动corePoolSize个worker等待从workQueue中获取任务执行</li></ol><p>下面将源代码分成两部分进行分析，第一段代码为<strong>检验模块</strong>，主要判断线程池当前是否为可以添加worker线程的状态，可以则继续下一步，不可以则返回 false，具体分为三种情况：</p><ul><li>线程池状态&gt;shutdown，可能为stop、tidying、terminated，不能添加worker线程</li><li>线程池状态==shutdown，firstTask不为空，不能添加worker线程，因为shutdown状态的线程池不接收新任务</li><li>线程池状态==shutdown，firstTask==null，workQueue为空，不能添加worker线程，因为firstTask为空是为了添加一个没有任务的线程再从workQueue获取task，而workQueue为空，说明添加无任务线程已经没有意义</li></ul><p>当以上的情况都没有发生，在创建worker之前还需要验证一下线程池中的线程数量有没有达到极限，达到极限直接返回false；没达到极限，先CAS修改线程池状态(+1操作)，若修改成功，直接退出检验模块循环，执行下面的<strong>运行模块</strong>。CAS设置状态失败则重新获取运行状态进行二重检验，若线程池状态发生改变，从头开始大循环检验，否则继续小循环执行cas。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">代码摘自：java.util.concurrent.ThreadPoolExecutor</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">        <span class="comment">//状态为 RUNNING 继续往下执行</span></span><br><span class="line">        <span class="comment">//状态为不为RUNNING时，如果状态为SHUTDOWN并且firstTask为null并且阻塞队列空时，可继续向下运行</span></span><br><span class="line">        <span class="comment">//否则返回false，添加worker失败</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">//线程数大于CAPACITY </span></span><br><span class="line">            <span class="comment">//线程数大于corePoolSize或maximumPoolSize（取决于core）</span></span><br><span class="line">            <span class="comment">//否则添加worker失败</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//线程数验证通过，使用CAS对c加1，执行成功则终止大循环继续向下运行</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">//CAS设置失败则重新获取运行状态，若线程池状态发生改变，从头开始大循环，否则继续小循环</span></span><br><span class="line">            c = ctl.get(); </span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二部分为运行模块，直接进入主题，将提交的任务包装成worker对象，加入worker set 并启动该worker的线程，worker插入set需要加锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 二重验证，获取池状态</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                <span class="comment">//状态为RUNNING 则通过继续执行</span></span><br><span class="line">                <span class="comment">//状态为SHUTDOWN并且提交的任务为null 则通过继续执行</span></span><br><span class="line">                <span class="comment">//否则直接执行finally解锁</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// 如果worker中的线程t已经处于运行状态</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();<span class="comment">//抛异常</span></span><br><span class="line">                    workers.add(w);<span class="comment">//将w加入HashSet</span></span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="comment">//更新largestPoolSize，largestPoolSize只能在lock下修改</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>addWorker执行流程总结：</strong></p><ol><li>判断是否可以addworker</li><li>线程池当前线程数量是否超过上限（corePoolSize 或 maximumPoolSize），超过了return false，没超过则对workerCount+1，继续下一步</li><li>在线程池的ReentrantLock保证下，向Workers Set中添加新创建的worker实例，添加完成后解锁，并启动worker线程，只有在新建的线程成功启动的情况下才能返回 true。如果添加worker入Set失败或启动失败，调用addWorkerFailed()逻辑</li></ol><h5 id="1-2-3-worker创建失败的善后处理"><a href="#1-2-3-worker创建失败的善后处理" class="headerlink" title="1.2.3 worker创建失败的善后处理"></a>1.2.3 worker创建失败的善后处理</h5><p>addWorkerFailed()</p><p>当任务执行失败，程序需要进行善后处理，即恢复任务执行过程中对内存的改动，移除Worker set中的worker对象，修改池状态，最后尝试终止线程池。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">代码摘自：java.util.concurrent.ThreadPoolExecutor</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        <span class="comment">//CAS对ctl减1</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="1-2-4-空闲线程怎么从阻塞队列中取任务"><a href="#1-2-4-空闲线程怎么从阻塞队列中取任务" class="headerlink" title="1.2.4 空闲线程怎么从阻塞队列中取任务"></a>1.2.4 空闲线程怎么从阻塞队列中取任务</h5><h3 id="2-配置线程池"><a href="#2-配置线程池" class="headerlink" title="2. 配置线程池"></a>2. 配置线程池</h3><p>流程介绍完了先来总结以下上文提到了几个核心参数在流程中的具体作用，然后介绍应该如何配置。</p><h4 id="2-1-参数详解"><a href="#2-1-参数详解" class="headerlink" title="2.1 参数详解"></a>2.1 参数详解</h4><ol><li>corePoolSize：核心线程数</li></ol><ul><li>核心线程会一直存活，即使没有任务需要执行</li><li>当线程数小于核心线程数时，即使有线程空闲，线程池也会有限创建新的线程</li><li>设置allowCoreThreadTimeout=true（默认是false）时，核心线程会超时关闭</li></ul><ol start="2"><li>maximumPoolSize：最大线程数</li></ol><ul><li>当线程数 &gt;= corePoolSize，且队列已满。线程池会创建新线程来处理  </li><li>当线程数 = maxmumPoolSize，且队列任务已满是，线程会拒绝处理任务  </li></ul><ol start="3"><li>keepAliveTime：线程空闲时间</li></ol><ul><li>当线程空闲时间达到keepAliveTime时，线程会退出，知道线程数量 = corePoolSize  </li><li>如果allowCoreThreadTimeout = true，则会知道线程数量 = 0</li></ul><ol start="4"><li>rejectedExecutionHandler：任务拒绝处理器<br>两种情况会拒绝处理任务： </li></ol><ul><li>当线程数已经达到maxmumPoolSize，且队列已满，会拒绝新任务</li><li>当线程池被调用shutdown()后，会等待线程池里的任务执行完毕，再shutdown。如果在调用shutdown()和线程池真正shutdown之间提交任务，会拒绝新任务</li></ul><p>线程池会调用rejectedExecutionHandler来处理这个任务。如果没有设置默认是AbortPolicy，会抛出异常，<br>ThreadPoolExecutor类有几个内部实现类来处理这类情况：  </p><blockquote><p>AbortPolicy 丢弃任务，抛运行时异常<br>CallerRunsPolicy 执行任务，调用Runnable的run强制执行。<br>DiscardPolicy 忽视，什么都不会发生<br>DiscardOldestPolicy 如果是应为第一种情况被拒绝，则从阻塞队列中踢出最先进入队列（最后一个执行）的任务，然后再次提交当前任务。</p></blockquote><p>实现RejectedExecutionHandler接口，可自定义处理器处理reject。</p><h4 id="2-2-参数配置"><a href="#2-2-参数配置" class="headerlink" title="2.2 参数配置"></a>2.2 参数配置</h4><p>默认值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">corePoolSize=<span class="number">1</span></span><br><span class="line">maxPoolSize=Integer.MAX_VALUE</span><br><span class="line">keepAliveTime=<span class="number">60</span>s</span><br><span class="line">allowCoreThreadTimeout=<span class="keyword">false</span></span><br><span class="line">rejectedExecutionHandler=AbortPolicy()</span><br></pre></td></tr></table></figure></p><p>如何设置，需要根据几个值来决定：  </p><ul><li>tasks ：系统每秒任务数，假设为500~1000</li><li>taskcost：单任务耗时，假设为0.1s</li><li>responsetime：系统允许容忍的最大响应时间，假设为1s</li></ul><p>做几个计算：<br>corePoolSize = 系统每秒任务数/单线程每秒任务数 = 系统每秒任务数/（1/单任务耗时）<br>corePoolSize = tasks/(1/taskcost) =tasks<em>taskcout =  (500~1000)</em>0.1 = 50~100 。  corePoolSize设置应该大于50，根据8020原则，如果80%的系统每秒任务数小于800，那么corePoolSize设置为80即可  </p><p>maxPoolSize = （最大任务数-队列容量）/每个线程每秒处理能力 = 最大线程数<br>计算可得 maxPoolSize = (1000-80)/10 = 92<br>队列容量在初始化池的时候指定，一旦指定不能修改</p><p>rejectedExecutionHandler：根据具体情况来决定，任务不重要可丢弃，任务重要则要利用一些缓冲机制来处理</p><p>keepAliveTime和allowCoreThreadTimeout采用默认通常能满足<br>以上都是理想值，实际情况下要根据机器性能来决定。如果在未达到最大线程数的情况机器cpu load已经满了，则需要通过升级硬件和优化代码，降低taskcost来处理。</p><h4 id="2-3-参数动态调整"><a href="#2-3-参数动态调整" class="headerlink" title="2.3 参数动态调整"></a>2.3 参数动态调整</h4><p>用户可以通过corePoolSize和maxmumPoolSize的getter/setter进行访问和设置，具体怎么设置需要根据当前池中一些状态变量进行判断，如：</p><ul><li>getLargestPoolSize() 获取到目前为止达到过的最大线程数</li><li>getPoolSize() 获取当前线程数</li><li>getQueue().size() 获取当前阻塞队列任务数</li></ul><h3 id="3-关闭线程池"><a href="#3-关闭线程池" class="headerlink" title="3. 关闭线程池"></a>3. 关闭线程池</h3><p>关闭线程池无非就是两个方法 shutdown()/shutdownNow()。</p><p>但他们有着重要的区别：</p><ul><li>shutdown() 执行后停止接受新任务，会把队列的任务执行完毕。</li><li>shutdownNow() 也是停止接受新任务，但会中断所有的任务，将线程池状态变为 stop。</li></ul><p>两个方法都会中断线程，用户可自行判断是否需要响应中断。<br>shutdownNow() 要更简单粗暴，可以根据实际场景选择不同的方法。</p><p>通常是按照以下方式关闭线程池的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    pool.execute(<span class="keyword">new</span> Job());</span><br><span class="line">&#125;</span><br><span class="line">pool.shutdown();</span><br><span class="line"><span class="keyword">while</span> (!pool.awaitTermination(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    LOGGER.info(<span class="string">"线程还在执行。。。"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">LOGGER.info(<span class="string">"一共处理了【&#123;&#125;】"</span>, (end - start));</span><br></pre></td></tr></table></figure></p><p>pool.awaitTermination(1, TimeUnit.SECONDS) 会每隔一秒钟检查一次是否执行完毕（状态为 TERMINATED），当从 while 循环退出时就表明线程池已经完全终止了。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;阿里巴巴Java手册有一条：&lt;br&gt;【强制】线程资源必须通过线程池提供，禁止在应用程序中显示创建线程。&lt;br&gt;说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程导致消耗完内存或者过
      
    
    </summary>
    
    
      <category term="并发编程" scheme="http://yoursite.com/child/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-ThreadLocal原理</title>
    <link href="http://yoursite.com/child/2018/05/03/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-ThreadLocal%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/child/2018/05/03/并发编程-ThreadLocal原理/</id>
    <published>2018-05-03T12:58:11.000Z</published>
    <updated>2019-05-17T04:53:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>ThreadLocal是一个本地线程副本变量工具类，ThreadLocal的实例代表了一个线程局部的变量，主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。</p><h3 id="1-我是什么"><a href="#1-我是什么" class="headerlink" title="1. 我是什么"></a>1. 我是什么</h3><ul><li>是让线程拥有独占的变量</li><li>它通过set、get方法进行设值和取值操作</li><li>它可以覆盖initialValue方法设置初始值，在没进行set之前调用get会调用初始化方法，一个线程只会调用一次</li><li>每个线程都会有一个指向threadLocal的弱引用，只要线程一直存活或者该threadLocal实例能被访问到，就不会被GC清理掉。当jvm内存溢出时，会清理掉值为Null的弱引用。</li></ul><h3 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2. 使用方法"></a>2. 使用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    ThreadLocal&lt;String&gt; stringThreadLocal = new ThreadLocal&lt;String&gt;()&#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected String initialValue()&#123;</span><br><span class="line">            return &quot;default string&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    for(int i = 0; i&lt; 10; i++)&#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            stringThreadLocal.set(Thread.currentThread().getName());</span><br><span class="line">            System.out.println(stringThreadLocal.get());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-我在一个map里"><a href="#3-我在一个map里" class="headerlink" title="3. 我在一个map里"></a>3. 我在一个map里</h3><p>每个线程都有一个ThreadLocalMap对象，map中存放了(ThreadLocal<t>,t)键值对<br><img src="http://ws1.sinaimg.cn/mw690/87c9e458gy1g2dhy5bvohj20me0n9q49.jpg" alt="timg">  </t></p><h4 id="3-1-get源码"><a href="#3-1-get源码" class="headerlink" title="3.1 get源码"></a>3.1 get源码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取当前线程内部的ThreadLocalMap</li><li>map存在则获取当前ThreadLocal对应的值</li><li>不存在则调用setInitialValue进行初始化</li></ul><h4 id="3-2-setInitialValue-源码"><a href="#3-2-setInitialValue-源码" class="headerlink" title="3.2 setInitialValue()源码"></a>3.2 setInitialValue()源码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private T setInitialValue() &#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调用重载的initialValue方法获取初始值</li><li>获取当前线程的ThreadLocalMap</li><li>map存在则将初始值put进去</li><li>map不存在则使用初始值为当前线程创建ThreadLocalMap</li></ul><h4 id="3-3-set-T-value-源码"><a href="#3-3-set-T-value-源码" class="headerlink" title="3.3 set(T value)源码"></a>3.3 set(T value)源码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取当前线程内部的ThreadLocalMap</li><li>map存在则把当前ThreadLocal和value添加到map中</li><li>map不存在则创建一个ThreadLocalMap，保存到当前线程内部</li></ul><p><strong>小结</strong><br>每个线程都有一个ThreadLocalMap类型的私有变量，当为线程添加ThreadLocal对象时，就是保存到了这个map中，所以线程之间不会相互干扰。</p><h3 id="4-我还有一个大坑"><a href="#4-我还有一个大坑" class="headerlink" title="4. 我还有一个大坑"></a>4. 我还有一个大坑</h3><p>ThreadLocal使用不当，会引发内存泄露的问题<br>ThreadLocal对象存在thread对象中，只要线程没有死亡，该对象就不会被回收</p><p>remove()源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void remove() &#123;</span><br><span class="line">     ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">     if (m != null)</span><br><span class="line">         m.remove(this);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><ul><li>获取当前线程内部的ThreadLocalMap，存在则从map中删除这个ThreadLocal对象。</li></ul><h3 id="5-无处不在的map"><a href="#5-无处不在的map" class="headerlink" title="5. 无处不在的map"></a>5. 无处不在的map</h3><p>分析完4个公开方法的源码，发现每个方法都离不开ThreadLocalMap类，下面分析一下这个无处不在的map。</p><ul><li>ThreadLocalMap是一个自定义的Hashmap，专门用来保存线程的ThreadLocal变量</li><li>它的操作仅限于ThreadLocal类中，不对外暴露</li><li>这个类被用在Thread类的私有变量threadLocals和inheritableThreadLocals上</li><li>为了能够保存大量且存活时间较长的threadLocal实例，hash table entries采用了WeakReferences作为key的类型</li><li>一旦hash table运行空间不足，key为null的entry就会被清理掉</li></ul><p><strong>源码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static class ThreadLocalMap &#123;</span><br><span class="line">    static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">        Object value;</span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            super(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final int INITIAL_CAPACITY = 16;</span><br><span class="line"></span><br><span class="line">    private Entry[] table;</span><br><span class="line"></span><br><span class="line">    private int size = 0;</span><br><span class="line"></span><br><span class="line">    private int threshold; // Default to 0</span><br><span class="line"></span><br><span class="line">    private void setThreshold(int len) &#123;</span><br><span class="line">        threshold = len * 2 / 3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        table = new Entry[INITIAL_CAPACITY];</span><br><span class="line">        int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);</span><br><span class="line">        table[i] = new Entry(firstKey, firstValue);</span><br><span class="line">        size = 1;</span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ThreadLocal是一个本地线程副本变量工具类，ThreadLocal的实例代表了一个线程局部的变量，主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。
      
    
    </summary>
    
    
      <category term="并发编程" scheme="http://yoursite.com/child/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-阻塞队列BQ</title>
    <link href="http://yoursite.com/child/2018/04/27/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97BQ/"/>
    <id>http://yoursite.com/child/2018/04/27/并发编程-阻塞队列BQ/</id>
    <published>2018-04-27T07:37:41.000Z</published>
    <updated>2019-06-12T09:27:09.764Z</updated>
    
    <content type="html"><![CDATA[<p>阻塞队列常用于生产者-消费者场景。</p><p>BQ有4套出队入队操作：</p><ul><li>offer(e) &amp; poll() 这套操作不会阻塞线程，队列满/空的时候返回特殊值 false/null</li><li>add(e) &amp; remove() 该操作对offer(e) &amp; pool()返回的特殊值抛出异常</li><li>put(e) &amp; take() 阻塞方法，遇到队列满/空的时候会阻塞，直到收到通知可以继续执行</li><li>offer(e,time,unit) &amp; poll(time,unit) 超时阻塞方法，超时返回 false/null </li></ul><p>Jdk7中给出了7种BQ：</p><ul><li>ArrayBlockingQueue</li><li>LinkedBlockingQueue</li><li>priorityBlockingQueue</li><li>DelayQueue</li><li>SynchronousQueue</li><li>LinkenTransferQueue</li><li>LinkedBlockingDeque</li></ul><p>本文将以LinkedBlockingQueue为例进行源码解读</p><h3 id="1-Condition"><a href="#1-Condition" class="headerlink" title="1. Condition"></a>1. Condition</h3><p>任意的一个java对象，都拥有一组监视器方法（定义在Object类中），主要包括wait()、wait(long timeout)、notify()、notifyAll()方法，这些方法与sychronized关键字配合使用，可以实现等待/通知模式。Condition接口也通过平了类似Object的监视器方法，与Lock配合可以实现等待/通知模式。但是这两种方式在使用方式以及功能特性上还是有差别的：</p><ol><li>每个Object监视器只有一个等待队列，而Condition接口可以支持多个等待队列</li><li>当前线程释放锁进入等待状态，Object监视器在等待过程中是不相应中断的，而Condition接口是可以的</li><li>Object监视器不支持线程等待到将来的某个特定时间，Condition接口支持</li></ol><h4 id="1-1-Condition的原理"><a href="#1-1-Condition的原理" class="headerlink" title="1.1 Condition的原理"></a>1.1 Condition的原理</h4><p>将在另一篇中解析AQS.ConditionObject类的源码</p><h4 id="1-2-LBQ中的Condition"><a href="#1-2-LBQ中的Condition" class="headerlink" title="1.2 LBQ中的Condition"></a>1.2 LBQ中的Condition</h4><p>LBQ的入队和出队使用了两把重入锁，相应的也有两个条件队列notFull和notEmpty：</p><ul><li>当队列满的时候执行入队操作，入队线程会进入notFull等待，当有元素出队则通知入队线程–队列notFull，可以继续执行；</li><li>当队列为空执行出队操作，出队线程会进入notEmpty等待，当有元素入队后则通知出队线程–队列notEmpty，可以继续执行。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Lock held by take, poll, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Wait queue for waiting takes */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Lock held by put, offer, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Wait queue for waiting puts */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure></li></ul><p>具体如何使用的，见下文LBQ源码分析</p><h3 id="2-offer-e-amp-poll"><a href="#2-offer-e-amp-poll" class="headerlink" title="2. offer(e) &amp; poll()"></a>2. offer(e) &amp; poll()</h3><p>这套方法是在接口 Queue<e> 中定义<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">以下代码摘自： java.util.concurrent.LinkedBlockingQueue</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="comment">//满了直接返回失败</span></span><br><span class="line">    <span class="keyword">if</span> (count.get() == capacity)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count.get() &lt; capacity) &#123;</span><br><span class="line">            enqueue(node);</span><br><span class="line">            c = count.getAndIncrement();</span><br><span class="line">            <span class="comment">//c是更新之前的计数</span></span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">                <span class="comment">//更新之后还未满，唤醒一个入队线程</span></span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//更新之前是空的，更新完就不空了，唤醒一个阻塞的出队线程</span></span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></e></p><p>offer(e)方法总结：  </p><ol><li>开始先检查参数是否为null，null则抛出NPE异常；</li><li>然后判断队列是否已经满了，满了直接返回false；</li><li>以上检查都通过，构造新节点，获取入队锁putLock</li><li>二重检查，判断队列是否未满，如果未满执行入队，计数器加1，如果计数器更新之后还小于capacity，则唤醒一个入队线程(如果有入队线程阻塞)</li><li>最后判断一下该线程入队前是否为空队列，如果之前是空的，入队完成就可以唤醒一个阻塞的出队线程。</li><li>最后入队成功返回true<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">if</span> (count.get() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    E x = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count.get() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = dequeue();</span><br><span class="line">            c = count.getAndDecrement();</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">                notEmpty.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>poll()方法总结：  </p><ol><li>首先检查队列是否空，若空直接返回null，不空继续执行；</li><li>获取出队锁takelock</li><li>二重检查，检查队列是否不空，不空执行出队，计数器减1，计数器更新之后还大于0(出队后队列还不空)，唤醒一个出队线程（如果有阻塞的出队线程）</li><li>释放锁，然后判断此次出队前队列是否满的，若出队前满则此次出队结束就有余位了，唤醒一个阻塞入队线程执行</li></ol><h3 id="3-add-e-amp-remove"><a href="#3-add-e-amp-remove" class="headerlink" title="3. add(e) &amp; remove()"></a>3. add(e) &amp; remove()</h3><p>这套方法也是在 Queue<e> 中定义，add方法继承自Collection接口，内部调用了offer(e) &amp; pool()，对队空或队满返回的特殊值做异常处理，队满执行入队操作抛 IllegalStateException 异常；队空做出队操作抛 NoSuchElementException 异常 。源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">以下代码摘自： java.util.AbstractQueue</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (offer(e))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E x = poll();</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></e></p><h3 id="4-put-e-amp-take"><a href="#4-put-e-amp-take" class="headerlink" title="4. put(e) &amp; take()"></a>4. put(e) &amp; take()</h3><p>这是阻塞接口，定义在 BlockingQueue<e> 接口中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">以下代码摘自： java.util.concurrent.LinkedBlockingQueue</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 除非设置，否则保持计数器的值为-1表示失败</span></span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//这里使用while进行判断，是因为await的线程被唤醒时从await返回，需要再进行一次判断</span></span><br><span class="line">        <span class="comment">//如果使用if的话就直接往下运行了，运行结果会不稳定。</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(node);</span><br><span class="line">        <span class="comment">//返回旧的计数然后计数+1</span></span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="comment">//入队之后如果还有位置，给notFull队列发信号，唤醒put线程</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个c是入队之前的计数，入队之前为空，入队后有元素了，所以要唤醒一个出队线程</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></e></p><p>put(e)方法总结：  </p><ol><li>检查参数为空抛NPE异常</li><li>使用参数构造新节点，获取入队锁putLock</li><li>当队满时，调用 notFull.await() 阻塞当前线程，注意此处使用while语句进行判断，原因后文分析。</li><li>队不满执行入队，计数器 +1</li><li>判断计数器更新后队是否未满，未满则唤醒阻塞的入队线程（如果存在的话）</li><li>解锁</li><li>判断此次入队前是否为空队列，如果是，此次入队完成后就不是了，所以要唤醒一个阻塞的出队线程。</li><li>无返回值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;<span class="comment">//2</span></span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();<span class="comment">//3</span></span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)<span class="comment">//4</span></span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();<span class="comment">//5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)<span class="comment">//6</span></span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;<span class="comment">//7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>take()方法总结：  </p><ol><li>获取出队锁takeLock</li><li>判断队列是否为空，为空就调用notEmpty.await()阻塞线程</li><li>不空就执行出队操作，计数器 -1</li><li>如果出队后队列仍然不空，唤醒一个阻塞的出队线程（如果存在的话）</li><li>解锁</li><li>若此次出队之前队列满，执行完本次出队就不满了，可以唤醒一个入队线程</li><li>返回出队的元素</li></ol><h3 id="5-offer-e-time-unit-amp-poll-time-unit"><a href="#5-offer-e-time-unit-amp-poll-time-unit" class="headerlink" title="5. offer(e,time,unit) &amp; poll(time, unit)"></a>5. offer(e,time,unit) &amp; poll(time, unit)</h3><p>超时阻塞方法，定义在 BlockingQueue<e> 接口中，该组方法在put/take的基础上加上了超时返回的功能，出队超时返回null，入队超时返回false。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">以下代码摘自： java.util.concurrent.LinkedBlockingQueue</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)<span class="comment">//超时了</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//没超时阻塞，nanos之后自动唤醒</span></span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">            <span class="comment">//唤醒后返回到这里，继续while循环判断队列是否满，还是满就妥妥的超时了</span></span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(<span class="keyword">new</span> Node&lt;E&gt;(e));</span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)<span class="comment">//超时了</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//没超时阻塞，nanos之后自动唤醒</span></span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">            <span class="comment">//唤醒后返回到这，继续为了循环判断队列是否为空，还是为空妥妥的超时</span></span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></e></p><h3 id="6-await之前的判断为什么用while"><a href="#6-await之前的判断为什么用while" class="headerlink" title="6. await之前的判断为什么用while"></a>6. await之前的判断为什么用while</h3><p>用put作为例子解释一下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">putLock.lockInterruptibly();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">        notFull.await();<span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line">    enqueue(node);</span><br><span class="line">    c = count.getAndIncrement(); <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">        notFull.signal();<span class="comment">//3</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    putLock.unlock();<span class="comment">//4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>假设A线程入队操作结束后(执行到2位置)，队列还剩一个空位，那么程序会唤醒阻塞队列中的put线程（3位置）B线程</li><li>B线程从await返回前需要竞争put锁（await会释放锁），但这时候有个C线程也来竞争put锁并且成功，C执行入队之后队列已经满了</li><li>C释放锁之后B获得锁，从await返回（位置1），如果这里使用 if 判断，1位置之后继续向下执行入队操作，显然会出错，因为最后一个空位让C线程用掉了</li><li>但是使用 while 判断，await返回之后，还在循环体内，继续循环判断队列是否满，发现满了，再次await。</li></ol><p>所以使用while判断其实是在这里进行了一次 double check， 不管是使用await还是wait，都需要while进行判断，不然在多线程环境中就会出错。</p><h3 id="7-其他方法"><a href="#7-其他方法" class="headerlink" title="7. 其他方法"></a>7. 其他方法</h3><ul><li>peek() 返回头结点，队列空返回null</li><li>element() 调用peak()，peak()返回null则抛异常 NoSuchElementException</li><li>remove(o) 移除指定的元素，参数接受null，若没找到该元素返回false</li><li>contains(o) 判断是否包含指定元素，参数为空或不包含返回false</li><li>remainingCapacity() 返回剩余容量</li><li>size() 返回现有元素数量</li><li>clear() 原子性的清除所有元素</li><li>drainTo(c) 将队列中的元素放到集合c中，返回转换的元素个数</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;阻塞队列常用于生产者-消费者场景。&lt;/p&gt;
&lt;p&gt;BQ有4套出队入队操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;offer(e) &amp;amp; poll() 这套操作不会阻塞线程，队列满/空的时候返回特殊值 false/null&lt;/li&gt;
&lt;li&gt;add(e) &amp;amp; remove
      
    
    </summary>
    
    
      <category term="并发编程" scheme="http://yoursite.com/child/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-共享式AQS源码详解</title>
    <link href="http://yoursite.com/child/2018/04/25/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%85%B1%E4%BA%AB%E5%BC%8FAQS%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/child/2018/04/25/并发编程-共享式AQS源码详解/</id>
    <published>2018-04-25T12:36:12.000Z</published>
    <updated>2019-05-21T06:49:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章详细的阐述了AQS在独占模式下的底层原理，本篇主要讲述共享式同步器的原理。</p><h3 id="1-acquireShared-int"><a href="#1-acquireShared-int" class="headerlink" title="1. acquireShared(int)"></a>1. acquireShared(int)</h3><p>此方式是共享模式下线程获取贡献资源的入口，他会获取指定量的资源，获取成功直接返回，失败则进入等待队列，知道获取到资源为止，整个过程忽略终端。下面看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    //</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected int tryAcquireShared(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 tryAcquireShared 依然需要自定义同步器去实现，但是AQS已经将返回值的语义定义好了，重载该函数的时候执行逻辑要符合下列语义：<br>-返回负值表示获取失败</p><ul><li>返回0表示获取成功，但是没有剩余资源</li><li>返回正数表示获取成功，还有剩余资源</li></ul><p>tryAcquireShared获取失败则执行 doAcquireShared 方法，看下面源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireShared(int arg) &#123;</span><br><span class="line">        //将线程以共享方式加入同步队列尾部</span><br><span class="line">        final Node node = addWaiter(Node.SHARED);</span><br><span class="line">        //获取失败吗，默认true（失败）</span><br><span class="line">        boolean failed = true;</span><br><span class="line">        try &#123;</span><br><span class="line">            //记录等待过程是否被中断过</span><br><span class="line">            boolean interrupted = false;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                //拿到前驱节点</span><br><span class="line">                final Node p = node.predecessor();</span><br><span class="line">                if (p == head) &#123;//如果前驱是头结点</span><br><span class="line">                    //尝试获取</span><br><span class="line">                    int r = tryAcquireShared(arg);</span><br><span class="line">                    if (r &gt;= 0) &#123;</span><br><span class="line">                        //自己获取资源的同时，如果还有剩余资源,唤醒后继节点</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = null; // help GC</span><br><span class="line">                        if (interrupted)//补上中断标志</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = false;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //前驱不是头结点，获取失败后寻找安全点</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>整个过程与acquireQueued()很相似，区别在于唤醒等待线程的条件不同。setHeadAndPropagate方法在setHead()的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line">    Node h = head; //与独占式不同原head并没有释放资源</span><br><span class="line">    setHead(node);</span><br><span class="line">    </span><br><span class="line">    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||</span><br><span class="line">        (h = head) == null || h.waitStatus &lt; 0) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        if (s == null || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-releaseShared"><a href="#2-releaseShared" class="headerlink" title="2. releaseShared()"></a>2. releaseShared()</h3><p>上一小节已经把acquireShared()说完了，这一小节就来讲讲它的反操作releaseShared()吧。此方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。下面是releaseShared()的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。例如，资源总量是13，A（5）和B（7）分别获取到资源并发运行，C（4）来时只剩1个资源就需要等待。A在运行过程中释放掉2个资源量，然后tryReleaseShared(2)返回true唤醒C，C一看只有3个仍不够继续等待；随后B又释放2个，tryReleaseShared(2)返回true唤醒C，C一看有5个够自己用了，然后C就可以跟A和B一起运行。而ReentrantReadWriteLock读锁的tryReleaseShared()只有在完全释放掉资源（state=0）才返回true，所以自定义同步器可以根据需要决定tryReleaseShared()的返回值。</p><h4 id="2-1-doReleaseShared"><a href="#2-1-doReleaseShared" class="headerlink" title="2.1 doReleaseShared()"></a>2.1 doReleaseShared()</h4><p>此方法主要用于唤醒后继。下面是它的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void doReleaseShared() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h != tail) &#123;</span><br><span class="line">            int ws = h.waitStatus;</span><br><span class="line">            if (ws == Node.SIGNAL) &#123;</span><br><span class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                    continue;            // loop to recheck cases</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ws == 0 &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                continue;                // loop on failed CAS</span><br><span class="line">        &#125;</span><br><span class="line">        if (h == head)                   // loop if head changed</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-Semaphore"><a href="#3-Semaphore" class="headerlink" title="3. Semaphore"></a>3. Semaphore</h3><p>一个具象化的例子：<br>停车场运作，假设停车场有10个车位，刚开始都是空的。如果同时来了11辆车，看守者只能允许10辆车进入，另一辆排队等候，当有车为空出来，等候车辆进入填满空车位。Semaphore就相当于停车场看守者。</p><p>和RentrantLock不同Semaphore没有实现Lock接口，获取资源有响应中断模式和忽略中断模式，中断模式获取资源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void acquire() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(1);</span><br><span class="line">&#125;</span><br><span class="line">public void acquire(int i) throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放资源统一使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void release() &#123;</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br><span class="line">public void release(int i) &#123;</span><br><span class="line">    sync.releaseShared(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部同步器sync重载的tryAcquireShared-tryRealseShared源码如下，代码逻辑简单易懂，实现自定义的同步器一般也只需要实现这几个方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//非公平</span><br><span class="line">final int nonfairTryAcquireShared(int acquires) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int available = getState();</span><br><span class="line">        int remaining = available - acquires;</span><br><span class="line">        if (remaining &lt; 0 ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            return remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//公平</span><br><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        if (hasQueuedPredecessors())</span><br><span class="line">            return -1;</span><br><span class="line">        int available = getState();</span><br><span class="line">        int remaining = available - acquires;</span><br><span class="line">        if (remaining &lt; 0 ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            return remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected final boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int current = getState();</span><br><span class="line">        int next = current + releases;</span><br><span class="line">        if (next &lt; current) // overflow</span><br><span class="line">            throw new Error(&quot;Maximum permit count exceeded&quot;);</span><br><span class="line">        if (compareAndSetState(current, next))</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上篇文章详细的阐述了AQS在独占模式下的底层原理，本篇主要讲述共享式同步器的原理。&lt;/p&gt;
&lt;h3 id=&quot;1-acquireShared-int&quot;&gt;&lt;a href=&quot;#1-acquireShared-int&quot; class=&quot;headerlink&quot; title=&quot;1. ac
      
    
    </summary>
    
    
      <category term="并发编程" scheme="http://yoursite.com/child/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>nginx入门</title>
    <link href="http://yoursite.com/child/2018/04/23/nginx%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/child/2018/04/23/nginx入门/</id>
    <published>2018-04-23T07:17:36.000Z</published>
    <updated>2019-04-26T07:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现。</p><h3 id="1、正向代理与反向代理"><a href="#1、正向代理与反向代理" class="headerlink" title="1、正向代理与反向代理"></a>1、正向代理与反向代理</h3><h4 id="1-1-正向代理：代理服务器代表的是客户端，代理对服务器端透明。"><a href="#1-1-正向代理：代理服务器代表的是客户端，代理对服务器端透明。" class="headerlink" title="1.1 正向代理：代理服务器代表的是客户端，代理对服务器端透明。"></a>1.1 正向代理：代理服务器代表的是客户端，代理对服务器端透明。</h4><p>正向代理的应用场景：  </p><ul><li>vpn  </li><li>缓存，加速访问资源  </li><li>对客户端访问授权，上网进行认证  </li><li>记录用户的上网记录，对外隐藏用户信息  </li></ul><p>正向代理产品：CCProxy  </p><h4 id="1-2-反向代理：代理服务器代表的是服务器端，代理对客户端透明"><a href="#1-2-反向代理：代理服务器代表的是服务器端，代理对客户端透明" class="headerlink" title="1.2 反向代理：代理服务器代表的是服务器端，代理对客户端透明"></a>1.2 反向代理：代理服务器代表的是服务器端，代理对客户端透明</h4><p>反向代理的应用场景：</p><ul><li>保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击</li><li>负载均衡  </li></ul><p>反向代理产品：Nginx  </p><p><img src="http://ws1.sinaimg.cn/mw690/87c9e458gy1g2cldja14kj20rm0op7wh.jpg" alt="正向代理和反向代理">  </p><h3 id="2、nginx安装"><a href="#2、nginx安装" class="headerlink" title="2、nginx安装"></a>2、nginx安装</h3><h4 id="2-1-安装环境"><a href="#2-1-安装环境" class="headerlink" title="2.1 安装环境"></a>2.1 安装环境</h4><ul><li>yum -y install wget      #安装下载工具</li><li>yum install -y gcc gcc-c++        #安装gcc编译环境</li><li>yum install -y pcre-devel          #安装PERE库</li><li>yum -y install openssl openssl-devel    #安装OpenSsl库</li></ul><h4 id="2-2-准备安装nginx"><a href="#2-2-准备安装nginx" class="headerlink" title="2.2 准备安装nginx"></a>2.2 准备安装nginx</h4><ul><li>wget <a href="http://nginx.org/download/nginx-1.14.0.tar.gz" target="_blank" rel="noopener">http://nginx.org/download/nginx-1.14.0.tar.gz</a>   #下载</li><li>tar -zxf nginx-1.14.0.tar.gz             #解压</li><li>cd nginx-1.14.0 </li><li>sed -i -e’s/1.14.0//g’ -e’ s/nginx\//WS/g’ -e’s/“NGINX”/“WS”/g’ src/core/nginx.h    #隐藏版本号(安全性考虑，爆出有些版本的nginx存在漏洞，容易被攻击)</li></ul><h4 id="2-3编译安装nginx"><a href="#2-3编译安装nginx" class="headerlink" title="2.3编译安装nginx"></a>2.3编译安装nginx</h4><ul><li>useradd www      #添加用户，不添加默认为nobody</li><li>./configure –user=www –group=www –prefix=/usr/local/nginx –with-http_ssl_module</li><li>make &amp; make install</li></ul><h3 id="3、nginx的五种负载分配算法"><a href="#3、nginx的五种负载分配算法" class="headerlink" title="3、nginx的五种负载分配算法"></a>3、nginx的五种负载分配算法</h3><h4 id="3-1-round-robin（默认）"><a href="#3-1-round-robin（默认）" class="headerlink" title="3.1 round robin（默认）"></a>3.1 round robin（默认）</h4><p>轮询方式，依次将请求分配到各个后台服务器中，默认的负载均衡方式。<br>适用于后台机器性能一致的情况。<br>挂掉的机器可以自动从服务列表中剔除。</p><h4 id="3-2-weight"><a href="#3-2-weight" class="headerlink" title="3.2 weight"></a>3.2 weight</h4><p>根据权重来分发请求到不同的机器中，指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream bakend &#123;    </span><br><span class="line">    server 192.168.0.14 weight=10;    </span><br><span class="line">    server 192.168.0.15 weight=10;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-3-IP-hash"><a href="#3-3-IP-hash" class="headerlink" title="3.3 IP_hash"></a>3.3 IP_hash</h4><p>根据请求者ip的hash值将请求发送到后台服务器中，可以保证来自同一ip的请求被打到固定的机器上，可以解决session问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream bakend &#123;    </span><br><span class="line">ip_hash;    </span><br><span class="line">server 192.168.0.14:88;    </span><br><span class="line">server 192.168.0.15:80;    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-url-hash（第三方）"><a href="#3-4-url-hash（第三方）" class="headerlink" title="3.4 url_hash（第三方）"></a>3.4 url_hash（第三方）</h4><p>根据请求的url的hash值将请求分到不同的机器中，当后台服务器为缓存的时候效率高。<br>例如：<br>在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;    </span><br><span class="line">    server squid1:3128;    </span><br><span class="line">    server squid2:3128;    </span><br><span class="line">    hash $request_uri;    </span><br><span class="line">    hash_method crc32;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-5-fair（第三方）"><a href="#3-5-fair（第三方）" class="headerlink" title="3.5 fair（第三方）"></a>3.5 fair（第三方）</h4><p>根据后台响应时间来分发请求，响应时间短的分发的请求多。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;    </span><br><span class="line">    server server1;    </span><br><span class="line">    server server2;    </span><br><span class="line">    fair;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现。&lt;/p&gt;
&lt;h3 id=&quot;1、正向代理与反向
      
    
    </summary>
    
    
      <category term="nginx" scheme="http://yoursite.com/child/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-独占式AQS源码详解</title>
    <link href="http://yoursite.com/child/2018/04/19/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E7%8B%AC%E5%8D%A0%E5%BC%8FAQS%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/child/2018/04/19/并发编程-独占式AQS源码详解/</id>
    <published>2018-04-19T12:36:12.000Z</published>
    <updated>2019-06-12T09:07:40.730Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-框架概述"><a href="#1-框架概述" class="headerlink" title="1. 框架概述"></a>1. 框架概述</h3><p>AQS是AbstractQueuedSynchronizer的简称，抽象队列同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类的实现都依赖于它，比如常用的ReentrantLock/CountDownLatch/Semaphore…</p><p>AQS维护了一个volatile int state 代表共享资源，一个FIFO线程等待队列用来记录争用资源而进入等待的线程，这里有一点需要强调，AQS同步队列中的线程是处于WAITING状态的，而竞争synchronized同步块的线程是处于BLOCKING状态的。</p><p>AQS定义了两种组员共享方式：Exclusive 和 Share</p><p>自定义同步器在实现时只需要实现共享资源state的获取与释放方式，至于具体的线程等待队列的维护，AQS已经实现好了。自定义同步器是现实需要实现的几个方法：</p><ul><li>isHeldExclusively() 该线程是否正在独占资源，只有用到Condition才需要实现它</li><li>tryAcquire(int) 独占方式获取资源，获取成功返回ture</li><li>tryRelease(int) 独占方式释放资源，释放成功返回ture</li><li>tryAcquireShared(int) 共享方式获取资源，负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int) 共享方式释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ul><p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p><p>再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p><p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p><h3 id="2-源码详解"><a href="#2-源码详解" class="headerlink" title="2. 源码详解"></a>2. 源码详解</h3><p>本节依照acquire-release、acquireShared-releaseShared的次序来讲解AQS的源码实现。</p><h4 id="2-1-acquire-int"><a href="#2-1-acquire-int" class="headerlink" title="2.1 acquire(int)"></a>2.1 acquire(int)</h4><p>该方法是在独占模式下获取共享资源的顶层入口，如果获取资源成功tryAcquire返回true，该函数直接返回，且整个过程忽略中断的影响；否则调用addWaiter将线程包装成Node对象进入阻塞队列，并不断acquireQueued获取资源。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数流程如下：</p><ol><li>tryAcquire() 尝试直接去获取资源，如果成功则直接返回；</li><li>addWaiter() 将该线程加入等待队列的尾部，并标记为独占模式；</li><li>acquireQueued() 使线程在等待队列中尝试获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li><li>如果线程在等待过程中被中断过，它是不响应的（关于中断的介绍请参考文章线程中断），获取资源后通过selfInterrupt()，将该线程的中断标志置为true。</li></ol><h5 id="2-1-1-tryAcquire-int"><a href="#2-1-1-tryAcquire-int" class="headerlink" title="2.1.1 tryAcquire(int)"></a>2.1.1 tryAcquire(int)</h5><p>此方法尝试获取独占资源，如果成功返回true，否则返回false。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>AQS中该方法没有具体的执行逻辑，这是因为这是AQS定义的一个方法模板，具体的实现需要自定义同步类自己完成，能不能重入，竞争资源时可不可以加塞，都需要子类自己设计。如果子类没有实现该方法，就会调用AQS的默认实现，如上直接抛出异常。</p><h5 id="2-1-2-addWaiter-Node"><a href="#2-1-2-addWaiter-Node" class="headerlink" title="2.1.2 addWaiter(Node)"></a>2.1.2 addWaiter(Node)</h5><p>此方法作用是将当前线程加入到阻塞队列的队尾，并返回当前线程所在节点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 尝试快速入队</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//快速入队失败，调用enq方法入队</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先介绍一下Node，Node节点是对每一个竞争同步代码的线程的封装，主要包含了当前线程对象以及线程的状态。变量waitStatus表示当前Node节点的等待状态，共有4中取值CANCELLED、SIGNAL、CONDITION、PROPAGATE</p><ul><li>CANCELLED ： 值为1，表示当前节点处于结束状态，在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该Node节点</li><li>SIGNAL 值为-1，表示当前节点线程取消或者释放资源的时候，需要unpark其后继节点</li><li>CONDITION 值为-2，表示当前节点处于条件队列，在转变（状态被设为0）之前不会被当做同步队列节点</li><li>PROPAGATE 值为-3，与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态</li><li>0 代表初始状态。</li></ul><h5 id="2-1-3-enq-Node"><a href="#2-1-3-enq-Node" class="headerlink" title="2.1.3 enq(Node)"></a>2.1.3 enq(Node)</h5><p>此方法用于将node加入队尾。源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果你看过AtomicInteger.getAndIncrement()函数源码，那么相信你一眼便看出这段代码的精华。CAS自旋volatile变量，是一种很经典的用法。</p><h5 id="2-1-4-acquireQueued-Node-int"><a href="#2-1-4-acquireQueued-Node-int" class="headerlink" title="2.1.4 acquireQueued(Node, int)"></a>2.1.4 acquireQueued(Node, int)</h5><p>通过tryAcquire()和addWaiter()，该线程获取资源失败，已经被放入等待队列尾部了，下一步该干什么？进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了。这个函数非常关键，上源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取资源失败了吗？</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//标识等待过程中是否被中断过</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获得当前节点的前驱</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//如果前驱是head，那就有资格去尝试获取</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">//获取资源成功，将自己设置成head</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">//help GC，原头结点断开与队列的链接，等待被回收</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; </span><br><span class="line">                failed = <span class="keyword">false</span>;<span class="comment">//表示获取资源成功</span></span><br><span class="line">                <span class="keyword">return</span> interrupted; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//先判断此次获取失败后可不可以 WAITTING，如果不能，继续重复循环</span></span><br><span class="line">            <span class="comment">//执行park让线程进入WAITTING状态，并判断等待过程中有没有中断，发生过就改状态</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么怎么判断线程是不是应该执行park()呢？继续看下面代码，shouldParkAfterFailedAcquire方法主要用于检查状态，看看自己是否真的可以去休息了（进入waiting状态），万一排在队列前边的线程都取消了只是瞎站着，那就需要往前加塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取前驱节点的状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">//如果前驱节点状态是SIGNAL，说明前驱节点释放资源后会通知本节点，可以安全的执行park()</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果前驱节点是取消状态CANCELLED，执行加塞操作，跳过所有取消节点</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果前驱节点状态正常有效，那就把前驱节点的状态设置成SIGNAL，前驱节点执行完释放资源就会通知本节点</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回false表示此次循环不能更改线程状态，返回到acquireQueued方法即系执行循环获取资源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个流程用一句话概括，如果前驱结点的状态不是SIGNAL，那么自己就不能放心去休息，需要去找个安全的休息点，找到安全点后可以再尝试下看能不能获取资源，再次获取失败就可以放心进入WAITTING状态。</p><p>parkAndCheckInterrupt方法就是让线程执行park()进入WAITTINGZ状态，并返回该线程的中断标志<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，Thread.interrupted()方法在获取线程中断标志的同时会将该标志复位为false</p><h5 id="2-1-5-小结"><a href="#2-1-5-小结" class="headerlink" title="2.1.5 小结"></a>2.1.5 小结</h5><p>源码再贴一遍：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>获取独占资源流程如下：<br><img src="https://ws2.sinaimg.cn/large/87c9e458ly1g3vucyalgfj20nz0jdgnc.jpg" alt="独占式AQS获取资源流程"></p><ol><li>调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回；</li><li>否则addWaiter()将该线程加入等待队列的尾部；</li><li>acquireQueued()使线程在等待队列中休息，当前驱节点为head 会去尝试获取资源，获取到资源后将自己设置为head，获取失败寻找安全点等待。注意此处寻找到安全点后不会立即park()，而是在下一次循环尝试获取失败后才会执行park()。如果在整个等待过程中被中断过，则返回true，否则返回false。</li><li>如果线程在等待过程中被中断过，它是不响应的，并且中断标志被Thread.interrupted()重置为false了，所以获取资源后才再进行自我中断selfInterrupt()，将中断标志重置为true。</li></ol><h4 id="2-2-release-int"><a href="#2-2-release-int" class="headerlink" title="2.2 release(int)"></a>2.2 release(int)</h4><p>release是独占模式下线程释放共享资源的顶层接口。它会释放指定量的资源，如果彻底释放了（即state=0），它会唤醒等待队列里的其他线程来获取资源。<br>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);<span class="comment">//唤醒后继节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>逻辑并不复杂。它调用tryRelease()来释放资源。有一点需要注意的是，它是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了。所以自定义同步器在设计tryRelease()的时候要明确这一点</p><h5 id="2-2-1-tryRelease-int"><a href="#2-2-1-tryRelease-int" class="headerlink" title="2.2.1 tryRelease(int)"></a>2.2.1 tryRelease(int)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟tryAcquire()一样，这个方法是需要独占模式的自定义同步器去实现的。正常来说，tryRelease()都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可(state-=arg)，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，release()是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回true，否则返回false。</p><h5 id="2-2-2-unparkSuccessor-Node"><a href="#2-2-2-unparkSuccessor-Node" class="headerlink" title="2.2.2 unparkSuccessor(Node)"></a>2.2.2 unparkSuccessor(Node)</h5><p>此方法用于唤醒等待队列中下一个线程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前节点的状态</span></span><br><span class="line">        <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);<span class="comment">//置0</span></span><br><span class="line">        <span class="comment">//获取下一个将唤醒的节点</span></span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="comment">//若后继节点已取消，找到最靠近head的有效节点</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="comment">//waitStatus&lt;=0的都是有效节点，都可以唤醒</span></span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">            LockSupport.unpark(s.thread);<span class="comment">//唤醒</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>一句话概括，用用unpark()唤醒等待队列中最前边的那个有效线程。</p><h3 id="3-ReentrantLock"><a href="#3-ReentrantLock" class="headerlink" title="3. ReentrantLock"></a>3. ReentrantLock</h3><p>ReentrantLock自身没有继承AQS，但是它持有一个AQS的子类Sync的对象实例sync，Sync又派生了两个子类 FairSync 和 NonfairSync。ReentrantLock实例化时，无参的默认构造函数会使用NonfairSync对sync进行初始化；而接受一个布尔型变量的构造函数根据用户传入的参数决定使用公平锁还是非公平锁。</p><p>公平性是针对锁获取而言的，如果是公平锁，那么锁的获取顺序应该符合请求的绝对时间顺序，也就是FIFO，该原则保证公平的代价是进行大量的线程切换。非公平锁虽然可能造成线程饥饿，但是极少的线程切换保证了其更大的吞吐量，因此ReentrantLock默认实现非公平锁。</p><h4 id="3-1-获取锁"><a href="#3-1-获取锁" class="headerlink" title="3.1 获取锁"></a>3.1 获取锁</h4><p>下面代码是非公平锁和公平锁分别获取资源的操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程对象</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="comment">//如果资源空闲，CAS设置状态量</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果资源被占用，判断持有锁的线程是不是本线程，是的话重入</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重入锁的意义就是持有锁的线程可以多次重复进入临界区，而不需要在同步队列中等待，每次进入状态量加1，进入几次就要释放几次，释放1次状态量减1，当状态量为0时，完全释放资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    int c = getState();</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">    //注意与非公平锁的区别</span><br><span class="line">        if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较以上两个获取资源的函数，发现唯一的区别在于公平锁在设置状态量之前多做了一次判断 !hasQueuedPredecessors()，该函数返回是否有线程排在当前线程前面，如果没有则可以获得锁。hasQueuedPredecessors源码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final boolean hasQueuedPredecessors() &#123;</span><br><span class="line">        Node t = tail; // Read fields in reverse initialization order</span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        //队列中不止一个线程</span><br><span class="line">        //并且第二个线程节点为空或者第二个节点不是是自己</span><br><span class="line">        return h != t &amp;&amp;</span><br><span class="line">            ((s = h.next) == null || s.thread != Thread.currentThread());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-2-释放锁"><a href="#3-2-释放锁" class="headerlink" title="3.2 释放锁"></a>3.2 释放锁</h4><p>释放操作没有公平与非公平之分，所以释放操作是在父类Sync中实现，下面看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    int c = getState() - releases;</span><br><span class="line">    //如果当前线程不是占用线程，抛异常</span><br><span class="line">    if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    boolean free = false;</span><br><span class="line">    //状态量等于0，才是真正释放</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        free = true;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为释放锁之前，当前线程还持有锁，其他线程无权访问，所以修改状态没有用CAS，直接使用setState</p><p>共享式同步器 请看下一篇 并发编程-共享式AQS源码详解</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-框架概述&quot;&gt;&lt;a href=&quot;#1-框架概述&quot; class=&quot;headerlink&quot; title=&quot;1. 框架概述&quot;&gt;&lt;/a&gt;1. 框架概述&lt;/h3&gt;&lt;p&gt;AQS是AbstractQueuedSynchronizer的简称，抽象队列同步器，AQS定义了一套多线
      
    
    </summary>
    
    
      <category term="并发编程" scheme="http://yoursite.com/child/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>spring-HV参数校验</title>
    <link href="http://yoursite.com/child/2018/04/02/spring-HV%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"/>
    <id>http://yoursite.com/child/2018/04/02/spring-HV参数校验/</id>
    <published>2018-04-02T07:39:40.000Z</published>
    <updated>2019-05-23T02:59:16.742Z</updated>
    
    <content type="html"><![CDATA[<p>参数验证是一个常见的问题，无论是前端还是后台，都需对用户输入进行验证，以此来保证系统数据的正确性。对于web来说，有些人可能理所当然的想在前端验证就行了，但这样是非常错误的做法，前端代码对于用户来说是透明的，稍微有点技术的人就可以绕过这个验证，直接提交数据到后台。无论是前端网页提交的接口，还是提供给外部的接口，参数验证随处可见，也是必不可少的。前端做验证只是为了用户体验，比如控制按钮的显示隐藏，单页应用的路由跳转等等。后端才是最终的保障。总之，一切用户的输入都是不可信的。</p><h3 id="1、gradle依赖"><a href="#1、gradle依赖" class="headerlink" title="1、gradle依赖"></a>1、gradle依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;org.springframework.boot:spring-boot-starter-validation&apos;</span><br></pre></td></tr></table></figure><h3 id="2、常用约束"><a href="#2、常用约束" class="headerlink" title="2、常用约束"></a>2、常用约束</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Null             被注释的元素必须为 null     </span><br><span class="line">@NotNull          被注释的元素必须不为 null     </span><br><span class="line">@AssertTrue       被注释的元素必须为 true     </span><br><span class="line">@AssertFalse      被注释的元素必须为 false     </span><br><span class="line">@Min(value)       被注释的元素必须是一个数字，其值必须大于等于指定的最小值     </span><br><span class="line">@Max(value)       被注释的元素必须是一个数字，其值必须小于等于指定的最大值     </span><br><span class="line">@DecimalMin(value)  被注释的元素必须是一个数字，其值必须大于等于指定的最小值 </span><br><span class="line">@DecimalMax(value)  被注释的元素必须是一个数字，其值必须小于等于指定的最大值</span><br><span class="line">@Size(max=, min=)   被注释的元素的大小必须在指定的范围内     </span><br><span class="line">@Digits (integer, fraction)  被注释的元素必须是一个数字，其值必须在可接受的范围内     </span><br><span class="line">@Past   被注释的元素必须是一个过去的日期     </span><br><span class="line">@Future     被注释的元素必须是一个将来的日期     </span><br><span class="line">@Pattern(regex=,flag=)  被注释的元素必须符合指定的正则表达式Hibernate Validator附加的constraint     </span><br><span class="line">@NotBlank(message =)   验证字符串非null，且长度必须大于0     </span><br><span class="line">@Email  被注释的元素必须是电子邮箱地址     </span><br><span class="line">@Length(min=,max=)  被注释的字符串的大小必须在指定的范围内     </span><br><span class="line">@NotEmpty   被注释的字符串的必须非空     </span><br><span class="line">@Range(min=,max=,message=)  被注释的元素必须在合适的范围内</span><br></pre></td></tr></table></figure><h3 id="3、使用方法"><a href="#3、使用方法" class="headerlink" title="3、使用方法"></a>3、使用方法</h3><ul><li>在model类中使用注解约束字段</li><li>接口中需要校验的model对象前使用@Valid注解，并在接口方法参数列表中增加BindingResult对象来接受校验错误信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(value = &quot;/demo&quot;)</span><br><span class="line">    public Integer addDemo(@Valid @RequestBody Demo demo, BindingResult bindingResult)&#123;</span><br><span class="line">        if(bindingResult.hasErrors())&#123;</span><br><span class="line">            for(ObjectError error : bindingResult.getAllErrors())&#123;</span><br><span class="line">                throw new DemoException(DemoExceptionEnum.PARAM_ERROR.getCode(),error.getDefaultMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return demoService.insert(demo);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意：如果在一个接口中有多个参数需要校验，那么每一个参数都需要定义一个BindingResult对象来接收校验结果</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void test()(@RequestBody @Valid DemoModel demo, BindingResult result)</span><br><span class="line"></span><br><span class="line">public void test()(@RequestBody @Valid DemoModel demo, BindingResult result,@RequestBody @Valid DemoModel demo2, BindingResult result2)</span><br></pre></td></tr></table></figure><h3 id="4、深入使用"><a href="#4、深入使用" class="headerlink" title="4、深入使用"></a>4、深入使用</h3><h4 id="4-1-配置校验模式"><a href="#4-1-配置校验模式" class="headerlink" title="4.1 配置校验模式"></a>4.1 配置校验模式</h4><ul><li>默认的校验模式为<strong>普通模式</strong>，普通模式下会校验完所有的属性然后返回所有的校验失败信息</li><li>可配置为<strong>快速失败返回模式</strong>，只要有一个属性校验失败则立即返回</li></ul><blockquote><p>配置方式</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ValidatorConfiguration &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Validator validator()&#123;</span><br><span class="line">        ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )</span><br><span class="line">                .configure()</span><br><span class="line">            　　/**设置validator模式为快速失败返回*/</span><br><span class="line">                .addProperty( &quot;hibernate.validator.fail_fast&quot;, &quot;true&quot; )</span><br><span class="line">                .buildValidatorFactory();</span><br><span class="line">        Validator validator = validatorFactory.getValidator();</span><br><span class="line"></span><br><span class="line">        return validator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-分组校验"><a href="#4-2-分组校验" class="headerlink" title="4.2 分组校验"></a>4.2 分组校验</h4><ul><li><p>使用场景：针对同一个model类，不同的接口需要对不同的属性进行校验  </p><blockquote><p>例如，数据插入接口与数据更新接口需要校验的参数是不同的</p><ul><li>使用方法  <ol><li>在model类中定义内部接口 </li><li>约束增加组别属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;    public class Demo&#123;</span><br><span class="line">&gt;        public interface AddGorup&#123;&#125;</span><br><span class="line">&gt;        public interface UpdateGroup&#123;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></li></ul></blockquote><pre><code>@Range(min = 1,max = Integer.MAX_VALUE,groups = {UpdateGroup.class})private Integer id;@Email(groups = {AddGroup.class,UpdateGroup.class})private String email;@Past(groups = {UpdateGroup.class})private Date birthday; </code></pre><p>  }</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   3. 在接口中使用@Validated(&#123;Demo.AddGroup.class&#125;)来注解参数，表示该参数使用AddGroup来进行校验</span><br><span class="line">     </span><br><span class="line">     &gt;约束的groups属性中可以填写多个接口名，表示该参数加入多个组进行校验</span><br><span class="line">   4. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 4.3 自定义约束</span><br><span class="line">- 创建约束标注</span><br></pre></td></tr></table></figure></li></ul><p>@Target({ElementType.METHOD,ElementType.ANNOTATION_TYPE,ElementType.FIELD,ElementType.PARAMETER})<br>@Retention(RetentionPolicy.RUNTIME)<br>@Constraint(validatedBy = DemoConstraintValidator.class)<br>@Documented<br>public @interface DemoConstraint {<br>    String message() default “default message”;<br>    Class&lt;?&gt;[] groups() default {};<br>    Class&lt;? extends Payload&gt;[] payload() default {};<br>    E value();//约束中设置的value值<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 实现一个验证器</span><br></pre></td></tr></table></figure></p><p>/**</p><ul><li>T  自定义的约束注解类型DemoConstraint</li><li><p>V  需要检验的参数类型<br>public class DemoConstraintValidator implements ConstraintValidator&lt;T, V&gt;{<br> private E value;//注入设置的具体约束<br> @Override<br> public void initialize(T t) {</p><pre><code>this.value = t.value();</code></pre><p> }</p><p> @Override<br> public boolean isValid(V v, ConstraintValidatorContext constraintValidatorContext) {</p><pre><code>//根据value 对 参数v 进行一些判断return true;if(!isValid) {    constraintContext.disableDefaultConstraintViolation();    constraintContext.buildConstraintViolationWithTemplate(&quot;new default message&quot;).addConstraintViolation();    return false;}</code></pre><p> }<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  &gt;T表示创建的注解，V表示该约束校验的数据类型</span><br><span class="line">- 定义默认的验证错误信息  </span><br><span class="line">可以通过ConstraintValidatorContext修改默认的message信息，一旦使用，在注解中给message赋值将不起作用（一般情况下不推荐使用）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 4.4 检验组序列</span><br><span class="line">默认情况下，约束的计算没有特定的顺序，这与它们属于哪个组无关。然而，在某些情况下，控制约束求值的顺序是有用的，例如，我们可以要求在检查汽车的道路价值之前，首先通过所有默认的汽车约束。最后，在我们开车离开之前，我们检查了实际司机的约束条件。为了实现这样的顺序，需要定义一个新的接口，并使用@GroupSequence对其进行注释，以定义必须验证组的顺序。</span><br><span class="line">~~~</span><br><span class="line">注意：</span><br><span class="line">如果这个校验组序列中有一个约束条件没有通过验证的话, 那么此约束条件后面的都不会再继续被校验了.</span><br><span class="line">~~~</span><br></pre></td></tr></table></figure></li></ul><p>@GroupSequence({Default.class, CarChecks.class, DriverChecks.class})<br>public interface OrderedChecks {<br>}<br><code>`</code></p><h3 id="5、-Valid-amp-Validated"><a href="#5、-Valid-amp-Validated" class="headerlink" title="5、@Valid  &amp; @Validated"></a>5、@Valid  &amp; @Validated</h3><table><thead><tr><th>用法</th><th style="text-align:center">@valid</th><th style="text-align:center">@validated</th></tr></thead><tbody><tr><td>类名前</td><td style="text-align:center"></td><td style="text-align:center">√</td></tr><tr><td>类属性前</td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td>方法前</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td>入参前</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr></tbody></table><blockquote><ul><li>类名前是否加@Validated只影响@RequestParam注解的参数校验，如要进行校验，必须加。  </li><li>不需要分组校验的情况下，接口入参之前只能注解@Valid才能正常校验</li><li>需要分组校验的时候，接口入参之前需要使用@Validated({GroupA.class,…})才能正常校验</li><li>@Valid用在类成员属性名之前，是为了实现嵌套校验</li></ul></blockquote><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://docs.jboss.org/hibernate/validator/4.2/reference/zh-CN/html_single/#preface" target="_blank" rel="noopener">官方文档</a><br><a href="https://www.cnblogs.com/mr-yang-localhost/p/7812038.html" target="_blank" rel="noopener">springboot使用hibernate validator校验</a><br><a href="https://blog.csdn.net/qq_27680317/article/details/79970590" target="_blank" rel="noopener">@Validated和@Valid区别</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参数验证是一个常见的问题，无论是前端还是后台，都需对用户输入进行验证，以此来保证系统数据的正确性。对于web来说，有些人可能理所当然的想在前端验证就行了，但这样是非常错误的做法，前端代码对于用户来说是透明的，稍微有点技术的人就可以绕过这个验证，直接提交数据到后台。无论是前端
      
    
    </summary>
    
    
      <category term="spring" scheme="http://yoursite.com/child/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-锁</title>
    <link href="http://yoursite.com/child/2018/04/01/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E9%94%81/"/>
    <id>http://yoursite.com/child/2018/04/01/并发编程-锁/</id>
    <published>2018-04-01T04:32:12.000Z</published>
    <updated>2019-05-28T14:57:42.154Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-基础"><a href="#1-基础" class="headerlink" title="1 基础"></a>1 基础</h3><h4 id="1-1-锁的类型"><a href="#1-1-锁的类型" class="headerlink" title="1.1 锁的类型"></a>1.1 锁的类型</h4><p>锁从宏观上分类，分为悲观锁与乐观锁。</p><p><strong>乐观锁</strong>是一种乐观思想，认为读多写少，遇到并发写的可能性低。每次读数据的时候，都认为别的线程没有修改过数据，所以不会上锁；但是写数据的时候会判断一下其他线程有没有更新过该数据。具体操作方式是：先读出当前版本号，然后加锁操作，如果跟之前的版本号一致则更新，否则重复 读-比较-写 的操作。java中的乐观锁基本上都是使用CAS实现的。</p><p><strong>悲观锁</strong>就是一种悲观思想，认为写多读少，遇到并发写的可能性高。每次读数据的时候都认为会被其他线程修改，所以每次读写都会上锁。java中的 synchronized 即使悲观锁，而AQS框架下的锁先是尝试CAS乐观锁去获取，获取不到才会转换为悲观锁，如ReentrantLock。</p><h4 id="1-2-java线程阻塞的代价"><a href="#1-2-java线程阻塞的代价" class="headerlink" title="1.2 java线程阻塞的代价"></a>1.2 java线程阻塞的代价</h4><p>java的线程是映射到操作系统原生线程上的，如果要阻塞或唤醒一个线程就需要操作系统介入，操作系统需要在用户态与核心态之间转换，这种切换会消耗大量的系统资源（因为用户态与核心态有各自的内存区域、寄存器等资源，用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。）</p><ul><li>如果线程状态切换是一个高频操作时，这将会消耗很多CPU处理时间；</li><li>如果对于那些需要同步的简单的代码块，获取锁挂起操作消耗的时间比用户代码执行的时间还要长，这种同步策略显然非常糟糕的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java线程的 WAITING 和 BLOCKED 状态对于操作系统来说其实是一回事，都是暂停线程，都需要进行上下文切换。</span><br><span class="line">他们的区别在于唤醒方式不同，W 是用户主动唤醒，而 B 是系统自动唤醒。</span><br></pre></td></tr></table></figure></li></ul><p>synchronized会导致争用不到锁的线程进入阻塞状态，所以说它是java语言中一个重量级的同步操纵，被称为重量级锁，为了缓解上述性能问题，JVM从1.5开始，引入了轻量锁与偏向锁，默认启用了自旋锁，他们都属于乐观锁。</p><p>明确java线程切换的代价，是理解java中各种锁的优缺点的基础。</p><h3 id="1-3-MarkWord"><a href="#1-3-MarkWord" class="headerlink" title="1.3 MarkWord"></a>1.3 MarkWord</h3><p>markword是java对象数据结构中的一部分，对象的markword和java各种类型的锁密切相关。</p><p>markword数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，它的最后2bit是锁状态标志位，用来标记当前对象的状态，对象的所处的状态，决定了markword存储的内容，如下表所示:  </p><table><thead><tr><th>状态</th><th>标志位</th><th>存储内容</th></tr></thead><tbody><tr><td>未锁定</td><td>01</td><td>对象哈希码、对象分代年龄</td></tr><tr><td>轻量级锁定</td><td>00</td><td>指向锁记录的指针</td></tr><tr><td>膨胀(重量级锁定)</td><td>10</td><td>执行重量级锁定的指针</td></tr><tr><td>GC标记</td><td>11</td><td>空(不需要记录信息)</td></tr><tr><td>可偏向</td><td>01</td><td>偏向线程ID、偏向时间戳、对象分代年龄</td></tr></tbody></table><p>32位虚拟机在不同状态下markword结构如下图所示：<br><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Mark%20Word.png" alt="MarkWord"><br>了解了markword结构，有助于后面了解java锁的加锁解锁过程；</p><p><strong>小结：</strong><br>前面提到了java的4种锁，他们分别是重量级锁、自旋锁、轻量级锁和偏向锁，<br>不同的锁有不同特点，每种锁只有在其特定的场景下，才会有出色的表现，java中没有哪种锁能够在所有情况下都能有出色的效率，引入这么多锁的原因就是为了应对不同的情况；</p><p>前面讲到了重量级锁是悲观锁的一种，自旋锁、轻量级锁与偏向锁属于乐观锁，所以现在你就能够大致理解了他们的适用范围，但是具体如何使用这几种锁呢，就要看后面的具体分析他们的特性；</p><h3 id="2-java中的锁"><a href="#2-java中的锁" class="headerlink" title="2. java中的锁"></a>2. java中的锁</h3><h4 id="2-1-自旋锁"><a href="#2-1-自旋锁" class="headerlink" title="2.1 自旋锁"></a>2.1 自旋锁</h4><p>自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p><p>但是线程自旋是需要消耗cup的，说白了就是让cup在做无用功，线程不能一直占用cup自旋做无用功，所以需要设定一个自旋等待的最大时间。</p><p>如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。</p><p><strong>优缺点</strong>  自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起操作的消耗！</p><p>但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用cpu做无用功，占着XX不XX，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要cup的线程又不能获取到cpu，造成cpu的浪费。</p><p>自旋锁时间阈值<br>自旋锁的目的是为了占着CPU的资源不释放，等到获取到锁立即进行处理。但是如何去选择自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用CPU资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要！</p><p>JVM对于自旋周期的选择，jdk1.5这个限度是一定的写死的，在1.6引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间，同时JVM还针对当前CPU的负荷情况做了较多的优化</p><ol><li>如果平均负载小于CPUs则一直自旋</li><li>如果有超过(CPUs/2)个线程正在自旋，则后来线程直接阻塞</li><li>如果正在自旋的线程发现Owner发生了变化则延迟自旋时间（自旋计数）或进入阻塞</li><li>如果CPU处于节电模式则停止自旋</li><li>自旋时间的最坏情况是CPU的存储延迟（CPU A存储了一个数据，到CPU B得知这个数据直接的时间差）</li><li>自旋时会适当放弃线程优先级之间的差异</li></ol><h4 id="2-2-重量级锁Synchronized"><a href="#2-2-重量级锁Synchronized" class="headerlink" title="2.2 重量级锁Synchronized"></a>2.2 重量级锁Synchronized</h4><h5 id="2-2-1-Synchronized的作用"><a href="#2-2-1-Synchronized的作用" class="headerlink" title="2.2.1 Synchronized的作用"></a>2.2.1 Synchronized的作用</h5><p>在JDK1.5之前都是使用synchronized关键字保证同步的，<br>它可以把任意一个非NULL的对象当作锁。</p><ul><li>作用于方法时，锁住的是对象的实例(this)；</li><li>当作用于静态方法时，锁住的是Class实例，又因为Class的相关数据存储在永久带PermGen（jdk1.8则是metaspace），永久带是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程；</li><li>当作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。</li></ul><h5 id="2-2-2-Synchronized的实现"><a href="#2-2-2-Synchronized的实现" class="headerlink" title="2.2.2 Synchronized的实现"></a>2.2.2 Synchronized的实现</h5><p>它有多个队列，当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中，如下如所示：<br><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.png" alt="重量级锁">  </p><ol><li>Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；</li><li>Entry List：Contention List中那些有资格成为候选资源的线程被移动到Entry List中；</li><li>Wait Set：哪些调用wait方法被阻塞的线程被放置在这里；</li><li>OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为OnDeck；</li><li>Owner：当前已经获取到所资源的线程被称为Owner；</li><li>!Owner：当前释放锁的线程。</li></ol><p>JVM每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下，ContentionList会被大量的并发线程进行CAS访问，为了降低对尾部元素的竞争，JVM会将一部分线程移动到EntryList中作为候选竞争线程。Owner线程会在unlock时，将ContentionList中的部分线程迁移到EntryList中，并指定EntryList中的某个线程为OnDeck线程（一般是最先进去的那个线程）。Owner线程并不直接把锁传递给OnDeck线程，而是把锁竞争的权利交给OnDeck，OnDeck需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在JVM中，也把这种选择行为称之为“竞争切换”。</p><p>OnDeck线程获取到锁资源后会变为Owner线程，而没有得到锁资源的仍然停留在EntryList中。如果Owner线程被wait方法阻塞，则转移到WaitSet队列中，直到某个时刻通过notify或者notifyAll唤醒，会重新进去EntryList中。</p><p>处于ContentionList、EntryList、WaitSet中的线程都处于阻塞状态，该阻塞是由操作系统来完成的（Linux内核下采用pthread_mutex_lock内核函数实现的）。</p><h5 id="2-2-3-Synchronized的非公平性"><a href="#2-2-3-Synchronized的非公平性" class="headerlink" title="2.2.3 Synchronized的非公平性"></a>2.2.3 Synchronized的非公平性</h5><ul><li>Synchronized在线程进入ContentionList时，等待的线程会先尝试自旋获取锁，如果获取不到就进入ContentionList，这明显对于已经进入队列的线程是不公平的</li><li>自旋获取锁的线程还可能直接抢占OnDeck线程的锁资源。</li></ul><h4 id="2-3-偏向锁"><a href="#2-3-偏向锁" class="headerlink" title="2.3 偏向锁"></a>2.3 偏向锁</h4><p>Java偏向锁(Biased Locking)是Java6引入的一项多线程优化。<br>偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，这种情况下，就会给线程加一个偏向锁。<br>如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。</p><h5 id="2-3-1-偏向锁的实现"><a href="#2-3-1-偏向锁的实现" class="headerlink" title="2.3.1 偏向锁的实现"></a>2.3.1 偏向锁的实现</h5><ul><li>偏向锁获取过程：</li></ul><ol><li>访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01，确认为可偏向状态。</li><li>如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤5，否则进入步骤3。</li><li>如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行5；如果竞争失败，执行4。</li><li>如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。（撤销偏向锁的时候会导致stop the word）</li><li>执行同步代码。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：第四步中到达安全点safepoint会导致stop the word，时间很短。</span><br></pre></td></tr></table></figure></li></ol><ul><li>偏向锁的释放：</li></ul><p>偏向锁的撤销在上述第四步骤中有提到。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p><h5 id="2-3-2-偏向锁的适用场景"><a href="#2-3-2-偏向锁的适用场景" class="headerlink" title="2.3.2 偏向锁的适用场景"></a>2.3.2 偏向锁的适用场景</h5><p>始终只有一个线程在执行同步块，在它没有执行完释放锁之前，没有其它线程去执行同步块，在锁无竞争的情况下使用，一旦有了竞争就升级为轻量级锁，升级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁的时候会导致stop the word操作；<br>在有锁的竞争时，偏向锁会多做很多额外操作，尤其是撤销偏向所的时候会导致进入安全点，安全点会导致stw，导致性能下降，所以高并发的应用会禁用掉偏向锁。</p><h5 id="2-3-3-jvm开启-关闭偏向锁"><a href="#2-3-3-jvm开启-关闭偏向锁" class="headerlink" title="2.3.3 jvm开启/关闭偏向锁"></a>2.3.3 jvm开启/关闭偏向锁</h5><p>开启偏向锁：-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0<br>关闭偏向锁：-XX:-UseBiasedLocking</p><h4 id="2-4-轻量级锁"><a href="#2-4-轻量级锁" class="headerlink" title="2.4 轻量级锁"></a>2.4 轻量级锁</h4><p>轻量级锁是由偏向所升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁； </p><p>轻量级锁的加锁过程：</p><ol><li>在代码进入同步块之前，如果同步对象锁状态为无锁状态（偏向锁标志为“0”，锁标志位为“01”），JVM会在当前线程的栈桢中创建用于存储<strong>锁记录</strong>的空间，并将对象头中的MarkWord复制到锁记录中，官方称为Displaced Mark Word。</li><li>然后线程尝试使用CAS将对象头中的Mark Word替换为指向该线程锁记录的指针。</li><li>如果成功，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”</li><li>如果失败，表示有其他线程竞争锁，当前线程自旋来获取锁。</li></ol><p>轻量级锁解锁过程：</p><ol><li>轻量级解锁时，会使用CAS操作将Displaced Mark Word替换回对象头</li><li>如果替换失败，说明有其他线程尝试过获取该锁（此时锁已膨胀成重量级），那就要在释放锁的同时，唤醒被挂起的线程。</li></ol><h4 id="2-5-锁升级过程"><a href="#2-5-锁升级过程" class="headerlink" title="2.5 锁升级过程"></a>2.5 锁升级过程</h4><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B%E5%9B%BE.jpeg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-基础&quot;&gt;&lt;a href=&quot;#1-基础&quot; class=&quot;headerlink&quot; title=&quot;1 基础&quot;&gt;&lt;/a&gt;1 基础&lt;/h3&gt;&lt;h4 id=&quot;1-1-锁的类型&quot;&gt;&lt;a href=&quot;#1-1-锁的类型&quot; class=&quot;headerlink&quot; title=&quot;1
      
    
    </summary>
    
    
      <category term="并发编程" scheme="http://yoursite.com/child/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis-批量操作数据库</title>
    <link href="http://yoursite.com/child/2018/03/21/Mybatis-%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/child/2018/03/21/Mybatis-批量操作数据库/</id>
    <published>2018-03-21T02:01:21.000Z</published>
    <updated>2019-06-25T14:08:38.120Z</updated>
    
    <content type="html"><![CDATA[<h3 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Insert</span>(<span class="string">"&lt;script&gt;"</span> +</span><br><span class="line">            <span class="string">"INSERT INTO patent_post_info(patent_id,post_time,post_information) values "</span>+</span><br><span class="line">            <span class="string">"&lt;foreach collection =\"postInfos\" item=\"postInfo\" index= \"index\" separator =\",\"&gt;"</span> +</span><br><span class="line">            <span class="string">"("</span>+</span><br><span class="line">            <span class="string">"#&#123;patentId&#125;, "</span> +</span><br><span class="line">            <span class="string">"CAST (#&#123;postInfo.postTime&#125; AS timestamp),"</span>+</span><br><span class="line">            <span class="string">"#&#123;postInfo.postInformation&#125;"</span>+</span><br><span class="line">            <span class="string">")"</span> +</span><br><span class="line">            <span class="string">"&lt;/foreach &gt;"</span>+</span><br><span class="line">            <span class="string">"&lt;/script&gt;"</span></span><br><span class="line">    )</span><br><span class="line">    <span class="function">Integer <span class="title">insertPatentPostInfo</span><span class="params">(@Param(<span class="string">"patentId"</span>)</span>Integer id, @<span class="title">Param</span><span class="params">(<span class="string">"postInfos"</span>)</span>List&lt;PatentPostInfo&gt; postInfos)</span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure><h3 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h3><p>以下示例展示了更新两个字段，每一个字段使用一个<foerach>片段<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Update</span>(<span class="string">"&lt;script&gt;"</span>+</span><br><span class="line">           <span class="string">"UPDATE order_items "</span> +</span><br><span class="line">           <span class="string">"SET "</span> +</span><br><span class="line">           <span class="string">"goods_total_price="</span> +</span><br><span class="line">           <span class="string">"&lt;foreach collection=\"orderItems\" item=\"orderItem\"index=\"index\" separator=\" \" open=\"CASE id\" close=\"END\"&gt;"</span> +</span><br><span class="line">           <span class="string">"WHEN #&#123;orderItem.id&#125; THEN #&#123;orderItem.goodsTotalPrice&#125;"</span> +</span><br><span class="line">           <span class="string">"&lt;/foreach&gt;"</span> +</span><br><span class="line">           <span class="string">",goods_name="</span>+</span><br><span class="line">           <span class="string">"&lt;foreach collection=\"list\" item=\"orderItem\" index=\"index\" separator=\" \" open=\"CASE id\" close=\"END\"&gt;"</span> +</span><br><span class="line">           <span class="string">"WHEN #&#123;orderItem.id&#125; THEN #&#123;orderItem.goodsName&#125;"</span> +</span><br><span class="line">           <span class="string">"&lt;/foreach&gt;"</span> +</span><br><span class="line">           <span class="string">"WHERE id IN "</span> +</span><br><span class="line">           <span class="string">"&lt;foreach collection=\"list\" item=\"orderItem\" index=\"index\" separator=\",\" open=\"(\" close=\")\"&gt;"</span> +</span><br><span class="line">           <span class="string">"#&#123;orderItem.id&#125;"</span>+</span><br><span class="line">           <span class="string">"&lt;/foreach&gt;"</span> +</span><br><span class="line">           <span class="string">"&lt;/script&gt;"</span>)</span><br><span class="line">   <span class="function">Integer <span class="title">bathUpdateOrderItem</span><span class="params">(@Param(<span class="string">"orderItems"</span>)</span>List&lt;OrderItemCustom&gt; orderItems) <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure></foerach></p><h3 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h3><p>使用数组接受参数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Delete</span>(<span class="string">"&lt;script&gt;"</span> +</span><br><span class="line">            <span class="string">"DELETE FROM order_items WHERE id IN"</span> +</span><br><span class="line">            <span class="string">"&lt;foreach collection=\"ids\" item=\"itemId\" index=\"index\" separator=\",\" open=\"(\" close=\")\"&gt;"</span>+</span><br><span class="line">                <span class="string">"#&#123;itemId&#125;"</span> +</span><br><span class="line">            <span class="string">"&lt;/foreach&gt;"</span>+</span><br><span class="line">            <span class="string">"&lt;/script&gt;"</span></span><br><span class="line">    )</span><br><span class="line">    <span class="function">Integer <span class="title">bathdeleteOrderItem</span><span class="params">(@Param(<span class="string">"ids"</span>)</span> Integer[] itemIds)<span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure></p><p>controller中使用 @RequestParam 注解修饰数组，请求时将参数拼接到url后面（类似Get请求）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;批量插入&quot;&gt;&lt;a href=&quot;#批量插入&quot; class=&quot;headerlink&quot; title=&quot;批量插入&quot;&gt;&lt;/a&gt;批量插入&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
      
    
    </summary>
    
    
      <category term="Mybatis" scheme="http://yoursite.com/child/tags/Mybatis/"/>
    
  </entry>
  
</feed>
