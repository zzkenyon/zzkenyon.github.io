<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>黑风雅过吟</title>
  
  <subtitle>不积跬步无以至千里</subtitle>
  <link href="/zzkenyon.github.io/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/child/"/>
  <updated>2020-07-16T09:30:33.512Z</updated>
  <id>http://yoursite.com/child/</id>
  
  <author>
    <name>Zhao Zhengkang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot-事务源码分析</title>
    <link href="http://yoursite.com/child/2020/06/21/SpringBoot-%E4%BA%8B%E5%8A%A1%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/child/2020/06/21/SpringBoot-事务源码分析/</id>
    <published>2020-06-20T16:00:00.000Z</published>
    <updated>2020-07-16T09:30:33.512Z</updated>
    
    <content type="html"><![CDATA[<h3 id="复习总结："><a href="#复习总结：" class="headerlink" title="复习总结："></a>复习总结：</h3><ul><li>注解式事务是通过aop实现的，底层是cglib动态代理实现的<ul><li>事务aop场景中的Advice是<code>TransactionInterceptor</code></li><li>PointCut是<code>TransactionAttributeSourcePointcut</code>，它通过<code>TransactionAttributeSource</code>来检测@Transactional注解，因此注解可以理解为切面</li></ul></li><li><code>TransactionInterceptor</code>作为事务增强逻辑的封装类，需要持有逻辑事务管理器引用，不同的数据持久化平台都实现了自己的事务管理器</li><li>项目中使用多种持久化平台时，建议在事务注解中显示的指定事务管理器</li></ul><hr><h4 id="1-springboot事务自动装配"><a href="#1-springboot事务自动装配" class="headerlink" title="1. springboot事务自动装配"></a>1. springboot事务自动装配</h4><p>spring-boot-autoconfigurae 包中对事物有自动配置的支持，自动配置类为<code>TransactionAutoConfiguration</code>，在<code>spring.factories</code>文件中可以找到这条自动配置项，源码分析先从自动装配开始，看看spring-boot装配了哪些事务相关的bean。</p><p><code>TransactionAutoConfiguration</code>中只显示定义了以下的三个bean，辅助bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个PlatformTransactionManagerCustomizer列表</span></span><br><span class="line"><span class="comment"> * springboot提供的扩展点，使用它可以对事务管理器进行一些配置，</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">TransactionManagerCustomizers </span><br><span class="line">TransactionalOperator  <span class="comment">//简化程序化事务界定和事务异常处理的操作符类。</span></span><br><span class="line">TransactionTemplate <span class="comment">// 简化程序化事务界定和事务异常处理的模板类。</span></span><br></pre></td></tr></table></figure><p><code>TransactionAutoConfiguration</code>里的重点配置是在内部类<code>EnableTransactionManagementConfiguration</code>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(TransactionManager.class)</span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(AbstractTransactionManagementConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EnableTransactionManagementConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line">   <span class="meta">@EnableTransactionManagement</span>(proxyTargetClass = <span class="keyword">false</span>)</span><br><span class="line">   <span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.aop"</span>, name = <span class="string">"proxy-target-class"</span>, havingValue = <span class="string">"false"</span>,</span><br><span class="line">         matchIfMissing = <span class="keyword">false</span>)</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAutoProxyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line">   <span class="meta">@EnableTransactionManagement</span>(proxyTargetClass = <span class="keyword">true</span>)</span><br><span class="line">   <span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.aop"</span>, name = <span class="string">"proxy-target-class"</span>, havingValue = <span class="string">"true"</span>,</span><br><span class="line">         matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibAutoProxyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类对Jdk动态代理和CGlib动态代理两种方式分别作了配置，此类中并没有配置事务相关的bean，其关键是在<code>@EnableTransactionManagement</code>注解中</p><h5 id="1-1-EnableTransactionManagement"><a href="#1-1-EnableTransactionManagement" class="headerlink" title="1.1 EnableTransactionManagement"></a>1.1 EnableTransactionManagement</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(TransactionManagementConfigurationSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableTransactionManagement &#123;...&#125;</span><br></pre></td></tr></table></figure><p><code>EnableTransactionManagement</code>使用<code>@Import</code>注解导入了一个<code>TransactionManagementConfigurationSelector</code>，这种用法已经不陌生，常用于动态的装配bean，也就是根据应用的环境或配置装载不同类型的bean，进入该选择器代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `TransactionManagementConfigurationSelector`</span></span><br><span class="line"><span class="keyword">protected</span> String[] selectImports(AdviceMode adviceMode) &#123;</span><br><span class="line">   <span class="keyword">switch</span> (adviceMode) &#123;</span><br><span class="line">      <span class="keyword">case</span> PROXY:</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;AutoProxyRegistrar.class.getName(),</span><br><span class="line">               ProxyTransactionManagementConfiguration.class.getName()&#125;;</span><br><span class="line">      <span class="keyword">case</span> ASPECTJ:</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;determineTransactionAspectClass()&#125;;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>springboot启动时会执行者这段逻辑，当adviceMode是动态代理模式，装配的是<code>TransactionManagementConfiguration</code>，当adviceMode是aspectj织入模式，装配的是其他的，本文只讨论动态代理的情况。</p><p><code>TransactionManagementConfiguration</code>是此时真正的配置类，那么配置了哪些bean呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME)</span><br><span class="line"><span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanFactoryTransactionAttributeSourceAdvisor <span class="title">transactionAdvisor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      ...</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">@Bean</span></span></span><br><span class="line"><span class="function"><span class="params">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionAttributeSource <span class="title">transactionAttributeSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> AnnotationTransactionAttributeSource();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionInterceptor <span class="title">transactionInterceptor</span><span class="params">(TransactionAttributeSource transactionAttributeSource)</span> </span>&#123;</span><br><span class="line">   TransactionInterceptor interceptor = <span class="keyword">new</span> TransactionInterceptor();</span><br><span class="line">   interceptor.setTransactionAttributeSource(transactionAttributeSource);</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.txManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">      interceptor.setTransactionManager(<span class="keyword">this</span>.txManager);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个是<code>BeanFactoryTransactionAttributeSourceAdvisor</code>。它以Advisor结尾说明它是Spring AOP范畴里的东西。在AOP里，Advisor = Pointcut + Advice，Pointcut是切入点，表示要拦截的方法，Advice是增强，表示要加进去的事物功能。在<code>BeanFactoryTransactionAttributeSourceAdvisor</code>中有一个成员<code>TransactionAttributeSourcePointcut</code>，看名字就知道这是一个PointCut，它通过第三个bean—<code>TransactionAttributeSource</code>检测一个类的方法上是否有<code>@Transactional</code>注解，来确定该方法是否需要事物增强。</p><p>第二个bean是<code>TransactionInterceptor</code>，他就是一个Advice，因为它实现了Advice接口，包含了把事物加进去的逻辑。</p><h5 id="1-2-TransactionInterceptor"><a href="#1-2-TransactionInterceptor" class="headerlink" title="1.2 TransactionInterceptor"></a>1.2 TransactionInterceptor</h5><p>事务拦截器<code>TransactionInterceptor</code>用于拦截添加了事务注解的方法或类，对其执行事务管理器<code>txManager</code>的相关操作，那么事务管理器又是什么时候装载的呢？ 我们看到该配置类的父类中自动注入了一个<code>TransactionManager</code>，这里注入的是默认的事务管理器。当我们项目用到不止一个事务管理器的时候，开启事务时需要指定使用哪一个事务管理器，此时可以实现<code>TransactionManagementConfigurer</code>接口来指定一个默认的事务管理器，对有的系统，为了避免不必要的问题，在业务中必须要明确指定 <code>@Transactional</code> 的 value 值的情况下。不建议实现接口 <code>TransactionManagementConfigurer</code>，这样控制台会明确抛出异常，开发人员就不会忘记主动指定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTransactionManagementConfiguration</span> <span class="keyword">implements</span> <span class="title">ImportAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">protected</span> TransactionManager txManager;</span><br><span class="line">    <span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setConfigurers</span><span class="params">(Collection&lt;TransactionManagementConfigurer&gt; configurers)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (CollectionUtils.isEmpty(configurers)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (configurers.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Only one TransactionManagementConfigurer may exist"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      TransactionManagementConfigurer configurer = configurers.iterator().next();</span><br><span class="line">      <span class="keyword">this</span>.txManager = configurer.annotationDrivenTransactionManager();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当没有实现TransactionManagementConfigurer指定默认管理器时，上面的自动注入可能为空。</p><p>实时上关于事务管理器，不管是JPA还是JDBC等都实现自接口 PlatformTransactionManager 如果你添加的是 spring-boot-starter-jdbc 依赖，框架会默认注入 DataSourceTransactionManager 实例。如果你添加的是 spring-boot-starter-data-jpa 依赖，框架会默认注入 JpaTransactionManager 实例。</p><p><code>TransactionInterceptor</code>的核心逻辑是<code>invoke()</code>方法，具体的执行逻辑我会在下文执行流程中分析。</p><h4 id="2-spring事物的执行流程"><a href="#2-spring事物的执行流程" class="headerlink" title="2. spring事物的执行流程"></a>2. spring事物的执行流程</h4><p>spring-boot完成了事务bean的自动装配之后，下面来分析事务方法执行时，事务管理器的执行过程。</p><p>定义事务管理器的接口是<code>PlatformTransactionManager</code>，这个接口定义了三个方法，官方给出的注释很详细：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> <span class="keyword">extends</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line">  <span class="comment">//根据指定的传播行为，返回当前活动的事务或创建新的事务。</span></span><br><span class="line">  <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(@Nullable TransactionDefinition definition)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> TransactionException</span>;  </span><br><span class="line">  <span class="comment">//提交给定事务的状态。如果事务以编程方式标记为仅回滚，则执行回滚。</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>; </span><br><span class="line">  <span class="comment">//执行给定事务的回滚。</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口<code>PlatformTransactionManager</code>的一个抽象实现类就是<code>AbstractPlatformTransactionManager</code>，这个类实现了事务管理的整个逻辑关系流程，但是把与具体事务打交道的东西又定义为抽象方法让子类去实现（模板设计模式）。</p><h5 id="2-1-事务管理器涉及的关键对象"><a href="#2-1-事务管理器涉及的关键对象" class="headerlink" title="2.1 事务管理器涉及的关键对象"></a>2.1 事务管理器涉及的关键对象</h5><p><strong>事务定义 <code>TransactionDefinition</code></strong></p><p>这是一个接口，然而并没有需要实现的方法，接口中定义了spring事务支持的传播属性、隔离级别、超时时间、只读标记等事务属性的可选值，并制定了默认值。其派生接口为TransactionAttribute</p><p><strong>事务对象 <code>SmartTransactionObject</code></strong></p><p>不同数据源框架定义的事务对象不同，<code>SmartTransactionObject</code>只是spring-tx包定义的接口标准，不同框架对其都有自己的实现，这里我们以<code>DataSourceTransactionObject</code>为例，它是jdbc定义的事务对象</p><p><code>DataSourceTransactionObject</code>是<code>DataSourceTransactionManager</code>的内部类，看下面简单的类继承图</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/springboot/%E4%BA%8B%E5%8A%A1%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" style="zoom:67%;"></p><p>这个事务对象中最重要的成员是抽象类<code>JdbcTransactionObjectSupport</code>中定义的<code>ConnectionHolder</code>对象，它存储了该执行逻辑事务的数据库连接，也就是物理事务。</p><p><strong>事务状态 <code>TransactionStatus</code></strong></p><p><code>TransactionStatus</code>是一个接口，它继承了其他的三个接口：</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/springboot/%E4%BA%8B%E5%8A%A1%E7%8A%B6%E6%80%81%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" style="zoom:67%;"></p><p>常用的实现类是<code>DefaultTransactionStatus</code>，继承自<code>AbstractTransactionStatus</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultTransactionStatus</span> <span class="keyword">extends</span> <span class="title">AbstractTransactionStatus</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Object transaction;  <span class="comment">// 事务对象</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> newTransaction; <span class="comment">// 标记--是否为新创建的事务</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> newSynchronization; <span class="comment">// 标记--是否开启了新事务的同步</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> readOnly; <span class="comment">// 标记--是否为只读事务</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> debug; </span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Object suspendedResources; <span class="comment">// 当事务被挂起后存放挂起事务状态</span></span><br><span class="line">   <span class="comment">// 继承的属性</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> rollbackOnly = <span class="keyword">false</span>;  <span class="comment">//事务是否只支持回滚</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">boolean</span> completed = <span class="keyword">false</span>; <span class="comment">// 事务是否已完成</span></span><br><span class="line"> <span class="meta">@Nullable</span></span><br><span class="line"> <span class="keyword">private</span> Object savepoint; <span class="comment">// 保存点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重要的属性：</p><ul><li>持有一个事务对象的引用<code>Object transaction</code>，还记录了一些事务的状态信息</li><li><code>Object suspendedResources</code> ，保存被挂起事务的状态，后文会详细分析</li></ul><h5 id="2-2-事务执行流程分析"><a href="#2-2-事务执行流程分析" class="headerlink" title="2.2 事务执行流程分析"></a>2.2 事务执行流程分析</h5><h6 id="2-2-1-aop动态代理阶段"><a href="#2-2-1-aop动态代理阶段" class="headerlink" title="2.2.1 aop动态代理阶段"></a>2.2.1 aop动态代理阶段</h6><p>当调用的方法注解了事务，调用之前会通过cglib产生一个代理对象，cglib的动态代理的关键是实现<code>MethodInterceptor</code>接口，找到这个类，它是CglibAopProxy的一个私有的内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CglibAopProxy</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicAdvisedInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> AdvisedSupport advised;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">DynamicAdvisedInterceptor</span><span class="params">(AdvisedSupport advised)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.advised = advised;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    retVal = <span class="keyword">new</span> CglibMethodInvocation(proxy, target, method, args, </span><br><span class="line">                                       targetClass,  chain,  methodProxy).proceed();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>intercept() 是spring aop 进行拦截的方法，spring事务基于aop实现，所以事务增强会被aop拦截，执行intercept方法</p><p>intercept方法中不会直接开启事务或关闭事务，因为事务不一定是方法上唯一的增强点（可能存在其他增强，比如记录审计日志、开启分布式锁等等），所以事务增强逻辑肯定是封装成了一个Advisor，交给aop统一管理。</p><p>那么我们就去找这个Advisor</p><p>上面的代码创建了<code>CglibMethodInvocation</code>对象后执行了<code>proceed()</code>方法，进入该方法发现他调用了父类<code>ReflectiveMethodInvocation</code>的<code>proceed()</code>，这是一个反射方法调用器的执行过程，</p><p>由于在同一个切点可能会存在多个增强，所以动态代理也可能代理多次，每次代理都将增强的逻辑存放到一个容器中，在执行时逐个执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReflectiveMethodInvocation</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">   <span class="comment">// interceptorsAndDynamicMethodMatchers是拦截器链，同一个切点可能被多个advice拦截</span></span><br><span class="line">   <span class="comment">// currentInterceptorIndex初始为-1，这条判断其实是若拦截器链中没有拦截器，直接调用invokeJoinpoint</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">// currentInterceptorIndex先加1，再获取拦截器，此处获取到的就是事务拦截器</span></span><br><span class="line">   Object interceptorOrInterceptionAdvice =</span><br><span class="line">         <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line">   <span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">      ...</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 事务拦截会执行到这里</span></span><br><span class="line">      <span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟代码可以看到获取到的拦截器是<code>TransactionInterceptor</code>类型的，中间的判断都不满足，直接运行到代码的最后一行，调用<code>Invoke(this)</code></p><p>注意：<code>TransactionInterceptor</code> 实现的<code>MethodInterceptor</code>接口与上面cglib的不是同一个：</p><ul><li>cglib的<code>MethodInterceptor</code>接口是为了让代理对象执行代理逻辑，需要实现的是intercept方法</li><li>此处的<code>MethodInterceptor</code>接口是为了调用代理逻辑中的增强方法，需要实现的是invoke方法，因为增强逻辑是被封装过的。</li></ul><h6 id="2-2-2-TransactionInterceptor-invoke方法"><a href="#2-2-2-TransactionInterceptor-invoke方法" class="headerlink" title="2.2.2 TransactionInterceptor.invoke方法"></a>2.2.2 TransactionInterceptor.invoke方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TransactionInterceptor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">   <span class="comment">// 参数invocation就是上面创建的CglibMethodInvocation</span></span><br><span class="line">   <span class="comment">// 获取被代理对象的类型</span></span><br><span class="line">   Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="keyword">null</span> ? </span><br><span class="line">                           AopUtils.getTargetClass(invocation.getThis()) : <span class="keyword">null</span>);</span><br><span class="line">   <span class="comment">// 终于开始进入正题了,在事务中调用方法&gt;&gt;</span></span><br><span class="line">   <span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>invokeWithinTransaction</code>方法是定义在父类<code>TransactionAspectSupport</code>中的，此方法代码有点长，这里节选一些关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeWithinTransaction</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> InvocationCallback invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// 获取注解属性源，此处获取到的是AnnotationTransactionAttributeSource对象</span></span><br><span class="line">   TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line">   <span class="comment">// 从属性源中拿到事务的属性，RuleBasedTransactionAttribute对象</span></span><br><span class="line">   <span class="keyword">final</span> TransactionAttribute txAttr = (tas != <span class="keyword">null</span> ? </span><br><span class="line">                                        tas.getTransactionAttribute(method, targetClass) : <span class="keyword">null</span>);</span><br><span class="line">   <span class="comment">// 根据事务属性，创建事务管理器，如果没有配置事务管理器，自适应创建</span></span><br><span class="line">   <span class="keyword">final</span> PlatformTransactionManager tm = determineTransactionManager(txAttr);</span><br><span class="line">   <span class="comment">// com.pd.service.AccountService.transferAccount  就是方法的名称</span></span><br><span class="line">   <span class="keyword">final</span> String joinpointIdentification = methodIdentification(method, targetClass, txAttr);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || !(tm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">      <span class="comment">// 创建事务，开启事务 &gt;&gt;</span></span><br><span class="line">      TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line"></span><br><span class="line">      Object retVal;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 调用方法逻辑</span></span><br><span class="line">         retVal = invocation.proceedWithInvocation();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">         <span class="comment">// 目标方法抛出异常，结束事务。可能回滚，可能啥也不做</span></span><br><span class="line">         completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// 清理事务现场</span></span><br><span class="line">         cleanupTransactionInfo(txInfo);</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line"><span class="comment">// 提交事务</span></span><br><span class="line">      commitTransactionAfterReturning(txInfo);</span><br><span class="line">      <span class="keyword">return</span> retVal;</span><br><span class="line">   &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里找到事务创建的方法<code>createTransactionIfNecessary</code>，跟进方法：</p><p><code>DelegatingTransactionAttribute</code>是<code>TransactionAttribute</code>的代理实现类，这里用静态代理。为什么要用代理类？因为<code>TransactionAttribute</code>是接口，不能实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> TransactionInfo <span class="title">createTransactionIfNecessary</span><span class="params">(@Nullable PlatformTransactionManager tm,</span></span></span><br><span class="line"><span class="function"><span class="params">      @Nullable TransactionAttribute txAttr, <span class="keyword">final</span> String joinpointIdentification)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 事务如果没有指定名称，用之前生成的方法切入点id作为事务名称</span></span><br><span class="line">   <span class="keyword">if</span> (txAttr != <span class="keyword">null</span> &amp;&amp; txAttr.getName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      txAttr = <span class="keyword">new</span> DelegatingTransactionAttribute(txAttr) &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> joinpointIdentification;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   TransactionStatus status = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tm != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 就是在这里创建事务开启事务了，事务的属性传进去</span></span><br><span class="line">         status = tm.getTransaction(txAttr);</span><br><span class="line">      &#125;</span><br><span class="line">      ... <span class="comment">// 日志操作</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进方法<code>getTransaction</code>，该方法将返回一个<code>TransactionStatus</code>类型的结果，这个叫事务状态的返回结果持有创建的事务对象（逻辑事务），以及该事务对象的一些状态信息。</p><p>那我们来看一下这个获取事务的方法的整一个流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title">getTransaction</span><span class="params">(@Nullable TransactionDefinition definition)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">   TransactionDefinition def = (definition != <span class="keyword">null</span> ? definition : </span><br><span class="line">                                TransactionDefinition.withDefaults());</span><br><span class="line"><span class="comment">// doGetTransaction()从当前上下文中获取事务对象，这是一个抽象方法，子类实现 &gt;&gt;</span></span><br><span class="line">   Object transaction = doGetTransaction();</span><br><span class="line">   <span class="keyword">boolean</span> debugEnabled = logger.isDebugEnabled();</span><br><span class="line"> <span class="comment">//若被调用的事务方法已处于事务之中（事务方法A调用事务方法B）</span></span><br><span class="line">   <span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line">      <span class="comment">// 根据当前事务的传播属性，来决定下一步处理 &gt;&gt;</span></span><br><span class="line">      <span class="keyword">return</span> handleExistingTransaction(def, transaction, debugEnabled);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">//-----------------------当前还没有事务会往下走-----------------------</span></span><br><span class="line">   <span class="comment">// 检查超时设置是否合理</span></span><br><span class="line">   <span class="keyword">if</span> (def.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InvalidTimeoutException(<span class="string">"Invalid transaction timeout"</span>, def.getTimeout());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 若配置的事务传播属性是MANDATORY（该配置表示当前存在事务则加入，否则），抛异常</span></span><br><span class="line">   <span class="keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line">            <span class="string">"No existing transaction found for transaction marked with propagation 'mandatory'"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">         def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">         def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">      SuspendedResourcesHolder suspendedResources = suspend(<span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">         logger.debug(<span class="string">"Creating new transaction with name ["</span> + def.getName() + <span class="string">"]: "</span> + def);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">         DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">               def, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">         doBegin(transaction, def);  <span class="comment">//  开启一个新事务</span></span><br><span class="line">         prepareSynchronization(status, def);</span><br><span class="line">         <span class="keyword">return</span> status;</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">   &#125;<span class="keyword">else</span></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在分析以上代码之前，首先需要明白几个概念，最终要搞清楚几个问题：</p><ol><li>物理事务就是到数据库的一个物理链接（数据库连接），那么这个链接是什么时候获取的？建立连接后又是如何保存起来的？</li><li>逻辑事务就是一个带有spring事务注解的方法，它需要关联到一个物理事务上。那它们之间如何进行关联？</li><li>多个逻辑事务可以映射到一个物理事务上，逻辑事务是各自提交的，如何处理逻辑事务提交和物理事务提交间的关系呢，至少所有的逻辑事务都提交了才可以提交物理事务。</li></ol><hr><p>带着问题来分析获取事务的方法：</p><h6 id="2-2-3-doGetTransaction"><a href="#2-2-3-doGetTransaction" class="headerlink" title="2.2.3 doGetTransaction"></a>2.2.3 doGetTransaction</h6><p>接下来的分析都是以数据源事务管理器为列进行的，首先来看<code>doGetTransaction()</code>这个方法，这个方法首先会创建一个逻辑事务对象<code>DataSourceTransactionObject</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataSourceTransactionManager</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doGetTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 创建事务对象（逻辑事务）</span></span><br><span class="line">   DataSourceTransactionObject txObject = <span class="keyword">new</span> DataSourceTransactionObject();</span><br><span class="line">   txObject.setSavepointAllowed(isNestedTransactionAllowed());</span><br><span class="line">   <span class="comment">// 从线程私有变量中获取物理事务，没有事务嵌套，获取到的是null</span></span><br><span class="line">   ConnectionHolder conHolder =</span><br><span class="line">         (ConnectionHolder) TransactionSynchronizationManager.getResource(obtainDataSource());</span><br><span class="line">   <span class="comment">// 将获取到的物理事务 绑定给 逻辑事务对象 false表示这个物理事务不是新创建的</span></span><br><span class="line">   txObject.setConnectionHolder(conHolder, <span class="keyword">false</span>);</span><br><span class="line">   <span class="keyword">return</span> txObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑事务对象中到底有哪些内容呢</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceTransactionObject</span> <span class="keyword">extends</span> <span class="title">JdbcTransactionObjectSupport</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 新连接标志，当事务对象新获取一个数据库连接是，设为true </span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> newConnectionHolder;  </span><br><span class="line">  <span class="comment">// 当数据库连接开启自动提交，逻辑事务关闭它之前，会先保存这个状态</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> mustRestoreAutoCommit; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*------------- 继承到的属性----------------*/</span></span><br><span class="line">  <span class="meta">@Nullable</span>  <span class="comment">// 数据库连接封装类对象</span></span><br><span class="line"><span class="keyword">private</span> ConnectionHolder connectionHolder;</span><br><span class="line"><span class="meta">@Nullable</span>  <span class="comment">// 隔离级别</span></span><br><span class="line"><span class="keyword">private</span> Integer previousIsolationLevel;</span><br><span class="line">  <span class="comment">//是否允许设置保存点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> savepointAllowed = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据源事务对象中最重要的成员变量是就是<code>ConnectionHolder</code>，它是数据库连接的封装类，创建逻辑事务时，它为null。也就是说逻辑事务创建的时候并没有关联到物理事务（数据库连接）</p><p>现在回到<code>doGetTransaction</code>方法，接下来的关键点是尝试获取线程中已经获得的物理事务，在事务同步管理器<code>TransactionSynchronizationManager</code>中，有几个线程私有的变量（ThreadLocal）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionSynchronizationManager</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 存储事务资源 map的key是数据源DataSource，value是ConnectionHolder（内含数据库连接）</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources =</span><br><span class="line">         <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Transactional resources"</span>);</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt; synchronizations =</span><br><span class="line">         <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Transaction synchronizations"</span>);</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; currentTransactionName =</span><br><span class="line">         <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Current transaction name"</span>);</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; currentTransactionReadOnly =</span><br><span class="line">         <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Current transaction read-only status"</span>);</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; currentTransactionIsolationLevel =</span><br><span class="line">         <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Current transaction isolation level"</span>);</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; actualTransactionActive =</span><br><span class="line">         <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Actual transaction active"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>事务性资源是存储在Map&lt;Object, Object&gt;里，key就是DataSource对象，value就是ConnectionHolder对象，那么是怎么知道key和value的类型的呢？往下看会看到map的put操作</p></li><li><p>事务同步这个集合Set<transactionsynchronization>，只有在多个数据源的分布式事务时才使用。</transactionsynchronization></p></li><li><p>剩下的是四个和事务相关的变量，事务名称/是否只读/隔离级别/是否激活。</p></li></ul><p>此处重点关注叫<code>resources</code> 的ThreadLocal变量，该变量一个Map，key是<code>DataSource</code>对象，value是<code>ConnectionHolder</code>对象，那么这就意味着<strong><em>每个线程在同一个数据源上只能获取一个连接绑定到这个变量中</em></strong></p><p><code>TransactionSynchronizationManager.getResource(obtainDataSource())</code>这一句执行完如果能够获取到一个连接说明什么？说明当前已经有一个逻辑事务获取了同一个数据源的连接并绑定到了map中，说明现在正在获取的逻辑事务在另一个逻辑事务之中。</p><p>如果没有事务嵌套的话，这一句代码执行获取到的肯定是null。</p><hr><h6 id="2-2-4-handleExistingTransaction"><a href="#2-2-4-handleExistingTransaction" class="headerlink" title="2.2.4 handleExistingTransaction"></a>2.2.4 handleExistingTransaction</h6><p>获取事务对象之后，继续往下将执行<code>isExistingTransaction()</code>方法，该方法判断获取到的事务对象是否已经存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isExistingTransaction</span><span class="params">(Object transaction)</span> </span>&#123;</span><br><span class="line">   DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;</span><br><span class="line">   <span class="keyword">return</span> (txObject.hasConnectionHolder() &amp;&amp;  </span><br><span class="line">           txObject.getConnectionHolder().isTransactionActive());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要是检查事务对象中是否设置了<code>ConnectionHolder</code>，并判断该物理事务是不是已经被激活。</p><p>如果此方法返回true，表明当前获取到的物理事务已经存在，从而表明此处肯定存在逻辑事务的嵌套，这时候应该根据配置的事务传播属性来进行处理，<code>handleExistingTransaction</code>处理逻辑如下：</p><ul><li><p>如果此时事务传播特性是NEVER，则抛出异常。（<u>never表示以非事务的方式执行，存在事务则抛异常</u>）</p></li><li><p>如果此时事务的传播特性是NOT_SUPPORTED，则调用suspend(transaction)挂起当前事务，将被挂起的资源suspendedResources放入事务状态里。（<u>not_supported表示以非事务方式运行，若存在事务则挂起事务</u>）</p></li><li><p>如果此时事务状态是REQUIRES_NEW，则调用suspend(transaction)挂起当前事务，将事务对象transaction和被挂起的资源suspendedResources放入事务状态里。然后调用doBegin(transaction, definition)方法去真正打开事务。最后调用prepareSynchronization(status, definition)方法准备一下事务同步。</p></li><li><p>如果此时事务的传播特性是NESTED，又分三种情况：</p><ul><li>如果不允许嵌套事务，直接抛出异常。</li><li>如果使用保存点（Savepoint）来实现嵌套事务，那直接使用当前事务，创建一个保存点就可以了。</li><li>如果使用新的事务来实现嵌套事务，那就调用doBegin(transaction, definition)开启新的事务，此时不需要挂起当前事务。</li></ul></li><li><p>对于剩下三种传播特性REQUIRED/MANDATORY/SUPPORTS，则不需要创建新事务，直接使用当前事务就可以了。</p></li></ul><hr><h6 id="2-2-5-dobegin"><a href="#2-2-5-dobegin" class="headerlink" title="2.2.5 dobegin()"></a>2.2.5 dobegin()</h6><p>上面也分析了，在首次执行事务方法时，事务肯定是不存在的，因为从线程的ThreadLocal里没有取出<code>ConnectionHolder</code>对象。那此时就要新开一个物理事务，新开物理事务是在<code>doBegin()</code>方法中进行的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBegin</span><span class="params">(Object transaction, TransactionDefinition definition)</span> </span>&#123;</span><br><span class="line">   DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;</span><br><span class="line">   Connection con = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;  <span class="comment">// 若事务对象没有绑定物理资源  或者  持有的物理资源还没有和事务对象同步</span></span><br><span class="line">      <span class="keyword">if</span> (!txObject.hasConnectionHolder() ||</span><br><span class="line">            txObject.getConnectionHolder().isSynchronizedWithTransaction()) &#123;</span><br><span class="line">         <span class="comment">// 创建新连接，封装成物理资源赋值给事务对象</span></span><br><span class="line">         Connection newCon = obtainDataSource().getConnection();</span><br><span class="line">         txObject.setConnectionHolder(<span class="keyword">new</span> ConnectionHolder(newCon), <span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      txObject.getConnectionHolder().setSynchronizedWithTransaction(<span class="keyword">true</span>);</span><br><span class="line">      con = txObject.getConnectionHolder().getConnection();</span><br><span class="line"></span><br><span class="line">      Integer previousIsolationLevel = </span><br><span class="line">        DataSourceUtils.prepareConnectionForTransaction(con, definition);</span><br><span class="line">      txObject.setPreviousIsolationLevel(previousIsolationLevel);</span><br><span class="line"><span class="comment">// 若物理连接开启了自动提交（默认开启）</span></span><br><span class="line">      <span class="keyword">if</span> (con.getAutoCommit()) &#123;</span><br><span class="line">         txObject.setMustRestoreAutoCommit(<span class="keyword">true</span>);   <span class="comment">// 存储物理连接的自动提交状态</span></span><br><span class="line">         con.setAutoCommit(<span class="keyword">false</span>);  <span class="comment">// 关闭物理连接自动提交</span></span><br><span class="line">      &#125;</span><br><span class="line">      prepareTransactionalConnection(con, definition);</span><br><span class="line">      <span class="comment">// 激活物理事务</span></span><br><span class="line">      txObject.getConnectionHolder().setTransactionActive(<span class="keyword">true</span>);</span><br><span class="line">...</span><br><span class="line">      <span class="comment">// 将物理事务绑定到ThreadLocal变量，这里是map的put操作</span></span><br><span class="line">      <span class="keyword">if</span> (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line">         TransactionSynchronizationManager.bindResource</span><br><span class="line">           (obtainDataSource(), txObject.getConnectionHolder());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line">         DataSourceUtils.releaseConnection(con, obtainDataSource());</span><br><span class="line">         txObject.setConnectionHolder(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> CannotCreateTransactionException(</span><br><span class="line">        <span class="string">"Could not open JDBC Connection for transaction"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新事务开启之后，继续回到<code>getTransaction()</code>方法，这个方法返回的是一个事务状态对象，继续看返回值创建的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DefaultTransactionStatus <span class="title">newTransactionStatus</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      TransactionDefinition definition, @Nullable Object transaction, <span class="keyword">boolean</span> newTransaction,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> newSynchronization, <span class="keyword">boolean</span> debug, @Nullable Object suspendedResources)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">boolean</span> actualNewSynchronization = newSynchronization &amp;&amp;</span><br><span class="line">         !TransactionSynchronizationManager.isSynchronizationActive();</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> DefaultTransactionStatus(</span><br><span class="line">         transaction, newTransaction, actualNewSynchronization,</span><br><span class="line">         definition.isReadOnly(), debug, suspendedResources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个对象有很重要的三点：</p><ol><li><p>它需要包含逻辑事务对象（已关联了物理事务）。</p></li><li><p>它需要表明这个事务是一个新开启的物理事务，还是参与到已有的物理事务。</p></li><li><p>它需要包含被挂起的（上一个）物理事务连接（如果有的话）。</p></li></ol><h5 id="2-3-物理事务与逻辑事务的对应关系"><a href="#2-3-物理事务与逻辑事务的对应关系" class="headerlink" title="2.3 物理事务与逻辑事务的对应关系"></a>2.3 物理事务与逻辑事务的对应关系</h5><ul><li><p>当事务A调用事务B并且传播属性允许两个逻辑事务合并时，用一个物理事务执行就可以执行两个逻辑事务，此时物理事务与逻辑事务是<strong>1对多</strong>的关系。</p></li><li><p>事务A中调用事务B，B的传播属性为<strong><em>Propagation.REQUIRES_NEW</em></strong>，物理事务与逻辑事务是<strong>1对1</strong>的关系</p></li><li>不存在1个逻辑事务对应多个物理事务的情况。</li></ul><h5 id="2-4-事务的挂起"><a href="#2-4-事务的挂起" class="headerlink" title="2.4 事务的挂起"></a>2.4 事务的挂起</h5><p>在一些事务的传播模式下，可能会挂起当前的事务，举例：</p><p>事务A中调用事务B，B的传播属性为<strong><em>Propagation.REQUIRES_NEW</em></strong>，这时候需要将事务A挂起，创建事务B运行，创建事务B的时候会将挂起的事务A资源放到事务B的<code>TransactionStatus</code>对象中，事务B结束（提交或回滚）之后，恢复事务A继续执行</p><p>挂起做了哪些工作？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doSuspend</span><span class="params">(Object transaction)</span> </span>&#123;</span><br><span class="line">   DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;</span><br><span class="line">   txObject.setConnectionHolder(<span class="keyword">null</span>);</span><br><span class="line">   <span class="keyword">return</span> TransactionSynchronizationManager.unbindResource(obtainDataSource());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将事务对象中的ConnectionHolder清空</li><li>将ThreadLocal中的数据源对应的ConnectionHolder清除，并返回被清除的ConnectionHolder</li><li>将返回的ConnectionHolder封装成SuspendedResourcesHolder，保存到创建的新事务对象中</li></ul><p>为什么要这么做？</p><p>ThreadLocal资源虽然是一个map，但是这个map的数据源是key，这意味着每个线程在同一个数据源上只能使用一个连接（可以持有多个连接，但同一时间只能使用一个，单线程）。事务A在挂起的时候将物理连接保存起来，然后事务B再重新获取一个连接执行操作，事务B结束之后，再取出事务A对应的物理资源，继续执行事务A。</p><p>因此可以得出结论：逻辑事务没有结束之前，对应的物理事务是不能执行其他事务操作的，物理事务上应该是保存了事务的状态信息（未提交），不能串着用</p><p><a href="https://mp.weixin.qq.com/s/i0QmrEDZ6aTsZFFahYC_ow" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/i0QmrEDZ6aTsZFFahYC_ow</a>  </p><p><a href="https://mp.weixin.qq.com/s/sysm3AY7PG9MV9584UTasg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/sysm3AY7PG9MV9584UTasg</a>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;复习总结：&quot;&gt;&lt;a href=&quot;#复习总结：&quot; class=&quot;headerlink&quot; title=&quot;复习总结：&quot;&gt;&lt;/a&gt;复习总结：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;注解式事务是通过aop实现的，底层是cglib动态代理实现的&lt;ul&gt;
&lt;li&gt;事务aop场景中的Advi
      
    
    </summary>
    
      <category term="SpringBoot" scheme="http://yoursite.com/child/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/child/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis-给源码加中文注释(转)</title>
    <link href="http://yoursite.com/child/2020/04/24/MyBatis-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E4%BB%8E%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BA/"/>
    <id>http://yoursite.com/child/2020/04/24/MyBatis-源码分析之从源码构建/</id>
    <published>2020-04-23T16:00:00.000Z</published>
    <updated>2020-05-22T11:54:43.915Z</updated>
    
    <content type="html"><![CDATA[<p>我们在看框架源码的时候，如果没有注释，看起来会比较吃力。所以如果能够一边看源码一边自己加中文注释，下次阅读的时候就会轻松很多。</p><p>问题是：通过maven下载的jar，查看源码，实际上看到的是经过反编译的class文件，是不能够修改的（提示：file is read only）。<br>如果把当前maven下载的jar包强行关联到自己下载的源码，又有可能会出现字节码跟源码文件不一致的情况（提示：Library source does not match the bytecode for class），导致debug的时候无法进入代码。</p><p>如果要保证源码和字节码一致，最好的办法当然是在本地把下载的源码编译生成jar包，上传到本地maven仓库，再引用这个jar。</p><p>以MyBatis为例，如果我们要给MyBatis源码加上中文注释（以IDEA操作为例）</p><p><a href="https://mp.weixin.qq.com/s/v0ihaPsuyGufdc_ImEqX8A" target="_blank" rel="noopener">原文连接</a></p><h4 id="1、配置Maven"><a href="#1、配置Maven" class="headerlink" title="1、配置Maven"></a>1、配置Maven</h4><p>因为需要用Maven打包编译源代码，所以第一步是检查Maven的配置。</p><p>第一个是环境变量，需要在系统变量中添加MAVEN_HOME，配置Maven主路径，例如“E:\dev\apache-maven-3.5.4”，确保mvn命令可以使用。</p><p>第二个是检查Maven的配置。Maven运行时，默认会使用conf目录下的settings.xml配置，例如：E:\dev\apache-maven-3.5.4\conf\settings.xml。</p><p>为了保证下载速度，建议配置成国内的aliyun中央仓库（此处需要自行搜索）。</p><p>并且，settings.xml中的localRepository应该和IDEA中打开的项目设置中的Local repository保持一致（例如：E:\repository）。否则项目引入依赖时，无法读取到编译后的jar包。</p><h4 id="2、下载编译MyBatis源码"><a href="#2、下载编译MyBatis源码" class="headerlink" title="2、下载编译MyBatis源码"></a>2、下载编译MyBatis源码</h4><p>因为MyBatis源码编译依赖parent项目的源码，所以第一步是编译parent项目。</p><p>先从git clone两个工程的项目（截止2020年4月，最新版本是3.5.4）。</p><p>以在E盘根目录下载为例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/mybatis/parent</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/mybatis/mybatis-3</span><br></pre></td></tr></table></figure><p>打开mybatis-3中的pom.xml文件，查看parent的版本号，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>31<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>确定parent版本是31（记住这个数字）。</p><p>把mybatis版本号改成自定义的版本号，避免跟官方版本号冲突（加上了-snapshot）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.4-snapshot<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><p>进入parent目录，切换项目分支（不能在默认的master分支中编译），工程名后面的数字就是前面看到的parent版本号。</p><p>开始编译parent项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> parent</span><br><span class="line"></span><br><span class="line">git checkout mybatis-parent-31</span><br><span class="line"></span><br><span class="line">mvn install</span><br></pre></td></tr></table></figure><p>接下来编译mybatis工程，进入mybatis-3目录，切换到最新3.5.4分支（不能在默认的master分支中编译）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd ../mybatis-3</span><br><span class="line"></span><br><span class="line">git checkout mybatis-3.5.4</span><br><span class="line"></span><br><span class="line">mvn clean</span><br><span class="line"></span><br><span class="line">mvn install -DskipTests=true -Dmaven.test.skip=true -Dlicense.skip=true</span><br></pre></td></tr></table></figure><p>编译完毕，本地仓库就会出现一个编译后的jar包，例如：E:\repository\org\mybatis\mybatis\3.5.4-snapshot\mybatis-3.5.4-snapshot.jar</p><p>在我们的项目中就可以引入这个jar包了（version是自定义的version）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.4-snapshot<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3、关联jar包到源码"><a href="#3、关联jar包到源码" class="headerlink" title="3、关联jar包到源码"></a>3、关联jar包到源码</h4><p>本地编译的jar包已经有了，接下来是把jar包和源码关联起来。</p><p>Project Structure —— Libries —— Maven: org.mybatis:mybatis:3.5.4-snapshot —— 在原来的Sources上面点+（加号） —— 选择到下载的源码路径，例如：E:\mybatis-3\src\main\java，点击OK</p><p>关联好之后，开始打断点debug，就会进入到本地的源码，可以给本地的源码加上注释了。</p><h4 id="4、注意"><a href="#4、注意" class="headerlink" title="4、注意"></a>4、注意</h4><p>1、如果之前打开过类的字节码文件，本地可能有缓存，一样会有“Library source does not match the bytecode for class”的提示。解决办法：File —— Invalidate Caches and Restart（IDEA会重启）。</p><p>2、如果添加注释导致了debug的当前行跟实际行不一致，再把mybatis3工程编译一次即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们在看框架源码的时候，如果没有注释，看起来会比较吃力。所以如果能够一边看源码一边自己加中文注释，下次阅读的时候就会轻松很多。&lt;/p&gt;
&lt;p&gt;问题是：通过maven下载的jar，查看源码，实际上看到的是经过反编译的class文件，是不能够修改的（提示：file is rea
      
    
    </summary>
    
      <category term="ORM框架" scheme="http://yoursite.com/child/categories/ORM%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Mybatis" scheme="http://yoursite.com/child/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>RPC-手写RPC调用过程</title>
    <link href="http://yoursite.com/child/2020/04/19/%E5%88%86%E5%B8%83%E5%BC%8F-%E6%89%8B%E5%86%99RPC%E8%B0%83%E7%94%A8/"/>
    <id>http://yoursite.com/child/2020/04/19/分布式-手写RPC调用/</id>
    <published>2020-04-18T16:00:00.000Z</published>
    <updated>2020-05-22T11:45:12.708Z</updated>
    
    <content type="html"><![CDATA[<p>rpc 全称remote procedure call 远程过程调用，是一种分布式服务调用协议。</p><p>需求：分布式环境下，服务A想要调用服务B的某方法，就像调用自己本地的方法一样</p><p>分析：</p><ul><li>首先，服务A需要知道服务B提供了哪些方法，并且知道这些方法的调用方式（参数列表，返回类型）</li><li>其次，服务A需要将调用的方法和参数发送给服务B，B接收到之后本地调用获得结果，再将结果发送给服务A</li></ul><p>设计：</p><ul><li>要提供一套统一的接口让调用方服务A知道有哪些方法可供调用，服务B作为接口的实现方。</li><li>服务A要提供接口的代理类工厂，本地调用接口方法时，代理类能将调用请求发送出去。</li><li>数据传输方面，暂不考虑性能，使用BIO以及JDK序列化方式</li></ul><p>开始编码：</p><p>提供一套接口：创建maven项目rpc-api，项目中添加接口文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHelloService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口中还需要指定一个简要的rpc协议，调用方和服务方都要遵循此协议</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcRequest</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="keyword">private</span> Object[] args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将rpc-api install到本地仓库。</p><p>调用方服务A：创建maven项目rpc-client，pom中添加依赖rpc-api</p><p>先来写main方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">        RpcProxyFactory rpcProxyFactory = <span class="keyword">new</span> RpcProxyFactory();</span><br><span class="line">        IHelloService helloService = </span><br><span class="line">          rpcProxyFactory.newProxyInstance(IHelloService.class,<span class="string">"localhost"</span>,<span class="number">8080</span>);</span><br><span class="line">        Object o = helloService.sayHello(<span class="string">"zzk"</span>);</span><br><span class="line">        System.out.println((String) o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程很清晰：</p><ol><li>创建代理工厂<code>RpcProxyFactory</code></li><li>使用代理工厂类生成指定接口的代理对象</li><li>调用接口方法获取结果</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">newProxyInstance</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; interfaceClass, <span class="keyword">final</span> String host, <span class="keyword">final</span> <span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T)Proxy.newProxyInstance(interfaceClass.getClassLoader(),<span class="keyword">new</span> Class&lt;?&gt;[] &#123;interfaceClass&#125;,</span><br><span class="line">                <span class="keyword">new</span> RemoteInvocationHandler(host,port));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理方式我选用的是jdk的动态代理，创建代理对象需要传进三个参数</p><ul><li>类加载器</li><li>需要代理的接口</li><li>触发管理类</li></ul><p>前两个参数都是现成的，编写触发管理类代码，实现<code>InvocationHandler</code>接口，通过代理对象调用接口方法都会进到invoke方法中来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RemoteInvocationHandler</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        RpcRequest rpcRequest = <span class="keyword">new</span> RpcRequest();</span><br><span class="line">        rpcRequest.setClassName(method.getDeclaringClass().getName());</span><br><span class="line">        rpcRequest.setMethodName(method.getName());</span><br><span class="line">        rpcRequest.setArgs(args);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RpcNetTransport(host,port).send(rpcRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>invoke 方法负责将请求参数序列化，并发送出去，这里使用一个类专门负责发送：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcNetTransport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcNetTransport</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">send</span><span class="params">(RpcRequest rpcRequest)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(Socket socket = <span class="keyword">new</span> Socket(host,port);</span><br><span class="line">            ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream());</span><br><span class="line">            ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream())) &#123;</span><br><span class="line">            out.writeObject(rpcRequest);</span><br><span class="line">            <span class="keyword">return</span> in.readObject();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此调用发代码完成</p><p>再来看服务方B的代码编写：创建maven项目，引入依赖rpc-api、spring-context来管理对象</p><p>首先服务方应该实现接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">IHelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"request sayHello from : "</span> + content);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Response: hello, "</span> + content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器需要接收请求，代码思想：启动监听指定端口，这里使用了spring的<code>InitializingBean</code>接口，创建RpcServer时，当port设置成功之后会执行<code>afterPropertiesSet()</code>方法启动监听。</p><p>此外，我们将对象交给spring管理后，当请求进来我们需要找到正确service去执行，我的做法是让<code>RpcServer</code>实现<code>ApplicationContextAware</code>接口，这样RpcServer可以在<code>setApplicationContext</code>方法中，将所有的service对象取出来缓存，请求进来直接在缓存中找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcServer</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>,<span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; serviceObjs = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// socket 通信 发布服务</span></span><br><span class="line">        <span class="keyword">try</span> (ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(port))&#123;</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                Socket socket = serverSocket.accept();</span><br><span class="line">                pool.execute(<span class="keyword">new</span> ProcessorHandler(socket,serviceObjs));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取容器中的服务bean 封装成map</span></span><br><span class="line">        Map&lt;String,Object&gt; beans = </span><br><span class="line">          applicationContext.getBeansWithAnnotation(RpcService.class);</span><br><span class="line">        <span class="keyword">for</span>(Object service : beans.values())&#123;</span><br><span class="line">            Class&lt;?&gt; clazz = service.getClass();</span><br><span class="line">            String serviceKey = rpcService.value().getName();</span><br><span class="line">            serviceObjs.put(serviceKey,service);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当获取请求之后，丢给线程池进行执行，那我继续编写线程池执行任务代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessorHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; serviceObj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProcessorHandler</span><span class="params">(Socket socket,Map&lt;String,Object&gt; serviceObj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        <span class="keyword">this</span>.serviceObj = serviceObj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</span><br><span class="line">             ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream()))&#123;</span><br><span class="line"></span><br><span class="line">            RpcRequest rpcRequest = (RpcRequest) in.readObject();</span><br><span class="line">            Object result = invoke(rpcRequest);</span><br><span class="line">            out.writeObject(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">invoke</span><span class="params">(RpcRequest rpcRequest)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        Object[] args = rpcRequest.getArgs();</span><br><span class="line">        Class&lt;?&gt;[] types = <span class="keyword">new</span> Class[args.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++)&#123;</span><br><span class="line">            types[i]= args[i].getClass();</span><br><span class="line">        &#125;</span><br><span class="line">        Class clazz = Class.forName(rpcRequest.getClassName());</span><br><span class="line">        Method method = clazz.getMethod(rpcRequest.getMethodName(),types);</span><br><span class="line">        String serviceKey = rpcRequest.getClassName() + rpcRequest.getVersion();</span><br><span class="line">        <span class="keyword">return</span> method.invoke(serviceObj.get(serviceKey),args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然是线程池执行的任务，肯定是Runnable对象，run方法的逻辑很清晰：从socket中获取请求对象，丢给invoke返回结果，在通过socket发送出去。</p><p>重点在invoke方法：通过反射的方式对方法进行调用</p><p>还有spring的最后一步，配置和启动:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"com.pd"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RpcServer <span class="title">rpcServer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RpcServer(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context =</span><br><span class="line">                <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line">        context.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p>先启动rpc-server  再启动rpc-client</p><p>结果：<code>Response: hello, zzk</code></p><p>总结流程图示：</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/rpc/rpc%E5%9F%BA%E7%A1%80%E8%B0%83%E7%94%A8.png" alt="rpc-基础流程"></p><p><a href="https://github.com/zzkenyon/rpc-learn.git" target="_blank" rel="noopener">参考代码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;rpc 全称remote procedure call 远程过程调用，是一种分布式服务调用协议。&lt;/p&gt;
&lt;p&gt;需求：分布式环境下，服务A想要调用服务B的某方法，就像调用自己本地的方法一样&lt;/p&gt;
&lt;p&gt;分析：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，服务A需要知道服务B提供了哪些
      
    
    </summary>
    
      <category term="分布式架构技术" scheme="http://yoursite.com/child/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="RPC" scheme="http://yoursite.com/child/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>CSRF攻击与防御（转）</title>
    <link href="http://yoursite.com/child/2020/04/14/%E5%85%B6%E4%BB%96-CSRF%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1/"/>
    <id>http://yoursite.com/child/2020/04/14/其他-CSRF攻击与防御/</id>
    <published>2020-04-13T16:00:00.000Z</published>
    <updated>2020-06-12T00:32:49.804Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.phpddt.com/reprint/csrf.html" target="_blank" rel="noopener">转载地址</a></p><p><strong>CSRF概念：</strong>CSRF跨站点请求伪造(Cross—Site Request Forgery)，跟XSS攻击一样，存在巨大的危害性，你可以这样来理解：攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 如下：其中Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。</p><h4 id="CSRF攻击攻击原理及过程如下："><a href="#CSRF攻击攻击原理及过程如下：" class="headerlink" title="CSRF攻击攻击原理及过程如下："></a>CSRF攻击攻击原理及过程如下：</h4><ol><li><p>用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；</p></li><li><p>在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；</p></li><li><p>用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；</p></li><li><p>网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；</p></li><li><p>浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 </p></li></ol><h4 id="CSRF攻击实例"><a href="#CSRF攻击实例" class="headerlink" title="CSRF攻击实例"></a>CSRF攻击实例</h4><p>受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求 <a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2" target="_blank" rel="noopener">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2</a> 可以使 Bob 把 1000000 的存款转到 bob2 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。</p><p>黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行：<a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory。但是这个请求来自" target="_blank" rel="noopener">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory。但是这个请求来自</a> Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。</p><p>这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码： src=”<a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory" target="_blank" rel="noopener">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</a> ”，并且通过广告等诱使 Bob 来访问他的网站。当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。 </p><h4 id="CSRF漏洞检测："><a href="#CSRF漏洞检测：" class="headerlink" title="CSRF漏洞检测："></a>CSRF漏洞检测：</h4><p>检测CSRF漏洞是一项比较繁琐的工作，最简单的方法就是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。</p><p>随着对CSRF漏洞研究的不断深入，不断涌现出一些专门针对CSRF漏洞进行检测的工具，如CSRFTester，CSRF Request Builder等。</p><p>以CSRFTester工具为例，CSRF漏洞检测工具的测试原理如下：使用CSRFTester进行测试时，首先需要抓取我们在浏览器中访问过的所有链接以及所有的表单等信息，然后通过在CSRFTester中修改相应的表单等信息，重新提交，这相当于一次伪造客户端请求。如果修改后的测试请求成功被网站服务器接受，则说明存在CSRF漏洞，当然此款工具也可以被用来进行CSRF攻击。</p><h4 id="防御CSRF攻击："><a href="#防御CSRF攻击：" class="headerlink" title="防御CSRF攻击："></a>防御CSRF攻击：</h4><h4 id="（1）验证-HTTP-Referer-字段"><a href="#（1）验证-HTTP-Referer-字段" class="headerlink" title="（1）验证 HTTP Referer 字段"></a>（1）验证 HTTP Referer 字段</h4><p>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 <a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory，用户必须先登陆" target="_blank" rel="noopener">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory，用户必须先登陆</a> bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。</p><p>这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。</p><p>然而，这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。</p><p>即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。</p><h4 id="（2）在请求地址中添加-token-并验证"><a href="#（2）在请求地址中添加-token-并验证" class="headerlink" title="（2）在请求地址中添加 token 并验证"></a>（2）在请求地址中添加 token 并验证</h4><p>CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p><p>这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 <a href="http://url?csrftoken=tokenvalue。" target="_blank" rel="noopener">http://url?csrftoken=tokenvalue。</a> 而对于 POST 请求来说，要在 form 的最后加上 <input type="hidden" name="csrftoken" value="tokenvalue">，这样就把 token 以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。</p><p>该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。</p><h4 id="（3）在-HTTP-头中自定义属性并验证"><a href="#（3）在-HTTP-头中自定义属性并验证" class="headerlink" title="（3）在 HTTP 头中自定义属性并验证"></a>（3）在 HTTP 头中自定义属性并验证</h4><p>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</p><p>然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.phpddt.com/reprint/csrf.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;转载地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CSRF概念：&lt;/strong&gt;CSRF跨站点请求伪造(Cros
      
    
    </summary>
    
      <category term="其他" scheme="http://yoursite.com/child/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/child/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>分布式-logstash配置文件编写</title>
    <link href="http://yoursite.com/child/2020/04/09/%E5%88%86%E5%B8%83%E5%BC%8F-logstash%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99/"/>
    <id>http://yoursite.com/child/2020/04/09/分布式-logstash配置文件编写/</id>
    <published>2020-04-08T16:00:00.000Z</published>
    <updated>2020-06-12T00:27:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>贴一下配置好的logstash配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">input&#123;</span><br><span class="line">tcp&#123;</span><br><span class="line">port=&gt;4675</span><br><span class="line">codec=&gt;json</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter&#123;</span><br><span class="line">mutate&#123;</span><br><span class="line">gsub=&gt;[&quot;message&quot;,&quot;[\\]&quot;,&quot;&quot;]</span><br><span class="line">&#125;</span><br><span class="line">json&#123;</span><br><span class="line">source=&gt;&quot;message&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">output&#123;</span><br><span class="line">elasticsearch&#123;</span><br><span class="line">action=&gt;index</span><br><span class="line">host=&gt;localhost:9092</span><br><span class="line">index=&gt;&quot;dmp_audit_logs_%&#123;[+YYYY-MM-dd]&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置中主要分为三部分input、filter、output，这三部分是logstash pipeline中的三个元素，其中input和output是必须的，filter是可选的。</p><h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><p>配置数据的输入源</p><p>控制台输入 </p><p>文件输入  </p><p>插件输入（beat）  </p><p>中间件输入（kafka）</p><p>应用日志输入（日志appender）</p><p>最简单的输入源配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input&#123; stdin&#123;&#125; &#125;</span><br><span class="line">output&#123; stdout&#123;&#125; &#125;  <span class="comment">//控制台输出</span></span><br></pre></td></tr></table></figure><p>这样就配置了一个控制台输入和输出，启动logstash在控制台输入一条消息：hello logstash</p><p>控制台输出如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "@timestamp" =&gt; 2020-06-10T00:29:46.056Z,</span><br><span class="line">       "message" =&gt; "hello logstash",</span><br><span class="line">      "@version" =&gt; "1",</span><br><span class="line">          "host" =&gt; "zzk-redis.novalocal"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>logstash会自动给消息加上时间戳和版本信息，以及消息来源的ip，这里由于是本地发送的消息，所以host显示的是主机名</p><p>需求：将系统日志以json格式直接发送到logstash服务器</p><p>项目中配置logAppender，将日志直接发送给logshatsh的10514端口，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">input&#123;</span><br><span class="line">tcp&#123;</span><br><span class="line">port=&gt;<span class="number">10514</span>    <span class="comment">// 配置logstash监听4675端口</span></span><br><span class="line">codec=&gt;json   <span class="comment">// 配置数据解析方式为json</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>在生产环境中，当服务器访问量较大，连续执行日志写出动作，出现了tcp拆包的问题，见下图：</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/%E7%BD%91%E7%BB%9C/logstash%E6%8B%86%E5%8C%85%E9%97%AE%E9%A2%98.png" alt></p><p>可以看到，一条日志被拆成了两份，导致json解析失败。</p><p>所以高并发场景下，直接将日志写出到logstash是不可取的。</p><p>在中间加一层kafka就能解决上述问题，logAppender直接将日志文件写出到kafka中，logstash配置输入源为kafka，kafka作为消息中间件，一定不存在tcp拆包问题。</p><h4 id="output"><a href="#output" class="headerlink" title="output"></a>output</h4><p>配置数据输出目的地：</p><p>标准输出</p><p>es输出</p><p>中间件输出</p><p>需求：将日志数据输出到es存储</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">output&#123;</span><br><span class="line">elasticsearch&#123;</span><br><span class="line">action=&gt;index</span><br><span class="line">host=&gt;localhost:<span class="number">9092</span></span><br><span class="line">index=&gt;<span class="string">"dmp_audit_logs_%&#123;[+YYYY-MM-dd]&#125;"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>action=&gt;index表示是插入索引操作</p><p>host=&gt;localhost:9092 es的host</p><p>index=&gt;”dmp_audit_logs_%{[+YYYY-MM-dd]}”  表示插入的索引名称</p><p>配置完input和output就可以收集数据上传到es啦，那么logstash肯定不是只有这么简单的收集&amp;上传操作，logstash主要解决的问题是将乱七八糟各式各样的日志文件，整理成统一的格式上传到es，方便es进行统计分析。最主要的功能是在可选的filter模块实现的。</p><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>我在上传审计日志的过程中，遇到一些问题：</p><p>审计日志主要是采集了用户的一些请求信息，将这些信息转换成json字符串之后，字串携带了大量的转义反斜杠，将这个字串直接上传到logstash，发现审计信息不能解析出来，还是以json字串形式存放在message字段中，我的需求是将所有的信息都解析成独立的字段。</p><p>字串去反斜杠</p><p>去反斜杠的操作不能再在java中执行，因为java并不知道反斜杠的存在</p><p>因此需要在logshtash中进行配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">filter&#123;</span><br><span class="line">mutate&#123;</span><br><span class="line">gsub=&gt;[<span class="string">"message"</span>,<span class="string">"[\\]"</span>,<span class="string">""</span>] <span class="comment">// 去掉反斜杠</span></span><br><span class="line">&#125;</span><br><span class="line">json&#123;</span><br><span class="line">source=&gt;<span class="string">"message"</span>  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gsub 操作：将制定字段中的 某字串 替换成 另一个字符（串）</p><p>json操作： 对制定字段的信息执行反json操作，获取字段信息</p><p>以上就解决了将java审计日志上传至es的配置</p><p>filter可以对数据字段进行很多的操作，本业务场景中并没有用到，可以参考一以下链接</p><p><a href="https://cloud.tencent.com/developer/article/1353068" target="_blank" rel="noopener">一文快速上手Logstash</a></p><p><a href="https://www.cnblogs.com/wzxmt/p/11031110.html" target="_blank" rel="noopener">logstash配置文件详解</a></p><p><a href="https://www.jianshu.com/p/0b89c07021f4" target="_blank" rel="noopener">Logstash输出到Elasticsearch笔记</a></p><p><a href="https://www.cnblogs.com/yangwenbo214/p/9831081.html" target="_blank" rel="noopener">Logstash替换字符串</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;贴一下配置好的logstash配置文件&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li
      
    
    </summary>
    
      <category term="分布式架构技术" scheme="http://yoursite.com/child/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ElasticSearch" scheme="http://yoursite.com/child/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>ELK统一日志管理</title>
    <link href="http://yoursite.com/child/2020/04/07/%E5%88%86%E5%B8%83%E5%BC%8F-ELK%E7%BB%9F%E4%B8%80%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/child/2020/04/07/分布式-ELK统一日志管理/</id>
    <published>2020-04-06T16:00:00.000Z</published>
    <updated>2020-06-12T00:42:20.960Z</updated>
    
    <content type="html"><![CDATA[<h4 id="ElasticSearch部署"><a href="#ElasticSearch部署" class="headerlink" title="ElasticSearch部署"></a>ElasticSearch部署</h4><p>下载解压改配置文件/config/elasticsearch.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cluster.name:</span> <span class="string">my-application</span></span><br><span class="line"><span class="string">node.name:</span> <span class="string">node-1</span></span><br><span class="line"><span class="string">network.host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="string">http.port:</span> <span class="number">9200</span></span><br><span class="line"><span class="string">cluster.initial_master_nodes:</span> <span class="string">["node-1"]</span></span><br></pre></td></tr></table></figure><p>启动es命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/app/elasticSearch</span><br><span class="line"><span class="comment">#后台启动</span></span><br><span class="line">./bin/elasticksearch -d</span><br></pre></td></tr></table></figure><h4 id="Kibana部署"><a href="#Kibana部署" class="headerlink" title="Kibana部署"></a>Kibana部署</h4><p>下载解压改配置文件/config/kibana.yml：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">port:</span> <span class="number">5601</span></span><br><span class="line"><span class="string">server.host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="string">elasticsearch.hosts:</span> <span class="string">["ip:port","ip:port"]</span></span><br></pre></td></tr></table></figure><p>启动kibana命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/app/kibana</span><br><span class="line"><span class="comment">#后台启动</span></span><br><span class="line">nohup ./bin/kibana &amp;</span><br></pre></td></tr></table></figure><h4 id="logstash部署"><a href="#logstash部署" class="headerlink" title="logstash部署"></a>logstash部署</h4><p>启动logstash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/app/logstash/bin</span><br><span class="line"><span class="comment">#测试</span></span><br><span class="line">logstash --path.settings ../config/ -f ../config/logstash.conf --config.test_and_exit</span><br><span class="line"><span class="comment">#启动</span></span><br><span class="line">logstash -f ../config/logstash-es.conf</span><br><span class="line"><span class="comment">#查看端口监听状态以及pid</span></span><br><span class="line">netstat -lntp |grep 10514</span><br></pre></td></tr></table></figure><p>logstash-es.conf 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    tcp &#123;</span><br><span class="line">        port =&gt; 10514</span><br><span class="line">        codec =&gt; json</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  grok &#123;</span><br><span class="line">    match=&gt;&#123;<span class="string">"message"</span>=&gt; <span class="string">"%&#123;IP:client&#125; %&#123;WORD:method&#125; %&#123;URIPATHPARAM:request&#125; %&#123;NUMBER:bytes&#125; %&#123;NUMBER:duration&#125;"</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">stdout&#123;</span><br><span class="line">codec=&gt;rubydebug <span class="comment">#美化输出</span></span><br><span class="line">&#125;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">        action =&gt; <span class="string">"index"</span></span><br><span class="line">        hosts =&gt; [<span class="string">"10.0.12.72:9200"</span>]</span><br><span class="line">        index =&gt; <span class="string">"dmp_audit_logs_%&#123;[+YYYY-MM-dd]&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>logback.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">"false"</span> <span class="attr">scan</span>=<span class="string">"false"</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"console"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;MM-dd HH:mm:ss.SSS&#125; %-5level [%logger&#123;50&#125;] - %msg%n</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"logstash"</span> <span class="attr">class</span>=<span class="string">"net.logstash.logback.appender.LogstashTcpSocketAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"Encoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">destination</span>&gt;</span>10.0.12.72:10514<span class="tag">&lt;/<span class="name">destination</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> <span class="attr">class</span>=<span class="string">"net.logstash.logback.encoder.LogstashEncoder"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--%&#123;appName&#125;中的appName需要在属性中配置，作为字段写入到doc中--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">customFields</span>&gt;</span>&#123;"appname":"dmp"&#125;<span class="tag">&lt;/<span class="name">customFields</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">connectionStrategy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">roundRobin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">connectionTTL</span>&gt;</span>5 minutes<span class="tag">&lt;/<span class="name">connectionTTL</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">roundRobin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">connectionStrategy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"console"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.cetiti.es.controller"</span> <span class="attr">level</span>=<span class="string">"INFO"</span> <span class="attr">addtivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"logstash"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>参考文档：</p><p><a href="https://www.jianshu.com/p/d66bfe7e9127" target="_blank" rel="noopener">ELK-概念</a></p><p><a href="https://www.cnblogs.com/wangzhuxing/p/9665905.html" target="_blank" rel="noopener">logback+ELK日志搭建</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;ElasticSearch部署&quot;&gt;&lt;a href=&quot;#ElasticSearch部署&quot; class=&quot;headerlink&quot; title=&quot;ElasticSearch部署&quot;&gt;&lt;/a&gt;ElasticSearch部署&lt;/h4&gt;&lt;p&gt;下载解压改配置文件/config/e
      
    
    </summary>
    
      <category term="分布式架构技术" scheme="http://yoursite.com/child/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ElasticSearch" scheme="http://yoursite.com/child/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>系统审计日志需求分析及方案</title>
    <link href="http://yoursite.com/child/2020/04/06/%E4%B8%9A%E5%8A%A1-%E7%B3%BB%E7%BB%9F%E5%AE%A1%E8%AE%A1%E6%97%A5%E5%BF%97%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/child/2020/04/06/业务-系统审计日志需求分析以及方案/</id>
    <published>2020-04-05T16:00:00.000Z</published>
    <updated>2020-06-12T00:34:52.099Z</updated>
    
    <content type="html"><![CDATA[<p>在一个完整的信息系统里面，日志系统是一个非常重要的功能组成部分。它可以记录下系统所产生的所有行为，并按照某种规范表达出来。我们可以使用日志系统所记录的信息为系统进行排错，优化系统的性能，或者根据这些信息调整系统的行为。在安全领域，日志可以反应出很多的安全攻击行为，比如登录错误，异常访问等。日志还能告诉你很多关于网络中所发生事件的信息，包括性能信息、故障检测和入侵检测。日志会成为在事故发生后查明“发生了什么”的一个很好的“取证”信息来源。日志可以为审计进行审计跟踪。</p><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p><strong><em>审计日志在哪里执行记录操作？</em></strong></p><p>controller层？service层？dao层？</p><p>controller层最先接触到request请求，如果我们要对分析用户的行为，那么日志应该在c层记录</p><p>service层是向c层提供服务的，整合了数据访问、数据计算等任务，如果要分析系统服务性能、那么日志应该打在s层</p><p>dao层是数据访问层，主要负责数据库的读写任务，如果要对数据访问接口的性能进行分析，那么日志应该在dao层</p><p><strong><em>审计日志内容怎么存储？</em></strong></p><p>日志文件？关系？es？</p><p>写日志文件是对磁盘顺序写操作，操作效率高，但是有两个缺点：一是不利于检索，一是日志文件存储在本地，分布式环境下不利于日志统一管理，因此日志文件不适合审计日志的存储</p><p>关系型数据，中小型系统可以使用，随着日志越来越多，检索效率降低，可以根据日志时间或者日志类型分表存储，缺点是日志分析不是很方便</p><p>ES，卓越的检索效率，集群部署方便扩展的特点，是审计日志最好的存储方式，自带分析统计功能，可以实时统计</p><p><strong><em>审计日志要记录哪些内容？</em></strong></p><p>针对用户分析日志：请求用户、请求ip地址、请求参数、</p><p>针对服务分析日志：服务接口执行时间、调用次数、堆栈大小，继而可以分析出服务的调用频率、平均耗时</p><p>用户行为分析：</p><ul><li><p>登录日志：记录登录时间、登录ip地址、登录用户、登录结果</p></li><li><p>业务访问日志：记录操作时间、用户Ip地址、访问接口、请求参数、请求结果</p></li></ul><h3 id="确定方案"><a href="#确定方案" class="headerlink" title="确定方案"></a>确定方案</h3><p>spring-aop  +  自定义注解  +  elk</p><p>aop面向切面的思想可以将记录日志逻辑 从 业务逻辑中解耦出来</p><p>自定义注解可以 更灵活的 指定切面</p><p>es存储日志，便于扩展，利于检索和分析</p><h3 id="方案实现"><a href="#方案实现" class="headerlink" title="方案实现"></a>方案实现</h3><p>所有的外部请求都会经过网关，网关负责登录，考虑到登录与业务访问需要记录的日志内容不太相同，所以登录模块单独设计一个注解，业务模块可以共用一个注解。</p><p>登录模块：</p><p>业务模块：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在一个完整的信息系统里面，日志系统是一个非常重要的功能组成部分。它可以记录下系统所产生的所有行为，并按照某种规范表达出来。我们可以使用日志系统所记录的信息为系统进行排错，优化系统的性能，或者根据这些信息调整系统的行为。在安全领域，日志可以反应出很多的安全攻击行为，比如登录错
      
    
    </summary>
    
      <category term="业务" scheme="http://yoursite.com/child/categories/%E4%B8%9A%E5%8A%A1/"/>
    
    
      <category term="ElasticSearch" scheme="http://yoursite.com/child/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>mysql-innoDB架构分析</title>
    <link href="http://yoursite.com/child/2020/01/02/mysql-innoDB%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/child/2020/01/02/mysql-innoDB架构分析/</id>
    <published>2020-01-01T16:00:00.000Z</published>
    <updated>2020-05-22T11:52:38.724Z</updated>
    
    <content type="html"><![CDATA[<p>先上一张官网的架构图，本文将按照架构图中的组件逐一分析。</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/mysql/innodb-architecture.png" alt="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/mysql/innodb-architecture.png"></p><h4 id="1-buffer-pool"><a href="#1-buffer-pool" class="headerlink" title="1. buffer pool"></a>1. buffer pool</h4><p>按照局部性原理，将预期会使用到的数据缓存到内存中，避免每次读取数据都需要进行磁盘i/o，提升i/o性能，这块存放缓存的内存区域就是buffer pool。</p><p>buffer pool 是一种降低磁盘访问的机制。</p><p>磁盘访问通常以页为单位。</p><p>缓存池常见的实现方式是LRU（链表实现，为了减少数据移动），管理磁盘页。</p><p>缓存池管理方式–LRU（链表实现，为了减少数据移动）</p><p>普通LRU会有以下问题：</p><ul><li>预读取失效，预读取的页不会真正被读取<ul><li>优化思路：让预读失效页尽快出内存，真正读取页才挪到LRU头部</li><li>方案：分代管理，预读取进入老生代，真正读取再进入新生代</li></ul></li><li>缓冲池污染，要批量扫描大量数据，导致缓冲池中的热点页被大量替换出去<ul><li>方案：在老生代设置停留时间，只有被真正读取并且停留时间达到阈值，才会移步新生代</li></ul></li></ul><p><strong>innoDB 的buffer pool 对应参数</strong></p><p>参数：innodb_buffer_pool_size</p><p>介绍：配置缓冲池的大小，在内存允许的情况下，DBA往往会建议调大这个参数，越多数据和索引放到内存里，数据库的性能会越好。 </p><p>参数：innodb_old_blocks_pct</p><p>介绍：老生代占整个LRU链长度的比例，默认是37，即整个LRU中新生代与老生代长度比例是63:37。</p><p><em>画外音：如果把这个参数设为100，就退化为普通LRU了。</em></p><p>参数：innodb_old_blocks_time</p><p>介绍：老生代停留时间窗口，单位是毫秒，默认是1000，即同时满足“被访问”与“在老生代停留时间超过1秒”两个条件，才会被插入到新生代头部。</p><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651962450&amp;idx=1&amp;sn=ce17c4da8d20ce275f75d0f2ef5e40c9&amp;chksm=bd2d098e8a5a809834aaa07da0d7546555385543fb6d687a7cf94d183ab061cd301a76547411&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Buffer pool 参考链接</a></p><p>对于读请求，buffer pool 能够减少磁盘的io，提高性能，那么对于写请求呢？change buffer此时登场。</p><h4 id="2-Change-Buffer"><a href="#2-Change-Buffer" class="headerlink" title="2. Change Buffer"></a>2. Change Buffer</h4><p>而对于写请求的优化，就是使用change buffer 来降低磁盘io的</p><p>主要应用于<strong>不在缓冲池中的非唯一普通索引页的写操作</strong></p><p>如果要写的页写已经在缓冲池中了是怎样一个写流程？</p><p>为什么唯一索引不适用呢？</p><p>唯一索引的话每次插入操作都需要检查索引的唯一性</p><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651962467&amp;idx=1&amp;sn=899ea157b0fc6f849ec80a4d055a309b&amp;chksm=bd2d09bf8a5a80a972a2e16a190ed7dffe03f89015ead707bdfcc5aeb8388fb278f397c125f1&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">change buffer 参考</a></p><p>相关参数：</p><p><strong>参数</strong>：innodb_change_buffer_max_size</p><p><strong>介绍</strong>：配置写缓冲的大小，占整个缓冲池的比例，默认值是25%，最大值是50%。</p><p><em>画外音：写多读少的业务，才需要调大这个值，读多写少的业务，25%其实也多了。</em></p><p><strong>参数</strong>：innodb_change_buffering</p><p><strong>介绍</strong>：配置哪些写操作启用写缓冲，可以设置成all/none/inserts/deletes等。</p><h4 id="3-Log-buffer"><a href="#3-Log-buffer" class="headerlink" title="3. Log buffer"></a>3. Log buffer</h4><p>知其然，知其所以然。思路比结论重要</p><p>事务提交时，事务日志为什么要先写到log buffer 在写到os cache中呢？</p><p>虽然是内存操作，但是日志写到os cache中需要进行上下文切换切换到内核态，每次事务提交都直接写则每次都要切换到内核态。先写到log buffer中，将每次写优化为批量写，减少上下文切换次数。</p><p><em>这个优化思路很常见，高并发的MQ落盘，高并发的业务数据落盘，都可以使用。</em></p><h4 id="4-AHI–Adaptive-Hash-Index"><a href="#4-AHI–Adaptive-Hash-Index" class="headerlink" title="4. AHI–Adaptive Hash Index"></a>4. AHI–Adaptive Hash Index</h4><p>自适应哈希索引</p><p><strong>为什么叫自适应？</strong></p><p>用户不能创建，是mysql优化器自行判断，需要时创建</p><p><strong>既然是hash，key是什么，value是什么？</strong></p><p>key是索引键值</p><p>value是索引记录的页面位置</p><p>所以hash索引是索引的索引</p><p><strong>为什么要用哈希索引进行优化？</strong></p><p>通过附加索引查询数据时，有时候会进行回表查询，这样会导致查询连路很长降低查询效率</p><p><strong>哪些业务适用，哪些业务不适用？</strong></p><p>单行记录查询、索引范围查询、记录数不多能全部放到内存中—-适用</p><p>业务中有大量join、like时，AHI的维护会成为负担，建议手动关闭。</p><h4 id="5-redo-log"><a href="#5-redo-log" class="headerlink" title="5. redo log"></a>5. redo log</h4><p>有单独文章讲解</p><h4 id="6-double-write-buffer"><a href="#6-double-write-buffer" class="headerlink" title="6. double write buffer"></a>6. double write buffer</h4><p>知其然，知其所以然。思路比结论重要</p><p><strong>解决什么问题？</strong></p><p>innoDB数据页大小是16k，文件系统中的数据页（后称系统页）大小是4K，那么写数据库时我们将一页数据页落盘，需要刷写4页系统页，如果在此过程中系统掉电，将造成磁盘数据页损坏（例如，前两页系统页已被刷写，后两页未刷写）。</p><p><strong>如何解决？</strong></p><p>DWB缓存即将刷写的数据页。。</p><p>DWB具有两层架构，分为内存和磁盘</p><p>当有数据要落盘时：</p><p>第一步：将内存中修改后的数据页memcopy到dwb内存中</p><p>第二步：将dwb内存中的数据页写入dwb磁盘</p><p>第三步：将dwb中的数据页落盘到磁盘数据页</p><p>假使第二步掉电，磁盘数据页也还是完整的，可以通过redo log进行恢复</p><p>假如第三笔掉电，dwb中的数据页也是完整的，可以直接落盘</p><p><strong>性能影响大吗？</strong></p><p>第一步属于内存操作，速度很快</p><p>第二步属于磁盘顺序追加写，1秒几万次没问题</p><p>第三步不属于额外操作</p><p>另外，dwb 由128页组成，容量2MB，会分两次刷入dwb磁盘，每次1M，速度也很快</p><p><em>有第三方评测，性能损失约为10%</em></p><p>可以通过：</p><p>show global status like “%dblwr%” 查看dwb使用情况</p><p>Innodb_dblwr_pages_written 记录dwb中的写入页数</p><p>Innodb_dblwr_writes 记录dwb的写入次数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先上一张官网的架构图，本文将按照架构图中的组件逐一分析。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/mysql/innodb-architecture.png&quot; alt=&quot;https
      
    
    </summary>
    
      <category term="数据库技术" scheme="http://yoursite.com/child/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/child/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql-redo log写流程分析(转)</title>
    <link href="http://yoursite.com/child/2020/01/02/mysql-redo%20log%E5%86%99%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/child/2020/01/02/mysql-redo log写流程分析/</id>
    <published>2020-01-01T16:00:00.000Z</published>
    <updated>2020-05-22T11:52:20.859Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://mp.weixin.qq.com/s/-Hx2KKYMEQCcTC-ADEuwVA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/-Hx2KKYMEQCcTC-ADEuwVA</a></p><p>为什么我的事务提交了，还会丢失数据呢？</p><p>这要从innoDB的一个参数说起</p><p><em>innodb_flush_log_at_trx_commit</em></p><p>参数的字面意思是innodb在事务提交时更新日志的方式，这个参数有 0，1，2 三种取值，表示有三种方式更新日志</p><p>首先我们要弄清楚事务提交时会更新那些日志呢？</p><p>前滚日志redo log 和 回滚日志undo log ，这两者称为innodb的事务日志。</p><p>事务提交后，存储引擎要将事务对数据的修改刷写到磁盘上以保证事务的ACID特性</p><blockquote><p><strong>A</strong>: atomicity-原子性</p><p><strong>C</strong>: consistency-一致性</p><p><strong>I</strong>: isolation-隔离性</p><p><strong>D</strong>: durability-持久性</p></blockquote><p>这个刷盘，是一个随机写，随机写性能较低，如果每次事务提交都刷盘，会极大影响数据库的性能。</p><p>知其然，知其所以然。思路比结论重要</p><p>所以为了优化随机写带来的低性能，架构设计中有两个常见的优化方法：</p><p>（1）先写日志(write log first)，将随机写优化为<strong>顺序写</strong>；</p><p>（2）将每次写优化为<strong>批量写</strong>；</p><p>这两个优化，InnoDB都用上了。</p><p>先说第一个优化，将对数据的修改先顺序写到日志里，这个日志就是redo log。</p><p>假如某一时刻，数据库崩溃，还没来得及将数据页刷盘，数据库重启时，会重做redo log里的内容，以保证已提交事务对数据的影响被刷到磁盘上。因此，redo log 又称为重做日志。</p><p>一句话，redo log是为了保证已提交事务的ACID特性，同时能够提高数据库性能的技术。</p><p>既然redo log能保证事务的ACID特性，那为什么还会出现，水友提问中出现的“数据库奔溃，丢数据”的问题呢？一起看下redo log的实现细节。</p><p><strong>redo log的三层架构</strong></p><p>画了一个丑图，简单说明下redo log的三层架构：</p><ul><li><strong>粉色</strong>，是InnoDB的一项很重要的内存结构(In-Memory Structure)，日志缓冲区(Log Buffer)，这一层，是MySQL应用程序用户态</li><li><strong>屎黄色</strong>，是操作系统的缓冲区(OS cache)，这一层，是OS内核态</li><li><strong>蓝色</strong>，是落盘的日志文件</li></ul><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/mysql/redolog-1.PNG" alt="redolog-1"></p><p><strong>redo log最终落盘的步骤如何？</strong></p><p><strong>首先</strong>，事务提交的时候，会写入Log Buffer，这里调用的是MySQL自己的函数WriteRedoLog；</p><p><strong>接着</strong>，只有当MySQL发起系统调用写文件write时，Log Buffer里的数据，才会写到OS cache。注意，MySQL系统调用完write之后，就认为文件已经写完，如果不flush，什么时候落盘，是操作系统决定的；</p><blockquote><p>画外音：<strong>有时候打日志，明明</strong>printf<strong>了，</strong>tail -f**却看不到，就是这个原因，这个细节在《明明打印到文件了，为啥tail -f看不到》一文里说过，此处不再展开。</p></blockquote><p><strong>最后</strong>，由操作系统（当然，MySQL也可以主动flush）将OS cache里的数据，最终fsync到磁盘上；</p><p><strong>操作系统为什么要缓冲数据到</strong>OS cache里，而不直接刷盘呢？</p><p>这里就是将“每次写”优化为“批量写”，以提高操作系统性能。</p><p><strong>数据库为什么要缓冲数据到Log Buffer</strong>里，而不是直接write呢？</p><p>这也是“每次写”优化为“批量写”思路的体现，以提高数据库性能。</p><blockquote><p>画外音：这个优化思路，非常常见，高并发的MQ落盘，高并发的业务数据落盘，都可以使用。</p></blockquote><p>redo log的三层架构，MySQL做了一次批量写优化，OS做了一次批量写优化，确实能极大提升性能，但有什么副作用吗？</p><blockquote><p>画外音：有优点，必有缺点。</p></blockquote><p>这个<strong>副作用</strong>，就是可能丢失数据：</p><p>（1）事务提交时，将redo log写入Log Buffer，就会认为事务提交成功；</p><p>（2）如果写入Log Buffer的数据，write入OS cache之前，数据库崩溃，就会出现数据丢失；</p><p>（3）如果写入OS cache的数据，fsync入磁盘之前，操作系统奔溃，也可能出现数据丢失；</p><blockquote><p>画外音：如上文所说，应用程序系统调用完write之后（不可能每次write后都立刻flush，这样写日志很蠢），就认为写成功了，操作系统何时fsync，应用程序并不知道，如果操作系统崩溃，数据可能丢失。</p></blockquote><p>任何脱离业务的技术方案都是耍流氓：</p><p>（1）有些业务允许低效，但不允许一丁点数据丢失；</p><p>（2）有些业务必须高性能高吞吐，能够容忍少量数据丢失；</p><p><strong>MySQL是如何折衷的呢？</strong></p><p>MySQL有一个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_flush_log_at_trx_commit</span><br></pre></td></tr></table></figure><p>能够控制事务提交时，刷redo log的策略。</p><p>目前有<strong>三种策略</strong>：</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/mysql/redolog-2.PNG" alt="redolog-2"></p><p><strong>策略一：最佳性能</strong>(innodb_flush_log_at_trx_commit=0)</p><p>每隔一秒，才将Log Buffer中的数据批量write入OS cache，同时MySQL主动fsync。</p><p>这种策略，如果数据库奔溃，有一秒的数据丢失。</p><p><strong>策略二：强一致</strong>(innodb_flush_log_at_trx_commit=1)</p><p>每次事务提交，都将Log Buffer中的数据write入OS cache，同时MySQL主动fsync。</p><p>这种策略，是InnoDB的默认配置，为的是保证事务ACID特性。</p><p><strong>策略三：折衷</strong>(innodb_flush_log_at_trx_commit=2)</p><p>每次事务提交，都将Log Buffer中的数据write入OS cache；</p><p>每隔一秒，MySQL主动将OS cache中的数据批量fsync。</p><p><em>画外音：**磁盘IO次数不确定，因为操作系统的fsync频率并不是MySQL能控制的。</em></p><p>这种策略，如果操作系统奔溃，最多有一秒的数据丢失。</p><blockquote><p>画外音：因为OS也会fsync，MySQL主动fsync的周期是一秒，所以最多丢一秒数据。</p></blockquote><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/mysql/redolog-3.PNG" alt="redolog-3"></p><p>讲了这么多，回到水友的提问上来，数据库崩溃，重启后丢失了数据，有很大的可能，是将innodb_flush_log_at_trx_commit参数设置为0了，这位水友最好和DBA一起检查一下InnoDB的配置。</p><p>可能有水友要问，<strong>高并发的业务，InnoDB运用哪种刷盘策略最合适？</strong></p><p>高并发业务，行业最佳实践，是使用<strong>第三种折衷配置</strong>（=2），这是因为：</p><ol><li>配置为2和配置为0，性能差异并不大，因为将数据从Log Buffer拷贝到OS cache，虽然跨越用户态与内核态，但毕竟只是内存的数据拷贝，速度很快；</li><li>配置为2和配置为0，安全性差异巨大，操作系统崩溃的概率相比MySQL应用程序崩溃的概率，小很多，设置为2，只要操作系统不奔溃，也绝对不会丢数据。</li></ol><p><strong>总结</strong></p><p>一、为了保证事务的ACID特性，理论上每次事务提交都应该刷盘，但此时效率很低，有两种优化方向：</p><ol><li>随机写优化为顺序写；</li><li>每次写优化为批量写；</li></ol><p>二、redo log是一种顺序写，它有三层架构：</p><ol><li>MySQL应用层：Log Buffer</li><li>OS内核层：OS cache</li><li>OS文件：log file</li></ol><p>三、为了满足不用业务对于吞吐量与一致性的需求，MySQL事务提交时刷redo log有三种策略：</p><ul><li>0：每秒write一次OS cache，同时fsync刷磁盘，性能好；</li><li>1：每次都write入OS cache，同时fsync刷磁盘，一致性好；</li><li>2：每次都write入OS cache，每秒fsync刷磁盘，折衷；</li></ul><p>四、高并发业务，行业内的最佳实践，是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_flush_log_at_trx_commit=2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/-Hx2KKYMEQCcTC-ADEuwVA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/-Hx2KKYMEQCcTC
      
    
    </summary>
    
      <category term="数据库技术" scheme="http://yoursite.com/child/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/child/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>redis-热key问题</title>
    <link href="http://yoursite.com/child/2020/01/02/redis-%E7%83%AD%E7%82%B9key%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/child/2020/01/02/redis-热点key问题/</id>
    <published>2020-01-01T16:00:00.000Z</published>
    <updated>2020-05-22T12:12:41.683Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/rjzheng/p/10874537.html" target="_blank" rel="noopener">原文链接</a></p><p>所谓热key问题就是，突然有几十万的请求去访问redis上的某个特定key。那么，这样会造成流量过于集中，达到物理网卡上限，从而导致这台redis的服务器宕机。<br>那接下来这个key的请求，就会直接怼到你的数据库上，导致你的服务不可用。</p><h3 id="1-怎么发现热key"><a href="#1-怎么发现热key" class="headerlink" title="1. 怎么发现热key"></a>1. 怎么发现热key</h3><p><strong><em>方法一:凭借业务经验，进行预估哪些是热key</em></strong><br>其实这个方法还是挺有可行性的。比如某商品在做秒杀，那这个商品的key就可以判断出是热key。</p><p>缺点很明显，并非所有业务都能预估出哪些key是热key。</p><p><strong><em>方法二:在客户端进行收集</em></strong><br>这个方式就是在操作redis之前，加入一行代码进行数据统计。那么这个数据统计的方式有很多种，也可以是给外部的通讯系统发送一个通知信息。缺点就是对客户端代码造成入侵。</p><p><strong><em>方法三:在Proxy层做收集</em></strong><br>有些集群架构是下面这样的，Proxy可以是Twemproxy，是统一的入口。可以在Proxy层做收集上报，但是缺点很明显，并非所有的redis集群架构都有proxy。</p><p><img src="https://img2018.cnblogs.com/blog/725429/201905/725429-20190516112209464-1290077151.png" alt="img"></p><p><strong><em>方法四:用redis自带命令</em></strong></p><ol><li>monitor命令，该命令可以实时抓取出redis服务器接收到的命令，然后写代码统计出热key是啥。当然，也有现成的分析工具可以给你使用，比如<code>redis-faina</code>。但是该命令在高并发的条件下，有内存增暴增的隐患，还会降低redis的性能。</li><li>hotkeys参数，redis 4.0.3提供了redis-cli的热点key发现功能，执行redis-cli时加上–hotkeys选项即可。但是该参数在执行的时候，如果key比较多，执行起来比较慢。</li></ol><p>缺点是对redis性能影响较大</p><p><strong><em>方法五:自己抓包评估</em></strong><br>Redis客户端使用TCP协议与服务端进行交互，通信协议采用的是RESP。自己写程序监听端口，按照RESP协议规则解析数据，进行分析。缺点就是开发成本高，维护困难，有丢包可能性。</p><p>以上五种方案，各有优缺点。根据自己业务场景进行抉择即可。那么发现热key后，如何解决呢？</p><h3 id="2-如何解决"><a href="#2-如何解决" class="headerlink" title="2. 如何解决"></a>2. 如何解决</h3><p>目前业内的方案有两种</p><p><strong><em>方案一：利用二级缓存</em></strong><br>比如利用<code>ehcache</code>，或者一个<code>HashMap</code>都可以。在你发现热key以后，把热key加载到系统的JVM中。<br>针对这种热key请求，会直接从jvm中取，而不会走到redis层。<br>假设此时有十万个针对同一个key的请求过来,如果没有本地缓存，这十万个请求就直接怼到同一台redis上了。<br>现在假设，你的应用层有50台机器，OK，你也有jvm缓存了。这十万个请求平均分散开来，每个机器有2000个请求，会从JVM中取到value值，然后返回数据。避免了十万个请求怼到同一台redis上的情形。</p><p><strong><em>方案二：备份热key</em></strong><br>这个方案也很简单。不要让key走到同一台redis上不就行了。我们把这个key，在多个redis上都存一份不就好了。接下来，有热key请求进来的时候，我们就在有备份的redis上随机选取一台，进行访问取值，返回数据。<br>假设redis的集群数量为N，步骤如下图所示</p><p><img src="https://img2018.cnblogs.com/blog/725429/201905/725429-20190516112222759-656135438.png" alt="img"></p><p>注:不一定是2N，你想取3N，4N都可以，看要求。<br>伪代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> M = N * <span class="number">2</span></span><br><span class="line"><span class="comment">//生成随机数</span></span><br><span class="line">random = GenRandom(<span class="number">0</span>, M)</span><br><span class="line"><span class="comment">//构造备份新key</span></span><br><span class="line">bakHotKey = hotKey + “_” + random</span><br><span class="line">data = redis.GET(bakHotKey)</span><br><span class="line"><span class="keyword">if</span> data == NULL &#123;</span><br><span class="line">    data = GetFromDB()</span><br><span class="line">    redis.SET(bakHotKey, expireTime + GenRandom(<span class="number">0</span>,<span class="number">5</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-业内方案"><a href="#3-业内方案" class="headerlink" title="3. 业内方案"></a>3. 业内方案</h3><p>OK，其实看完上面的内容，大家可能会有一个疑问。</p><blockquote><p><strong>有办法在项目运行过程中，自动发现热key，然后程序自动处理么？</strong></p></blockquote><p>嗯，好问题，那我们来讲讲业内怎么做的。其实只有两步</p><ol><li>监控热key</li><li>通知系统做处理</li></ol><p>正巧，前几天有赞出了一篇《有赞透明多级缓存解决方案（TMC）》，里头也有提到热点key问题，我们刚好借此说明</p><ul><li>监控热key</li></ul><p>在监控热key方面，有赞用的是<strong><em>方式二：在客户端进行收集</em></strong>。<br>在《有赞透明多级缓存解决方案（TMC）》中有一句话提到</p><blockquote><p><strong>TMC 对原生jedis包的JedisPool和Jedis类做了改造，在JedisPool初始化过程中集成TMC“热点发现”+“本地缓存”功能Hermes-SDK包的初始化逻辑。</strong></p></blockquote><p>也就说人家改写了jedis原生的jar包，加入了Hermes-SDK包。<br>那Hermes-SDK包用来干嘛？<br>OK，就是做<strong>热点发现</strong>和<strong>本地缓存</strong>。</p><p>从监控的角度看，该包对于Jedis-Client的每次key值访问请求，Hermes-SDK 都会通过其通信模块将key访问事件异步上报给Hermes服务端集群，以便其根据上报数据进行“热点探测”。</p><p>当然，这只是其中一种方式，有的公司在监控方面用的是方式五:<strong>自己抓包评估</strong>。</p><p>具体是这么做的，先利用flink搭建一套流式计算系统。然后自己写一个抓包程序抓redis监听端口的数据，抓到数据后往kafka里丢。接下来，流式计算系统消费kafka里的数据，进行数据统计即可，也能达到监控热key的目的。</p><ul><li>通知系统做处理</li></ul><p>在这个角度，有赞用的是上面的<strong><em>解决方案一:利用二级缓存进行处理</em></strong>。</p><p>有赞在监控到热key后，Hermes服务端集群会通过各种手段通知各业务系统里的Hermes-SDK，告诉他们:”老弟，这个key是热key，记得做本地缓存。”</p><p>于是Hermes-SDK就会将该key缓存在本地，对于后面的请求。Hermes-SDK发现这个是一个热key，直接从本地中拿，而不会去访问集群。</p><p>除了这种通知方式以外。我们也可以这么做，比如你的流式计算系统监控到热key了，往zookeeper里头的某个节点里写。然后你的业务系统监听该节点，发现节点数据变化了，就代表发现热key。最后往本地缓存里写，也是可以的。</p><p>通知方式各种各样，大家可以自由发挥。本文只是提供一个思路。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/rjzheng/p/10874537.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所谓热key问题就是，突然有几十万的请求去访问redis上的某个
      
    
    </summary>
    
      <category term="noSql" scheme="http://yoursite.com/child/categories/noSql/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/child/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>reids-5.0版本的高可用集群搭建</title>
    <link href="http://yoursite.com/child/2019/12/31/redis-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/child/2019/12/31/redis-集群搭建/</id>
    <published>2019-12-30T16:00:00.000Z</published>
    <updated>2020-05-22T12:12:57.988Z</updated>
    
    <content type="html"><![CDATA[<p>Redis系统介绍：</p><p><a href="https://www.jianshu.com/p/2a23257af57b" target="_blank" rel="noopener">Redis的基础介绍与安装使用步骤</a><br><a href="https://www.jianshu.com/p/c95c8450c5b6" target="_blank" rel="noopener">Redis的基础数据结构与使用</a><br><a href="https://www.jianshu.com/p/4e6b7809e10a" target="_blank" rel="noopener">Redis核心原理</a><br><a href="https://www.jianshu.com/p/8045b92fafb2" target="_blank" rel="noopener">Redis 5 之后版本的高可用集群搭建</a><br><a href="https://www.jianshu.com/p/6355d0827aea" target="_blank" rel="noopener">Redis 5 版本的高可用集群的水平扩展</a><br><a href="https://www.jianshu.com/p/e6894713a6d5" target="_blank" rel="noopener">Redis 5 集群选举原理分析</a><br><a href="https://www.jianshu.com/p/575544f68615" target="_blank" rel="noopener">Redis 5 通信协议解析以及手写一个Jedis客户端</a></p><hr><h4 id="1-集群方案比较："><a href="#1-集群方案比较：" class="headerlink" title="1. 集群方案比较："></a>1. 集群方案比较：</h4><h5 id="1-1-哨兵模式："><a href="#1-1-哨兵模式：" class="headerlink" title="1.1 哨兵模式："></a>1.1 哨兵模式：</h5><p>在redis3.0以前的版本要实现集群一般是借助哨兵sentinel工具来监控master节点的状态，如果master节点异常，则会做主从切换，将某一台slave作为master，哨兵的配置略微复杂，并且性能和高可用性等各方面表现一般，特别是在主从切换的瞬间存在访问瞬断的情况，而且哨兵模式只有一个主节点对外提供服务，没法支持很高的并发，且单个主节点内存也不宜设置得过大，否则会导致持久化文件过大，影响数据恢复或主从同步的效率。</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/redis/redis-cluster%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.png" alt="哨兵模式"></p><h5 id="1-2-高可用集群模式："><a href="#1-2-高可用集群模式：" class="headerlink" title="1.2 高可用集群模式："></a>1.2 高可用集群模式：</h5><p>redis集群是一个由多个主从节点群组成的分布式服务器群，它具有复制、高可用和分片特性。Redis集群不需要sentinel哨兵也能完成节点移除和故障转移的功能。需要将每个节点设置成集群模式，这种集群模式没有中心节点，可水平扩展，据官方文档称可以线性扩展到上万个节点(官方推荐不超过1000个节点)。redis集群的性能和高可用性均优于之前版本的哨兵模式，且集群配置非常简单。</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/redis/redis-cluster%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84.png" alt="高可用架构"></p><h4 id="2-开始搭建"><a href="#2-开始搭建" class="headerlink" title="2. 开始搭建"></a>2. 开始搭建</h4><h5 id="2-1-安装redis"><a href="#2-1-安装redis" class="headerlink" title="2.1 安装redis"></a>2.1 安装redis</h5><p>参考之前博客：Redis的基础介绍与安装使用步骤：<a href="https://www.jianshu.com/p/2a23257af57b" target="_blank" rel="noopener">https://www.jianshu.com/p/2a23257af57b</a></p><p>下载地址：<a href="http://redis.io/download" target="_blank" rel="noopener">http://redis.io/download</a></p><p>1、安装gcc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc</span><br></pre></td></tr></table></figure><p>2、把下载好的redis-5.0.2.tar.gz放在/usr/local文件夹下，并解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-5.0.2.tar.gz</span><br><span class="line">tar xzf redis-5.0.2.tar.gz</span><br><span class="line"><span class="built_in">cd</span> redis-5.0.2</span><br></pre></td></tr></table></figure><p>3、进入到解压好的redis-5.0.2目录下，进行编译与安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp; make install</span><br></pre></td></tr></table></figure><p>4、启动并指定配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/redis-server redis.conf</span><br></pre></td></tr></table></figure><p>（注意要使用后台启动，所以修改redis.conf里的daemonize改为yes)</p><p>5、验证启动是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure><p>6、进入redis客户端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/redis/redis-5.0.2/src</span><br><span class="line">./redis-cli</span><br></pre></td></tr></table></figure><p>7、退出客户端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>8、退出redis服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pkill redis-server</span><br><span class="line"><span class="built_in">kill</span> 进程号</span><br><span class="line">src/redis-cli shutdown</span><br></pre></td></tr></table></figure><h5 id="2-2-集群搭建"><a href="#2-2-集群搭建" class="headerlink" title="2.2 集群搭建"></a>2.2 集群搭建</h5><p>redis集群需要至少要三个master节点，我们这里搭建三个master节点，并且给每个master再搭建一个slave节点，总共6个redis节点，这里用一台机器（可以多台机器部署，修改一下ip地址就可以了）部署6个redis实例，三主三从，搭建集群的步骤如下：</p><p><strong>第一步：</strong>在机器的/usr/local下创建文件夹redis-cluster，然后在其下面创建6个文件夾如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/<span class="built_in">local</span>/redis-cluster</span><br><span class="line"></span><br><span class="line">mkdir 8001 8002 8003 8004 8005 8006</span><br></pre></td></tr></table></figure><p><strong>第二步：</strong>把之前的redis.conf配置文件copy到8001下，修改如下内容：</p><blockquote><p>1）daemonize yes</p><p>2）port 8001（分别对每个机器的端口号进行设置）</p><p>3）dir /usr/local/redis-cluster/8001/（指定数据文件存放位置，必须要指定不同的目录位置，不然会丢失数据）</p><p>4）cluster-enabled yes（启动集群模式）</p><p>5）cluster-config-file nodes-8001.conf（集群节点信息文件，这里800x最好和port对应上）</p><p>6）cluster-node-timeout 5000</p><p>7)  bind 127.0.0.1（去掉bind绑定访问ip信息）</p><p>8)  protected-mode  no   （关闭保护模式）</p><p>9）appendonly yes</p><p>如果要设置密码需要增加如下配置：</p><p>10）requirepass xxx     (设置redis访问密码)</p><p>11）masterauth  xxx     (设置集群节点间访问密码，跟上面一致)</p></blockquote><p><strong>第三步：</strong>把修改后的配置文件，copy到8002-8006，修改第2、3、5项里的端口号，可以用批量替换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%s/源字符串/目的字符串/g</span><br></pre></td></tr></table></figure><p><strong>第四步：</strong>分别启动6个redis实例，然后检查是否启动成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/redis-5.0.7/src/redis-server /usr/<span class="built_in">local</span>/redis-cluster/800*/redis.conf</span><br></pre></td></tr></table></figure><p><strong>第五步：</strong>用redis-cli创建整个redis集群(redis5以前的版本集群是依靠ruby脚本redis-trib.rb实现)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/redis-5.0.7/src/redis-cli -a xxx --cluster create --cluster-replicas 1 192.168.2.116:8001 192.168.2.116:8002 192.168.2.116:8003 192.168.2.116:8004 192.168.2.116:8005 192.168.2.116:8006</span><br></pre></td></tr></table></figure><p>代表为每个创建的主服务器节点创建一个从服务器节点</p><p><strong>第六步：</strong>验证集群：</p><p>1）连接任意一个客户端即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-cli -c -a xxx -h 192.168.2.116 -p 8001</span><br></pre></td></tr></table></figure><p>提示：-a访问服务端密码，-c表示集群模式，指定ip地址和端口号</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/redis-5.0.2/src/redis-cli -a xxx -c -h 192.168.2.116 -p 8001</span><br></pre></td></tr></table></figure><p>注意这里进入到8002了，redirected。</p><p>2）进行验证： cluster info（查看集群信息）、cluster nodes（查看节点列表）</p><p>3）进行数据操作验证</p><p>4）关闭集群则需要逐个进行关闭，使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/redis/src/redis-cli -a xxx -c -h 192.168.2.116 -p 8001 shutdown</span><br></pre></td></tr></table></figure><h4 id="3-设置开机自启"><a href="#3-设置开机自启" class="headerlink" title="3. 设置开机自启"></a>3. 设置开机自启</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/init.d/redis</span><br></pre></td></tr></table></figure><p>将如下代码粘贴进去：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/src/sh</span></span><br><span class="line"><span class="comment"># chkconfig: 2345 80 90</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Simple Redis init.d script conceived to work on Linux systems</span></span><br><span class="line"><span class="comment"># as it does use of the /proc filesystem.</span></span><br><span class="line">​</span><br><span class="line">REDISPORT1=8001</span><br><span class="line">REDISPORT2=8002</span><br><span class="line">REDISPORT3=8003</span><br><span class="line">REDISPORT4=8004</span><br><span class="line">REDISPORT5=8005</span><br><span class="line">REDISPORT6=8006</span><br><span class="line">EXEC=/usr/<span class="built_in">local</span>/redis-5.0.7/src/redis-server</span><br><span class="line">CLIEXEC=/usr/<span class="built_in">local</span>/redis-5.0.7/src/redis-cli</span><br><span class="line">​</span><br><span class="line">PIDFILE=/var/run/redis_<span class="variable">$&#123;REDISPORT1&#125;</span>.pid</span><br><span class="line">​</span><br><span class="line">CONF1=<span class="string">"/usr/local/redis-cluster/<span class="variable">$&#123;REDISPORT1&#125;</span>/redis.conf"</span></span><br><span class="line">CONF2=<span class="string">"/usr/local/redis-cluster/<span class="variable">$&#123;REDISPORT2&#125;</span>/redis.conf"</span></span><br><span class="line">CONF3=<span class="string">"/usr/local/redis-cluster/<span class="variable">$&#123;REDISPORT3&#125;</span>/redis.conf"</span></span><br><span class="line">CONF4=<span class="string">"/usr/local/redis-cluster/<span class="variable">$&#123;REDISPORT4&#125;</span>/redis.conf"</span></span><br><span class="line">CONF5=<span class="string">"/usr/local/redis-cluster/<span class="variable">$&#123;REDISPORT5&#125;</span>/redis.conf"</span></span><br><span class="line">CONF6=<span class="string">"/usr/local/redis-cluster/<span class="variable">$&#123;REDISPORT6&#125;</span>/redis.conf"</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></span><br><span class="line">    start)</span><br><span class="line">        <span class="keyword">if</span> [ -f <span class="variable">$PIDFILE</span> ]</span><br><span class="line">        <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"<span class="variable">$PIDFILE</span> exists, process is already running or crashed"</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"Starting Redis cluster server..."</span></span><br><span class="line">                <span class="variable">$EXEC</span> <span class="variable">$CONF1</span> &amp;</span><br><span class="line">                <span class="variable">$EXEC</span> <span class="variable">$CONF2</span> &amp;</span><br><span class="line">                <span class="variable">$EXEC</span> <span class="variable">$CONF3</span> &amp;</span><br><span class="line">                <span class="variable">$EXEC</span> <span class="variable">$CONF4</span> &amp;</span><br><span class="line">                <span class="variable">$EXEC</span> <span class="variable">$CONF5</span> &amp;</span><br><span class="line">                <span class="variable">$EXEC</span> <span class="variable">$CONF6</span> &amp;</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"启动成功..."</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        ;;</span><br><span class="line">    stop)</span><br><span class="line">        <span class="keyword">if</span> [ ! -f <span class="variable">$PIDFILE</span> ]</span><br><span class="line">        <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"<span class="variable">$PIDFILE</span> does not exist, process is not running"</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                PID=$(cat <span class="variable">$PIDFILE</span>)</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"Stopping ..."</span></span><br><span class="line">                <span class="variable">$CLIEXEC</span> -p <span class="variable">$REDISPORT1</span> shutdown</span><br><span class="line">                <span class="variable">$CLIEXEC</span> -p <span class="variable">$REDISPORT2</span> shutdown</span><br><span class="line">                <span class="variable">$CLIEXEC</span> -p <span class="variable">$REDISPORT3</span> shutdown</span><br><span class="line">                <span class="variable">$CLIEXEC</span> -p <span class="variable">$REDISPORT4</span> shutdown</span><br><span class="line">                <span class="variable">$CLIEXEC</span> -p <span class="variable">$REDISPORT5</span> shutdown</span><br><span class="line">                <span class="variable">$CLIEXEC</span> -p <span class="variable">$REDISPORT6</span> shutdown</span><br><span class="line">                <span class="keyword">while</span> [ -x /proc/<span class="variable">$&#123;PID&#125;</span> ]</span><br><span class="line">                <span class="keyword">do</span></span><br><span class="line">                    <span class="built_in">echo</span> <span class="string">"Waiting for Redis cluster to shutdown ..."</span></span><br><span class="line">                    sleep 1</span><br><span class="line">                <span class="keyword">done</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"Redis cluster stopped"</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Please use start or stop as first argument"</span></span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>添加权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /etc/init.d/redis</span><br></pre></td></tr></table></figure><p>加入开机启动服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --add redis</span><br></pre></td></tr></table></figure><p>使用命令进行开启或关闭redis集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service redis start </span><br><span class="line">service redis stop</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/8045b92fafb2" target="_blank" rel="noopener">原文连接</a></p><p><a href="https://blog.csdn.net/qq_37859539/article/details/83715803" target="_blank" rel="noopener">https://blog.csdn.net/qq_37859539/article/details/83715803</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Redis系统介绍：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/2a23257af57b&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Redis的基础介绍与安装使用步骤&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https
      
    
    </summary>
    
      <category term="noSql" scheme="http://yoursite.com/child/categories/noSql/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/child/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>彻底理解cookie/session/token</title>
    <link href="http://yoursite.com/child/2019/11/23/%E5%85%B6%E4%BB%96-%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3cookie%EF%BC%8Csession%EF%BC%8Ctoken/"/>
    <id>http://yoursite.com/child/2019/11/23/其他-彻底理解cookie，session，token/</id>
    <published>2019-11-22T16:00:00.000Z</published>
    <updated>2020-06-12T00:38:05.261Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/moyand/p/9047978.html" target="_blank" rel="noopener">原文链接</a></p><p>发展史</p><p>1、 很久很久以前，Web基本上就是文档的浏览而已，既然是浏览，作为服务器，不需要记录谁在某一段时间里都浏览了什么文 档，每次请求都是一个新的HTTP协议，就是请求加响应，尤其是我不用记住是谁刚刚发了 HTTP请求，每个请求对我来说都是 全新的。这段时间很嗨皮</p><p>2、 但是随着交互式Web应用的兴起，像在线购物网站，需要登录的网站等等，马上就面临一个问题，那就是要管理会话，必须记住 哪些人登录系统，哪些人往自己的购物车中放商品，也就是说我必须把每个人区分开，这就是一个不小的挑战，因为HTTP请求是 无状态的，所以想出的办法就是给大家发一个会话标识(session id),说白了就是一个随机的字串，每个人收到的都不一样，每次大 家向我发起HTTP请求的时候，把这个字符串给一并捎过来，这样我就能区分开谁是谁了</p><p>3、 这样大家很嗨皮了，可是服务器就不嗨皮了，每个人只需要保存自己的session id，而服务器要保存所有人的session id !如果 访问服务器多了，就得由成千上万，甚至几十万个。这对服务器说是一个巨大的开销，严重的限制了服务器扩展能力，比如说我用两个机器组成了一个集群，小F通过机器A登录了系 统，那session id会保存在机器A上，假设小F的下一次请求被转发到机器B怎么办？机器B可没有小F的session id啊。</p><p>有时候会采用_点小伎俩：session sticky,就是让小 F的请求一直粘连在机器A上，但是这也不管用，要是机器A挂掉了，还得转 到机器B去。那只好做session的复制了，把session id在两个机器之间搬来搬去，快累死了。</p><p>后来有个叫Memcached的支了招：把session id 集中存储到一个地方，所有的机器都来访问这个地方的数据，这样一来，就不用复制了。但是增加了单点失败的可能性，要是那个负责session的机器挂了，所有的人都得重新登录一遍，估计的被人骂死。后来也尝试把这个单点的机器搞成集群，增加可靠性，但是不管如何，这个小小的session对我来说是一个称重的负担。</p><p>4  于是就有人一直在思考，我为什么要保存这个可恶的session呢，让每个客户端去保存该多好可是如果不保存这些session id 怎么验证客户端发给我的session id 的确是我生成的呢？如果不去验证，我们都不知道他们是不是合法的登录用户，那些不怀好意的家伙们就能伪造session id 为所欲为了</p><p>哦，对了 关键点就是验证</p><p>比如说，小F已经登陆了系统，我给他发一个令牌（Token），里面包含了小F的user id ，下一次小F再次通过Http请求访问我的时候，把这个token通过http header带过来不就可以了。不过这和session id 没有本质区别啊 ，任何人都可以伪造，所以我的想点办法让别人伪造不了。</p><p>那就对数据做一个签名吧，比如说我用HMAC-SHA256算法，加上一个只我才知道的秘钥，对数据做一个签名，把这个签名和数据一起作为token，由于秘钥被人不知道，就无法伪造了。</p><p>这个token我们不保存，当小F把这个token发给我的时候，我在用同样的算法和密钥对数据在计算一次签名，和token中带的签名做个比较：如果相同，我就知道小F已经登陆过了，并且可以直接取到小F的user id；若果不相同，数据部分肯定被人篡改过，我就回复发送者：对不起，没有验证。</p><p>Token中的数据是明文保存的（虽然我会用Base64做下编码，但那不是加密），还是可以被别人看到的，所以我不能在其中保存像密码这样的敏感信息当然，如果一个人的token被别人偷走了，那我也没办法，我也会任为小偷就是合法用户，这其实和一个人的session id 被别人偷走是一样的。</p><p>这样一来，我就不保存session id 了，我只是生成token，然后验证token。用计算时间换区存储空间解除了session id 这个负担，可以说是一身轻松，我的机器集群现在可以轻松的做水平扩展，用户访问量增大，直接加机器就行。这种无状态的感觉实在太好了！</p><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>cookie是一个非常具体的东西，指的就是浏览器里能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。cookie有服务器生成，发送给浏览器，浏览器吧cookie一kv的形式保存到某个目录下的文本文件内，下一次请求同一域名时会把该cookie发送给服务器。由于cookie是存在客户端上的没所以浏览器加入了一些限制确保cookie不会给恶意使用，同事不会占据太多磁盘空间。所以每个域的cookie数量是有限的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/moyand/p/9047978.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;发展史&lt;/p&gt;
&lt;p&gt;1、 很久很久以前，Web基本上就是文档的浏览
      
    
    </summary>
    
      <category term="其他" scheme="http://yoursite.com/child/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/child/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>mysql-innodb的事务管理与锁</title>
    <link href="http://yoursite.com/child/2019/11/23/mysql-innodb%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E4%B8%8E%E9%94%81/"/>
    <id>http://yoursite.com/child/2019/11/23/mysql-innodb的事务管理与锁/</id>
    <published>2019-11-22T16:00:00.000Z</published>
    <updated>2020-06-19T07:08:53.361Z</updated>
    
    <content type="html"><![CDATA[<p>典型的事务场景：下单、转账</p><p><strong>事物的定义：事务是DBMS执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成</strong></p><p>MYSQL中支持事务的数据引擎：innodb  ndb</p><h5 id="1、数据库事务的四大特性是什么？"><a href="#1、数据库事务的四大特性是什么？" class="headerlink" title="1、数据库事务的四大特性是什么？"></a>1、数据库事务的四大特性是什么？</h5><p>原子性  Atomicity   由undo log保证</p><p>一致性  Consistent   数据完整性</p><p>隔离性   Isolation  不同事务之间处理同一段数据应当是隔离的互不干扰的</p><p>持久性   Durable  redo log</p><p><strong>原子性、隔离性和持久性最终都是为了实现一致性。</strong></p><h5 id="2、什么时候会出现事务、结束事务？"><a href="#2、什么时候会出现事务、结束事务？" class="headerlink" title="2、什么时候会出现事务、结束事务？"></a>2、什么时候会出现事务、结束事务？</h5><p>当我们执行单条语句的时候，会默认开启事务</p><p>mysql 参数 autocommit 默认为 on 开启状态，执行单条查询语句不需要显示的声明事务、提交事务</p><p>show global VARIABLE like ‘autocommit’  显示该参数的全局值</p><p>show session VARIABLE like ‘autocommit’ 显示当前会话该参数的值</p><p>set session autocommit=off; 关闭autocommit后，需要手动提交</p><p><strong>手动开启事务，两种方式</strong>  </p><p>start TRANSACATION;    </p><p> begin; </p><p>事务的结束：</p><p>提交结束 commit;</p><p>回滚结束 rollback；</p><p>连接断开 会话结束 -&gt; 事务结束</p><h5 id="3、事务并发带来的问题有哪些？"><a href="#3、事务并发带来的问题有哪些？" class="headerlink" title="3、事务并发带来的问题有哪些？"></a>3、事务并发带来的问题有哪些？</h5><p>脏读（读到未提交的数据）：事务A执行一条查询，事务B修改了这部分数据但没提交，导致A读取到事务B没有提交的数据，事务B可能回滚导致事务A读取到的数据是脏数据。</p><p>不可重复读：事务A执行一条查询后，事务B对这部分数据执行了update/delete并提交了，导致事务A再次查询时与上一次的查询结果不一致，称为不可重复度。</p><p>幻读：事务A执行一条范围查询后，事务B在此范围insert了若干条数据，导致事务A再次执行该查询是记录数增多，产生幻读。</p><p><strong><em>注意：幻读和不可重复度的区别是事务B对数据进行的操作不同，幻读是insert操作，不可重复读是update和delete操作</em></strong></p><p>以上三个问题称为数据库的读一致性问题，必须由数据库自己提供一定的事务隔离机制来解决</p><h5 id="4、SQL92-标准"><a href="#4、SQL92-标准" class="headerlink" title="4、SQL92 标准"></a>4、SQL92 标准</h5><p>许多数据库专家联合制定了一个标准，建议数据库厂商都按照这个标准提供一定的事务隔离级别，来解决事务并发问题。</p><p>看一下SQL92标准的官网：<a href="http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt" target="_blank" rel="noopener">http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt</a></p><p>在官网搜索_iso，会看到一张表格：</p><table><thead><tr><th style="text-align:left">Level</th><th>P1</th><th>P2</th><th>P3</th></tr></thead><tbody><tr><td style="text-align:left">READ UNCOMMITTED</td><td>Possible</td><td>Possible</td><td>Possible</td></tr><tr><td style="text-align:left">READ COMMITTED</td><td>Not Possible</td><td>Possible</td><td>Possible</td></tr><tr><td style="text-align:left">REPEATABLE READ</td><td>Not Possible</td><td>Not Possible</td><td>Possible</td></tr><tr><td style="text-align:left">SERIALIZABLE</td><td>Not Possible</td><td>Not Possible</td><td>Not Possible</td></tr></tbody></table><p>这里定义了四个隔离级别，右边的P1P2P3就是代表事务并发的三个问题，脏读，不可重复度，幻读。Possible表示在这个隔离级别下该问题有可能发生，Not Possible表示解决了该问题。</p><ul><li>Read Uncommited 未提交读</li></ul><p>顾名思义，事务可以读取到其他事物未提交的数据，使用这种隔离级别其实并未解决以上的任何问题</p><ul><li>Read Commited  已提交读</li></ul><p>只能读到其他事物已经提交了的数据，解决了脏读问题</p><ul><li>Repeatable Read  可重复读</li></ul><p>事务重复读取，保证重复读取数据一致，解决了不可重复度的问题</p><ul><li>Serializable 串行化</li></ul><p>事务串行化运行，没有并发自然没有不一性问题产生，但是严重影响效率，不推荐使用</p><p>不同的厂商或者数据库引擎在实现以上标准时会有一些差异。Oracle只实现了两种RC和Serializable，Innodb对以上的四种隔离级别都进行了实现，值得一提的是，innodb 对Repeatable Read 这一级别的实现同时也解决了幻读的问题，因此这一级别是innodb的默认事务隔离级别。</p><h5 id="5、innodb是如何实现事务隔离级别的呢"><a href="#5、innodb是如何实现事务隔离级别的呢" class="headerlink" title="5、innodb是如何实现事务隔离级别的呢?"></a>5、innodb是如何实现事务隔离级别的呢?</h5><p>如果要解决读一致性的问题 ，保证一个事务前后两次读取数据一致，实现事务隔离级别，应该怎么做 </p><p>方案一 ： LBCC 基于锁的并发控制</p><p>方案二： MVCC 基于多版本的并发控制  生成一个数据请求时间点的一致性数据，并用这个快照来提供一定级别的一致性读取。</p><p>首先介绍MVCC的实现原理</p><p>从三个隐藏字段开始</p><p>InnoDB为每行记录都实现了三个隐藏字段</p><p>DB_ROW_ID   6字节：行标识</p><p>DB_TRX_ID  6字节：插入或更新行的最后一个事务ID，自动递增（理解为创建版本号）</p><p>DB_ROLL_PTR：  7字节：回滚指针（理解为删除版本号）数据被删除或记录为旧数据的时候记录当前的操作事务id。</p><p><strong><em>mvcc核心思想，一个事务根据自己的事务id进行判断，只能查询到创建版本号比我的事务ID小的（在我之前插入或更新的数据）  和  删除版本号比我事务ID大的记录</em></strong>  </p><p>下面通过一个简单的例子说明：</p><p>事务一：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--Transaction 1</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mvcctest <span class="keyword">values</span>(<span class="literal">NULL</span>,<span class="string">"zzk"</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mvcctest <span class="keyword">values</span>(<span class="literal">NULL</span>,<span class="string">"pjp"</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>此时的数据，创建版本是当前的事务id，删除版本号为空；</p><table><thead><tr><th>id</th><th>name</th><th>创建版本</th><th>删除版本</th></tr></thead><tbody><tr><td>1</td><td>zzk</td><td>1</td><td>undefined</td></tr><tr><td>2</td><td>pjp</td><td>1</td><td>undefined</td></tr></tbody></table><p>事务二：执行第一次查询，读取到两天原始数据，这时事务id为2：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--Transaction 2</span></span><br><span class="line"><span class="keyword">begin</span>；</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mvcctest ; <span class="comment">-- (1) 第一次查询  注意此处没有提交，事务2没有结束</span></span><br></pre></td></tr></table></figure><p>事务三，插入一条数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Transaction 3</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mvctest <span class="keyword">values</span>(<span class="literal">NULL</span>,<span class="string">"zpd"</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>此时的数据多了一条zpd，它的创建版号是3：</p><table><thead><tr><th>id</th><th>name</th><th>创建版本</th><th>删除版本</th></tr></thead><tbody><tr><td>1</td><td>zzk</td><td>1</td><td>undefined</td></tr><tr><td>2</td><td>pjp</td><td>1</td><td>undefined</td></tr><tr><td>3</td><td>zpd</td><td>3</td><td>undefined</td></tr></tbody></table><p>然后事务二再进行第二次查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--Transaction 2</span></span><br><span class="line"><span class="keyword">begin</span>；</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mvcctest ; <span class="comment">-- (1) 第一次查询  注意此处没有提交，事务2没有结束</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mvcctest ; <span class="comment">-- (2) 第二次查询  注意此处没有提交，事务2没有结束</span></span><br></pre></td></tr></table></figure><p>根据MVCC的原则：只能查询创建版本比自己小的数据，所以第二次查询也只能查询2条数据。</p><p>事务四：删除数据，删除了id=1 zzk这条记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--Transaction 4</span></span><br><span class="line"><span class="keyword">begin</span>；</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> mvcctest <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>这时候的数据，赵政康的删除版本被记录为事务id 4，其他不变：</p><table><thead><tr><th>id</th><th>name</th><th>创建版本</th><th>删除版本</th></tr></thead><tbody><tr><td>1</td><td>zzk</td><td>1</td><td>4</td></tr><tr><td>2</td><td>pjp</td><td>1</td><td>undefined</td></tr><tr><td>3</td><td>zpd</td><td>3</td><td>undefined</td></tr></tbody></table><p>然后事务二执行第三次查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--Transaction 2</span></span><br><span class="line"><span class="keyword">begin</span>；</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mvcctest ; <span class="comment">-- (1) 第一次查询  注意此处没有提交，事务2没有结束</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mvcctest ; <span class="comment">-- (2) 第二次查询  注意此处没有提交，事务2没有结束</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mvcctest ; <span class="comment">-- (3) 第三次查询  注意此处没有提交，事务2没有结束</span></span><br></pre></td></tr></table></figure><p>根据MVCC的查找原则：只能查询创建版本比自己小，删除版本比自己大、以及未删除的记录</p><p>也就是说在事务2开始之后被删除的数据依然可以被查出来，所以查询结果依然是2条数据。</p><p>事务五：执行更新操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--Transaction 5</span></span><br><span class="line"><span class="keyword">begin</span>；</span><br><span class="line"><span class="keyword">update</span> mvcctest <span class="keyword">set</span> <span class="keyword">name</span>=<span class="string">'潘佳萍'</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span>；</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>此时的数据，更新数据的时候，旧数据的删除版本被记录为当前事务id，产生一条新数据，创建版本为当前事务id</p><table><thead><tr><th>id</th><th>name</th><th>创建版本</th><th>删除版本</th></tr></thead><tbody><tr><td>1</td><td>zzk</td><td>1</td><td>4</td></tr><tr><td>2</td><td>pjp</td><td>1</td><td>5</td></tr><tr><td>3</td><td>zpd</td><td>3</td><td>undefined</td></tr><tr><td>2</td><td>潘佳萍</td><td>5</td><td>undefined</td></tr></tbody></table><p>然后事务二执行第四次查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--Transaction 2</span></span><br><span class="line"><span class="keyword">begin</span>；</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mvcctest ; <span class="comment">-- (1) 第一次查询  注意此处没有提交，事务2没有结束</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mvcctest ; <span class="comment">-- (2) 第二次查询  注意此处没有提交，事务2没有结束</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mvcctest ; <span class="comment">-- (3) 第三次查询  注意此处没有提交，事务2没有结束</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mvcctest ; <span class="comment">-- (4) 第四次查询  注意此处没有提交，事务2没有结束</span></span><br></pre></td></tr></table></figure><p>查找规则：只能查询创建版本小于自己，删除版本大于自己，或者未删除的数据，所以依然是2条数据。</p><p>通过以上演示我们可以看到，通过版本号的控制，无论其他事物是插入修改删除，事务2查询到的数据都没有变化。</p><p>在InnoDB中，MVCC是通过undo log实现的，需要注意的是，MVCC和锁是协同使用来实现隔离性的，这两种方案并不是互斥的。</p><p>Oracle、postgres等其他数据口都有MVCC的实现。</p><h5 id="6、innodb中的锁"><a href="#6、innodb中的锁" class="headerlink" title="6、innodb中的锁"></a>6、innodb中的锁</h5><p>官网将锁分成了8类，这里我们将两个行级别的锁，和两个表级别的锁称为所得基本模式；后面三个Record Locks、Gap Locks、Next-Key Locks 称为锁的算法，也就是分别在上面情况下锁定什么范围。</p><h6 id="6-1-共享锁"><a href="#6-1-共享锁" class="headerlink" title="6.1 共享锁"></a>6.1 共享锁</h6><p>第一个行级别的锁就是我们在广网看到的Shard Locks（共享锁），我们获取了一行数据的共享锁之后，可以用他来读取数据，所以叫他读锁。而且多个事务可以共享一把读锁。</p><p>可以用<code>select... lock in share mode;</code>的方式手工加上一把读锁。</p><p>释放读锁有两种方式：提交事务或断开连接</p><p>读锁可以重复的获取</p><h6 id="6-2-排它锁"><a href="#6-2-排它锁" class="headerlink" title="6.2 排它锁"></a>6.2 排它锁</h6><p>第二个行级别的锁叫Exclusive Locks（排它锁），它是用来操作数据的，所以又叫写锁。只要一个事务获取了一行数据的排它锁，其他的事务就不能再获取这一行数据额的共享锁和排它锁。</p><p>排它锁加锁两种方式：自动（增删改查操作自动加），手动加锁</p><p>手动加锁命令 在查询语句后面加上<code>for update</code>，就会给查询的数据加上一个写锁</p><p>释放排它锁的方式和共享锁一样。</p><h6 id="6-3-意向锁"><a href="#6-3-意向锁" class="headerlink" title="6.3 意向锁"></a>6.3 意向锁</h6><p>意向锁是数据库自己维护的。</p><p>当我们你给一行数据加上共享锁之前，数据库会自动在这张表上面加上一个意向共享锁；当我们给一行数据加上排它锁之前，数据库会自动在这张表上加上一个意向排它锁。</p><p>如果一张表上至少有一个意向共享锁，说明有其他的事务给其中的某些数据加上了共享锁；如果一张表上面至少有一个意向排他锁，说明有其他的事务给其中的某些数据行加 了排他锁。</p><p>那么这两个表级别锁存在的意义是什么？</p><p>第一个，有了表级别锁，在innodb中就可以支持更多粒度的锁；第二个，如果没有意向锁的话，当我们想要一张表加上表锁的时候，是不是必须先判断有没有其他的事务锁定了其中的一行数据，那么这时候我们要扫描整张表才能确定能不能成功加上一个表锁，如果数据量大，加表锁的效率肯定很低</p><p>这是引入意向锁之后，只要判断这张表上面有没有意向锁，如果有加表锁操作直接返回失败。所以innodb中的意向表锁，我们可以把它理解成一个标志。</p><h5 id="7、行锁的原理"><a href="#7、行锁的原理" class="headerlink" title="7、行锁的原理"></a>7、行锁的原理</h5><p>行锁锁住的是什么？</p><p>首先我们准备三张表，一张没有索引的 t1，一张有主键索引的 t2，一张有唯一索引的 t3。</p><p>我们先假设 InnoDB 的锁锁住了是一行数据或者一条记录。 </p><p>我们先来看一下 t1 的表结构，它有两个字段，int 类型的 id 和 varchar 类型的 name。 里面有 4 条数据，1、2、3、4。 </p><table><thead><tr><th><strong>Transaction 1 </strong></th><th>Transaction 2</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>SELECT * FROM t1 WHERE id =1 FOR UPDATE;</td><td></td></tr><tr><td></td><td>select * from t1 where id=3 for update; //blocked</td></tr><tr><td></td><td>INSERT INTO <code>t1</code> (<code>id</code>, <code>name</code>) VALUES (5, ‘5’); //blocked</td></tr></tbody></table><p>现在我们在两个会话里面手工开启两个事务。 </p><p>在第一个事务里面，我们通过 where id =1 锁住第一行数据。 </p><p>在第二个事务里面，我们尝试给 id=3 的这一行数据加锁。 </p><p>这个加锁的操作被阻塞了。为什么第一个事务锁住了 id=1 的这行数据，我不能操作 </p><p>id=3 的数据呢？ </p><p>再来操作一条不存在的数据，插入 id=5。它也被阻塞了。实际上这里整张表都被锁 住了。所以，我们的第一个猜想被推翻了，InnoDB 的锁锁住的应该不是 Record。</p><p>为什么在没有索引或者没有用到索引的情况下，会锁住整张表？这个问题我们先留 在这里。 </p><p><strong>有主键索引的表</strong> </p><p>我们看一下 t2 的表结构。字段是一样的，不同的地方是 id 上创建了一个主键索引。 </p><p>里面的数据是 1、4、7、10。 </p><table><thead><tr><th><strong>Transaction 1 </strong></th><th>Transaction 2</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>select * from t2 where id=1 for update;</td><td></td></tr><tr><td></td><td>select * from t2 where id=1 for update; // blocked</td></tr><tr><td></td><td>select * from t2 where id=4 for update; // OK</td></tr></tbody></table><p>第一种情况，使用相同的 id 值去加锁，冲突；使用不同的 id 加锁，可以加锁成功。 那么，既然不是锁定一行数据，有没有可能是锁住了 id 的这个字段呢？ </p><p>我们继续往下验证。 </p><p><strong>唯一索引（假设锁住字段）</strong> </p><p>我们看一下 t3 的表结构。字段还是一样的， id 上创建了一个主键索引，name 上 </p><p>创建了一个唯一索引。里面的数据是 1、4、7、10。 </p><table><thead><tr><th><strong>Transaction 1 </strong></th><th>Transaction 2</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>select * from t3 where name= ‘4’ for update;</td><td></td></tr><tr><td></td><td>select * from t3 where name = ‘4’ for update; // blocked</td></tr><tr><td></td><td>select * from t3 where id = 4 for update; // blocked</td></tr></tbody></table><p>在第一个事务里面，我们通过 name 字段去锁定值是 4 的这行数据。 </p><p>在第二个事务里面，尝试获取一样的排它锁，肯定是失败的。 </p><p>在这里我们怀疑 InnoDB 锁住的是字段，所以换一个字段，用 id=4 去给这行数据加锁。又被阻塞了，说明锁住的是字段的这个推测也是错的，否则就不会出现第一个事务 锁住了 name，第二个字段锁住 id 失败的情况。 </p><p>既然锁住的不是 record，也不是 column，InnoDB 里面锁住的到底是什么呢？在这 三个案例里面，我们要去分析一下他们的差异在哪里，也就是这三张表的结构，是什么 区别导致了加锁的行为的差异？其实答案就是索引。InnoDB 的行锁，就是通过锁住索引实现的。 </p><p>那么我们还有两个问题没有解决： </p><p>1、为什么表里面没有索引的时候，锁住一行数据会导致锁表？ </p><p>或者说，如果锁住的是索引，一张表没有索引怎么办？ </p><p>所以，一张表有没有可能没有索引？ </p><p>1）如果我们定义了主键(PRIMARY KEY)，那么 InnoDB 会选择主键作为聚集索引。 </p><p>2）如果没有显式定义主键，则 InnoDB 会选择第一个不包含有 NULL 值的唯一索 引作为主键索引。 </p><p>3）如果也没有这样的唯一索引，则 InnoDB 会选择内置 6 字节长的 ROWID 作 为隐藏的聚集索引，它会随着行记录的写入而主键递增。 </p><p>所以，为什么锁表，是因为查询没有使用索引，会进行全表扫描，然后把每一个隐 藏的聚集索引都锁住了。 </p><p>2、为什么通过唯一索引给数据行加锁，主键索引也会被锁住？ </p><p>大家还记得在 InnoDB 里面，当我们使用辅助索引的时候，它是怎么检索数据的吗？ 辅助索引的叶子节点存储的是什么内容？</p><p>在辅助索引里面，索引存储的是二级索引和主键的值。比如name=4，存储的是name 的索引和主键 id 的值 4。 </p><p>而主键索引里面除了索引之外，还存储了完整的数据。所以我们通过辅助索引锁定 一行数据的时候，它跟我们检索数据的步骤是一样的，会通过主键值找到主键索引，然 后也锁定。 </p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/mysql/%E5%9B%9E%E8%A1%A8.png" alt="回表"></p><h5 id="8、锁的算法"><a href="#8、锁的算法" class="headerlink" title="8、锁的算法"></a>8、锁的算法</h5><p>t2 这张表有一个主键索引。 </p><p>我们插入了 4 行数据，主键 id 分别是 1、4、7、10。 </p><p>因为我们用主键索引加锁，我们这里的划分标准就是主键索引的值。 </p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/mysql/Gap-NextKey.png" alt></p><p>这些数据库里面存在的主键值，我们把它叫做 Record，记录，那么这里我们就有 4 个 Record。 </p><p>根据主键，这些存在的 Record 隔开的数据不存在的区间，我们把它叫做 Gap，间 隙，它是一个左开右开的区间。 </p><p>假设我们有 N 个 Record，那么所有的数据会被划分成多少个 Gap 区间？答案是 N+1，就像我们把一条绳子砍 N 刀，它最后肯定是变成 N+1 段。 </p><p>最后一个，间隙（Gap）连同它左边的记录（Record），我们把它叫做临键的区间， 它是一个左开右闭的区间。 </p><h6 id="8-1-记录锁"><a href="#8-1-记录锁" class="headerlink" title="8.1 记录锁"></a>8.1 <strong>记录锁</strong></h6><p>第一种情况，当我们对于唯一性的索引（包括唯一索引和主键索引）使用等值查询， 精准匹配到一条记录的时候，这个时候使用的就是记录锁。 </p><p>比如 where id = 1 4 7 10 。 </p><p>我们使用不同的 key 去加锁，不会冲突，它只锁住这个 record。 </p><h6 id="8-2-间隙锁"><a href="#8-2-间隙锁" class="headerlink" title="8.2 间隙锁"></a>8.2 <strong>间隙锁</strong></h6><p>第二种情况，当我们查询的记录不存在，没有命中任何一个 record，无论是用等值 查询还是范围查询的时候，它使用的都是间隙锁。 </p><p>举个例子，where id &gt;4 and id &lt;7，where id = 6。 </p><p>注意，间隙锁主要是阻塞插入 insert。相同的间隙锁之间不冲突。 </p><p>Gap Lock 只在 RR 中存在，如果要关闭间隙锁，就是把事务隔离级别设置成 RC， 并且把 innodb_locks_unsafe_for_binlog 设置为 ON。 </p><p>这种情况下除了外键约束和唯一性检查会加间隙锁，其他情况都不会用间隙锁。</p><h6 id="8-3-临键锁"><a href="#8-3-临键锁" class="headerlink" title="8.3 临键锁"></a>8.3 <strong>临键锁</strong></h6><p>第三种情况，当我们使用了范围查询，不仅仅命中了 Record 记录，还包含了 Gap 间隙，在这种情况下我们使用的就是临键锁，它是 MySQL 里面默认的行锁算法，相当于 记录锁加上间隙锁。 </p><p>唯一性索引，等值查询匹配到一条记录的时候，退化成记录锁。 </p><p>没有匹配到任何记录的时候，退化成间隙锁。</p><p>比如我们使用&gt;5 &lt;9， 它包含了记录不存在的区间，也包含了一个 Record 7。 </p><p>临键锁，锁住最后一个 key 的下一个左开右闭的区间。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t2 <span class="keyword">where</span> <span class="keyword">id</span> &gt;<span class="number">5</span> <span class="keyword">and</span> <span class="keyword">id</span> &lt;=<span class="number">7</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment">-- 锁住(4,7]和(7,10] </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t2 <span class="keyword">where</span> <span class="keyword">id</span> &gt;<span class="number">8</span> <span class="keyword">and</span> <span class="keyword">id</span> &lt;=<span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment">-- 锁住 (7,10]，(10,+∞)</span></span><br></pre></td></tr></table></figure><p>为什么要锁住下一个左开右闭的区间？——就是为了解决幻读的问题。</p><h5 id="9、innodb隔离级别的实现"><a href="#9、innodb隔离级别的实现" class="headerlink" title="9、innodb隔离级别的实现"></a>9、innodb隔离级别的实现</h5><h6 id="9-1-Read-Uncommited"><a href="#9-1-Read-Uncommited" class="headerlink" title="9.1 Read Uncommited"></a>9.1 Read Uncommited</h6><p>RU 隔离级别：不加锁。 </p><h6 id="9-2-Serializable"><a href="#9-2-Serializable" class="headerlink" title="9.2 Serializable"></a>9.2 <strong>Serializable</strong></h6><p>Serializable 所有的 select 语句都会被隐式的转化为 <code>select ... in share mode</code>，会 和 update、delete 互斥。 </p><p>这两个很好理解，主要是 RR 和 RC 的区别？ </p><h6 id="9-3-Repeatable-Read"><a href="#9-3-Repeatable-Read" class="headerlink" title="9.3  Repeatable Read"></a>9.3  <strong>Repeatable Read</strong></h6><p>RR 隔离级别下，普通的 select 使用基于MVCC的快照读(snapshot read)</p><p>加锁的 select(<code>select ... in share mode / select ... for update</code>)以及更新操作 update, delete 等语句使用当前读（current read），底层使用记录锁、或者间隙锁、 临键锁。 </p><h6 id="9-4-Read-Commited"><a href="#9-4-Read-Commited" class="headerlink" title="9.4 Read Commited"></a>9.4 <strong>Read Commited</strong></h6><p>RC 隔离级别下，普通的 select 都是快照读，使用 MVCC 实现。 </p><p>加锁的 select 都使用记录锁，因为没有 Gap Lock。 </p><p>除了两种特殊情况——外键约束检查(foreign-key constraint checking)以及重复键检查(duplicate-key checking)时会使用间隙锁封锁区间。 </p><p>所以 RC 会出现幻读的问题。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;典型的事务场景：下单、转账&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事物的定义：事务是DBMS执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MYSQL中支持事务的数据引擎：innodb  ndb&lt;/p&gt;
&lt;h5 id=&quot;1、数据库事务的四大
      
    
    </summary>
    
      <category term="数据库技术" scheme="http://yoursite.com/child/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/child/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>netty源码分析之PipeLine</title>
    <link href="http://yoursite.com/child/2019/11/21/nio-netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BPipeLine/"/>
    <id>http://yoursite.com/child/2019/11/21/nio-netty源码分析之PipeLine/</id>
    <published>2019-11-20T16:00:00.000Z</published>
    <updated>2020-05-22T11:49:23.176Z</updated>
    
    <content type="html"><![CDATA[<p>Channel创建的时候会创建一个PipeLine，并且PipeLine也持有Channel对象的引用，二者是互相引用的关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractChannel.class</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    pipeline = newChannelPipeline();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> DefaultChannelPipeline <span class="title">newChannelPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPipeline(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractChannel 是Channel接口的第一个抽象实现类，其中就声明了对pipeline的引用，在看pipeLine的初始化，创建了一个DefaultChannelPipeline ，构造函数将正在构造的channel对象传进去，看构造器源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultChannelPipeline</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">"channel"</span>);</span><br><span class="line">    succeededFuture = <span class="keyword">new</span> SucceededChannelFuture(channel, <span class="keyword">null</span>);</span><br><span class="line">    voidPromise =  <span class="keyword">new</span> VoidChannelPromise(channel, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>);</span><br><span class="line">    head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.prev = head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一步就是将传入的channel对象存下来，然后创建头结点head和尾结点tail组成一个初始的双向链表。</p><p>ok，至此我们可以了解到PipeLine 数据结构是一个双向链表，头结点是HeadContext对象，尾结点是TailContext对象，而头尾节点都是 AbstractChannelHandlerContext 的子类。</p><p>那我们要弄清楚pipeLine的工作方式，肯定要先搞搞明白组成它的节点AbstractChannelHandlerContext 到底是个啥。</p><h4 id="PipeLine节点分析"><a href="#PipeLine节点分析" class="headerlink" title="PipeLine节点分析"></a>PipeLine节点分析</h4><p>AbstractChannelHandlerContext 是实现了ChannelHandlerContext 的抽象类，我们根据字面意思理解，ChannelHandlerContext 就是执行 ChannelHandler的上下文，<strong>上下文应该包含该Handler的执行逻辑，并且负责这段逻辑的调用，以及调用结果的处理</strong>。</p><p>而ChannelHandler我们应该很熟悉了，用来处理客户端请求或者服务器响应的一些处理器。</p><p>服务器对客户端请求的处理，一般来说都是要分步骤执行的，一个常见的例子就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">接受请求得到byteBuf--&gt;解码得到request对象--&gt;对request鉴权--&gt;处理reques得到response</span><br><span class="line"></span><br><span class="line">--&gt;对response编码得到byteBuf并发送响应</span><br></pre></td></tr></table></figure><p>对于以上流程，服务器程序中需要调用<code>pipeline.addLast(new xxxxHandler())</code>方法加入到pipeline中Handler有：DecodeHandler–&gt;LoginHandler–&gt;BussinessHandler–&gt;EncodeHandler ，跟进addLast方法调用最终会到达</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultChannelPipeline</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//1 检查是否重复添加</span></span><br><span class="line">        checkMultiplicity(handler);</span><br><span class="line">        <span class="comment">//2 创建节点 DefaultChannelHandlerContext类型</span></span><br><span class="line">        newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line">        <span class="comment">//3 添加节点  双向链表操作</span></span><br><span class="line">        addLast0(newCtx);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4 回调用户方法</span></span><br><span class="line">    callHandlerAdded0(newCtx);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">newContext</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//group为null，因此childExecutor(group)也返回null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelHandlerContext(<span class="keyword">this</span>, childExecutor(group), name, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultChannelHandlerContext</span></span><br><span class="line">DefaultChannelHandlerContext(</span><br><span class="line">        DefaultChannelPipeline pipeline, EventExecutor executor, String name, ChannelHandler handler) &#123;</span><br><span class="line">    <span class="comment">// 将参数回传到父类，保存Handler的引用</span></span><br><span class="line">    <span class="keyword">super</span>(pipeline, executor, name, handler.getClass());</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractChannelHandlerContext</span></span><br><span class="line">AbstractChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor,</span><br><span class="line">                              String name, Class&lt;? extends ChannelHandler&gt; handlerClass) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = ObjectUtil.checkNotNull(name, <span class="string">"name"</span>);</span><br><span class="line">    <span class="keyword">this</span>.pipeline = pipeline;</span><br><span class="line">    <span class="keyword">this</span>.executor = executor; <span class="comment">// null</span></span><br><span class="line">    <span class="keyword">this</span>.executionMask = mask(handlerClass); <span class="comment">// 生成一个掩码 可以快读判断这个Handler重载了哪些方法</span></span><br><span class="line">    ordered = executor == <span class="keyword">null</span> || executor <span class="keyword">instanceof</span> OrderedEventExecutor; <span class="comment">// ture</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，addLast方法将用户写的Handler包装成了一个 DefaultChannelPipeline ，加入到了双向链表的tail节点之前。pipeline节点就拥有了handler执行逻辑。</p><p>接下来要弄清楚的是，ChannelHandlerContext 是怎样调用这些逻辑的，ChannelHandlerContext继承了ChannelInboundInvoker, ChannelOutboundInvoker这两个接口，里面定义的方法就是用来调用handler逻辑。</p><p>那为什么要继承两个接口呢？</p><p>Handler 有 in 和 out 之分，但是HandlerContext没有，所以为了既能调用inhandler逻辑又能调用outhandler逻辑，就继承了两个接口。</p><p>老版本的netty，AbstractChannelHandlerContext 有两个bool属性InBound 和outBound，<code>InBound=true</code>表示该节点是inBound，<code>outBound=true</code>表示该节点是outBound，当然也可能同时为true。在我阅读的源代码版本（4.1.50）中已经删除了这两个属性，取而代之的是属性<strong><em>executionMask</em></strong>，通过使用该属性可以在事件传播时，快速的判断出该节点中的Handler在inBound方向和outBound方向有没有重载某事件处理逻辑。此处将另外分析。</p><p>最后要弄明白的是，handler的执行结果应该怎么处理？</p><p>我们不要忘了，pipeLine是一个双向链表，在一个上下文节点中，我们可以很方便的获取到前一个或者后一个上下文节点，当前的节点执行完handler逻辑之后，调用ChannelInboundInvoker或者ChannelOutboundInvoker定义的方法（AbstractChannelHandlerContext对这些方法做了实现），就可以将当前的执行结果传递给下一个节点或者上一个节点。这将取决于事件的类型是inBound还是outBound。</p><h4 id="事件传播"><a href="#事件传播" class="headerlink" title="事件传播"></a>事件传播</h4><p>在此分别选取一种事件传播的源码看一下</p><p><strong>inBound事件</strong></p><p>看一个inBound事件，当unsafe中执行<code>pipeline.fireChannelRead()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultChannelPipeline</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最先调用的是head节点的channelRead方法，此处是静态方法调用</span></span><br><span class="line">    AbstractChannelHandlerContext.invokeChannelRead(head, msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractChannelHandlerContext</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最最核心的就是这个静态调用，负责传播的核心方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="string">"msg"</span>), next);</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">      next.invokeChannelRead(m);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            next.invokeChannelRead(m);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是实例方法，在某节点中确定下一个执行节点，确定了之后将执行静态调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">fireChannelRead</span><span class="params">(<span class="keyword">final</span> Object msg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 又是这个静态调用</span></span><br><span class="line">    invokeChannelRead(findContextInbound(MASK_CHANNEL_READ), msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 寻找下一个节点的逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextInbound</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</span><br><span class="line">    EventExecutor currentExecutor = executor();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// 这里可以看出inBound事件是向后传播的</span></span><br><span class="line">      ctx = ctx.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (skipContext(ctx, currentExecutor, mask, MASK_ONLY_INBOUND));</span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体负责执行handler逻辑的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          ((ChannelInboundHandler) handler()).channelRead(<span class="keyword">this</span>, msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          invokeExceptionCaught(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fireChannelRead(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在handler <code>channelRead()</code>逻辑最后，都会调用一下<code>ctx.channelRead</code>，将事件传播下去</p><p><strong>outBound事件</strong></p><p>再看一个outBound事件传播的代，当我们在某handler中执行 <code>ctx.pipeline().writeAndFlush()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultChannelPipeline</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tail.write(msg, promise); <span class="comment">//pipeline直接找tail</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractChannelHandlerContext</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">write</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> write(msg, newPromise());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">write</span><span class="params">(<span class="keyword">final</span> Object msg, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    write(msg, <span class="keyword">false</span>, promise);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, <span class="keyword">boolean</span> flush, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(msg, <span class="string">"msg"</span>);</span><br><span class="line">   ...</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound(flush ?</span><br><span class="line">            (MASK_WRITE | MASK_FLUSH) : MASK_WRITE);</span><br><span class="line">    <span class="keyword">final</span> Object m = pipeline.touch(msg, next);</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">            next.invokeWriteAndFlush(m, promise);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.invokeWrite(m, promise); <span class="comment">// 执行这里</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> WriteTask task = WriteTask.newInstance(next, m, promise, flush);</span><br><span class="line">        <span class="keyword">if</span> (!safeExecute(executor, task, promise, m, !flush)) &#123;</span><br><span class="line">            task.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 寻找下一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextOutbound</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</span><br><span class="line">    EventExecutor currentExecutor = executor();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      ctx = ctx.prev;<span class="comment">// 往前找</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (skipContext(ctx, currentExecutor, mask, MASK_ONLY_OUTBOUND));</span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeWrite</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">        invokeWrite0(msg, promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        write(msg, promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行handler逻辑的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeWrite0</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ((ChannelOutboundHandler) handler()).write(<span class="keyword">this</span>, msg, promise);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        notifyOutboundHandlerException(t, promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在handler的write方法中最后，都会调用一下<code>ctx.write()</code>将时间传播上去</p><p>inBound事件传播是从head节点开始，到tail节点结束。tail节点，作为InBoundHandler实现了所有的inBound事件处理方法，而实现的逻辑是空的，即不作任何处理，以结束inBound事件的传播。</p><p>OutBound事件传播是从tail节点开始，到head节点结束，head节点作为OutBoundHandler，实现了所有的outBound事件处理方法，将所有的outBoud事件委托给unsafe执行相应的底层逻辑。</p><p>整理一下思路：对于in 和 out 应该站在pipeLine的角度去理解，比如新连接channel注册成功之后，会调用<code>pipeline().fireChannelActive()</code>，向pipeline中传入事件，这种就是in事件；而writeAndFlush操作，需要跳出pipeline调用unSafe来向channel中写数据，因此是一个out事件。</p><p>至此，还有一点需要分析，那就是异常的传播。</p><h4 id="异常传播"><a href="#异常传播" class="headerlink" title="异常传播"></a>异常传播</h4><p>我们通常在业务代码中，会加入一个异常处理器，统一处理pipeline过程中的所有的异常，并且，一般该异常处理器需要加载自定义节点的最末尾</p><p>此类ExceptionHandler一般继承自 <code>ChannelDuplexHandler</code>，标识该节点既是一个inBound节点又是一个outBound节点，我们分别分析一下inBound事件和outBound事件过程中，ExceptionHandler是如何才处理这些异常的</p><p><strong>inBound异常</strong></p><p>我们以数据的读取为例，看下netty是如何传播在这个过程中发生的异常</p><p>我们前面已经知道，对于每一个节点的数据读取都会调用<code>AbstractChannelHandlerContext.invokeChannelRead()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractChannelHandlerContext</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ((ChannelInboundHandler) handler()).channelRead(<span class="keyword">this</span>, msg);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        notifyHandlerException(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到该节点最终委托到其内部的ChannelHandler处理channelRead，而在最外层catch整个Throwable，因此，我们在如下用户代码中的异常会被捕获</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object data)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(...); </span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段业务代码中的 <code>BusinessException</code> 会被 <code>BusinessHandler</code>所在的节点捕获，进入到 <code>notifyHandlerException(t);</code>往下传播，我们看下它是如何传播的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractChannelHandlerContext</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyHandlerException</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 略去了非关键代码，读者可自行分析</span></span><br><span class="line">    invokeExceptionCaught(cause);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeExceptionCaught</span><span class="params">(<span class="keyword">final</span> Throwable cause)</span> </span>&#123;</span><br><span class="line">    handler().exceptionCaught(<span class="keyword">this</span>, cause);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，此Hander中异常优先由此Handelr中的<code>exceptionCaught</code>方法来处理，默认情况下，如果不覆写此Handler中的<code>exceptionCaught</code>方法，调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ChannelInboundHandlerAdapter</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ctx.fireExceptionCaught(cause);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractChannelHandlerContext</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">fireExceptionCaught</span><span class="params">(<span class="keyword">final</span> Throwable cause)</span> </span>&#123;</span><br><span class="line">    invokeExceptionCaught(next, cause);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了这里，已经很清楚了，如果我们在自定义Handler中没有处理异常，那么默认情况下该异常将一直传递下去，遍历每一个节点，直到最后一个自定义异常处理器ExceptionHandler来终结，收编异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Exceptionhandler extends ChannelDuplexHandler &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 处理该异常，并终止异常的传播</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了这里，你应该知道为什么异常处理器要加在pipeline的最后了吧？</p><p><strong>outBound异常</strong></p><p>然而对于outBound事件传播过程中所发生的异常，该<code>Exceptionhandler</code>照样能完美处理，为什么？</p><p>我们以前面提到的<code>writeAndFlush</code>方法为例，来看看outBound事件传播过程中的异常最后是如何落到<code>Exceptionhandler</code>中去的</p><p>前面我们知道，<code>channel.writeAndFlush()</code>方法最终也会调用到节点的 <code>invokeFlush0()</code>方法（write机制比较复杂，我们留到后面的文章中将）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractChannelHandlerContext</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeWriteAndFlush</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">        invokeWrite0(msg, promise);</span><br><span class="line">        invokeFlush0();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        writeAndFlush(msg, promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeFlush0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ((ChannelOutboundHandler) handler()).flush(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        notifyHandlerException(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>invokeFlush0()</code>会委托其内部的ChannelHandler的flush方法，我们一般实现的即是ChannelHandler的flush方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeFlush0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ((ChannelOutboundHandler) handler()).flush(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        notifyHandlerException(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好，假设在当前节点在flush的过程中发生了异常，都会被 <code>notifyHandlerException(t);</code>捕获，该方法会和inBound事件传播过程中的异常传播方法一样，也是轮流找下一个异常处理器，而如果异常处理器在pipeline最后面的话，一定会被执行到，这就是为什么该异常处理器也能处理outBound异常的原因</p><p>关于为啥 <code>ExceptionHandler</code> 既能处理inBound，又能处理outBound类型的异常的原因，总结一点就是，在任何节点中发生的异常都会往下一个节点传递，最后终究会传递到异常处理器</p><h4 id="Handler热插拔"><a href="#Handler热插拔" class="headerlink" title="Handler热插拔"></a>Handler热插拔</h4><p>netty 还有个最大的特性之一就是Handler可插拔，可以做到动态编织pipeline，比如在首次建立连接的时候，需要通过进行权限认证，在认证通过之后，就可以将此context移除，下次pipeline在传播事件的时候就就不会调用到权限认证处理器。</p><p>新连接接入时，ServerBootstrapAcceptor 会给新的NioSocketChannel 添加一个InBoundHandler叫ChannelInitialzer，添加成功之后会触发handlerAdded方法，该方法会调用重载的initialChannel方法初始化新连接的pipeline，结束后会调用pipeline.remove 删除此handler，这里也是热插拔的体现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Channel创建的时候会创建一个PipeLine，并且PipeLine也持有Channel对象的引用，二者是互相引用的关系。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp
      
    
    </summary>
    
      <category term="I/O和网络编程" scheme="http://yoursite.com/child/categories/I-O%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="netty" scheme="http://yoursite.com/child/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>mysql-innodb的索引</title>
    <link href="http://yoursite.com/child/2019/11/20/mysql-innodb%E7%9A%84%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/child/2019/11/20/mysql-innodb的索引/</id>
    <published>2019-11-19T16:00:00.000Z</published>
    <updated>2020-06-19T08:42:08.442Z</updated>
    
    <content type="html"><![CDATA[<p>数据库索引是数据库管理系统中一个排序的<strong>数据结构</strong>，以协助快速查询更新数据库表中数据</p><p>索引类型：normal普通索引、unique唯一索引、全文索引</p><ul><li>普通索引：也叫非唯一索引，没有任何的限制</li><li>唯一索引：要求索引的键值不能重复，另外，主键索引是一种特殊的唯一索引，比唯一索引多了一条限制。即键值不能为null</li><li>全文索引：针对较大的数据，比如我么存放的是消息内容没有几KB的数据这种情况。如果要解决like查询效率低的问题，可以创建全文索引。只有文本类型的字段才可以创建全文索引，比如：char、varchar、text</li></ul><h4 id="1、索引用什么数据结构？"><a href="#1、索引用什么数据结构？" class="headerlink" title="1、索引用什么数据结构？"></a>1、索引用什么数据结构？</h4><p>索引是用来加快记录的查找速度，但是在查询记录之前是不是需要先定位到记录索引呢。因此为了加快索引的查找速度，可以考虑将索引按照顺序进行存放，然后使用二分查找法查找。</p><p>既然是按照顺序存放，那么可以考虑的数据结构就有以下几种：</p><h5 id="1-1-有序列表"><a href="#1-1-有序列表" class="headerlink" title="1.1 有序列表"></a>1.1 有序列表</h5><p>有序列表查询没有问题，但是插如记录的时候需要同步插入记录的索引，有序列表的插入需要移动大量的数据，所以有序列表排除。</p><h5 id="1-2-单链表"><a href="#1-2-单链表" class="headerlink" title="1.2 单链表"></a>1.2 单链表</h5><p>单链表插入没有问题，查找的时候需要重头开始遍历，不能使用二分查找，因此排除</p><h5 id="1-3-二叉树查找树"><a href="#1-3-二叉树查找树" class="headerlink" title="1.3  二叉树查找树"></a>1.3  二叉树查找树</h5><p>既然单链表不能二分查找，那么就用支持二分查找的二叉树，但是极端情况下（插入顺序有序），二叉链表回退化成单链表，排除</p><h5 id="1-4-AVL树-平衡二叉树"><a href="#1-4-AVL树-平衡二叉树" class="headerlink" title="1.4 AVL树-平衡二叉树"></a>1.4 AVL树-平衡二叉树</h5><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/mysql/avl%E6%A0%91.png" alt></p><p>平衡二叉树解决了二叉树左右子树高度相差太大的极端问题，但是它也存在其他问题：</p><ul><li>二叉树每个节点只能存放一条索引记录，当数据量很大的时候，树会长的很高，查询效率降低</li><li>平衡二叉树的平衡操作开销比较大</li><li>索引数据是以节点为单位存放到磁盘上，磁盘的最小单位是一页16KB，使用二叉树意味着每页磁盘页只能存放一条索引，浪费巨大显然不合理。</li></ul><h5 id="1-5-多路平衡查找树-B-Tree"><a href="#1-5-多路平衡查找树-B-Tree" class="headerlink" title="1.5 多路平衡查找树 B Tree"></a>1.5 多路平衡查找树 B Tree</h5><p>跟 AVL 树一样，B 树在枝节点和叶子节点存储键值、数据地址、节点引用。 </p><p>它有一个特点：分叉数（路数）永远比关键字数多 1。比如我们画的这棵树，每个节点存储两个关键字，那么就会有三个指针指向三个子节点。 </p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/mysql/B%E6%A0%91.png" alt></p><p>B Tree 的查找规则是什么样的呢？ </p><p>比如我们要在这张表里面查找 15。 </p><p>因为 15 小于 17，走左边。 </p><p>因为 15 大于 12，走右边。 </p><p>在磁盘块 7 里面就找到了 15，只用了 3 次 IO。 </p><p><strong><em>B树的缺点：范围查询时性能捉急</em></strong></p><h5 id="1-6-B-树（加强版多路平衡查找树）"><a href="#1-6-B-树（加强版多路平衡查找树）" class="headerlink" title="1.6 B+树（加强版多路平衡查找树）"></a>1.6 B+树（加强版多路平衡查找树）</h5><p>B Tree 的效率已经很高了，为什么 MySQL 还要对 B Tree 进行改良，最终使用了 B+Tree 呢？ </p><p>总体上来说，这个 B +树的改良版本解决的问题比 B Tree 更全面。 我们来看一下 InnoDB 里面的 B+树的存储结构：</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/mysql/B%2B%E6%A0%91.png" alt></p><p>的 B+Tree 有几个特点： </p><p>1、它的关键字的数量是跟路数相等的； </p><p>2、B+Tree 的根节点和枝节点中都不会存储数据，只有叶子节点才存储数据。查找到索引键值不会直接返回，会到最后一层的叶子节点。比如我们搜索 id=28，虽然在第一层直接命中了，但是全部的数据在叶子节点上面，所以我还要继续往下搜索，一直到叶子节点。</p><p>我们举个例子：假设一条记录是 1K，一个叶子节点（一页）可以存储 16 条记录。 </p><p>非叶子节点可以存储多少个指针？ </p><p>假设主键为自增的bigint类型，占8字节，B+树指针为6字节，一页能存放的索引数量是16KB/14B=1170，即至少有1170页即18MB存放行数据。而实际上这个这个值应该比计算出来的要大，原因是理论上一个叶节点中可能存放的记录数应该是1-1170行，但是1170是按照<u>主键大小+指针大小</u>计算出来的值，真正的行数据肯定还会有其他的字段，因此叶节点不能存放1170行数据是肯定的，那么多出来的行数据就会使用新的页进行存储并通过指针进行连接，这部分页并没有直接与B+树的中间节点连接，所以也无法进行精确计算。</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/mysql/B%2Btree%20index.png" alt></p><p>树 深 度 为 2 的 时 候 ， 有 1170^2 个 叶 子 节 点 ， 可 以 存 储 的 数 据 为 1170X1170X16=21902400。 </p><p>在查找数据时一次页的查找代表一次 IO，也就是说，一张 2000 万左右的表，查询 数据最多需要访问 3 次磁盘。 </p><p>所以在 InnoDB 中 B+ 树深度一般为 1-3 层，它就能满足千万级的数据存储。 </p><p>3、B+Tree 的每个叶子节点增加了一个指向相邻叶子节点的指针，它的最后一个数据会指向下一个叶子节点的第一个数据，形成了一个有序链表的结构。 </p><p>4、它是根据左闭右开的区间 [ )来检索数据。 </p><p>B+Tree 的数据搜寻过程： </p><p>1）比如我们要查找 28，在根节点就找到了键值，但是因为它不是页子节点，所以 会继续往下搜寻，28 是[28,66)的左闭右开的区间的临界值，所以会走中间的子节点，然后继续搜索，它又是[28,34)的左闭右开的区间的临界值，所以会走左边的子节点，最后在叶子节点上找到了需要的数据。 </p><p>2）第二个，如果是范围查询，比如要查询从 22 到 60 的数据，当找到 22 之后，只需要顺着节点和指针顺序遍历就可以一次性访问到所有的数据节点，这样就极大地提高了区间查询效率（不需要返回上层父节点重复遍历查找）。 </p><p>总结一下，InnoDB 中的 B+Tree 的特点： </p><p>1)它是 B Tree 的变种，B Tree 能解决的问题，它都能解决。B Tree 解决的两大问题是什么？（每个节点存储更多关键字；路数更多） </p><p>2)扫库、扫表能力更强（如果我们要对表进行全表扫描，只需要遍历叶子节点就可以了，不需要遍历整棵 B+Tree 拿到所有的数据） </p><p>3) B+Tree 的磁盘读写能力相对于 B Tree 来说更强（根节点和枝节点不保存数据区，所以一个节点可以保存更多的关键字，一次磁盘加载的关键字更多） </p><p>4)排序能力更强（因为叶子节点上有下一个数据区的指针，数据形成了链表） </p><p>5)效率更加稳定（B+Tree 永远是在叶子节点拿到数据，所以 IO 次数是稳定的） </p><p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">数据结构可视化网站</a></p><h4 id="2、B-Tree-落地形式"><a href="#2、B-Tree-落地形式" class="headerlink" title="2、B+Tree 落地形式"></a>2、B+Tree <strong>落地形式</strong></h4><p>不同的存储引擎文件不一样。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'datadir'</span>;</span><br></pre></td></tr></table></figure><p>每 张 InnoDB 的 表 有 两 个 文 件 （ .frm 和 .ibd ） ， MyISAM 的 表 有 三 个 文 件 （.frm、.MYD、.MYI）。</p><p>有一个是相同的文件，.frm。 .frm 是 MySQL 里面表结构定义的文件，不管你建表的时候选用任何一个存储引擎都会生成，我们就不看了。 </p><p>我们主要看一下其他两个文件是怎么实现 MySQL 不同的存储引擎的索引的。 </p><h5 id="2-1-MyISAM"><a href="#2-1-MyISAM" class="headerlink" title="2.1 MyISAM"></a>2.1 <strong>MyISAM</strong></h5><p>在 MyISAM 里面，另外有两个文件： </p><p>一个是.MYD 文件，D 代表 Data，是 MyISAM 的数据文件，存放数据记录，比如我 们的 user_myisam 表的所有的表数据。 </p><p>一个是.MYI 文件，I 代表 Index，是 MyISAM 的索引文件，存放索引，比如我们在id 字段上面创建了一个主键索引，那么主键索引就是在这个索引文件里面。 </p><p>也就是说，在 MyISAM 里面，索引和数据是两个独立的文件。 </p><p>那我们怎么根据索引找到数据呢？ </p><p>MyISAM 的 B+Tree 里面，叶子节点存储的是数据文件对应的磁盘地址。所以从索引文件.MYI 中找到键值后，会到数据文件.MYD 中获取相应的数据记录。</p><h5 id="2-2-InnoDB"><a href="#2-2-InnoDB" class="headerlink" title="2.2 InnoDB"></a>2.2 <strong>InnoDB</strong></h5><p>InnoDB 只有一个文件（.ibd 文件），那索引放在哪里呢？ </p><p>在 InnoDB 里面，它是以主键为索引来组织数据的存储的，所以索引文件和数据文 件是同一个文件，都在.ibd 文件里面。 </p><p>在 InnoDB 的主键索引的叶子节点上，它直接存储了我们的数据。 </p><p>什么叫做聚集索引（聚簇索引）？ </p><p>就是索引键值的逻辑顺序跟表数据行的物理存储顺序是一致的。（比如字典的目录 是按拼音排序的，内容也是按拼音排序的，按拼音排序的这种目录就叫聚集索引）。 </p><p>在 InnoDB 里面，它组织数据的方式叫做叫做（聚集）索引组织表（clustered index organize table），所以主键索引是聚集索引，非主键都是非聚集索引。 </p><p>主键之外的索引，比如我们在 name 字段上面建的普通索引，又是怎么存储和检索 数据的呢？ </p><p>InnoDB 中，主键索引和辅助索引是有一个主次之分的。 </p><p>辅助索引存储的是辅助索引和主键值。如果使用辅助索引查询，会根据主键值在主键索引中查询，最终取得数据。 </p><p>比如我们用 name 索引查询 name= ‘青山’，它会在叶子节点找到主键值，也就是 id=1，然后再到主键索引的叶子节点拿到数据。</p><h4 id="3、主键索引的三种情形"><a href="#3、主键索引的三种情形" class="headerlink" title="3、主键索引的三种情形"></a>3、主键索引的三种情形</h4><p>有primaryKey –使用主键组织数据存储</p><p>没有主键，存在unique字段– 使用该unique字段组织数据存储</p><p>没有主键，没有unique字段–使用隐藏字段_rowid组织数据</p><h4 id="4、使用索引的注意点"><a href="#4、使用索引的注意点" class="headerlink" title="4、使用索引的注意点"></a>4、使用索引的注意点</h4><p>回表查询：命中辅助索引后，根据辅助索引查询到的主键，再去主键索引中查询数据，称为回表</p><p>覆盖索引：组成联合索引的字段包含了所需查询的字段，查询到辅助索引页即可得到结果，无需回表查询</p><ol><li><p>为什么不建议使用Select * ？</p><p>阻止了覆盖索引生效，导致回表查询，使用指定列的sql能节省数据库内存占用，提高数据传输效率</p></li><li><p>索引的最左匹配原则是什么意思？</p><p>有联合索引 index(A,B,C)</p><p>查询时，使用A、A&amp;B 、A&amp;B&amp;C 查询都能命中该索引，且与字段顺序无关，即B&amp;A也能命中</p><p>A&amp;C  B&amp;C  B&amp;C  B  C  都不符合最左匹配原则，不能命中</p></li><li><p>模糊匹配可以用到索引吗？</p><p>like %abc 不能命中索引，like abc%可以命中</p><p>因此我们得出结论：前导模糊匹配不能命中索引</p></li><li><p>负向查询 !=  not in &lt;&gt; 能不能用到索引？</p><p>能不能用到索引是优化器决定的，优化器基于开销判断，一般不推荐使用负向查询</p></li><li><p>为什么推荐递增字段做主键索引？</p><p>InnoDB的索引底层是B+树，且通过主键索引来组织数据存储。如果使用自增主键，那么每次插入新的记录，就会顺序添加到当前索引节点的后续位置（右边），当写满一页就会开辟新页，这样就会形成一个近似顺序填满的紧凑结构，插入过程无需移动已有数据。</p><p>而如果使用uuid或者身份证号这种不规则的数据作为主键索引，那么插入数据时，相当于随机插入，导致已有数据频繁移动，磁盘io开销变大，且可能产生大量的叶碎片</p></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>使用索引应注意以下几点：</p><ul><li>负向查询不能命中索引</li><li>前导模糊查询不能命中索引（like条件前面带%）</li><li>字符串不加引号，出现隐式转换 ，不能命中索引</li><li>数据区分度不大不宜建立索引（性别）</li><li>在索引属性上进行计算（函数或表达式）不能命中索引</li></ul><p>并非周知的sql实践：</p><ul><li>业务存在大量单条查询，实用hash索引效率高</li><li>允许为null的字段有大坑，单列索引不存null值，复合索引不存全为null的值，设置为not null 或者设置默认值</li><li>固定范围取值的字段使用枚举类型而不是字符串</li></ul><p>小众实用的规则：</p><ul><li>明确返回结果数量，实用limit能提升查询效率</li><li>把计算放到业务层而不是数据库层</li><li>强制类型转换会扫描全表</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数据库索引是数据库管理系统中一个排序的&lt;strong&gt;数据结构&lt;/strong&gt;，以协助快速查询更新数据库表中数据&lt;/p&gt;
&lt;p&gt;索引类型：normal普通索引、unique唯一索引、全文索引&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通索引：也叫非唯一索引，没有任何的限制&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="数据库技术" scheme="http://yoursite.com/child/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/child/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>netty源码分析之新连接接入</title>
    <link href="http://yoursite.com/child/2019/11/18/nio-netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%96%B0%E8%BF%9E%E6%8E%A5%E6%8E%A5%E5%85%A5/"/>
    <id>http://yoursite.com/child/2019/11/18/nio-netty源码分析之新连接接入/</id>
    <published>2019-11-17T16:00:00.000Z</published>
    <updated>2020-05-22T12:09:10.899Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道服务端启动后，会有一条boss线程在运行着，负责接受客户端的新连接。boss线程具体运行的逻辑在NioEventLoop的<code>run()</code>方法中，这里不做具体体分析，只截取本文关心的代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NioEventLoop</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  strategy = select(curDeadlineNanos);</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">if</span> (strategy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        processSelectedKeys();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>典型的jdk nio 的代码逻辑，先select，再处理selectedKey，跟进处理代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NioEventLoop</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (selectedKeys != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 优化过的处理 一般会进这里</span></span><br><span class="line">        processSelectedKeysOptimized();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 正常处理</span></span><br><span class="line">        processSelectedKeysPlain(selector.selectedKeys());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeysOptimized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; selectedKeys.size; ++i) &#123;</span><br><span class="line">        <span class="keyword">final</span> SelectionKey k = selectedKeys.keys[i];</span><br><span class="line">        selectedKeys.keys[i] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> Object a = k.attachment();</span><br><span class="line">      <span class="comment">// 从selectedKey中取出的附件是NioSocketChannel对象</span></span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) &#123;</span><br><span class="line">          <span class="comment">// 继续跟进</span></span><br><span class="line">            processSelectedKey(k, (AbstractNioChannel) a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;</span><br><span class="line">            processSelectedKey(k, task);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (needsToSelectAgain) &#123;</span><br><span class="line">            selectedKeys.reset(i + <span class="number">1</span>);</span><br><span class="line">            selectAgain();</span><br><span class="line">            i = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//注意：所有通道注册的时候都没有第一时间指定监听事件，而ops==0 时，这里默认是监听读就绪事件</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">          unsafe.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException ignored) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到最终调用了<code>unsafe.read()</code>方法，注意这里处理的是 NioServerSocketChannel 上的读。</p><p>这里我们要清楚，netty能读到的数据分为两种类型，对于NioServerSocketChannel来说，它只负责接收新连接，所以读到的是建立连接的请求，netty将这类数据称为 message 。对于已经接入的客户端连接，读到的是业务请求，netty将这类数据成为 byte。</p><p>由于这里处理的是新连接接入，<code>read()</code>方法将进入 <em>AbstractNioMessageChannel.NioMessageUnsafe</em> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NioMessageUnsafe</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">eventLoop</span><span class="params">()</span>.<span class="title">inEventLoop</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">        <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line">        <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();</span><br><span class="line">        allocHandle.reset(config);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line">        Throwable exception = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">// 不断的读取消息，可以猜到读取的是一个个NioSocketChannel对象</span></span><br><span class="line">                    <span class="keyword">int</span> localRead = doReadMessages(readBuf);</span><br><span class="line">                    ...</span><br><span class="line">                &#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">int</span> size = readBuf.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">                readPending = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 这里向NioServerSocketChannel 的pipeline中传进ChannelRead事件,参数是读取到的NioSocketChannel</span></span><br><span class="line">                pipeline.fireChannelRead(readBuf.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            readBuf.clear();</span><br><span class="line">            allocHandle.readComplete();</span><br><span class="line">            pipeline.fireChannelReadComplete();</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;        </span><br><span class="line">            <span class="keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">                removeReadOp();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点在<code>doReadMessages()</code> 方法，该方法将调用到底层的jdk的<code>accept()</code>得到的 SocketChannel ，并将其包装成netty的 NioSocketChannel  并add 到 buf 中，上层的<code>read()</code>方法可以直接访问 buf。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NioServerSocketChannel</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadMessages</span><span class="params">(List&lt;Object&gt; buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// accept得到SocketChannel对象</span></span><br><span class="line">    SocketChannel ch = SocketUtils.accept(javaChannel());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 根据SocketChannel对象 创建NioSocketChannel</span></span><br><span class="line">            buf.add(<span class="keyword">new</span> NioSocketChannel(<span class="keyword">this</span>, ch));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>doReadMessages()</code> 调用完之后，我们再回到<code>read()</code>方法，可以看到<strong>将读取到每个 NioSocketChannel 作为参数</strong>调用了 NioServerSocketChannel 的 <code>pipeline.channalRead(buf.get(i))</code> 方法，这个调用会产生什么反应呢？</p><p>原来服务器端启动时，初始化 NioServerSocketChannel  阶段向 PipeLine 中 添加了一个 ServerBootstrapAcceptor ，后文称接收器，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ServerBootstrap</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    ChannelPipeline p = channel.pipeline(); <span class="comment">// 这里是NioServerSocketChannel的pipeline</span></span><br><span class="line">    p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> </span>&#123;</span><br><span class="line">          ...</span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化结束后， NioServerSocketChannel 的 pipeline 有以下几个节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head--&gt;ServerBootstrapAcceptor--&gt;tail</span><br></pre></td></tr></table></figure><p>再看这个接收器ServerBootstrapAcceptor，它是 NioServerSocketChannel 的一个 InBound 事件处理器，<code>read()</code>方法调用<code>pipeline.channalRead(buf.get(i))</code>时，会首先进入head执行channelRead 方法，head只是简单的向下传播此事件，然后进入 ServerBootstrapAcceptor 的 channelRead 方法，我们来看具体做了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ServerBootstrapAcceptor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Channel child = (Channel) msg;</span><br><span class="line">            <span class="comment">//1、向NioSocketChannel的PipeLine中 add ChannelInitializer</span></span><br><span class="line">            child.pipeline().addLast(childHandler);</span><br><span class="line">  <span class="comment">//2. 设置options和attrs</span></span><br><span class="line">            setChannelOptions(child, childOptions, logger);</span><br><span class="line">            setAttributes(child, childAttrs);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//3. 异步执行通道注册，监听事件尚未指定，未指定默认监听读就绪</span></span><br><span class="line">                childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                            forceClose(child, future.cause());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                forceClose(child, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>原来是对读取到的 NioSocketChannel 执行了初始化，该方法主要对 NioSocketChannel 做了三件事：</p><ol><li>添加用户代码中指定的 InBound 事件处理器 ChannelInitializer 用于初始化NioSocketChannel，该handle主要是向NioSocketChannel 中 add 一系列事件处理器 ，执行完成之后将会被<code>remove</code>掉。</li><li>设置用户代码中指定的 NioSocketChannel 的 options 和 attrs</li><li>使用 childGroup 线程池执行 NioSocketChannel 注册任务</li></ol><p>childGroup 会使用 chooser 选择分配一条线程（EventLoop）给 NioSocketChannel，之后所有该channel的任务都将由这条线程执行。</p><p>注册过程与NioServerSocketChannel的注册流程一致，最终会调用到 <em>AbstractChannel.AbstractUnsafe</em> 类的 <code>register0 ()</code>方法进行注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line">        <span class="comment">//1. 执行注册</span></span><br><span class="line">            doRegister(); </span><br><span class="line">            neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">            registered = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//2.传入事件handlerAdded</span></span><br><span class="line">            pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line">            safeSetSuccess(promise);</span><br><span class="line">        <span class="comment">//3.传入事件channelRegistered</span></span><br><span class="line">            pipeline.fireChannelRegistered();</span><br><span class="line">            <span class="comment">//4.注册成功则传入事件channelActice</span></span><br><span class="line">            <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                  pipeline.fireChannelActive();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                  beginRead();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            ...</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用jdk底层注册channel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">    selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，注册时并没有设置感兴趣的事件，第二个参数为0，第三个参数则是将netty封装后的NioSocketChannel 当做附件，放到了selectionKey中，之后select出的selectionKey中都将带有netty的channel对象，这种设计实现了netty channel 与 jdk channel 的映射。</p><p>继续往下看，注册完之后，会调用一系列的pipeline方法，handlerAdded、channelRegistered、channelActive，这里我们要明白，从 unsafe 中调用 pipeline 的方法，<strong>调用进入 pipeline传入的事件我们称之为 inbound 事件</strong>。</p><p>其中 channelActive 为流程中的重要一环，pipeLine调用后首先会调用head节点的channelActive方法，我们看一下head的channelActive源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HeadCotext</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 向下传递事件</span></span><br><span class="line">    ctx.fireChannelActive();</span><br><span class="line">    <span class="comment">// 如果设置为自动读，autoRead 默认为true，则调用channel的read方法</span></span><br><span class="line">    readIfIsAutoRead();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readIfIsAutoRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (channel.config().isAutoRead()) &#123;</span><br><span class="line">      channel.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>往下看调用链：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractChannel</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Channel <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pipeline.read();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再跟进</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultChannelPipeline</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tail.read();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用到了tail的read方法, tail 的 read 方法是继承自父类 AbstractChannelHandlerContext：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractChannelHandlerContext</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// read方法 将从tail开始往前检索，找到实现了read方法的OutBoundHandler，将找到head节点</span></span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound(MASK_READ);</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeRead();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Tasks tasks = next.invokeTasks;</span><br><span class="line">        <span class="keyword">if</span> (tasks == <span class="keyword">null</span>) &#123;</span><br><span class="line">            next.invokeTasks = tasks = <span class="keyword">new</span> Tasks(next);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.execute(tasks.invokeReadTask);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑也很清晰，从 tail 开始，向前调用重载了read方法的OutboundHandler，直到head节点，看一下head节点的 <code>read()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">unsafe.beginRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用到了 unsafe 的 beginRead方法，这里我们需要明白<strong>从 pipeline 中不断调用最终到达unsafe 的调用链，称为OutBound 事件传播，调用出pipeline</strong>，所以 read 是一个outbound事件。</p><p>继续跟源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">beginRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    doBeginRead();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractNioChannel</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SelectionKey selectionKey = <span class="keyword">this</span>.selectionKey;</span><br><span class="line">        <span class="keyword">if</span> (!selectionKey.isValid()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        readPending = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> interestOps = selectionKey.interestOps();</span><br><span class="line">        <span class="comment">// interestOps &amp; OP_READ 若果没有监听读就绪事件 do it</span></span><br><span class="line">        <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;</span><br><span class="line">            selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>重点是最后一行，设置监听事件为读就绪。</p><p>一个连接从接入，到注册，到设置监听读就绪，之后，客户端与服务器便能正常的通信了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们知道服务端启动后，会有一条boss线程在运行着，负责接受客户端的新连接。boss线程具体运行的逻辑在NioEventLoop的&lt;code&gt;run()&lt;/code&gt;方法中，这里不做具体体分析，只截取本文关心的代码片段：&lt;/p&gt;
&lt;figure class=&quot;highlig
      
    
    </summary>
    
      <category term="I/O和网络编程" scheme="http://yoursite.com/child/categories/I-O%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="netty" scheme="http://yoursite.com/child/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>netty源码分析之服务端启动</title>
    <link href="http://yoursite.com/child/2019/11/15/nio-netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8/"/>
    <id>http://yoursite.com/child/2019/11/15/nio-netty源码分析之服务端启动/</id>
    <published>2019-11-14T16:00:00.000Z</published>
    <updated>2020-06-08T03:19:57.812Z</updated>
    
    <content type="html"><![CDATA[<p>首先贴一段简单的服务器启动代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  NioEventLoopGroup parent = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>); </span><br><span class="line">  NioEventLoopGroup children = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">  ServerBootstrap bs = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">  bs.group(parent,children)</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> ServerHandler())</span><br><span class="line">    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;()&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">          ch.pipeline().addLast(<span class="keyword">new</span> Spliter());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  bs.bind(<span class="number">8080</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码逻辑：</p><p>1、创建了一个线程池 parent，其中只有一个线程，主要负责接受新连接</p><p>2、创建另一个线程池 children，线程个数为默认值，核心数的2倍，主要负责处理客户端channel上的各种事件</p><p>3、创建服务器启动引导对象，将两个线程池通过 group 方法设置进去</p><p>4、使用 channel 方法指定服务器使用的i/o模型为nio</p><p>5、使用 handler 方法给服务器的 NioServerSocketChannel 的pipeline添加节点。</p><p>6、使用childHandler 方法指定新连接接入过程中客户端 NioSocketChannel 初始化方法，主要给这些channe l的 PipeLine 添加节点</p><p>7、通过 bind(8080) 方法启动服务绑定到8080端口</p><blockquote><p>对于Reactor线程模型一直有一点疑惑，worker线程池的工作方式是一条channel分配一条线程执行所有的业务逻辑，但是boss线程池面对是仅有一条的NioServerSocketChannel，为什么还需要线程池来处理呢？</p><p>实际上bossGroup中有多个NioEventLoop线程，每个NioEventLoop绑定一个端口，也就是说，如果程序只需要监听1个端口的话，bossGroup里面只需要有一个NioEventLoop线程就行了。</p></blockquote><p>本文的主要讲述的是服务端的启动流程，所以以bind方法为入口，源码节选关键代码块。</p><p>bind方法定义在 ServerBootstrap 类的父类 AbstractBootstrap中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractBootstrap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> doBind(localAddress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 核心 初始化通道 注册通道</span></span><br><span class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">        ChannelPromise promise = channel.newPromise();</span><br><span class="line">        <span class="comment">// 核心 绑定监听端口</span></span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>doBind</code>方法中主要有两个核心方法 <code>initAndRegister()</code>和<code>doBind0()</code>，前者主要负责创建、初始化、注册NioServerSocketChannel，后者负责将创建的通绑定到指定端口并启动服务。</p><p>下面我们逐一来分析，首先是<code>initAndRegister()</code>，看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建</span></span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑清晰，先创建，再初始化，再注册。</p><p><strong>创建</strong>：见文章开头服务器启动代码，调用ServerBootstrap的<code>channel()</code>方法设置io模式的时候：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractBootstrap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> channelFactory(<span class="keyword">new</span> ReflectiveChannelFactory&lt;C&gt;(</span><br><span class="line">            ObjectUtil.checkNotNull(channelClass, <span class="string">"channelClass"</span>)</span><br><span class="line">    ));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channelFactory</span><span class="params">(ChannelFactory&lt;? extends C&gt; channelFactory)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">this</span>.channelFactory = channelFactory;</span><br><span class="line">    <span class="keyword">return</span> self();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已经指定了 channelFactory 为 ReflectiveChannelFactory , 所以创建语句<code>channelFactory.newChannel()</code>会调用到ReflectiveChannelFactory的<code>newChannel()</code>方法，源码就不贴了，就是反射调用指定类型的默认构造函数创建一个Channel对象，io模型为NIO时，创建的是NioServerSocketChannel对象。</p><p><strong>初始化</strong>： <code>init(channel)</code>调用到ServerBootstrap的init</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ServerBootstrap</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置options</span></span><br><span class="line">    setChannelOptions(channel, newOptionsArray(), logger);</span><br><span class="line">    <span class="comment">// 设置 attrs</span></span><br><span class="line">    setAttributes(channel, attrs0().entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY));</span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line">    <span class="comment">// 设置新接入channel的options和attrs</span></span><br><span class="line">    <span class="keyword">final</span> EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line">    <span class="keyword">final</span> ChannelHandler currentChildHandler = childHandler;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class="line">    <span class="keyword">synchronized</span> (childOptions) &#123;</span><br><span class="line">        currentChildOptions = childOptions.entrySet().toArray(EMPTY_OPTION_ARRAY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs = childAttrs.entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY);</span><br><span class="line">    <span class="comment">// 向NioServerSocketChannel中添加用户自定义Handler，最后添加用于处理新连接的ServerBootstrapAcceptor</span></span><br><span class="line">    p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            ChannelHandler handler = config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向serverChannel的流水线处理器中加入了一个 ServerBootstrapAcceptor，</span></span><br><span class="line">            <span class="comment">// 从名字上就可以看出来，这是一个接入器，专门接受新请求</span></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注册</strong>：<code>config().group().register(channel)</code>经过一系列调用，最终进入最终会调用到 <em>AbstractChannel.AbstractUnsafe</em> 类的 <code>register0 ()</code>方法进行注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractChannel.AbstractUnsafe</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line">        <span class="comment">//1. 执行注册</span></span><br><span class="line">            doRegister(); </span><br><span class="line">            neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">            registered = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//2.传入事件handlerAdded</span></span><br><span class="line">            pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line">            safeSetSuccess(promise);</span><br><span class="line">        <span class="comment">//3.传入事件channelRegistered</span></span><br><span class="line">            pipeline.fireChannelRegistered();</span><br><span class="line">            <span class="comment">//4.注册成功判断是否激活，是则传入事件channelActice</span></span><br><span class="line">            <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                  pipeline.fireChannelActive();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                  beginRead();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            ...</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用jdk底层注册channel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractChannel.AbstractUnsafe</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">    selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，注册时并没有设置感兴趣的事件，第二个参数为0，第三个参数则是将netty封装后的NioSocketChannel 当做附件，放到了selectionKey中，之后select出的selectionKey中都将带有netty的channel对象，这种设计实现了netty channel 与 jdk channel 的映射。</p><p>注册完成之后会会进行一次判断<code>isActive()</code>，对于NioServerSocketChannel来说，到这里并没有激活，因为NioServerSocketChannel 的激活条件是<code>isOpen() &amp;&amp; javaChannel().socket().isBound()</code>，channel需要open且已绑定端口，目前只完成了注册还未进行绑定，所以这里不能触发<code>channelActive</code>事件。</p><p>而对于NioSocketChannel来说，判断条件是<code>ch.isOpen() &amp;&amp; ch.isConnected()</code>，open并已连接，所以NioSocketChannel 一般是在此处触发<code>channelActive</code>事件。</p><p><code>initAndRegister()</code>执行完，来到了<code>dBind0()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractBootstrap</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doBind0</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    channel.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (regFuture.isSuccess()) &#123;</span><br><span class="line">                channel.bind(localAddress, promise)</span><br><span class="line">                  .addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                promise.setFailure(regFuture.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唯一的逻辑就是提交了一个异步任务，调用<code>channel.bind()</code>方法。</p><p>对于channel来说bind是一个outBound事件，<code>channel.bind()</code>会继续调用<code>pipeline.bind()</code>，继续往下掉用<code>tail.bind()</code>，然后就是一个节点一个节点往前传，最终调用到head节点的<code>bind</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    unsafe.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到unsafe我就开心，因为马上要干活了，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractChannel.AbstractUnsafe</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ...<span class="comment">//略过一大堆判断</span></span><br><span class="line">    <span class="comment">// 连接是否激活 绑定之前时false</span></span><br><span class="line">    <span class="keyword">boolean</span> wasActive = isActive();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 关键点</span></span><br><span class="line">        doBind(localAddress);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;&#125;</span><br><span class="line">    <span class="comment">// 之前未激活 现在已激活</span></span><br><span class="line">    <span class="keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;</span><br><span class="line">        <span class="comment">//触发连接激活事件</span></span><br><span class="line">        invokeLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    safeSetSuccess(promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终<code>unsafe.doBind()</code>调用到了NioServerSocketChannel中的<code>doBind()</code>，兜了一个大圈还是回到了原点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NioServerSocketChannel</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里调用jdk nio的api 进行绑定</span></span><br><span class="line">        javaChannel().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是底层jdk的逻辑了，这里执行完成，serverSocket就算是真正的启动了起来。</p><p>再回到<code>unsafe.doBind()</code>，成功后触发<code>pipeline.fireChannelActive()</code>，我们现在都有经验了，这种inBound事件，调用一大圈最终都是从head节点开始执行，来看head的<code>channelActive()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HeadCotext</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 向下传递事件</span></span><br><span class="line">    ctx.fireChannelActive();</span><br><span class="line">    <span class="comment">// 如果设置为自动读，autoRead 默认为true，则调用channel的read方法</span></span><br><span class="line">    readIfIsAutoRead();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readIfIsAutoRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (channel.config().isAutoRead()) &#123;</span><br><span class="line">      channel.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>往下看调用链：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractChannel</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Channel <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pipeline.read();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再跟进</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultChannelPipeline</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tail.read();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用到了tail的read方法, tail 的 read 方法是继承自父类 AbstractChannelHandlerContext：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractChannelHandlerContext</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// read方法 将从tail开始往前检索，找到实现了read方法的OutBoundHandler，将找到head节点</span></span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound(MASK_READ);</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeRead();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑也很清晰，从 tail 开始，向前调用重载了read方法的OutboundHandler，直到head节点，看一下head节点的 <code>read()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">unsafe.beginRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用到了 unsafe 的 beginRead方法，这里我们需要明白<strong>从 pipeline 中不断调用最终到达unsafe 的调用链，称为OutBound 事件传播，调用出pipeline</strong>，所以 read 是一个outbound事件。</p><p>继续跟源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractChannel.AbstractUnsafe</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">beginRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    doBeginRead();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractNioChannel</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SelectionKey selectionKey = <span class="keyword">this</span>.selectionKey;</span><br><span class="line">        <span class="keyword">if</span> (!selectionKey.isValid()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        readPending = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> interestOps = selectionKey.interestOps();</span><br><span class="line">        <span class="comment">// 若果没有监听指定的事件 do it 这里readInterestOp = OP_ACCEPT</span></span><br><span class="line">        <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;</span><br><span class="line">            selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>重点是最后一行，设置监听事件为OP_ACCEPT。至此 NioServerSocketChannel 注册成功并监听OP_ACCEPT事件，客户端连接放马过来吧。</p><p>下一篇分析客户端新连接入流程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先贴一段简单的服务器启动代码&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2
      
    
    </summary>
    
      <category term="I/O和网络编程" scheme="http://yoursite.com/child/categories/I-O%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="netty" scheme="http://yoursite.com/child/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>netty源码分析之异步编程</title>
    <link href="http://yoursite.com/child/2019/11/08/nio-netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/child/2019/11/08/nio-netty源码分析之异步编程/</id>
    <published>2019-11-07T16:00:00.000Z</published>
    <updated>2020-06-29T10:44:55.022Z</updated>
    
    <content type="html"><![CDATA[<h4 id="netty的异步编程模型"><a href="#netty的异步编程模型" class="headerlink" title="netty的异步编程模型"></a>netty的异步编程模型</h4><p>异步编程的目标是：提交一个任务给线程池，在任务执行期间，提交者可以执行其他的逻辑，当提交的任务执行完成，通知提交者来获取执行结果</p><p>netty 异步任务的实现Future/Promise异步模型，</p><p>模型定义了几个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">concurrent</span>.<span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSuccess</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isCancellable</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Throwable <span class="title">cause</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Future&lt;V&gt; <span class="title">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt; listener)</span></span>;</span><br><span class="line">  <span class="function">Future&lt;V&gt; <span class="title">addListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt;... listeners)</span></span>;</span><br><span class="line">  <span class="function">Future&lt;V&gt; <span class="title">removeListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt; listener)</span></span>;</span><br><span class="line">  <span class="function">Future&lt;V&gt; <span class="title">removeListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt;... listeners)</span></span>;</span><br><span class="line">  <span class="function">Future&lt;V&gt; <span class="title">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  <span class="function">Future&lt;V&gt; <span class="title">syncUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Future&lt;V&gt; <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  <span class="function">Future&lt;V&gt; <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">awaitUninterruptibly</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">awaitUninterruptibly</span><span class="params">(<span class="keyword">long</span> timeoutMillis)</span></span>;</span><br><span class="line">  <span class="function">V <span class="title">getNow</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelFuture</span> <span class="keyword">extends</span> <span class="title">Future</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">Channel <span class="title">channel</span><span class="params">()</span></span>; <span class="comment">// 实现类需要持有channel引用</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isVoid</span><span class="params">()</span></span>; <span class="comment">// 如果该实现类是一个Future&lt;Void&gt; </span></span><br><span class="line">  <span class="function">ChannelFuture <span class="title">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> Void&gt;&gt; listener)</span></span>;</span><br><span class="line">  <span class="function">ChannelFuture <span class="title">addListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> Void&gt;&gt;... listeners)</span></span>;</span><br><span class="line">  <span class="function">ChannelFuture <span class="title">removeListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> Void&gt;&gt; listener)</span></span>;</span><br><span class="line">  <span class="function">ChannelFuture <span class="title">removeListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> Void&gt;&gt;... listeners)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isSuccess</span><span class="params">()</span></span>; <span class="comment">// 当且仅当io操作成功返回true</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isCancellable</span><span class="params">()</span></span>; <span class="comment">// 当且仅当io操作被cancel方法取消，返回true</span></span><br><span class="line">  <span class="function">ChannelFuture <span class="title">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>; <span class="comment">// 等待这个future直到它完成为止，如果future失败，则重新抛出失败的原因。</span></span><br><span class="line">  <span class="function">ChannelFuture <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;<span class="comment">// 等待这个future的完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Promise</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">Promise&lt;V&gt; <span class="title">setSuccess</span><span class="params">(V result)</span></span>;<span class="comment">// 标记此futrue成功，并通知所有的监听器</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">trySuccess</span><span class="params">(V result)</span></span>;<span class="comment">//标记此futrue成功，并通知所有的监听器，当且仅当成功返回true</span></span><br><span class="line">  <span class="function">Promise&lt;V&gt; <span class="title">setFailure</span><span class="params">(Throwable cause)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">tryFailure</span><span class="params">(Throwable cause)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">setUncancellable</span><span class="params">()</span></span>; <span class="comment">// 标记此futrue不可取消，如果这该futrue已取消，返回false</span></span><br><span class="line">  <span class="function">Promise&lt;V&gt; <span class="title">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt; listener)</span></span>;</span><br><span class="line">  <span class="function">Promise&lt;V&gt; <span class="title">addListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt;... listeners)</span></span>;</span><br><span class="line">  <span class="function">Promise&lt;V&gt; <span class="title">removeListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt; listener)</span></span>;</span><br><span class="line">  <span class="function">Promise&lt;V&gt; <span class="title">removeListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt;... listeners)</span></span>;</span><br><span class="line">  <span class="function">Promise&lt;V&gt; <span class="title">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  <span class="function">Promise&lt;V&gt; <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelPromise</span> <span class="keyword">extends</span> <span class="title">ChannelFuture</span>, <span class="title">Promise</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Channel <span class="title">channel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">ChannelPromise <span class="title">setSuccess</span><span class="params">(Void result)</span></span>;</span><br><span class="line">    <span class="function">ChannelPromise <span class="title">setSuccess</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">trySuccess</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">ChannelPromise <span class="title">setFailure</span><span class="params">(Throwable cause)</span></span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">ChannelPromise <span class="title">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> Void&gt;&gt; listener)</span></span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">ChannelPromise <span class="title">addListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> Void&gt;&gt;... listeners)</span></span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">ChannelPromise <span class="title">removeListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> Void&gt;&gt; listener)</span></span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">ChannelPromise <span class="title">removeListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> Void&gt;&gt;... listeners)</span></span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">ChannelPromise <span class="title">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">ChannelPromise <span class="title">syncUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">ChannelPromise <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">ChannelPromise <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a new &#123;<span class="doctag">@link</span> ChannelPromise&#125; if &#123;<span class="doctag">@link</span> #isVoid()&#125; returns &#123;<span class="doctag">@code</span> true&#125; otherwise itself.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ChannelPromise <span class="title">unvoid</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ChannelFutureListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelFutureListener</span> <span class="keyword">extends</span> <span class="title">GenericFutureListener</span>&lt;<span class="title">ChannelFuture</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    ChannelFutureListener CLOSE = <span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> </span>&#123;</span><br><span class="line">            future.channel().close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ChannelFutureListener CLOSE_ON_FAILURE = <span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                future.channel().close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ChannelFutureListener FIRE_EXCEPTION_ON_FAILURE = <span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                future.channel().pipeline().fireExceptionCaught(future.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericFutureListener</span>&lt;<span class="title">F</span> <span class="keyword">extends</span> <span class="title">Future</span>&lt;?&gt;&gt; <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(F future)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要创建一个ChannelPromise，需要提供一个channel和处理该channel上事件的Executor，例如注册一个channel时，创建一个<code>DefaultChannelPromise</code>，里面包装了即将注册的channel和即将执行注册操作的Executor：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> register(<span class="keyword">new</span> DefaultChannelPromise(channel, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(promise, <span class="string">"promise"</span>);</span><br><span class="line">    promise.channel().unsafe().register(<span class="keyword">this</span>, promise);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成注册操作之后返回这个promise，注意返回值类型是<code>ChannelFuture</code>，<code>DefaultChannelPromise</code>向上转型成 <code>ChannelFuture</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line">        doRegister();</span><br><span class="line">        neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">        registered = <span class="keyword">true</span>;     </span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line">        safeSetSuccess(promise); <span class="comment">// &gt;&gt;</span></span><br><span class="line">        pipeline.fireChannelRegistered();       </span><br><span class="line">        <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;               </span><br><span class="line">                beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        closeForcibly();</span><br><span class="line">        closeFuture.setClosed();</span><br><span class="line">        safeSetFailure(promise, t);  <span class="comment">// &gt;&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要看这两个方法：<code>safeSetSuccess</code>和<code>safeSetFailure</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">safeSetSuccess</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(promise <span class="keyword">instanceof</span> VoidChannelPromise) &amp;&amp; !promise.trySuccess()) &#123;</span><br><span class="line">        logger.warn(<span class="string">"Failed to mark a promise as success because it is done already: &#123;&#125;"</span>, promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">safeSetFailure</span><span class="params">(ChannelPromise promise, Throwable cause)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(promise <span class="keyword">instanceof</span> VoidChannelPromise) &amp;&amp; !promise.tryFailure(cause)) &#123;</span><br><span class="line">        logger.warn(<span class="string">"Failed to mark a promise as failure because it's done already: &#123;&#125;"</span>, promise, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>trySuccess</code>会通知所有的监听器，跟一下调用链：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">trySuccess</span><span class="params">(V result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> setSuccess0(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setSuccess0</span><span class="params">(V result)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> setValue0(result == <span class="keyword">null</span> ? SUCCESS : result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setValue0</span><span class="params">(Object objResult)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">       notifyListeners();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        notifyListenersNow();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">      safeExecute(executor, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            notifyListenersNow();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在往下就是调用具体的监听器方法<code>operationComplete(future)</code></p><p>此处需要注意的是，<code>DefaultPromise</code>中保存监听器的字段是<code>private Object listeners</code>，它是一个object引用，当我们之添加了一个监听器的时候，该引用是<code>GenericFutureListener</code>类型的，当大于一个监听器被添加到这个promise中，该引用就是<code>DefaultFutureListeners</code>类型了，此类型维护了一个监听器数组。这样处理的原因是为了性能考虑，因为大多数时候我们只会添加一个监听器。看一下add函数更一目了然·</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addListener0</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt; listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (listeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">        listeners = listener;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (listeners <span class="keyword">instanceof</span> DefaultFutureListeners) &#123;</span><br><span class="line">        ((DefaultFutureListeners) listeners).add(listener);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        listeners = <span class="keyword">new</span> DefaultFutureListeners((GenericFutureListener&lt;?&gt;) listeners, listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>netty的异步响应处理的是多线程之间的任务，最终也没有超出虚拟机的层面，还有一种异步编程，节点与节点之间的异步响应，比如向消息中间件服务器发送异步消息</p><h4 id="rocketMq的异步消息发送"><a href="#rocketMq的异步消息发送" class="headerlink" title="rocketMq的异步消息发送"></a>rocketMq的异步消息发送</h4><p>rocket mq 底层使用netty实现客户端与服务器之间的通信，使用rocketmq原生的api异步发送一条消息：消息msg发送出去之后立即返回，当服务器响应到达时，mq客户端会通过异步编程处理最终调用到SendCallback中的方法，消息发送成功调用<code>onSuccess()</code>，否则调用<code>onException()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">producer.send(msg, <span class="keyword">new</span> SendCallback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"%s%n"</span> ,sendResult);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>接下来我将跟一下源码，分析一下这里是怎么实现客户端与服务器之间的异步通信的；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultMQProducer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">    SendCallback sendCallback)</span> <span class="keyword">throws</span> MQClientException, RemotingException, InterruptedException </span>&#123;</span><br><span class="line">    msg.setTopic(withNamespace(msg.getTopic()));</span><br><span class="line">    <span class="keyword">this</span>.defaultMQProducerImpl.send(msg, sendCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultMQProducerImpl</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">    SendCallback sendCallback)</span> <span class="keyword">throws</span> MQClientException, RemotingException, InterruptedException </span>&#123;</span><br><span class="line">    send(msg, sendCallback, <span class="keyword">this</span>.defaultMQProducer.getSendMsgTimeout());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultMQProducerImpl</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">final</span> Message msg, <span class="keyword">final</span> MessageQueue mq, <span class="keyword">final</span> SendCallback sendCallback, <span class="keyword">final</span> <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> MQClientException, RemotingException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> beginStartTime = System.currentTimeMillis();</span><br><span class="line">    ExecutorService executor = <span class="keyword">this</span>.getAsyncSenderExecutor();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        executor.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    makeSureStateOK();</span><br><span class="line">                    Validators.checkMessage(msg, defaultMQProducer);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!msg.getTopic().equals(mq.getTopic())) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"message's topic not equal mq's topic"</span>, <span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">long</span> costTime = System.currentTimeMillis() - beginStartTime;</span><br><span class="line">                    <span class="keyword">if</span> (timeout &gt; costTime) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            sendKernelImpl(msg, mq, CommunicationMode.ASYNC, sendCallback, <span class="keyword">null</span>,</span><br><span class="line">                                timeout - costTime);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (MQBrokerException e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"unknown exception"</span>, e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        sendCallback.onException(<span class="keyword">new</span> RemotingTooMuchRequestException(<span class="string">"call timeout"</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    sendCallback.onException(e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"executor rejected "</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;netty的异步编程模型&quot;&gt;&lt;a href=&quot;#netty的异步编程模型&quot; class=&quot;headerlink&quot; title=&quot;netty的异步编程模型&quot;&gt;&lt;/a&gt;netty的异步编程模型&lt;/h4&gt;&lt;p&gt;异步编程的目标是：提交一个任务给线程池，在任务执行期间，提交
      
    
    </summary>
    
      <category term="I/O和网络编程" scheme="http://yoursite.com/child/categories/I-O%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="netty" scheme="http://yoursite.com/child/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>netty源码分析之线程模型</title>
    <link href="http://yoursite.com/child/2019/11/01/nio-netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/child/2019/11/01/nio-netty源码分析之线程模型/</id>
    <published>2019-10-31T16:00:00.000Z</published>
    <updated>2020-06-28T09:11:27.301Z</updated>
    
    <content type="html"><![CDATA[<p>一个NioEventLoop对应于Reactor模型中的一个从Reactor线程，它持有一个Thread引用，可以简单将NioEventLoop理解为一个用于处理channel事件的线程。</p><p>一个channel上的事件只能被同一个线程处理，NioEventLoop线程对channel事件的处理是一个串行化无锁执行过程，我们在初始化channel的时候在pipeline中添加了一系列的Handler（编解码、数据处理等），这些Handler的处理需要遵循一个固定的顺序，netty底层使用同一个线程按照这个顺序串行执行，避免了多个线程处理同一个channel需要使用锁同步产生的开销，这叫<strong>串行化无锁编程</strong></p><p>一个NioEventLoop可以处理多个channel的就绪事件，即同一个nio线程可以处理多条连接的请求，这叫<strong>多路复用</strong></p><h4 id="Channel指定evenloop"><a href="#Channel指定evenloop" class="headerlink" title="Channel指定evenloop"></a>Channel指定evenloop</h4><p>Channel的EventLoop是在注册的时候指定的，netty服务器启动时，首先会注册一个ServerChannel，该注册工作由Boss线程池完成，通常Boss线程池中值有一个线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractBootstrap</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>group().register(channel)</code>在boss线程池中注册Channel，boss线程池调用<code>next()</code>方法获取一个EventLoop对象来注册channel，看下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MultithreadEventLoopGroup</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture  <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> next().register(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>next方法获取到一个<code>EventLoop</code>对象之后，再调用<code>SingleThreadEventLoop</code>类的注册方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SingleThreadEventLoop</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(promise, <span class="string">"promise"</span>);</span><br><span class="line">    promise.channel().unsafe().register(<span class="keyword">this</span>, promise);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终会调用channel的unsafe对象完成注册，并在此时将this EventLoop 作为参数传进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractChannel.AbstractUnsafe</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册的时候完成了eventLoop的指定。</p><p>总结一下：</p><p>以上分析的是ServerChannel注册时指定EventLoop的过程，这个过程只会在服务启动的时候进行，而在服务运行期间，会不断的有新连接接入，每个新连接都需要注册到一个selector上，这是nio编程的规则。</p><p>所以服务启动程序创建的childGroup中的每个线程都持有一个selector的，新连接的注册过程，就是从childGroup中选取一个EventLoop对象，然后将新连接注册到该对象的selector上，再指定新连接channel的EventLoop为当前选取的的实例。</p><h4 id="reactor线程启动"><a href="#reactor线程启动" class="headerlink" title="reactor线程启动"></a>reactor线程启动</h4><p>netty对于线程的创建采取的懒加载模式，第一次提交任务的时候才会创建线程。</p><p>NioServerSocketChannel 第一次提交任务，也是在<strong>注册</strong>的时候</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractChannel.AbstractUnsafe</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop; <span class="comment">// 刚指定了channel的eventLoop</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123; <span class="comment">// 还是主线程在执行，返回false</span></span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">//来到这里提交注册任务</span></span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>eventLoop.execute()</code>可以向NioEventLoop中提交一个任务，这个方法继承自父类SingleThreadEventExecutor </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SingleThreadEventExecutor </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task, <span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断当前线程是不是this对象的线程</span></span><br><span class="line">    <span class="comment">// 还是主线程在执行，返回false</span></span><br><span class="line">    <span class="keyword">boolean</span> inEventLoop = inEventLoop();</span><br><span class="line">    <span class="comment">//将task加入EventLoop持有的任务队列</span></span><br><span class="line">    addTask(task);</span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop) &#123;</span><br><span class="line">      <span class="comment">//如果执行此代码的线程不是eventloop线程，创建新线程并启动</span></span><br><span class="line">      startThread();</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进<code>startThread()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SingleThreadEventExecutor </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (state == ST_NOT_STARTED) &#123;</span><br><span class="line">    <span class="keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;</span><br><span class="line">      <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        doStartThread();</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继续跟进     </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 创建新线程</span></span><br><span class="line">    executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 设置eventLoop持有线程为执行这段代码的线程</span></span><br><span class="line">            thread = Thread.currentThread();</span><br><span class="line">            ...</span><br><span class="line">            SingleThreadEventExecutor.<span class="keyword">this</span>.run();</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再调用了<code>doStartThread</code>方法，这个方法是启动线程的核心逻辑了，在执行<code>doStartThread</code>的时候，会调用eventLoop内部的一个用于<strong>新建线程的执行器</strong><code>execute()</code>方法，注意与上面的区别，此执行器默认为<code>ThreadPerTaskExecutor</code>类型，创建新线程后将NioEventLoop的主体逻辑<code>run()</code>提交进去，并启动。</p><p>ThreadPerTaskExecutor 在每次执行execute 方法的时候都会通过DefaultThreadFactory创建一个FastThreadLocalThread线程，而这个线程就是netty中的reactor线程实体，创建线程源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory threadFactory;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPerTaskExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = ObjectUtil.checkNotNull(threadFactory, <span class="string">"threadFactory"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        threadFactory.newThread(command).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下：</p><ol><li>我们在new一个NioEventLoopGroup的时候，它会持有一个NioEventLoop数组，数组中每个NioEventLoop元素对象会持有一个Thread引用，就是reactor线程本体了。 </li><li>netty对于线程的初始化采取的懒加载模式，当我们没有用到某个NioEventLoop时，它的线程是不会被创建出来的。</li><li>当我们通过<code>group().next()</code>获取到一个NioEventLoop，并向其提交任务，这时就会触发线程的创建-任务提交-启动。创建是通过 ThreadPerTaskExecutor 和 DefaultThreadFactory 两个类执行的，新线程执行的任务是 NioEventLoop 的主体逻辑run方法。</li></ol><h4 id="2、reactor线程执行"><a href="#2、reactor线程执行" class="headerlink" title="2、reactor线程执行"></a>2、reactor线程执行</h4><p>回到主线逻辑中，创建的线程中执行了<code>SingleThreadEventExecutor.this.run();</code>即reactor线程的主体逻辑，贴一下主要代码片段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ...</span><br><span class="line">        strategy = select(curDeadlineNanos);</span><br><span class="line">        ...</span><br><span class="line">        processSelectedKeys();</span><br><span class="line">        ...     </span><br><span class="line">        ranTasks = runAllTasks(<span class="number">0</span>); </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法内部是一个无限循环，一旦启动将一直运行。</p><p>从以上代码中可以看出，线程一直在循环做三件事情</p><ol><li>执行select</li><li>处理就绪的channel</li><li>执行任务队列中的任务</li></ol><p>此处的源代码很长，下面我将分三个步骤分析run函数的主要流程</p><h5 id="2-1-select阶段"><a href="#2-1-select阶段" class="headerlink" title="2.1 select阶段"></a>2.1 select阶段</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> selectCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> strategy;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());</span><br><span class="line">                <span class="keyword">switch</span> (strategy) &#123;</span><br><span class="line">                <span class="comment">// hasTask 时continue</span></span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 由于NIO不支持忙碌等待，因此要选择跳过</span></span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.BUSY_WAIT:</span><br><span class="line">                <span class="comment">// 当没有可调度任务时 strategy = SelectStrategy.SELECT</span></span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">                    <span class="comment">// 获取现在到下一个计划任务调度执行之间的时间，没有定时任务返回-1</span></span><br><span class="line">                    <span class="keyword">long</span> curDeadlineNanos = nextScheduledTaskDeadlineNanos();</span><br><span class="line">                    <span class="keyword">if</span> (curDeadlineNanos == -<span class="number">1L</span>) &#123;</span><br><span class="line">                        <span class="comment">//NONE 是Integer.maxValue</span></span><br><span class="line">                        curDeadlineNanos = NONE;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 设定原子量</span></span><br><span class="line">                    nextWakeupNanos.set(curDeadlineNanos);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!hasTasks()) &#123;</span><br><span class="line">                            strategy = select(curDeadlineNanos);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// fall through</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// select计数器+1</span></span><br><span class="line">            selectCnt++;</span><br><span class="line">            ...</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看<code>strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());</code>这句，netty会根据任务队列的情况执行相应的select操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultSelectStrategy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateStrategy</span><span class="params">(IntSupplier selectSupplier, <span class="keyword">boolean</span> hasTasks)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hasTasks ? selectSupplier.get() : SelectStrategy.SELECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>hasTasks()</code>返回true表明当前的任务队列中有需要执行的任务，会执行<code>selectSupplier.get()</code>，那么selectSupplier是什么呢？定位到该成员变量的初始化代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NioEventLoop</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> IntSupplier selectNowSupplier = <span class="keyword">new</span> IntSupplier() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> selectNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">selectNow</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> selector.selectNow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里我就可以得出结论了，strategy的初始化逻辑是：<strong><em>当任务队列hasTasks时selectNow，返回就绪数量，否则返回SelectStrategy.SELECT</em></strong>。</p><p>当<code>strategy=SelectStrategy.SELECT</code>时，获取现在到下一个计划任务调度执行之间的时间<code>curDeadlineNanos</code>，在这段时间内执行<code>strategy=select(curDeadlineNanos)</code></p><p>当<code>strategy</code>为正数，说明select到了就绪事件，此时将继续往下执行，进入处理阶段。</p><p>思考：<code>SelectStrategy.CONTINUE</code>是哪种情况时设置的?</p><h5 id="2-2-处理阶段"><a href="#2-2-处理阶段" class="headerlink" title="2.2 处理阶段"></a>2.2 处理阶段</h5><p>在处理就绪事件的过程中，netty对io时间和cpu时间做了统计，并根据不同情况动态调整io和cpu执行的时间占比：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io时间所占比例，初始值为50</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio;</span><br><span class="line"><span class="keyword">boolean</span> ranTasks;</span><br><span class="line"><span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (strategy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 就绪数量大于0，处理selectedKeys，这里的处理属于io处理</span></span><br><span class="line">            processSelectedKeys();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// io时间占比达到100% 将一直执行runAllTasks 这里的处理属于cpu处理</span></span><br><span class="line">        <span class="comment">// 执行所有任务，当且仅当最后一个任务被执行 返回 true</span></span><br><span class="line">        ranTasks = runAllTasks();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (strategy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      processSelectedKeys();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">      <span class="comment">// 由于ioRatio = 50 所以运行runAllTasks时间与上面处理io时间一致</span></span><br><span class="line">      <span class="comment">// 当执行时间超出了指定事件，返回 true</span></span><br><span class="line">      ranTasks = runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ranTasks = runAllTasks(<span class="number">0</span>); <span class="comment">// This will run the minimum number of tasks，默认是64个任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理阶段不仅仅是对执行时间进行了细粒度的优化，在处理过程中也是尽可能的考虑到了执行效率，继续往下分析处理逻辑，也就是<code>processSelectedKeys()</code>方法，贴上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NioEventLoop</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里做的优化，主要是使用netty 自定义的selectedKeys对象 通过反射的方式替换掉jdk原生selector中的 selectedKeySet字段属性</span></span><br><span class="line">    <span class="comment">// 自定义的keyset 使用数组存放selectedKeys，原生的使用HashSet，主要优化的是检索性能</span></span><br><span class="line">    <span class="comment">// 替换过程 见本类的openSelector方法</span></span><br><span class="line">    <span class="keyword">if</span> (selectedKeys != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 优化过的处理 一般会进这里</span></span><br><span class="line">        processSelectedKeysOptimized();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 正常处理</span></span><br><span class="line">        processSelectedKeysPlain(selector.selectedKeys());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对优化过的selectedKeys的处理稍微展开一下，看看netty是如何优化的，我们查看 <code>selectedKeys</code> 被引用过的地方，有如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SelectorTuple <span class="title">openSelector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> SelectedSelectionKeySet selectedKeySet = <span class="keyword">new</span> SelectedSelectionKeySet();</span><br><span class="line"></span><br><span class="line">    Object maybeException = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Field selectedKeysField = selectorImplClass.getDeclaredField(<span class="string">"selectedKeys"</span>);</span><br><span class="line">                Field publicSelectedKeysField = selectorImplClass.getDeclaredField(<span class="string">"publicSelectedKeys"</span>);</span><br><span class="line">...</span><br><span class="line">                Throwable cause = ReflectionUtil.trySetAccessible(selectedKeysField, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> cause;</span><br><span class="line">                &#125;</span><br><span class="line">                cause = ReflectionUtil.trySetAccessible(publicSelectedKeysField, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> cause;</span><br><span class="line">                &#125;</span><br><span class="line">                selectedKeysField.set(unwrappedSelector, selectedKeySet);</span><br><span class="line">                publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  ...</span><br><span class="line">    selectedKeys = selectedKeySet;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，selectedKeys是一个 <code>SelectedSelectionKeySet</code> 类对象，在<code>NioEventLoop</code> 的 <code>openSelector</code> 方法中创建，之后就通过反射将selectedKeys与 <code>sun.nio.ch.SelectorImpl</code> 中的两个field绑定</p><p><code>sun.nio.ch.SelectorImpl</code> 中我们可以看到，这两个field其实是两个HashSet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectorImpl</span> <span class="keyword">extends</span> <span class="title">AbstractSelector</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// Public views of the key sets</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;SelectionKey&gt; publicKeys;             <span class="comment">// Immutable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;SelectionKey&gt; publicSelectedKeys;     <span class="comment">// Removal allowed, but not addition</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">SelectorImpl</span><span class="params">(SelectorProvider sp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(sp);</span><br><span class="line">        keys = ConcurrentHashMap.newKeySet();</span><br><span class="line">        selectedKeys = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        publicKeys = Collections.unmodifiableSet(keys);</span><br><span class="line">        publicSelectedKeys = Util.ungrowableSet(selectedKeys);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>selector在调用<code>select()</code>族方法的时候，如果有IO事件发生，就会往里面的两个field中塞相应的<code>selectionKey</code>(具体怎么塞有待研究)，即相当于往一个hashSet中add元素，既然netty通过反射将jdk中的两个field替换掉，那我们就应该意识到是不是netty自定义的<code>SelectedSelectionKeySet</code>在<code>add</code>方法做了某些优化呢？</p><p>带着这个疑问，我们进入到 <code>SelectedSelectionKeySet</code> 类中探个究竟</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectedSelectionKeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">SelectionKey</span>&gt; </span>&#123;</span><br><span class="line">    SelectionKey[] keys;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    SelectedSelectionKeySet() &#123;</span><br><span class="line">        keys = <span class="keyword">new</span> SelectionKey[<span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(SelectionKey o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        keys[size++] = o;</span><br><span class="line">        <span class="keyword">if</span> (size == keys.length) &#123;</span><br><span class="line">            increaseCapacity();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类其实很简单，继承了 <code>AbstractSet</code>，说明该类可以当作一个set来用，但是底层使用一个数据来存放selectedKey，在<code>add</code>方法中经历下面三个步骤<br> 1.将SelectionKey塞到该数组的逻辑尾部<br> 2.更新该数组的逻辑长度+1<br> 3.如果该数组的逻辑长度等于数组的物理长度，就将该数组扩容</p><p>我们可以看到，待程序跑过一段时间，等数组的长度足够长，每次在轮询到nio事件的时候，netty只需要O(1)的时间复杂度就能将 <code>SelectionKey</code> 塞到 set中去，而jdk底层使用的hashSet需要O(lgn)的时间复杂度</p><p>关于netty对<code>SelectionKeySet</code>的优化我们暂时就跟这么多，下面我们继续跟netty对IO事件的处理，转到<code>processSelectedKeysOptimized</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeysOptimized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; selectedKeys.size; ++i) &#123;</span><br><span class="line">        <span class="keyword">final</span> SelectionKey k = selectedKeys.keys[i];</span><br><span class="line">        <span class="comment">// 手动置空 gc</span></span><br><span class="line">        selectedKeys.keys[i] = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// SelectionKey中附件了channel的引用</span></span><br><span class="line">        <span class="keyword">final</span> Object a = k.attachment();</span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) &#123;</span><br><span class="line">            processSelectedKey(k, (AbstractNioChannel) a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;</span><br><span class="line">            processSelectedKey(k, task);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// needsToSelectAgain 默认为false 在本类的cancel方法中，当连接取消次数达到256 被设置为true</span></span><br><span class="line">        <span class="comment">// cancel方法 最终是在 AbstractNioChannel 类的 doDeregister 方法中被调用，调用一次取消连接数+1</span></span><br><span class="line">        <span class="keyword">if</span> (needsToSelectAgain) &#123;</span><br><span class="line">            <span class="comment">// reset将selectedKeys中未处理的所有key手动置空</span></span><br><span class="line">            selectedKeys.reset(i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//重新select</span></span><br><span class="line">            selectAgain();</span><br><span class="line">            i = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-执行队列任务"><a href="#2-3-执行队列任务" class="headerlink" title="2.3 执行队列任务"></a>2.3 执行队列任务</h5><p>netty中的task的常见使用场景：</p><ul><li>用户自定义普通任务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ctx.channel().eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们跟进<code>execute</code>方法，看重点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    addTask(task);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>execute</code>方法调用 <code>addTask</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (!offerTask(task)) &#123;</span><br><span class="line">        reject(task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用<code>offerTask</code>方法，如果offer失败，那就调用<code>reject</code>方法，通过默认的 <code>RejectedExecutionHandler</code> 直接抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">offerTask</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> taskQueue.offer(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟到<code>offerTask</code>方法，基本上task就落地了，netty内部使用一个<code>taskQueue</code>将task保存起来，那么这个<code>taskQueue</code>又是何方神圣？</p><p>我们查看 <code>taskQueue</code> 定义的地方和被初始化的地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Runnable&gt; taskQueue;</span><br><span class="line"></span><br><span class="line">taskQueue = newTaskQueue(<span class="keyword">this</span>.maxPendingTasks);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Queue&lt;Runnable&gt; <span class="title">newTaskQueue</span><span class="params">(<span class="keyword">int</span> maxPendingTasks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(maxPendingTasks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现 <code>taskQueue</code>在NioEventLoop中默认是阻塞队列，老版本（4.1.6）中使用mpsc队列，即多生产者单消费者队列，netty使用mpsc，方便的将外部线程的task聚集，在reactor线程内部用单线程来串行执行，此处为什么要做此改变？</p><p>在本节讨论的任务场景中，所有代码的执行都是在reactor线程中的，所以，所有调用 <code>inEventLoop()</code> 的地方都返回true，既然都是在reactor线程中执行，那么其实这里的阻塞队列其实没有发挥真正的作用。</p><ul><li>非当前reactor线程调用channel的各种方法</li></ul><p>这种情况在push系统中比较常见，一般在业务线程里面，根据用户的标识，找到对应的channel引用，然后调用write类方法向该用户推送消息，就会进入到这种场景</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// non reactor thread</span></span><br><span class="line">channel.write(...)</span><br></pre></td></tr></table></figure><p>关于channel.write()类方法的调用链，后面会单独拉出一篇文章来深入剖析，这里，我们只需要知道，最终write方法串至以下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, <span class="keyword">boolean</span> flush, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">            next.invokeWriteAndFlush(m, promise);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.invokeWrite(m, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        AbstractWriteTask task;</span><br><span class="line">        <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">            task = WriteAndFlushTask.newInstance(next, m, promise);</span><br><span class="line">        &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">            task = WriteTask.newInstance(next, m, promise);</span><br><span class="line">        &#125;</span><br><span class="line">        safeExecute(executor, task, promise, m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>外部线程在调用<code>write</code>的时候，<code>executor.inEventLoop()</code>会返回false，直接进入到else分支，将write封装成一个<code>WriteTask</code>（这里仅仅是write而没有flush，因此<code>flush</code>参数为false）, 然后调用 <code>safeExecute</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">safeExecute</span><span class="params">(EventExecutor executor, Runnable runnable, ChannelPromise promise, Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    executor.execute(runnable);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来的调用链就进入到第一种场景了，但是和第一种场景有个明显的区别就是，第一种场景的调用链的发起线程是reactor线程，第二种场景的调用链的发起线程是用户线程，用户线程可能会有很多个，显然多个线程并发写<code>taskQueue</code>可能出现线程同步问题，此时阻塞队列的作用展现出来了。</p><ul><li>用户自定义定时任务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ctx.channel().eventLoop().schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">60</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>第三种场景就是定时任务逻辑了，用的最多的便是如上方法：在一定时间之后执行任务</p><p>我们跟进<code>schedule</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="keyword">long</span> delay, TimeUnit unit) &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> schedule(<span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(</span><br><span class="line">            <span class="keyword">this</span>, command, <span class="keyword">null</span>, ScheduledFutureTask.deadlineNanos(unit.toNanos(delay))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>ScheduledFutureTask</code>, 将用户自定义任务再次包装成一个netty内部的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(<span class="keyword">final</span> ScheduledFutureTask&lt;V&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    scheduledTaskQueue().add(task);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了这里，我们有点似曾相识，在非定时任务的处理中，netty通过一个阻塞队列将任务落地，这里，是否也有一个类似的队列来承载这类定时任务呢？带着这个疑问，我们继续向前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">Queue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue() &#123;</span><br><span class="line">    <span class="keyword">if</span> (scheduledTaskQueue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        scheduledTaskQueue = <span class="keyword">new</span> DefaultPriorityQueue&lt;ScheduledFutureTask&lt;?&gt;&gt;(</span><br><span class="line">                    SCHEDULED_FUTURE_TASK_COMPARATOR,</span><br><span class="line">                    <span class="comment">// Use same initial capacity as java.util.PriorityQueue</span></span><br><span class="line">                    <span class="number">11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> scheduledTaskQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>果不其然，<code>scheduledTaskQueue()</code> 方法，会返回一个优先级队列，然后调用 <code>add</code> 方法将定时任务加入到队列中去，但是，这里为什么要使用优先级队列，而不需要考虑多线程的并发？</p><p>因为我们现在讨论的场景，调用链的发起方是reactor线程，不会存在多线程并发这些问题</p><p>但是，万一有的用户在reactor之外执行定时任务呢？虽然这类场景很少见，但是netty作为一个无比健壮的高性能io框架，必须要考虑到这种情况。</p><p>对此，netty的处理是，如果是在外部线程调用schedule，netty将添加定时任务的逻辑封装成一个普通的task，这个task的任务是添加[添加定时任务]的任务，而不是添加定时任务，其实也就是第二种场景，这样，对 <code>PriorityQueue</code>的访问就变成单线程，即只有reactor线程</p><blockquote><p>完整的schedule方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(<span class="keyword">final</span> ScheduledFutureTask&lt;V&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inEventLoop()) &#123;</span><br><span class="line">        scheduledTaskQueue().add(task);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 进入到场景二，进一步封装任务</span></span><br><span class="line">        execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                scheduledTaskQueue().add(task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在阅读源码细节的过程中，我们应该多问几个为什么？这样会有利于看源码的时候不至于犯困！比如这里，为什么定时任务要保存在优先级队列中，我们可以先不看源码，来思考一下优先级对列的特性</p><p>优先级队列按一定的顺序来排列内部元素，内部元素必须是可以比较的，联系到这里每个元素都是定时任务，那就说明定时任务是可以比较的，那么到底有哪些地方可以比较？</p><p>每个任务都有一个下一次执行的截止时间，截止时间是可以比较的，截止时间相同的情况下，任务添加的顺序也是可以比较的，就像这样，阅读源码的过程中，一定要多和自己对话，多问几个为什么</p><p>带着猜想，我们研究与一下<code>ScheduledFutureTask</code>，抽取出关键部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledFutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">PromiseTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ScheduledFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextTaskId = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> START_TIME = System.nanoTime();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">nanoTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.nanoTime() - START_TIME;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = nextTaskId.getAndIncrement();</span><br><span class="line">    <span class="comment">/* 0 - no repeat, &gt;0 - repeat at fixed rate, &lt;0 - repeat with fixed delay */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> periodNanos;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 精简过的代码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里，我们一眼就找到了<code>compareTo</code> 方法，<code>cmd+u</code>跳转到实现的接口，发现就是<code>Comparable</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ScheduledFutureTask&lt;?&gt; that = (ScheduledFutureTask&lt;?&gt;) o;</span><br><span class="line">    <span class="keyword">long</span> d = deadlineNanos() - that.deadlineNanos();</span><br><span class="line">    <span class="keyword">if</span> (d &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id &lt; that.id) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == that.id) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入到方法体内部，我们发现，两个定时任务的比较，确实是先比较任务的截止时间，截止时间相同的情况下，再比较id，即任务添加的顺序，如果id再相同的话，就抛Error</p><p>这样，在执行定时任务的时候，就能保证最近截止时间的任务先执行</p><p>下面，我们再来看下netty是如何来保证各种定时任务的执行的，netty里面的定时任务分以下三种</p><p>1.若干时间后执行一次<br> 2.每隔一段时间执行一次<br> 3.每次执行结束，隔一定时间再执行一次</p><p>netty使用一个 <code>periodNanos</code> 来区分这三种情况，正如netty的注释那样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 0 - no repeat, &gt;0 - repeat at fixed rate, &lt;0 - repeat with fixed delay */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> periodNanos;</span><br></pre></td></tr></table></figure><p>了解这些背景之后，我们来看下netty是如何来处理这三种不同类型的定时任务的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (periodNanos == <span class="number">0</span>) &#123;</span><br><span class="line">        V result = task.call();</span><br><span class="line">        setSuccessInternal(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        task.call();</span><br><span class="line">        <span class="keyword">long</span> p = periodNanos;</span><br><span class="line">        <span class="keyword">if</span> (p &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            deadlineNanos += p;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            deadlineNanos = nanoTime() - p;</span><br><span class="line">        &#125;</span><br><span class="line">            scheduledTaskQueue.add(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>if (periodNanos == 0)</code> 对应 <code>若干时间后执行一次</code> 的定时任务类型，执行完了该任务就结束了。</p><p>否则，进入到else代码块，先执行任务，然后再区分是哪种类型的任务，<code>periodNanos</code>大于0，表示是以固定频率执行某个任务，和任务的持续时间无关，然后，设置该任务的下一次截止时间为本次的截止时间加上间隔时间<code>periodNanos</code>，否则，就是每次任务执行完毕之后，间隔多长时间之后再次执行，截止时间为当前时间加上间隔时间，<code>-p</code>就表示加上一个正的间隔时间，最后，将当前任务对象再次加入到队列，实现任务的定时执行</p><p>netty内部的任务添加机制了解地差不多之后，我们就可以查看reactor第三部曲是如何来调度这些任务的</p><p><a href="https://www.jianshu.com/p/0d0eece6d467" target="_blank" rel="noopener">https://www.jianshu.com/p/0d0eece6d467</a></p><p><a href="https://www.jianshu.com/p/467a9b41833e" target="_blank" rel="noopener">https://www.jianshu.com/p/467a9b41833e</a></p><p><a href="https://www.jianshu.com/p/58fad8e42379" target="_blank" rel="noopener">https://www.jianshu.com/p/58fad8e42379</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个NioEventLoop对应于Reactor模型中的一个从Reactor线程，它持有一个Thread引用，可以简单将NioEventLoop理解为一个用于处理channel事件的线程。&lt;/p&gt;
&lt;p&gt;一个channel上的事件只能被同一个线程处理，NioEventLoo
      
    
    </summary>
    
      <category term="I/O和网络编程" scheme="http://yoursite.com/child/categories/I-O%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="netty" scheme="http://yoursite.com/child/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>epoll高效运行的原理</title>
    <link href="http://yoursite.com/child/2019/10/26/nio-epoll%E9%AB%98%E6%95%88%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/child/2019/10/26/nio-epoll高效运行原理/</id>
    <published>2019-10-25T16:00:00.000Z</published>
    <updated>2020-06-08T03:05:50.661Z</updated>
    
    <content type="html"><![CDATA[<p>nio非阻塞牛逼在哪里？</p><p>要解答这个问题首先要清楚bio的痛点在哪里。</p><p>假如我们的服务使用bio模型，服务器启动之后需要一条线程一直监听端口上是否有连接请求发过来，如果没有请求，这条线程就一直等着；</p><p>等了好久好久终于来了一个请求连接，连接建立成功后，又要开始等业务请求，由于网络慢或者其他原因又等了一千年；</p><p>终于拿到了请求，电光火石间处理完拿到响应数据，准备响应出去，这时候发现由于不明原因，一千五百年之前的一条响应还没有发送出去，占据了内核缓冲区，这时候害得等，等前一条响应发出去才能将本次的响应写入缓冲区。。。沧海桑田</p><p>当然这里可以使用多线程优化，但是没有解决根本问题，那就是线程等太久的问题。</p><p>这时候nio模式横空出世，牛逼在不用等。nio在linux平台基于epoll实现的</p><p>接下来的疑问</p><p>1、epoll是基于事件的，那么有哪些事件，事件由谁来触发？</p><p>2、jdk nio是怎么和epoll实现对接的？</p><p>带着这两个疑问，查阅了网上一些文章，大概能解答以上两点疑惑</p><p>链接：<a href="https://baijiahao.baidu.com/s?id=1641172494287388070&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">彻底搞懂epoll高效运行的原理</a></p><p>epoll是一种I/O事件通知机制，是linux 内核实现IO多路复用的一个实现。</p><p>IO多路复用是指，在一个操作里同时监听多个输入输出源，在其中一个或多个输入输出源可用的时候返回，然后对其的进行读写操作。</p><p><strong>事件</strong></p><p>可读事件，当文件描述符关联的内核读缓冲区可读，则触发可读事件。(可读：内核缓冲区非空，有数据可以读取)</p><p>可写事件，当文件描述符关联的内核写缓冲区可写，则触发可写事件。(可写：内核缓冲区不满，有空闲空间可以写入）</p><p><strong>epoll的通俗解释是：一种当文件描述符的内核缓冲区非空时发出可读信号通知、当写缓冲区不满时发出可写信号通知的机制</strong></p><h4 id="epoll的API"><a href="#epoll的API" class="headerlink" title="epoll的API"></a>epoll的API</h4><p>epoll的核心是3个API，核心数据结构是：1个红黑树和1个链表</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/rpc/epoll%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86.png" alt="epoll"></p><p><strong>1. int epoll_create(int size);</strong><br>创建一个epoll对象，返回对象的句柄，后面两个操作都以句柄为核心。</p><p>参数size用来表示要监听的fd数量的最大值，之后版本的Linux已弃用该参数。</p><p><strong>2.int epoll_ctl(int epfd, int op, int fd, struct epoll_event* event);</strong><br>epoll的事件注册接口，负责将被监听的描述符添加到红黑树或从红黑树中删除或者对监听事件进行修改。<br>参数 epfd 表示epoll对象句柄；<br>参数 op 表示动作，用三个宏来表示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EPOLL_CTL_ADD <span class="comment">//注册新的fd到epfd中；</span></span><br><span class="line">EPOLL_CTL_MOD <span class="comment">//修改已经注册的fd的监听事件；</span></span><br><span class="line">EPOLL_CTL_DEL <span class="comment">//从epfd中删除一个fd；</span></span><br></pre></td></tr></table></figure><p>参数 fd 是需要监听的fd</p><p>参数 event 表示此次注册的事件，struct epoll_event结构如下：</p><p>data域是唯一能给出描述符信息的字段，所以在调用epoll_ctl加入一个需要监测的描述符时，一定要在此域写入描述符相关信息；</p><p>events域是bit mask，描述一组epoll事件，在epoll_ctl调用中解释为：描述符所期望的epoll事件，可多选。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">表示某个fd上某事件被触发了</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">__uint32_t</span> events; <span class="comment">// 在被监测的文件描述符上实际发生的事件。</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr; <span class="comment">// 指向用户自定义数据 </span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">//注册的文件描述符</span></span><br><span class="line">    <span class="keyword">__uint32_t</span> u32; <span class="comment">//32-bit integer</span></span><br><span class="line">    <span class="keyword">__uint64_t</span> u64; <span class="comment">//64-bit integer</span></span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure><p>常用的epoll事件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EPOLLIN <span class="comment">//表示对应的文件描述符可以读（包括对端SOCKET正常关闭）</span></span><br><span class="line">EPOLLOUT <span class="comment">//表示对应的文件描述符可以写</span></span><br><span class="line">EPOLLET <span class="comment">//将 EPOLL设为边缘触发</span></span><br><span class="line">EPOLLONESHOT <span class="comment">//第一次进行通知，之后不再监测</span></span><br><span class="line">EPOLLPRI <span class="comment">//由带外数据触发</span></span><br><span class="line">EPOLLERR <span class="comment">//描述符产生错误时触发，默认检测事件</span></span><br><span class="line">EPOLLHUP <span class="comment">//本端描述符产生一个挂断事件，默认监测事件</span></span><br><span class="line">EPOLLRDHUP <span class="comment">//对端描述符产生一个挂断事件</span></span><br></pre></td></tr></table></figure><h4 id="epoll的两种触发方式"><a href="#epoll的两种触发方式" class="headerlink" title="epoll的两种触发方式"></a>epoll的两种触发方式</h4><p>epoll监控多个文件描述符的I/O事件。epoll支持边缘触发(edge trigger，ET)或水平触发（level trigger，LT)，通过epoll_wait等待I/O事件，如果当前没有可用的事件则阻塞调用线程。</p><p>select和poll只支持LT工作模式，epoll的默认的工作模式是LT模式。</p><p><strong>1.水平触发的时机</strong></p><p>对于读操作，只要缓冲不为空，LT模式返回读就绪。对于写操作，只要缓冲区还不满，LT模式会返回写就绪。</p><p>当被监控的文件描述符上有可读写事件发生时，<code>epoll_wait()</code>会通知处理程序去读写。如果这次没有把数据一次性全部读写完(如读写缓冲区太小)，那么下次调用 <code>epoll_wait()</code>时，它还会通知你在上没读写完的文件描述符上继续读写，当然如果你一直不去读写，它会一直通知你。如果系统中有大量你不需要读写的就绪文件描述符，而它们每次都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率。</p><p><strong>2.边缘触发的时机</strong></p><p>对于读操作，以下三种情况会触发读就绪事件：</p><ul><li><p>当缓冲区由不可读变为可读的时候，即缓冲区由空变为不空的时候；</p></li><li><p>当有新数据到达时，即缓冲区中的待读数据变多的时候；</p></li><li><p>当缓冲区有数据可读，且应用进程对相应的描述符进行EPOLL_CTL_MOD 修改EPOLLIN事件时（设置监听读就绪时）；</p></li></ul><p>响应的对于写操作，以下情况会触发写就绪事件：</p><ul><li>当缓冲区由不可写变为可写时。</li><li>当有旧数据被发送走，即缓冲区中的内容变少的时候。</li><li>当缓冲区有空间可写，且应用进程对相应的描述符进行EPOLL_CTL_MOD 修改EPOLLOUT事件时。</li></ul><p>当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它不会通知你，就是说只会通知一次，直到该文件描述符上触发第二次可读写事件时才会再次通知。这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符。</p><p>举例1：</p><p>读缓冲区刚开始是空的读缓冲区写入2KB数据，水平触发和边缘触发模式此时都会发出可读信号收到信号通知后，读取了1KB的数据，读缓冲区还剩余1KB数据，水平触发会再次进行通知，而边缘触发不会再进行通知</p><p>举例2：（以脉冲的高低电平为例）</p><p>水平触发：0为无数据，1为有数据。缓冲区有数据则一直为1，则一直触发。边缘触发发：0为无数据，1为有数据，只要在0变到1的上升沿才触发。</p><p>JDK在Linux已经默认使用epoll方式，但是JDK的epoll采用的是水平触发，而Netty重新实现了epoll机制，采用边缘触发方式，netty epoll transport 暴露了更多的nio没有的配置参数，如 TCP_CORK, SO_REUSEADDR等等；另外像Nginx也采用边缘触发。</p><h4 id="epoll与select、poll的对比"><a href="#epoll与select、poll的对比" class="headerlink" title="epoll与select、poll的对比"></a>epoll与select、poll的对比</h4><p><strong>1. 用户态将文件描述符传入内核的方式</strong></p><ul><li><p>select：创建3个文件描述符集并拷贝到内核中，分别监听读、写、异常动作。这里受到单个进程可以打开的fd数量限制，默认是1024。</p></li><li><p>poll：将传入的struct pollfd结构体数组拷贝到内核中进行监听。</p></li><li><p>epoll：执行epoll_create会在内核的高速cache区中建立一颗红黑树以及就绪链表(该链表存储已经就绪的文件描述符)。接着用户执行的epoll_ctl函数添加文件描述符会在红黑树上增加相应的结点。</p></li></ul><p><strong>2. 内核态检测文件描述符读写状态的方式</strong></p><ul><li>select：采用轮询方式，遍历所有fd，最后返回一个描述符读写操作是否就绪的mask掩码，根据这个掩码给fd_set赋值。</li><li>poll：同样采用轮询方式，查询每个fd的状态，如果就绪则在等待队列中加入一项并继续遍历。</li><li>epoll：采用回调机制。在执行epoll_ctl的add操作时，不仅将文件描述符放到红黑树上，而且也注册了回调函数，内核在检测到某文件描述符可读/可写时会调用回调函数，该回调函数将文件描述符放在就绪链表中。</li></ul><p><strong>3. 找到就绪的文件描述符并传递给用户态的方式</strong></p><ul><li>select：将之前传入的fd_set拷贝传出到用户态并返回就绪的文件描述符总数。用户态并不知道是哪些文件描述符处于就绪态，需要遍历来判断。</li><li>poll：将之前传入的fd数组拷贝传出用户态并返回就绪的文件描述符总数。用户态并不知道是哪些文件描述符处于就绪态，需要遍历来判断。</li><li>epoll：epoll_wait只用观察就绪链表中有无数据即可，最后将链表的数据返回给数组并返回就绪的数量。内核将就绪的文件描述符放在传入的数组中，所以只用遍历依次处理即可。这里返回的文件描述符是通过mmap让内核和用户空间共享同一块内存实现传递的，减少了不必要的拷贝。</li></ul><p><strong>4. 重复监听的处理方式</strong></p><ul><li>select：将新的监听文件描述符集合拷贝传入内核中，继续以上步骤。</li><li>poll：将新的struct pollfd结构体数组拷贝传入内核中，继续以上步骤。</li><li>epoll：无需重新构建红黑树，直接沿用已存在的即可。</li></ul><h4 id="epoll更高效的原因"><a href="#epoll更高效的原因" class="headerlink" title="epoll更高效的原因"></a><strong>epoll更高效的原因</strong></h4><p>select和poll的动作基本一致，只是poll采用链表来进行文件描述符的存储，而select采用fd标注位来存放，所以select会受到最大连接数的限制，而poll不会。</p><p>select、poll、epoll虽然都会返回就绪的文件描述符数量。但是select和poll并不会明确指出是哪些文件描述符就绪，而epoll会。造成的区别就是，系统调用返回后，调用select和poll的程序需要遍历监听的整个文件描述符找到是谁处于就绪，而epoll则直接处理即可。select、poll都需要将有关文件描述符的数据结构拷贝进内核，最后再拷贝出来。而epoll创建的有关文件描述符的数据结构本身就存于内核态中，系统调用返回时利用mmap()文件映射内存加速与内核空间的消息传递：即epoll使用mmap减少复制开销。select、poll采用轮询的方式来检查文件描述符是否处于就绪态，而epoll采用回调机制。造成的结果就是，随着fd的增加，select和poll的效率会线性降低，而epoll不会受到太大影响，除非活跃的socket很多。epoll的边缘触发模式效率高，系统不会充斥大量不关心的就绪文件描述符虽然epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;nio非阻塞牛逼在哪里？&lt;/p&gt;
&lt;p&gt;要解答这个问题首先要清楚bio的痛点在哪里。&lt;/p&gt;
&lt;p&gt;假如我们的服务使用bio模型，服务器启动之后需要一条线程一直监听端口上是否有连接请求发过来，如果没有请求，这条线程就一直等着；&lt;/p&gt;
&lt;p&gt;等了好久好久终于来了一个请求连接
      
    
    </summary>
    
      <category term="I/O和网络编程" scheme="http://yoursite.com/child/categories/I-O%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="nio" scheme="http://yoursite.com/child/tags/nio/"/>
    
  </entry>
  
</feed>
