<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>黑风雅过吟</title>
  
  <subtitle>不积跬步无以至千里</subtitle>
  <link href="/zzkenyon.github.io/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/child/"/>
  <updated>2019-11-30T08:09:16.065Z</updated>
  <id>http://yoursite.com/child/</id>
  
  <author>
    <name>Zhao Zhengkang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>zookeeper-配置和基本操纵</title>
    <link href="http://yoursite.com/child/2019/11/30/zookeeper-%E9%85%8D%E7%BD%AE%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E7%BA%B5/"/>
    <id>http://yoursite.com/child/2019/11/30/zookeeper-配置和基本操纵/</id>
    <published>2019-11-30T08:09:16.065Z</published>
    <updated>2019-11-30T08:09:16.065Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-配置开机自启"><a href="#1-配置开机自启" class="headerlink" title="1. 配置开机自启"></a>1. 配置开机自启</h4><p>把zookeeper做成服务</p><p>1、进入到/etc/rc.d/init.d目录下，新建一个zookeeper脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# cd /etc/rc.d/init.d/ </span><br><span class="line">[root@node1 init.d]# pwd </span><br><span class="line">/etc/rc.d/init.d </span><br><span class="line">[root@node1 init.d]# touch zookeeper</span><br></pre></td></tr></table></figure><p>2、给脚本添加执行权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 init.d]# chmod +x zookeeper</span><br></pre></td></tr></table></figure><p>3、使用命令vim zookeeper进行编辑，在脚本中输入如下内容，其中同上面注意事项一样要添加export JAVA_HOME=/usr/java/jdk1.8.0_112这一行，否则无法正常启动。</p><p>[root@zookeeper init.d]# vim zookeeper</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span>chkconfig:2345 10 90</span><br><span class="line"><span class="meta">#</span>description:service zookeeper</span><br><span class="line">export     JAVA_HOME=/usr/lib/java/jdk-1.8.0_231</span><br><span class="line">ZOOKEEPER_HOME=/usr/local/apache/apache-zookeeper-3.5.6-bin</span><br><span class="line">case  "$1"   in</span><br><span class="line">     start)  su  root  $&#123;ZOOKEEPER_HOME&#125;/bin/zkServer.sh  start;;</span><br><span class="line">     stop)  su  root  $&#123;ZOOKEEPER_HOME&#125;/bin/zkServer.sh  stop;;</span><br><span class="line">     status)  su root  $&#123;ZOOKEEPER_HOME&#125;/bin/zkServer.sh    status;;</span><br><span class="line">     restart)  su root   $&#123;ZOOKEEPER_HOME&#125;/bin/zkServer.sh   restart;;</span><br><span class="line">     *)  echo "require start||stop|status|restart|";;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>4、 使用service zookeeper start/stop/restart命令来尝试启动关闭重启zookeeper，使用service zookeeper status查看zookeeper状态。</p><p>5、添加到开机自启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 init.d]# chkconfig --add zookeeper</span><br></pre></td></tr></table></figure><p>添加完之后，我们使用chkconfig –list来查看开机自启的服务中是否已经有我们的zookeeper了，如下所示，可以看到在最后一行便是我们的zookeeper服务了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 init.d]# chkconfig --list </span><br><span class="line">netconsole      0:off   1:off   2:off   3:off   4:off   5:off   6:off</span><br><span class="line">network         0:off   1:off   2:on    3:on    4:on    5:on    6:off</span><br><span class="line">zookeeper       0:off   1:off   2:on    3:on    4:on    5:on    6:off</span><br></pre></td></tr></table></figure><h4 id="2-zkCli客户端"><a href="#2-zkCli客户端" class="headerlink" title="2. zkCli客户端"></a>2. zkCli客户端</h4><p><a href="https://blog.csdn.net/dandandeshangni/article/details/80558383" target="_blank" rel="noopener">https://blog.csdn.net/dandandeshangni/article/details/80558383</a></p><h5 id="2-1-基本操作"><a href="#2-1-基本操作" class="headerlink" title="2.1 基本操作"></a>2.1 基本操作</h5><ul><li>列举子节点: ls path (ls /zookeeper)</li><li>查看节点更新信息：stat path (stat /zookeeper)</li><li>创建节点 ：create path val (creat /config “test string value”)</li><li>创建临时节点 ：create -e path val</li><li>创建顺序节点：create -s path val</li><li>修改节点：set path val (set /config “another config string”)</li><li>删除节点：delete path</li><li>监视节点：stat -w path、 get -w path</li></ul><h5 id="2-2-ACL权限控制"><a href="#2-2-ACL权限控制" class="headerlink" title="2.2 ACL权限控制"></a>2.2 ACL权限控制</h5><p>ZK的节点有5种操作权限：CREATE、READ、WRITE、DELETE、ADMIN 也就是 增、删、改、查、管理权限，这5种权限简写为crwda(即：每个单词的首字符缩写)。 注：这5种权限中，delete是指对子节点的删除权限，其它4种权限指对自身节点的操作权限</p><p>身份的认证有4种方式：</p><ul><li>world：默认方式，相当于全世界都能访问</li><li>auth：代表已经认证通过的用户(cli中可以通过addauth digest user:pwd 来添加当前上下文中的授权用户)</li><li>digest：即用户名:密码这种方式认证，这也是业务系统中最常用的</li><li>ip：使用Ip地址认证</li></ul><p>使用[scheme​ : id : permissions]来表示acl权限，比如-digest:username:password:cwrda</p><p>getAcl:获取某个节点的acl权限信息 getAcl path</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>World方案权限设置</span><br><span class="line">setAcl /config/global world:anyone:crwa</span><br><span class="line"><span class="meta">#</span>auth方案权限设置</span><br><span class="line">addauth digest test:123456 </span><br><span class="line">setAcl /config/global auth:test:123456:cdrwa</span><br><span class="line"><span class="meta">#</span>digest方案权限设置</span><br><span class="line">setAcl /config/global digest:test:V28q/NynI4JI3Rk54h0r8O5kMug=:cdra</span><br><span class="line"><span class="meta">#</span>ip权限设置</span><br><span class="line">setAcl /niocoder/ip ip:192.168.0.68:cdrwa</span><br></pre></td></tr></table></figure><h5 id="超级管理员"><a href="#超级管理员" class="headerlink" title="超级管理员"></a>超级管理员</h5><p>zk的权限管理表有一种ACL的模式叫做super，该模式的作用是方便管理节点。一旦我们为某一个节点设置了acl，那么其余的未授权的节点是无法访问或者操作该节点的，那么系统用久了以后，假如忘记了某一个节点的密码，那么就无法再操作这个节点了，所以需要这个super超级管理员用户权限，其作用还是很大的。</p><p>添加方式：只能在启动服务器的时候添加。</p><p>假设这个超管是：super:admin，通过代码得到其哈希值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String m = DigestAuthenticationProvider.generateDigest(<span class="string">"super:admin"</span>);</span><br></pre></td></tr></table></figure><p>m是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">super:xQJmxLMiHGwaqBvst5y6rkB6HQs=</span><br></pre></td></tr></table></figure><p>那么打开zk目录下的/bin/zkServer.sh服务器脚本文件，找到如下一行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup $JAVA "-Dzookeeper.log.dir=$&#123;ZOO_LOG_DIR&#125;" "-Dzookeeper.root.logger=$&#123;ZOO_LOG4J_PROP&#125;"</span><br></pre></td></tr></table></figure><p>这就是脚本中启动zk的命令，默认只有以上两个配置项，我们需要加一个超管的配置项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"-Dzookeeper.DigestAuthenticationProvider.superDigest=super:xQJmxLMiHGwaqBvst5y6rkB6HQs="</span><br></pre></td></tr></table></figure><p>第一个等号之后的就是刚才用户名密码的哈希值。 那么修改以后这条完整命令变成了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nohup $JAVA "-Dzookeeper.log.dir=$&#123;ZOO_LOG_DIR&#125;" "-Dzookeeper.root.logger=$&#123;ZOO_LOG4J_PROP&#125;" "-Dzookeeper.DigestAuthenticationProvider.superDigest=super:xQJmxLMiHGwaqBvst5y6rkB6HQs="\</span><br><span class="line">    -cp "$CLASSPATH" $JVMFLAGS $ZOOMAIN "$ZOOCFG" &gt; "$_ZOO_DAEMON_OUT" 2&gt;&amp;1 &lt; /dev/null &amp;</span><br></pre></td></tr></table></figure><p>之后重新启动zk集群，进入zkCli输入如下命令添加权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addauth digest super:admin</span><br></pre></td></tr></table></figure><p>假如zk有一个节点/test，acl为digest方案，但是忘记了用户名和密码，正常情况下，这次登陆如果不用那个digest授权是不能访问/test的数据的。但是由于我们配置了超管，所以这次还是可以访问到的。</p><p>需要说明的是，这个超管只是在这次服务器启动期间管用，如果关闭了服务器，并修改了服务器脚本，取消了超管配置，那么下一次启动就没有这个超管了。</p><h5 id="运维四字指令"><a href="#运维四字指令" class="headerlink" title="运维四字指令"></a>运维四字指令</h5><p>使用四字命令需要安装nc命令(yum install nc)</p><p>然后在启动脚本zkServer.sh里添加ＶＭ环境变量-Dzookeeper.4lw.commands.whitelist=*，便可以把所有四字指令添加到白名单（否则执行四字指令会报错is not executed because it is not in the whitelist），我是添加在脚本的这个位置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ZOOMAIN="-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=$JMXPORT -Dcom.sun.management.jmxremote.authenticate=$JMXAUTH -Dcom.sun.management.jmxremote.ssl=$JMXSSL -Dzookeeper.jmx.log4j.disable=$JMXLOG4J org.apache.zookeeper.server.quorum.QuorumPeerMain"</span><br><span class="line">  fi</span><br><span class="line">else</span><br><span class="line">    echo "JMX disabled by user request" &gt;&amp;2</span><br><span class="line">    ZOOMAIN="org.apache.zookeeper.server.quorum.QuorumPeerMain"</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span> 这里就是我添加的</span><br><span class="line"><span class="meta">#</span> 如果不想添加在这里，注意位置和赋值的顺序</span><br><span class="line">ZOOMAIN="-Dzookeeper.4lw.commands.whitelist=* $&#123;ZOOMAIN&#125;"</span><br></pre></td></tr></table></figure><p>重启zk即可。</p><p>四字指令调用方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]#echo xxxx | nc 192.168.0.68 2181</span><br></pre></td></tr></table></figure><p>其中xxxx为：</p><ul><li>stat 查看状态信息</li><li>ruok 查看zookeeper是否启动</li><li>dump 列出没有处理的节点，临时节点</li><li>conf 查看服务器配置</li><li>cons 显示连接到服务端的信息</li><li>envi 显示环境变量信息</li><li>mntr 查看zk的健康信息</li><li>wchs 展示watch的信息</li><li>wchc和wchp 显示session的watch信息 path的watch信息</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-配置开机自启&quot;&gt;&lt;a href=&quot;#1-配置开机自启&quot; class=&quot;headerlink&quot; title=&quot;1. 配置开机自启&quot;&gt;&lt;/a&gt;1. 配置开机自启&lt;/h4&gt;&lt;p&gt;把zookeeper做成服务&lt;/p&gt;
&lt;p&gt;1、进入到/etc/rc.d/init.d目
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/child/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper-是什么以及能干什么</title>
    <link href="http://yoursite.com/child/2019/11/24/zookeeper-%E6%98%AF%E4%BB%80%E4%B9%88%E4%BB%A5%E5%8F%8A%E8%83%BD%E5%B9%B2%E4%BB%80%E4%B9%88/"/>
    <id>http://yoursite.com/child/2019/11/24/zookeeper-是什么以及能干什么/</id>
    <published>2019-11-23T16:00:00.000Z</published>
    <updated>2019-11-30T08:51:01.789Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是-ZooKeeper"><a href="#1-什么是-ZooKeeper" class="headerlink" title="1. 什么是 ZooKeeper"></a>1. 什么是 ZooKeeper</h3><h4 id="1-1-ZooKeeper-的由来"><a href="#1-1-ZooKeeper-的由来" class="headerlink" title="1.1 ZooKeeper 的由来"></a>1.1 ZooKeeper 的由来</h4><p>下面这段内容摘自《从Paxos到Zookeeper 》第四章第一节的某段内容，推荐大家阅读：</p><blockquote><p>Zookeeper最早起源于雅虎研究院的一个研究小组。在当时，研究人员发现，在雅虎内部很多大型系统基本都需要依赖一个类似的系统来进行分布式协调，但是这些系统往往都存在分布式单点问题。所以，<strong>雅虎的开发人员就试图开发一个通用的无单点问题的分布式协调框架，以便让开发人员将精力集中在处理业务逻辑上。</strong></p><p>关于“ZooKeeper”这个项目的名字，其实也有一段趣闻。在立项初期，考虑到之前内部很多项目都是使用动物的名字来命名的（例如著名的Pig项目),雅虎的工程师希望给这个项目也取一个动物的名字。时任研究院的首席科学家RaghuRamakrishnan开玩笑地说：“在这样下去，我们这儿就变成动物园了！”此话一出，大家纷纷表示就叫动物园管理员吧一一一因为各个以动物命名的分布式组件放在一起，<strong>雅虎的整个分布式系统看上去就像一个大型的动物园了，而Zookeeper正好要用来进行分布式环境的协调一一于是，Zookeeper的名字也就由此诞生了。</strong></p></blockquote><h4 id="1-2-ZooKeeper-概览"><a href="#1-2-ZooKeeper-概览" class="headerlink" title="1.2 ZooKeeper 概览"></a>1.2 ZooKeeper 概览</h4><p>ZooKeeper 是一个开源的分布式协调服务，ZooKeeper框架最初是在“Yahoo!”上构建的，用于以简单而稳健的方式访问他们的应用程序。 后来，Apache ZooKeeper成为Hadoop，HBase和其他分布式框架使用的有组织服务的标准。 例如，Apache HBase使用ZooKeeper跟踪分布式数据的状态。</p><p><strong>ZooKeeper 的设计目标</strong>是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</p><p><strong>ZooKeeper 是一个典型的分布式数据一致性解决方案</strong>，分布式应用程序可以基于 ZooKeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</p><p><strong>Zookeeper 一个最常用的使用场景</strong> 就是用于担任服务生产者和服务消费者的注册中心(提供发布订阅服务)。服务生产者将自己提供的服务注册到Zookeeper中心，服务的消费者在进行服务调用的时候先到Zookeeper中查找服务，获取到服务生产者的详细信息之后，再去调用服务生产者的内容与数据。如下图所示，在 Dubbo架构中 Zookeeper 就担任了注册中心这一角色。</p><p><img src="https://camo.githubusercontent.com/833bc92999192c594d7c49527b813fec7ab4453d/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d31302f33353537313738322e6a7067" alt="Dubbo"></p><h4 id="1-2-结合使用情况的讲一下-ZooKeeper"><a href="#1-2-结合使用情况的讲一下-ZooKeeper" class="headerlink" title="1.2 结合使用情况的讲一下 ZooKeeper"></a>1.2 结合使用情况的讲一下 ZooKeeper</h4><p>在我自己做过的项目中，主要使用到了 ZooKeeper 作为 Dubbo 的注册中心(Dubbo 官方推荐使用 ZooKeeper注册中心)。另外在搭建 solr 集群的时候，我使用 ZooKeeper 作为 solr 集群的管理工具。这时，ZooKeeper 主要提供下面几个功能：1、集群管理：容错、负载均衡。2、配置文件的集中管理。3、集群的入口。</p><p>我个人觉得在使用 ZooKeeper 的时候，最好是使用 集群版的 ZooKeeper 而不是单机版的。官网给出的架构图就描述的是一个集群版的 ZooKeeper 。通常 3 台服务器就可以构成一个 ZooKeeper 集群了。</p><p><strong>为什么最好使用奇数台服务器构成 ZooKeeper 集群？</strong></p><p>所谓的zookeeper容错是指，当宕掉几个zookeeper服务器之后，剩下的个数必须大于宕掉的个数的话整个zookeeper才依然可用。假如我们的集群中有n台zookeeper服务器，那么也就是剩下的服务数必须大于n/2。先说一下结论，2n和2n-1的容忍度是一样的，都是n-1，大家可以先自己仔细想一想，这应该是一个很简单的数学问题了。 比如假如我们有3台，那么最大允许宕掉1台zookeeper服务器，如果我们有4台的的时候也同样只允许宕掉1台。 假如我们有5台，那么最大允许宕掉2台zookeeper服务器，如果我们有6台的的时候也同样只允许宕掉2台。</p><p>综上，何必增加那一个不必要的zookeeper呢？</p><h3 id="2-关于-ZooKeeper-的一些重要概念"><a href="#2-关于-ZooKeeper-的一些重要概念" class="headerlink" title="2. 关于 ZooKeeper 的一些重要概念"></a>2. 关于 ZooKeeper 的一些重要概念</h3><h4 id="2-1-重要概念总结"><a href="#2-1-重要概念总结" class="headerlink" title="2.1 重要概念总结"></a>2.1 重要概念总结</h4><ul><li>ZooKeeper 本身就是一个分布式程序，为了保证<strong>高可用</strong>，最好是以集群形态来部署 ZooKeeper。只要<strong>半数</strong>以上节点存活，ZooKeeper 就能正常服务。</li><li>ZooKeeper 将<strong>数据保存在内存中</strong>，这也就保证了 高吞吐量和低延迟，但是内存限制了能够存储的容量不太大，此限制也是保持znode中存储的数据量较小的进一步原因。</li><li>ZooKeeper 是<strong>在“读”多于“写”的应用程序中尤其地高性能</strong>，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景。）</li><li>ZooKeeper有<strong>临时节点</strong>的概念。 当创建临时节点的客户端会话一直保持活动，瞬时节点就一直存在。而当会话终结时，瞬时节点被删除。持久节点是指一旦这个ZNode被创建了，除非主动进行ZNode的移除操作，否则这个ZNode将一直保存在Zookeeper上。</li><li>ZooKeeper <strong>底层</strong>其实只提供了<strong>两个功能</strong>：①管理（存储、读取）用户程序提交的数据；②为用户程序提供数据节点监听服务。</li></ul><h4 id="2-2-会话（Session）"><a href="#2-2-会话（Session）" class="headerlink" title="2.2 会话（Session）"></a>2.2 会话（Session）</h4><p>Session 指的<strong>是</strong> ZooKeeper 服务器与客户端会话。在 ZooKeeper 中，一个客户端连接是指客户端和服务器之间的<strong>一个 TCP 长连接</strong>。客户端启动的时候，首先会与服务器建立一个 TCP 连接，从第一次连接建立开始，客户端会话的生命周期也开始了。通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向Zookeeper服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的Watch事件通知。</p><p> Session的<code>sessionTimeout</code>值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要<strong>在sessionTimeout规定的时间内能够重新连接上集群中任意一台</strong>服务器，那么之前创建的会话仍然有效。</p><p>在为客户端创建会话之前，服务端首先会为每个客户端都分配一个<strong>sessionID</strong>。由于 sessionID 是 Zookeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 sessionID 的，因此，无论是哪台服务器为客户端分配的 sessionID，都务必<strong>保证全局唯一</strong>。</p><h4 id="2-3-Znode"><a href="#2-3-Znode" class="headerlink" title="2.3 Znode"></a>2.3 Znode</h4><p>在谈到分布式的时候，我们通常说的“节点”是指组成集群的每一台机器。然而，在Zookeeper中，“节点”分为两类，第一类同样是指构成集群的机器，我们称之为机器节点；第二类则是指数据模型中的数据单元，我们称之为数据节点一一ZNode。</p><p>Zookeeper将所有数据存储在内存中，数据模型是一棵树（Znode Tree)，由斜杠（/）的进行分割的路径，就是一个Znode，例如/foo/path1。每个上都会保存自己的数据内容，同时还会保存一系列属性信息。</p><p>在Zookeeper中，node可以分为<strong>持久节点</strong>和<strong>临时节点</strong>两类。所谓持久节点是指一旦这个ZNode被创建了，除非主动进行ZNode的移除操作，否则这个ZNode将一直保存在Zookeeper上。而临时节点就不一样了，它的生命周期和客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。 另外，ZooKeeper还允许用户为每个节点添加一个特殊的属性：<strong>SEQUENTIAL</strong>.一旦节点被标记上这个属性，那么在这个节点被创建的时候，Zookeeper会自动在其节点名后面追加上一个整型数字，这个整型数字是一个由父节点维护的自增数字。</p><h4 id="2-4-版本"><a href="#2-4-版本" class="headerlink" title="2.4 版本"></a>2.4 版本</h4><p>在前面我们已经提到，Zookeeper 的每个 ZNode 上都会存储数据，对应于每个ZNode，Zookeeper 都会为其维护一个叫作 <strong>Stat</strong> 的数据结构，Stat 中记录了这个 ZNode 的三个数据版本，分别是version（当前ZNode的版本）、cversion（当前ZNode子节点的版本）和 aversion（当前ZNode的ACL版本）。</p><h4 id="2-5-Watcher"><a href="#2-5-Watcher" class="headerlink" title="2.5 Watcher"></a>2.5 Watcher</h4><p>Watcher（事件监听器），是Zookeeper中的一个很重要的特性。Zookeeper允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper服务端会将事件通知到感兴趣的客户端上去，该机制是Zookeeper实现分布式协调服务的重要特性。</p><h3 id="2-6-ACL"><a href="#2-6-ACL" class="headerlink" title="2.6 ACL"></a>2.6 ACL</h3><p>Zookeeper采用ACL（AccessControlLists）策略来进行权限控制，类似于 UNIX 文件系统的权限控制。Zookeeper 定义了如下5种权限。</p><p><img src="https://camo.githubusercontent.com/b4f115ed9ee12cdd9442923100859bf1717f4e86/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d31302f32373437333438302e6a7067" alt="img"></p><p>其中尤其需要注意的是，CREATE和DELETE这两种权限都是针对子节点的权限控制。</p><h3 id="3-ZooKeeper-特点"><a href="#3-ZooKeeper-特点" class="headerlink" title="3. ZooKeeper 特点"></a>3. ZooKeeper 特点</h3><ul><li><strong>顺序一致性：</strong> 从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。</li><li><strong>原子性：</strong> 所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。</li><li><strong>单一系统映像 ：</strong> 无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。</li><li><strong>可靠性：</strong> 一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。</li></ul><h3 id="4-ZooKeeper-设计目标"><a href="#4-ZooKeeper-设计目标" class="headerlink" title="4. ZooKeeper 设计目标"></a>4. ZooKeeper 设计目标</h3><h4 id="4-1-简单的数据模型"><a href="#4-1-简单的数据模型" class="headerlink" title="4.1 简单的数据模型"></a>4.1 简单的数据模型</h4><p>ZooKeeper 允许分布式进程通过共享的层次结构命名空间进行相互协调，这与标准文件系统类似。 名称空间由 ZooKeeper 中的数据寄存器组成 - 称为znode，这些类似于文件和目录。 与为存储设计的典型文件系统不同，ZooKeeper数据保存在内存中，这意味着ZooKeeper可以实现高吞吐量和低延迟。</p><p><img src="https://camo.githubusercontent.com/305d94895208d5c5c7ead576b16895f36d995119/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d31302f39343235313735372e6a7067" alt="img"></p><h4 id="4-2-可构建集群"><a href="#4-2-可构建集群" class="headerlink" title="4.2 可构建集群"></a>4.2 可构建集群</h4><p>为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么zookeeper本身仍然是可用的。 客户端在使用 ZooKeeper 时，需要知道集群机器列表，通过与集群中的某一台机器建立 TCP 连接来使用服务，客户端使用这个TCP链接来发送请求、获取结果、获取监听事件以及发送心跳包。如果这个连接异常断开了，客户端可以连接到另外的机器上。</p><p>ZooKeeper 官方提供的架构图：</p><p><img src="https://camo.githubusercontent.com/2195e2d261feb7dbb9922153d589dc87032570d1/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d31302f36383930303638362e6a7067" alt="img"></p><p>上图中每一个Server代表一个安装Zookeeper服务的服务器。组成 ZooKeeper 服务的服务器都会在内存中维护当前的服务器状态，并且每台服务器之间都互相保持着通信。集群间通过 Zab 协议（Zookeeper Atomic Broadcast）来保持数据的一致性。</p><h4 id="4-3-顺序访问"><a href="#4-3-顺序访问" class="headerlink" title="4.3 顺序访问"></a>4.3 顺序访问</h4><p>对于来自客户端的每个更新请求，ZooKeeper 都会分配一个全局唯一的递增编号，这个编号反应了所有事务操作的先后顺序，应用程序可以使用 ZooKeeper 这个特性来实现更高层次的同步原语。 这个编号也叫做时间戳——zxid（Zookeeper Transaction Id）</p><h4 id="4-4-高性能"><a href="#4-4-高性能" class="headerlink" title="4.4 高性能"></a>4.4 高性能</h4><p>ZooKeeper 是高性能的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景。）</p><h3 id="5-ZooKeeper-集群角色介绍"><a href="#5-ZooKeeper-集群角色介绍" class="headerlink" title="5. ZooKeeper 集群角色介绍"></a>5. ZooKeeper 集群角色介绍</h3><p>最典型集群模式： <strong>Master/Slave 模式</strong>（主备模式）。在这种模式中，通常 Master服务器作为主服务器提供写服务，其他的 Slave 服务器从服务器通过异步复制的方式获取 Master 服务器最新的数据提供读服务。</p><p>但是，在 ZooKeeper 中没有选择传统的 Master/Slave 概念，而是引入了Leader、Follower 和 Observer 三种角色。如下图所示</p><p><img src="https://camo.githubusercontent.com/7e9c188ef73fdd1d10a3a5ea7dfa67d4c7cd859f/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d31302f38393630323736322e6a7067" alt="img"></p><p>ZooKeeper 集群中的所有机器通过一个 Leader 选举过程来选定一台称为 “Leader” 的机器，Leader 既可以为客户端提供写服务又能提供读服务。除了 Leader 外，Follower 和 Observer 都只能提供读服务。<strong>Follower 和 Observer 唯一的区别在于 Observer 机器不参与 Leader 的选举过程，也不参与写操作的过半写成功策略</strong>，因此 Observer 机器可以在不影响写性能的情况下提升集群的读性能。</p><p><img src="https://camo.githubusercontent.com/f08946356f39f71ba0bdcf5ae10bc05a2e4d514b/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d31332f39313632323339352e6a7067" alt="img"></p><p>当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进人恢复模式并选举产生新的Leader服务器。这个过程大致是这样的：</p><ol><li>Leader election（选举阶段）：节点在一开始都处于选举阶段，只要有一个节点得到超半数节点的票数，它就可以当选准 leader。</li><li>Discovery（发现阶段）：在这个阶段，followers 跟准 leader 进行通信，同步 followers 最近接收的事务提议。</li><li>Synchronization（同步阶段）:同步阶段主要是利用 leader 前一阶段获得的最新提议历史，同步集群中所有的副本。同步完成之后 准 leader 才会成为真正的 leader。</li><li>Broadcast（广播阶段） 到了这个阶段，Zookeeper 集群才能正式对外提供事务服务，并且 leader 可以进行消息广播。同时如果有新的节点加入，还需要对新节点进行同步。</li></ol><h3 id="6-ZooKeeper-amp-ZAB-协议-amp-Paxos算法"><a href="#6-ZooKeeper-amp-ZAB-协议-amp-Paxos算法" class="headerlink" title="6. ZooKeeper &amp;ZAB 协议&amp;Paxos算法"></a>6. ZooKeeper &amp;ZAB 协议&amp;Paxos算法</h3><h4 id="6-1-ZAB-协议-amp-Paxos算法"><a href="#6-1-ZAB-协议-amp-Paxos算法" class="headerlink" title="6.1 ZAB 协议&amp;Paxos算法"></a>6.1 ZAB 协议&amp;Paxos算法</h4><p>Paxos 算法应该可以说是 ZooKeeper 的灵魂了。但是，ZooKeeper 并没有完全采用 Paxos算法 ，而是使用 ZAB 协议作为其保证数据一致性的核心算法。另外，在ZooKeeper的官方文档中也指出，ZAB协议并不像 Paxos 算法那样，是一种通用的分布式一致性算法，它是一种特别为Zookeeper设计的崩溃可恢复的原子消息广播算法。</p><h4 id="6-2-ZAB-协议介绍"><a href="#6-2-ZAB-协议介绍" class="headerlink" title="6.2 ZAB 协议介绍"></a>6.2 ZAB 协议介绍</h4><p>ZAB（ZooKeeper Atomic Broadcast 原子广播） 协议是为分布式协调服务 ZooKeeper 专门设计的一种支持崩溃恢复的原子广播协议。 在 ZooKeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。</p><h4 id="6-3-ZAB-协议的两种基本模式"><a href="#6-3-ZAB-协议的两种基本模式" class="headerlink" title="6.3 ZAB 协议的两种基本模式"></a>6.3 ZAB 协议的两种基本模式</h4><p>ZAB协议包括两种基本的模式，分别是 <strong>崩溃恢复</strong>和<strong>消息广播</strong>。当整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进人恢复模式并选举产生新的Leader服务器。当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该Leader服务器完成了状态同步之后，ZAB协议就会退出恢复模式。其中，<strong>所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和Leader服务器的数据状态保持一致</strong>。</p><p><strong>当集群中已经有过半的Follower服务器完成了和Leader服务器的状态同步，那么整个服务框架就可以进人消息广播模式了。</strong> 当一台同样遵守ZAB协议的服务器启动后加人到集群中时，如果此时集群中已经存在一个Leader服务器在负责进行消息广播，那么新加人的服务器就会自觉地进人数据恢复模式：找到Leader所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。正如上文介绍中所说的，ZooKeeper设计成只允许唯一的一个Leader服务器来进行事务请求的处理。Leader服务器在接收到客户端的事务请求后，会生成对应的事务提案并发起一轮广播协议；而如果集群中的其他机器接收到客户端的事务请求，那么这些非Leader服务器会首先将这个事务请求转发给Leader服务器。</p><p>关于 ZAB 协议&amp;Paxos算法 需要讲和理解的东西太多了，推荐阅读下面两篇文章：</p><ul><li><a href="http://codemacro.com/2014/10/15/explain-poxos/" target="_blank" rel="noopener">图解 Paxos 一致性协议</a></li><li><a href="https://dbaplus.cn/news-141-1875-1.html" target="_blank" rel="noopener">Zookeeper ZAB 协议分析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-什么是-ZooKeeper&quot;&gt;&lt;a href=&quot;#1-什么是-ZooKeeper&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是 ZooKeeper&quot;&gt;&lt;/a&gt;1. 什么是 ZooKeeper&lt;/h3&gt;&lt;h4 id=&quot;1-1-ZooKeep
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/child/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>分布式-vagrant&amp;virtualBox使用说明</title>
    <link href="http://yoursite.com/child/2019/11/22/%E5%88%86%E5%B8%83%E5%BC%8F-vagrant&amp;virtualBox%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <id>http://yoursite.com/child/2019/11/22/分布式-vagrant&amp;virtualBox使用说明/</id>
    <published>2019-11-21T16:00:00.000Z</published>
    <updated>2019-11-30T08:10:17.351Z</updated>
    
    <content type="html"><![CDATA[<p>vagrant是一个工具，用于创建和部署虚拟化开发环境的，能与virtualVM、virtualBox等虚拟机软件搭配使用。</p><p>拿VirtualBox举例，VirtualBox会开放一个创建虚拟机的接口，Vagrant会利用这个接口创建虚拟机，并且通过Vagrant来管理，配置和自动安装虚拟机。</p><ul><li><p>安装最新版virtualBox</p></li><li><p>安装最新版vagrant</p></li></ul><h4 id="1、创建虚拟机"><a href="#1、创建虚拟机" class="headerlink" title="1、创建虚拟机"></a>1、创建虚拟机</h4><p>首先下载镜像，我们使用vagrant box add 命令进行下载</p><p>Vagrant 的 box，是一个打包好的单一文件，其中包含了一个完整系统的虚拟机相关数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 添加virtualBox，名字可自定义，使用官方的命名不需要url，下载速度慢，建议使用国内镜像源下载</span><br><span class="line">vagrant box add &#123;name&#125; &#123;url&#125;</span><br><span class="line"><span class="meta">#</span> 列出已下载所有的virtualBox</span><br><span class="line">vagrant box list</span><br><span class="line"><span class="meta">#</span> 移除指定的virtualBox</span><br><span class="line">vagrant box remove &#123;name&#125;</span><br></pre></td></tr></table></figure><p>本文使用中国科技大学的centos7镜像源，在cmd任意目录下执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant box add centos7 http://mirrors.ustc.edu.cn/centos-cloud/centos/7/vagrant/x86_64/images/CentOS-7-x86_64-Vagrant-1708_01.VirtualBox.box</span><br></pre></td></tr></table></figure><p>在用户目录下新建文件夹 如：E:/vagrant/，在目录下执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vgrant init</span><br></pre></td></tr></table></figure><p>会生成一个vagrantfile文件，该文件是将要创建的虚拟机属性配置文件，如下修改文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(&quot;2&quot;) do |config|</span><br><span class="line">   (1..3).each do |i|</span><br><span class="line">        config.vm.define &quot;node#&#123;i&#125;&quot; do |node|</span><br><span class="line">            # 设置虚拟机的Box</span><br><span class="line">            node.vm.box = &quot;centos7&quot;</span><br><span class="line"></span><br><span class="line">            # 设置虚拟机的主机名</span><br><span class="line">            node.vm.hostname=&quot;node#&#123;i&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 设置虚拟机的IP</span><br><span class="line">            node.vm.network &quot;public_network&quot;, ip: &quot;192.168.2.#&#123;200+i&#125;&quot;</span><br><span class="line"></span><br><span class="line">            # VirtaulBox相关配置</span><br><span class="line">            node.vm.provider &quot;virtualbox&quot; do |v|</span><br><span class="line">                # 设置虚拟机的名称</span><br><span class="line">                v.name = &quot;node#&#123;i&#125;&quot;</span><br><span class="line">                # 设置虚拟机的内存大小</span><br><span class="line">                v.memory = 2048</span><br><span class="line">                # 设置虚拟机的CPU个数</span><br><span class="line">                v.cpus = 1</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">   end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>保存后，在当前目录执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant up</span><br></pre></td></tr></table></figure><p>vagrant会根据vagrantfile创建3台虚拟机并启动，本文将采用桥接网卡的网络模型，因此在virtualBox中将虚拟机关闭之后，对网络进行设置，取消默认勾选的NAT网络，只剩下桥接网卡。</p><h4 id="2、vagrantfile简析"><a href="#2、vagrantfile简析" class="headerlink" title="2、vagrantfile简析"></a>2、vagrantfile简析</h4><h5 id="2-1、box设置"><a href="#2-1、box设置" class="headerlink" title="2.1、box设置"></a>2.1、box设置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.box = &quot;centos7&quot;</span><br></pre></td></tr></table></figure><p>该名称是再使用 vagrant init 中后面跟的名字。</p><h5 id="2-2、hostname设置"><a href="#2-2、hostname设置" class="headerlink" title="2.2、hostname设置"></a>2.2、hostname设置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.hostname = &quot;node1&quot;</span><br></pre></td></tr></table></figure><p>设置hostname非常重要，因为当我们有很多台虚拟服务器的时候，都是依靠hostname來做识别的。比如，我安装了centos1,centos2 两台虚拟机，再启动时，我可以通过vagrant up centos1来指定只启动哪一台。</p><h5 id="2-3、虚拟机网络设置"><a href="#2-3、虚拟机网络设置" class="headerlink" title="2.3、虚拟机网络设置"></a>2.3、虚拟机网络设置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//Host-only模式</span><br><span class="line">config.vm.network &quot;private_network&quot;, ip: &quot;192.168.10.11&quot;</span><br><span class="line"></span><br><span class="line">//Bridge模式</span><br><span class="line">config.vm.network &quot;public_network&quot;, ip: &quot;10.1.2.61&quot;</span><br></pre></td></tr></table></figure><p>Vagrant的网络连接方式有三种：</p><ul><li><p>NAT : 缺省创建，用于让vm可以通过host转发访问局域网甚至互联网。</p></li><li><p>host-only : 只有主机可以访问vm，其他机器无法访问它。</p></li><li><p>bridge : 此模式下vm就像局域网中的一台独立的机器，可以被其他机器访问。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config.vm.network :private_network, ip: &quot;192.168.33.10&quot;</span><br><span class="line"></span><br><span class="line">配置当前vm的host-only网络的IP地址为192.168.33.10</span><br></pre></td></tr></table></figure><p>host-only 模式的IP可以不指定，而是采用dhcp自动生成的方式，如 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.network &quot;private_network&quot;, type: &quot;dhcp”</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#创建一个bridge桥接网络，指定IP</span><br><span class="line">config.vm.network &quot;public_network&quot;, ip: &quot;192.168.0.17&quot;</span><br><span class="line">#创建一个bridge桥接网络，指定桥接适配器</span><br><span class="line">config.vm.network &quot;public_network&quot;, bridge: &quot;en1: Wi-Fi (AirPort)&quot;</span><br><span class="line">#创建一个bridge桥接网络，不指定桥接适配器</span><br><span class="line">config.vm.network &quot;public_network&quot;</span><br></pre></td></tr></table></figure><h5 id="2-4、同步目录设置"><a href="#2-4、同步目录设置" class="headerlink" title="2.4、同步目录设置"></a>2.4、同步目录设置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.synced_folder &quot;D:/xxx/code&quot;, &quot;/home/www/&quot;</span><br></pre></td></tr></table></figure><p>前面的路径(D:/xxx/code)是本机代码的地址，后面的地址就是虚拟机的目录。虚拟机的/vagrant目录默认挂载宿主机的开发目录(可以在进入虚拟机机后，使用df -h 查看)，这是在虚拟机启动时自动挂载的。我们还可以设置额外的共享目录，上面这个设定，第一个参数是宿主机的目录，第二个参数是虚拟机挂载的目录。</p><h5 id="2-5、端口转发设置"><a href="#2-5、端口转发设置" class="headerlink" title="2.5、端口转发设置"></a>2.5、端口转发设置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.network :forwarded_port, guest: 80, host: 8080</span><br></pre></td></tr></table></figure><p>上面的配置把宿主机上的8080端口映射到客户虚拟机的80端口，例如你在虚拟机上使用nginx跑了一个Go应用，那么你在host上的浏览器中打开<a href="http://localhost:8080时，Vagrant就会把这个请求转发到虚拟机里跑在80端口的nginx服务上。不建议使用该方法，因为涉及端口占用问题，常常导致应用之间不能正常通信，建议使用Host-only和Bridge方式进行设置。" target="_blank" rel="noopener">http://localhost:8080时，Vagrant就会把这个请求转发到虚拟机里跑在80端口的nginx服务上。不建议使用该方法，因为涉及端口占用问题，常常导致应用之间不能正常通信，建议使用Host-only和Bridge方式进行设置。</a></p><p>guest和host是必须的，还有几个可选属性：</p><ul><li>guest_ip：字符串，vm指定绑定的Ip，缺省为0.0.0.0</li><li>host_ip：字符串，host指定绑定的Ip，缺省为0.0.0.0</li><li>protocol：字符串，可选TCP或UDP，缺省为TCP</li></ul><h5 id="2-6、定义vm的configure配置节点-一个节点就是一个虚拟机"><a href="#2-6、定义vm的configure配置节点-一个节点就是一个虚拟机" class="headerlink" title="2.6、定义vm的configure配置节点(一个节点就是一个虚拟机)"></a>2.6、定义vm的configure配置节点(一个节点就是一个虚拟机)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config.vm.define :mysql do |mysql_config|</span><br><span class="line">...</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>表示在config配置中，定义一个名为mysql的vm配置，该节点下的配置信息命名为mysql_config； 如果该Vagrantfile配置文件只定义了一个vm，这个配置节点层次可忽略。</p><p>还可以在一个Vagrantfile文件里建立多个虚拟机，一般情况下，你可以用多主机功能完成以下任务：</p><ul><li>分布式的服务，例如网站服务器和数据库服务器</li><li>分发系统</li><li>测试接口</li><li>灾难测试  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(&quot;2&quot;) do |config|</span><br><span class="line">  config.vm.define &quot;web&quot; do |web|</span><br><span class="line">    web.vm.box = &quot;apache&quot;</span><br><span class="line">  end</span><br><span class="line">  config.vm.define &quot;db&quot; do |db|</span><br><span class="line">    db.vm.box = &quot;mysql&quot;</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>当定义了多主机之后，在使用vagrant命令的时候，就需要加上主机名，例如vagrant ssh web；也有一些命令，如果你不指定特定的主机，那么将会对所有的主机起作用，比如vagrant up；你也可以使用表达式指定特定的主机名，例如vagrant up /follower[0-9]/。</p><h5 id="2-7、通用数据-设置一些基础数据，供配置信息中调用。"><a href="#2-7、通用数据-设置一些基础数据，供配置信息中调用。" class="headerlink" title="2.7、通用数据 设置一些基础数据，供配置信息中调用。"></a>2.7、通用数据 设置一些基础数据，供配置信息中调用。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app_servers = &#123;</span><br><span class="line">    :service1 =&gt; &apos;192.168.33.20&apos;,</span><br><span class="line">    :service2 =&gt; &apos;192.168.33.21&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是定义一个hashmap，以key-value方式来存储vm主机名和ip地址。</p><h5 id="2-8、配置信息"><a href="#2-8、配置信息" class="headerlink" title="2.8、配置信息"></a>2.8、配置信息</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ENV[&quot;LC_ALL&quot;] = &quot;en_US.UTF-8&quot;</span><br><span class="line">指定vm的语言环境，缺省地，会继承host的locale配置</span><br><span class="line">Vagrant.configure(&quot;2&quot;) do |config|</span><br><span class="line">    # ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>参数2，表示的是当前配置文件使用的vagrant configure版本号为Vagrant 1.1+,如果取值为1，表示为Vagrant 1.0.x Vagrantfiles，旧版本暂不考虑，记住就写2即可。</p><p>do … end 为配置的开始结束符，所有配置信息都写在这两段代码之间。 config是为当前配置命名，你可以指定任意名称，如myvmconfig，在后面引用的时候，改为自己的名字即可。</p><h5 id="2-9、vm提供者配置"><a href="#2-9、vm提供者配置" class="headerlink" title="2.9、vm提供者配置"></a>2.9、vm提供者配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config.vm.provider :virtualbox do |vb|</span><br><span class="line">     # ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h5 id="2-10-vm-provider通用配置"><a href="#2-10-vm-provider通用配置" class="headerlink" title="2.10 vm provider通用配置"></a>2.10 vm provider通用配置</h5><p>虚机容器提供者配置，对于不同的provider，特有的一些配置，此处配置信息是针对virtualbox定义一个提供者，命名为vb，跟前面一样，这个名字随意取，只要节点内部调用一致即可。</p><p>配置信息又分为通用配置和个性化配置，通用配置对于不同provider是通用的，常用的通用配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vb.name = &quot;centos7&quot;</span><br><span class="line"></span><br><span class="line">指定vm-name，也就是virtualbox管理控制台中的虚机名称。如果不指定该选项会生成一个随机的名字，不容易区分。</span><br><span class="line"></span><br><span class="line">vb.gui = true</span><br><span class="line"></span><br><span class="line">vagrant up启动时，是否自动打开virtual box的窗口，缺省为false</span><br><span class="line"></span><br><span class="line">vb.memory = &quot;1024&quot;</span><br><span class="line"></span><br><span class="line">指定vm内存，单位为MB</span><br><span class="line"></span><br><span class="line">vb.cpus = 2</span><br><span class="line"></span><br><span class="line">设置CPU个数</span><br></pre></td></tr></table></figure><h5 id="2-11-vm-provider个性化配置-virtualbox"><a href="#2-11-vm-provider个性化配置-virtualbox" class="headerlink" title="2.11 vm provider个性化配置(virtualbox)"></a>2.11 vm provider个性化配置(virtualbox)</h5><p>上面的provider配置是通用的配置，针对不同的虚拟机，还有一些的个性的配置，通过vb.customize配置来定制。</p><p>对virtual box的个性化配置，可以参考：VBoxManage modifyvm 命令的使用方法。详细的功能接口和使用说明，可以参考virtualbox官方文档。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">修改vb.name的值</span><br><span class="line">v.customize [&quot;modifyvm&quot;, :id, &quot;--name&quot;, &quot;mfsmaster2&quot;]</span><br><span class="line"></span><br><span class="line">如修改显存，缺省为8M，如果启动桌面，至少需要10M，如下修改为16M：</span><br><span class="line">vb.customize [&quot;modifyvm&quot;, :id, &quot;--vram&quot;, &quot;16&quot;]</span><br><span class="line"></span><br><span class="line">调整虚拟机的内存</span><br><span class="line">vb.customize [&quot;modifyvm&quot;, :id, &quot;--memory&quot;, &quot;1024&quot;]</span><br><span class="line"></span><br><span class="line">指定虚拟CPU个数</span><br><span class="line">vb.customize [&quot;modifyvm&quot;, :id, &quot;--cpus&quot;, &quot;2&quot;]</span><br><span class="line"></span><br><span class="line">增加光驱：</span><br><span class="line">vb.customize [&quot;storageattach&quot;,:id,&quot;--storagectl&quot;, &quot;IDE Controller&quot;,&quot;--port&quot;,&quot;0&quot;,&quot;--device&quot;,&quot;0&quot;,&quot;--type&quot;,&quot;dvddrive&quot;,&quot;--medium&quot;,&quot;/Applications/VirtualBox.app/Contents/MacOS/VBoxGuestAdditions.iso&quot;]</span><br><span class="line"></span><br><span class="line">注：meduim参数不可以为空，如果只挂载驱动器不挂在iso，指定为“emptydrive”。如果要卸载光驱，medium传入none即可。</span><br><span class="line">从这个指令可以看出，customize方法传入一个json数组，按照顺序传入参数即可。</span><br><span class="line"></span><br><span class="line">json数组传入多个参数</span><br><span class="line">v.customize [&quot;modifyvm&quot;, :id, &quot;--name&quot;, “mfsserver3&quot;, &quot;--memory&quot;, “2048&quot;]</span><br></pre></td></tr></table></figure><h5 id="2-12-一组相同配置的vm"><a href="#2-12-一组相同配置的vm" class="headerlink" title="2.12 一组相同配置的vm"></a>2.12 一组相同配置的vm</h5><p>前面配置了一组vm的hash map，定义一组vm时，使用如下节点遍历。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#遍历app_servers map，将key和value分别赋值给app_server_name和app_server_ip</span><br><span class="line">app_servers.each do |app_server_name, app_server_ip|</span><br><span class="line">#针对每一个app_server_name，来配置config.vm.define配置节点，命名为app_config</span><br><span class="line">    config.vm.define app_server_name do |app_config|</span><br><span class="line">#此处配置，参考config.vm.define</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>如果不想定义app_servers，下面也是一种方案:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(1..3).each do |i|</span><br><span class="line">        config.vm.define &quot;app-#&#123;i&#125;&quot; do |node|</span><br><span class="line">        app_config.vm.hostname = &quot;app-#&#123;i&#125;.vagrant.internal&quot;</span><br><span class="line">        app_config.vm.provider &quot;virtualbox&quot; do |vb|</span><br><span class="line">            vb.name = app-#&#123;i&#125;</span><br><span class="line">        end</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h5 id="2-13-provision任务"><a href="#2-13-provision任务" class="headerlink" title="2.13 provision任务"></a>2.13 provision任务</h5><p>你可以编写一些命令，让vagrant在启动虚拟机的时候自动执行，这样你就可以省去手动配置环境的时间了。</p><ul><li><p>脚本何时会被执行 </p><ul><li>第一次执行vagrant up命令</li><li>执行vagrant provision命令</li><li>执行vagrant reload –provision或者vagrant up –provision命令</li><li>你也可以在启动虚拟机的时候添加–no-provision参数以阻止脚本被执行</li></ul></li><li><p>provision任务是什么？</p></li></ul><p>provision任务是预先设置的一些操作指令，格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config.vm.provision 命令字 json格式参数</span><br><span class="line">config.vm.provion 命令字 do |s|</span><br><span class="line">    s.参数名 = 参数值</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>每一个 config.vm.provision 命令字 代码段，我们称之为一个provisioner。<br>根据任务操作的对象，provisioner可以分为：</p><ul><li>Shell</li><li>File</li><li>Ansible</li><li>CFEngine</li><li>Chef</li><li>Docker</li><li>Puppet</li><li>Salt</li></ul><p>根据vagrantfile的层次，分为：</p><p>configure级：它定义在 Vagrant.configure(“2”) 的下一层次，形如： config.vm.provision …</p><p>vm级：它定义在 config.vm.define “web” do |web| 的下一层次，web.vm.provision …</p><p>执行的顺序是先执行configure级任务，再执行vm级任务，即便configure级任务在vm定义的下面才定义。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(&quot;2&quot;) do |config|</span><br><span class="line">  config.vm.provision &quot;shell&quot;, inline: &quot;echo 1&quot;</span><br><span class="line"></span><br><span class="line">  config.vm.define &quot;web&quot; do |web|</span><br><span class="line">    web.vm.provision &quot;shell&quot;, inline: &quot;echo 2&quot;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  config.vm.provision &quot;shell&quot;, inline: &quot;echo 3&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">==&gt; default: &quot;1&quot;</span><br><span class="line">==&gt; default: &quot;2&quot;</span><br><span class="line">==&gt; default: &quot;3&quot;</span><br></pre></td></tr></table></figure><ul><li>如何使用</li></ul><p><strong>单行脚本</strong></p><p>helloword只是一个开始，对于inline模式，命令只能在写在一行中。</p><p>单行脚本使用的基本格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.provision &quot;shell&quot;, inline: &quot;echo fendo&quot;</span><br></pre></td></tr></table></figure><p>shell命令的参数还可以写入do … end代码块中，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config.vm.provision &quot;shell&quot; do |s|</span><br><span class="line">  s.inline = &quot;echo hello provision.&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><strong>内联脚本</strong></p><p>如果要执行脚本较多，可以在Vagrantfile中指定内联脚本，在Vagrant.configure节点外面，写入命名内联脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$script = &lt;&lt;SCRIPT</span><br><span class="line">echo I am provisioning...</span><br><span class="line">echo hello provision.</span><br><span class="line">SCRIPT</span><br></pre></td></tr></table></figure><p>然后，inline调用如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.provision &quot;shell&quot;, inline: $script</span><br></pre></td></tr></table></figure><p><strong>外部脚本</strong></p><p>也可以把代码写入代码文件，并保存在一个shell里，进行调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.provision &quot;shell&quot;, path: &quot;script.sh&quot;</span><br></pre></td></tr></table></figure><p>script.sh的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo hello provision.</span><br></pre></td></tr></table></figure><h4 id="3、网络模型选择"><a href="#3、网络模型选择" class="headerlink" title="3、网络模型选择"></a>3、网络模型选择</h4><h5 id="3-1-网络选型原则"><a href="#3-1-网络选型原则" class="headerlink" title="3.1 网络选型原则"></a>3.1 网络选型原则</h5><p>​        第一：每个网络只负载一种业务类型的数据流量，功能单一化。例如连接外网用一个网络、虚拟机之间互通用一个网络、虚拟机与主机之间互通又是一个网络。这样的话可使每种网络上的数据流量比较纯净，同时也可以避免因为网络故障而影响到全部的业务。</p><p>​    第二：在保证网络功能的前提下，单一的网络要保证最小的连通性、最大的隔离性。比如用于连接外网的网络，最好禁止掉连通宿主机，其它虚拟机这种额外的功能，可最大程序的提高效率。</p><p>​    第三：网络的独立性。当有多种技术可以达成某种网络功能时，选型时应选择对外部环境依赖程度最小、独立性最高的实现方式，避免因外宿主机换了一个无线网络环境，而影响到在宿主机上虚拟出来的网络。</p><p>​    第四：最后一条就是效率。当有多种选择时，数据流动路径最短的那一种，往住是效率最高的一种。</p><h5 id="3-2-四种网络模式连通性汇总列表"><a href="#3-2-四种网络模式连通性汇总列表" class="headerlink" title="3.2 四种网络模式连通性汇总列表"></a>3.2 四种网络模式连通性汇总列表</h5><p>“o”表示连接，“x”表示不通。前提条件是用VirtualBox创建出网络后，没有进行额外的配置，NAT网络没有进行端口映射、仅主机网络没有进行连接共享等。理论上，通过一定的技术手段，所有的模式对所有的网络都是可以连通的。</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/%E7%BD%91%E7%BB%9C/virtualBox-net-1.png" alt></p><h5 id="3-3-VirtualBox四种网络模式独立性"><a href="#3-3-VirtualBox四种网络模式独立性" class="headerlink" title="3.3 VirtualBox四种网络模式独立性"></a>3.3 VirtualBox四种网络模式独立性</h5><p>独立性即对外部环境依赖性，分成高、中，低三档，越高说明越依赖于外部环境。</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/%E7%BD%91%E7%BB%9C/virtualBox-net-2.png" alt></p><h5 id="3-4-四种网络模式的典型应用"><a href="#3-4-四种网络模式的典型应用" class="headerlink" title="3.4 四种网络模式的典型应用"></a>3.4 四种网络模式的典型应用</h5><p>例如想用VirtualBox创建虚拟机，以安装部署OpenStack,那么应该用VirtualBox创建四个网络，每个网络都有单独的目的，每种网络各司其职，同时对外部的依赖性降到最低。</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/%E7%BD%91%E7%BB%9C/virtualBox-net-3.png" alt></p><h4 id="4、远程登录"><a href="#4、远程登录" class="headerlink" title="4、远程登录"></a>4、远程登录</h4><p>本文选用的桥接网卡，虚拟机将与宿主机共享网络，在一个网络之中的设备（宿主机以及同一路由器下的设备）都能使用桥接网卡的ip地址远程登录到虚拟机中，端口默认22，可以自行修改。</p><p>在登陆之前需要修改虚拟机sshd配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line"><span class="meta">#</span> 修改项如下</span><br><span class="line">PasswordAuthentication=yes</span><br></pre></td></tr></table></figure><p>笔者宿主机ip为192.168.2.110</p><p>查看node1虚拟机桥接网卡ip为 192.168.2.112，因此执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 22 root@192.168.2.112</span><br></pre></td></tr></table></figure><p>输入密码完成登录。</p><p>参考：</p><p><a href="https://blog.csdn.net/u011781521/article/details/80291765" target="_blank" rel="noopener">Vagrant的配置文件Vagrantfile详解</a></p><p><a href="https://blog.csdn.net/dkfajsldfsdfsd/article/details/79444582" target="_blank" rel="noopener">VirtualBox四种网络模式及典型配置</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;vagrant是一个工具，用于创建和部署虚拟化开发环境的，能与virtualVM、virtualBox等虚拟机软件搭配使用。&lt;/p&gt;
&lt;p&gt;拿VirtualBox举例，VirtualBox会开放一个创建虚拟机的接口，Vagrant会利用这个接口创建虚拟机，并且通过Vagra
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/child/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JVM-元空间</title>
    <link href="http://yoursite.com/child/2019/11/06/JVM-%E5%85%83%E7%A9%BA%E9%97%B4/"/>
    <id>http://yoursite.com/child/2019/11/06/JVM-元空间/</id>
    <published>2019-11-05T16:00:00.000Z</published>
    <updated>2019-11-08T12:55:41.713Z</updated>
    
    <content type="html"><![CDATA[<p>基础概念：</p><ol><li><p><strong>方法区：</strong>jvm规范中的定义，指一片内存区域，用于存放加载到内存中的类信息、常量池等。</p></li><li><p><strong>永久代：</strong>JDK1.7（含）之前方法区的实现方式，使用永久代实现主要是为了把GC分代收集扩展至方法区，省去了专门为方法区编写内存管理代码的工作。</p></li><li><p><strong>元空间：</strong>JDK1.8（含）之后的方法区实现。</p></li><li><p><strong>instanceKlass ：</strong>java类的运行时结构数据，就是常说的类元数据，jvm底层C++实现，java应用程序不能直接访问该对象，而是通过java.lang.Class类的实例间接访问该部分信息。xx.class对象是java程序访问xx类instanceKlass 数据的接口，且xx.class对象其实是存在堆里的。</p></li><li><p><strong>指针压缩</strong></p><ul><li>64位平台上默认打开</li><li>设置-XX:+UseCompressedOops压缩对象指针， <strong>oops</strong>指的是普通对象指针(ordinary object pointers)， 会被压缩成32位。</li><li>设置-XX:+UseCompressedClassPointers压缩类指针，会被压缩成32位。</li></ul></li><li><p><strong>类指针压缩空间</strong>（Compressed Class Pointer Space）：对于64位平台，为了压缩JVM对象中的_klass指针的大小，引入了类指针压缩空间。</p><ul><li>只有是64位平台上启用了类指针压缩才会存在这个区域。</li><li>类指针压缩空间会有一个基地址</li></ul></li></ol><h3 id="1-永久代被取代"><a href="#1-永久代被取代" class="headerlink" title="1. 永久代被取代"></a>1. 永久代被取代</h3><p>Permanent Generation space是指内存的永久保存区域，用于存放Class和Meta的信息，类在被加载的时候被放入PermGen space区域，它和存放对象的堆区域不同，所以应用程序会加载很多类的话，就很可能出现永久代溢出错误，这种错误常见在web服务器对jsp进行预编译的时候。</p><h4 id="1-1-为什么移除持久代"><a href="#1-1-为什么移除持久代" class="headerlink" title="1.1 为什么移除持久代"></a>1.1 为什么移除持久代</h4><ul><li>永久代空间大小是在启动时固定好的——很难进行调优。-XX:MaxPermSize，设置成多少好呢？</li><li>HotSpot的内部类型也是Java对象：它可能会在Full GC中被移动，同时它对应用不透明，且是非强类型的，难以跟踪调试，还需要存储元数据的元数据信息（meta-metadata）。</li><li>简化Full GC：每一个回收器有专门的元数据迭代器。</li><li>可以在GC不进行暂停的情况下并发地释放类数据。</li><li>使得原来受限于持久代的一些改进未来有可能实现</li></ul><p>根据上面的各种原因，永久代最终被移除，<strong>方法区移至Metaspace，字符串常量移至Java Heap</strong>。</p><h4 id="1-2-移除持久代后，PermGen空间的状况"><a href="#1-2-移除持久代后，PermGen空间的状况" class="headerlink" title="1.2 移除持久代后，PermGen空间的状况"></a>1.2 移除持久代后，PermGen空间的状况</h4><ul><li>这部分内存空间将全部移除。</li><li>JVM的参数：-XX:PermSize 和-XX:MaxPermSize 会被忽略并给出警告（如果在启用时设置了这两个参数）。</li></ul><h3 id="2-元空间"><a href="#2-元空间" class="headerlink" title="2. 元空间"></a>2. 元空间</h3><p>随着JDK1.8的到来，JVM不再有PermGen。但类的元数据信息还在，只不过不再是存储在连续的堆空间上，而是移动到叫做“Metaspace”的本地内存（Native memory）中。</p><h4 id="2-1-Metaspace的组成"><a href="#2-1-Metaspace的组成" class="headerlink" title="2.1 Metaspace的组成"></a>2.1 Metaspace的组成</h4><ul><li><p><strong>Klass Metaspace</strong> </p><ul><li><p>这块内存最多只会存在一块，用来存 instanceKlass</p></li><li><p>这部分默认放在<strong>类指针压缩空间</strong>中，是一块连续的内存区域，和之前的perm一样紧接着Heap。通过<strong>-XX:CompressedClassSpaceSize</strong>来控制这块内存的大小，默认是1 G。</p></li></ul></li></ul><ul><li>但是这块内存不是必须的，如果设置了<strong>-XX:-UseCompressedClassPointers</strong>，或者<strong>-Xmx设置大于32 G</strong>，就不会有这块内存，这种情况下klass都会存在NoKlass Metaspace里。</li></ul><ul><li><p><strong>NoKlass Metaspace</strong>:</p><ul><li><p>用来存klass相关的其他的内容，比如method，constantPool等，这块内存是由多块内存组合起来的，所以可以认为是不连续的内存块组成的。</p></li><li><p>这块内存是必须的，虽然叫做NoKlass Metaspace，但是也其实可以存klass的内容，上面已经提到了对应场景。</p></li><li>NoKlass Metaspace在本地内存中分配。</li></ul></li></ul><p>Klass Metaspace和NoKlass Metaspace 都是所有class-loader共享的，所以类加载器们要分配内存，但是每个类加载器都有一个SpaceManager，来管理属于这个类加载的内存小块。如果Klass Metaspace用完了，那就会报OOM异常，不过一般情况下不会，NoKlass Metaspace是由一块块内存慢慢组合起来的，在没有达到限制条件的情况下，会不断加长这条链，让它可以持续工作。</p><h4 id="2-2-Metaspace的几个参数"><a href="#2-2-Metaspace的几个参数" class="headerlink" title="2.2 Metaspace的几个参数"></a>2.2 Metaspace的几个参数</h4><p>如果我们要改变Metaspace的一些行为，我们一般会对其相关的一些参数做调整，因为Metaspace的参数本身不是很多，所以我这里将涉及到的所有参数都做一个介绍。</p><ul><li><p>MetaspaceSize ：初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。 </p></li><li><p>MaxMetaspaceSize ：最大空间，默认是没有限制的。 </p></li><li><p>MinMetaspaceFreeRatio ：在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集 </p></li><li><p>MaxMetaspaceFreeRatio ：在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</p></li><li><p>CompressedClassSpaceSize ：默认1 G，这个参数主要是设置Klass Metaspace的大小，不过这个参数设置了也不一定起作用，前提是能开启压缩指针，假如-Xmx超过了32 G，压缩指针是开启不来的。如果有Klass Metaspace，那这块内存是和Heap连着的。</p></li><li><p>MinMetaspaceExpansion ：MinMetaspaceExpansion和MaxMetaspaceExpansion这两个参数或许和大家认识的并不一样，也许很多人会认为这两个参数不就是内存不够的时候，然后扩容的最小大小吗？其实不然</p><p>这两个参数和扩容其实并没有直接的关系，也就是并不是为了增大committed的内存，而是为了增大触发metaspace GC的阈值</p><p>这两个参数主要是在比较特殊的场景下救急使用，比如gcLocker或者<code>should_concurrent_collect</code>的一些场景，因为这些场景下接下来会做一次GC，相信在接下来的GC中可能会释放一些metaspace的内存，于是先临时扩大下metaspace触发GC的阈值，而有些内存分配失败其实正好是因为这个阈值触顶导致的，于是可以通过增大阈值暂时绕过去</p><p>默认332.8K，增大触发metaspace GC阈值的最小要求。假如我们要救急分配的内存很小，没有达到MinMetaspaceExpansion，但是我们会将这次触发metaspace GC的阈值提升MinMetaspaceExpansion，之所以要大于这次要分配的内存大小主要是为了防止别的线程也有类似的请求而频繁触发相关的操作，不过如果要分配的内存超过了MaxMetaspaceExpansion，那MinMetaspaceExpansion将会是要分配的内存大小基础上的一个增量</p></li><li><p>MaxMetaspaceExpansion ：默认5.2M，增大触发metaspace GC阈值的最大要求。假如说我们要分配的内存超过了MinMetaspaceExpansion但是低于MaxMetaspaceExpansion，那增量是MaxMetaspaceExpansion，如果超过了MaxMetaspaceExpansion，那增量是MinMetaspaceExpansion加上要分配的内存大小</p><p>注：每次分配只会给对应的线程一次扩展触发metaspace GC阈值的机会，如果扩展了，但是还不能分配，那就只能等着做GC了</p></li><li><p>UseLargePagesInMetaspace ：默认false，这个参数是说是否在metaspace里使用LargePage，一般情况下我们使用4 KB的page size，这个参数依赖于UseLargePages这个参数开启，不过这个参数我们一般不开。</p></li><li><p>InitialBootClassLoaderMetaspaceSize ：64位下默认4M，32位下默认2200K，metasapce前面已经提到主要分了两大块，Klass Metaspace以及NoKlass Metaspace，而NoKlass Metaspace是由一块块内存组合起来的，这个参数决定了NoKlass Metaspace的第一个内存Block的大小，即2*InitialBootClassLoaderMetaspaceSize，同时为bootstrapClassLoader的第一块内存chunk分配了InitialBootClassLoaderMetaspaceSize的大小</p></li></ul><h4 id="2-3-Metaspace内存管理"><a href="#2-3-Metaspace内存管理" class="headerlink" title="2.3  Metaspace内存管理"></a>2.3  Metaspace内存管理</h4><ol><li>在metaspace中，类和其元数据的生命周期与其对应的类加载器相同，只要类的类加载器是存活的，在Metaspace中的类元数据也是存活的，不能被回收。</li><li>每个加载器有单独的存储空间。</li><li>省掉了GC扫描及压缩的时间。</li><li>当GC发现某个类加载器不再存活了，会把对应的空间整个回收。</li></ol><p>参考文档：</p><p><a href="https://www.cnblogs.com/duanxz/p/3520829.html" target="_blank" rel="noopener">Metaspace 之一：Metaspace整体介绍（永久代被替换原因、元空间特点、元空间内存查看分析方法</a></p><p><a href="https://www.jianshu.com/p/92a5fbb33764" target="_blank" rel="noopener">JVM源码分析之Metaspace解密</a></p><p><a href="https://www.jianshu.com/p/1a0b4bf8d498" target="_blank" rel="noopener">JDK8 的FullGC 之 metaspace</a></p><p><a href="https://www.jianshu.com/p/a6f19189ec62" target="_blank" rel="noopener">JVM学习——元空间（Metaspace）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基础概念：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;方法区：&lt;/strong&gt;jvm规范中的定义，指一片内存区域，用于存放加载到内存中的类信息、常量池等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;永久代：&lt;/strong&gt;JDK1.7（含）之前方法区的实现
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/child/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>git-规范的commit message（转）</title>
    <link href="http://yoursite.com/child/2019/10/23/git-%E8%A7%84%E8%8C%83%E7%9A%84Commit%20Message/"/>
    <id>http://yoursite.com/child/2019/10/23/git-规范的Commit Message/</id>
    <published>2019-10-22T16:00:00.000Z</published>
    <updated>2019-11-08T12:55:43.084Z</updated>
    
    <content type="html"><![CDATA[<p>git上每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>(<span class="tag">&lt;<span class="name">scope</span>&gt;</span>): <span class="tag">&lt;<span class="name">subject</span>&gt;</span></span><br><span class="line">// 空一行</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">// 空一行</span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中，Header 是必需的，Body 和 Footer 可以省略。</p><p>不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。</p><h3 id="Header-必需"><a href="#Header-必需" class="headerlink" title="Header(必需)"></a>Header(必需)</h3><ul><li><p><strong>type(必需)</strong> 用于说明 commit 的类别</p><blockquote><ul><li>feat：新功能（feature）</li><li>fix：修补bug</li><li>docs：文档（documentation）</li><li>style： 格式（不影响代码运行的变动）</li><li>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</li><li>test：增加测试</li><li>chore：构建过程或辅助工具的变动</li><li>revert：用于以前的 commit，则必须以<code>revert:</code>开头，后面跟着被撤销 Commit 的 Header。</li></ul></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">revert: feat(pencil): add &apos;graphiteWidth&apos; option</span><br><span class="line"></span><br><span class="line">This reverts commit 667ecc1654a317a13331b17617d973392f415f02.</span><br></pre></td></tr></table></figure><p>Body部分的格式是固定的，必须写成<code>This reverts commit &amp;lt;hash&gt;.</code>，其中的<code>hash</code>是被撤销 commit 的 SHA 标识符。</p><p>如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的<code>Reverts</code>小标题下面。</p><p>如果<strong>type</strong>为<code>feat</code>和<code>fix</code>，则该 commit 将肯定出现在 Change log 之中。其他情况（<code>docs</code>、<code>chore</code>、<code>style</code>、<code>refactor</code>、<code>test</code>）由你决定，要不要放入 Change log，建议是不要。</p><p><strong>scope</strong> 用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p><p><strong>subject(必需)</strong> 是 commit 目的的简短描述，不超过50个字符。</p><blockquote><ul><li>以动词开头，使用第一人称现在时，比如<code>change</code>，而不是<code>changed</code>或<code>changes</code></li><li>第一个字母小写</li><li>结尾不加句号（<code>.</code>）</li></ul></blockquote><h3 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h3><p>Body 部分是对本次 commit 的详细描述，可以分成多行。</p><p>有两个注意点:</p><ul><li>使用第一人称现在时，比如使用<code>change</code>而不是<code>changed</code>或<code>changes</code>。</li><li>应该说明代码变动的动机，以及与以前行为的对比。</li></ul><h3 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h3><p>Footer 部分只用于两种情况。</p><ul><li><p><strong>不兼容变动</strong></p><p>如果当前代码与上一个版本不兼容，则 Footer 部分以<code>BREAKING CHANGE</code>开头，后面是对变动的描述、以及变动理由和迁移方法。</p></li><li><p><strong>关闭 Issue</strong></p><p>如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。</p><blockquote><p>Closes #234</p></blockquote><p>也可以一次关闭多个 issue 。</p><blockquote><p>Closes #123, #245, #992</p></blockquote></li></ul><p><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2016%2F01%2Fcommit_message_change_log.html" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;git上每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;l
      
    
    </summary>
    
    
      <category term="其他" scheme="http://yoursite.com/child/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>redis-总结精讲</title>
    <link href="http://yoursite.com/child/2019/09/02/reids-%E6%80%BB%E7%BB%93%E7%B2%BE%E8%AE%B2/"/>
    <id>http://yoursite.com/child/2019/09/02/reids-总结精讲/</id>
    <published>2019-09-01T16:00:00.000Z</published>
    <updated>2019-09-02T09:49:42.854Z</updated>
    
    <content type="html"><![CDATA[<p>本文围绕以下几个主题：</p><p>1、为什么使用redis<br>2、使用redis有什么缺点<br>3、单线程的redis为什么这么快<br>4、redis的数据类型，以及每种数据类型的使用场景<br>5、redis的过期策略以及内存淘汰机制<br>6、redis和数据库双写一致性问题<br>7、如何应对缓存穿透和缓存雪崩问题<br>8、如何解决redis的并发竞争问题</p><h3 id="1、为什么使用redis"><a href="#1、为什么使用redis" class="headerlink" title="1、为什么使用redis"></a>1、为什么使用redis</h3><p>在项目中使用redis，主要是从两个角度去考虑:<strong>性能</strong>和<strong>并发</strong>。当然redis还具备可以做分布式锁等其他功能，但是如果只是为了分布式锁这些其他功能，完全还有其他中间件(如zookpeer等)代替，并不是非要使用redis。因此，这个问题主要从性能和并发两个角度去答。</p><h4 id="1-1-性能"><a href="#1-1-性能" class="headerlink" title="1.1 性能"></a>1.1 性能</h4><p>如下图所示，我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够<strong>迅速响应</strong>。</p><p><strong>题外话：</strong>忽然想聊一下这个<strong>迅速响应</strong>的标准。其实根据交互效果的不同，这个响应时间没有固定标准。不过曾经有人这么告诉我:”在理想状态下，我们的页面跳转需要在<strong>瞬间</strong>解决，对于页内操作则需要在<strong>刹那</strong>间解决。另外，超过<strong>一弹指</strong>的耗时操作要有进度提示，并且可以随时中止或取消，这样才能给用户最好的体验。”<br>那么<strong>瞬间、刹那、一弹指</strong>具体是多少时间呢？<br>根据《摩诃僧祗律》记载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一刹那者为一念，二十念为一瞬，二十瞬为一弹指，二十弹指为一罗预，二十罗预为一须臾，一日一夜有三十须臾。</span><br></pre></td></tr></table></figure><p>那么，经过周密的计算，一<strong>瞬间</strong>为0.36 秒,一<strong>刹那</strong>有 0.018 秒.一<strong>弹指</strong>长达 7.2 秒。</p><h4 id="1-2-并发"><a href="#1-2-并发" class="headerlink" title="1.2 并发"></a>1.2 并发</h4><p>在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。</p><h3 id="2、使用redis有什么缺点"><a href="#2、使用redis有什么缺点" class="headerlink" title="2、使用redis有什么缺点"></a>2、使用redis有什么缺点</h3><p>基本上使用redis都会碰到一些问题，常见的也就几个。</p><ul><li>缓存和数据库双写一致性问题</li><li>缓存雪崩问题</li><li>缓存击穿问题</li><li>缓存的并发竞争问题</li></ul><p>这四个问题项目中比较常遇见，具体解决方案，后文给出。</p><h3 id="3、单线程的redis为什么这么快"><a href="#3、单线程的redis为什么这么快" class="headerlink" title="3、单线程的redis为什么这么快"></a>3、单线程的redis为什么这么快</h3><p>这个问题其实是对redis内部机制的一个考察，主要是以下三点</p><ul><li>纯内存操作</li><li>单线程操作，避免了频繁的上下文切换</li><li>采用了非阻塞<strong>I/O多路复用</strong></li></ul><h3 id="4、redis的数据类型，以及每种数据类型的使用场景"><a href="#4、redis的数据类型，以及每种数据类型的使用场景" class="headerlink" title="4、redis的数据类型，以及每种数据类型的使用场景"></a>4、redis的数据类型，以及每种数据类型的使用场景</h3><ol><li>String<br>这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做<strong>一些复杂的计数功能的缓存。</strong></li><li>hash<br>这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。在做<strong>单点登录</strong>的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。</li><li>list<br>使用List的数据结构，可以<strong>做简单的消息队列的功能</strong>。另外还有一个就是，可以利用lrange命令，<strong>做基于redis的分页功能</strong>，性能极佳，用户体验好。</li><li>set<br>因为set堆放的是一堆不重复值的集合。所以可以做<strong>全局去重的功能</strong>。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。<br>另外，就是利用交集、并集、差集等操作，可以<strong>计算共同喜好，全部的喜好，自己独有的喜好等功能</strong>。</li><li>sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做<strong>排行榜应用，取TOP N操作</strong>、<strong>延时任务</strong>、<strong>范围查找</strong>等。</li></ol><h3 id="5、redis的过期策略以及内存淘汰机制"><a href="#5、redis的过期策略以及内存淘汰机制" class="headerlink" title="5、redis的过期策略以及内存淘汰机制"></a>5、redis的过期策略以及内存淘汰机制</h3><p>redis采用的是<u><strong>定期删除+惰性删除</strong></u>策略。</p><h4 id="5-1-为什么不用定时删除策略"><a href="#5-1-为什么不用定时删除策略" class="headerlink" title="5.1 为什么不用定时删除策略"></a>5.1 为什么不用定时删除策略</h4><p>定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.</p><h4 id="5-2-定期删除-惰性删除是如何工作的"><a href="#5-2-定期删除-惰性删除是如何工作的" class="headerlink" title="5.2 定期删除+惰性删除是如何工作的"></a>5.2 定期删除+惰性删除是如何工作的</h4><p>定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。<br>于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。</p><h4 id="5-2-定期删除-惰性删除的问题"><a href="#5-2-定期删除-惰性删除的问题" class="headerlink" title="5.2 定期删除+惰性删除的问题"></a>5.2 定期删除+惰性删除的问题</h4><p>如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。</p><p>解决方法：采用<strong>内存淘汰机制</strong>。<br>在redis.conf中有一行配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-policy volatile-lru</span><br></pre></td></tr></table></figure><p>该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)</p><ul><li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。<strong>不推荐</strong></li><li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。<strong>推荐使用</strong></li><li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。<strong>不推荐</strong></li><li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。<strong>这种情况一般是把redis既当缓存，又做持久化存储的时候才用。</strong></li><li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。<strong>不推荐</strong></li><li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。<strong>不推荐</strong></li></ul><h3 id="6、redis和数据库双写一致性问题"><a href="#6、redis和数据库双写一致性问题" class="headerlink" title="6、redis和数据库双写一致性问题"></a>6、redis和数据库双写一致性问题</h3><p> 一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。答这个问题，先明白一个前提。就是<strong>如果对数据有强一致性要求，不能放缓存。</strong>我们所做的一切，只能保证最终一致性。另外，我们所做的方案其实从根本上来说，只能说<strong>降低不一致发生的概率</strong>，无法完全避免。因此，有强一致性要求的数据，不能放缓存。</p><p>首先，采取正确更新策略，<strong>先更新数据库，再删缓存</strong>。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。</p><h3 id="7、如何应对缓存穿透、缓存击穿和缓存雪崩问题"><a href="#7、如何应对缓存穿透、缓存击穿和缓存雪崩问题" class="headerlink" title="7、如何应对缓存穿透、缓存击穿和缓存雪崩问题"></a>7、如何应对缓存穿透、缓存击穿和缓存雪崩问题</h3><h4 id="7-1-缓存穿透"><a href="#7-1-缓存穿透" class="headerlink" title="7.1 缓存穿透"></a>7.1 缓存穿透</h4><p>缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大</p><p>解决方案：</p><ol><li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</li><li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</li></ol><h4 id="7-2-缓存击穿"><a href="#7-2-缓存击穿" class="headerlink" title="7.2 缓存击穿"></a>7.2 缓存击穿</h4><p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力</p><p>解决方案：</p><ol><li>设置热点数据永远不过期。</li><li>加互斥锁</li></ol><h4 id="7-3-缓存雪崩"><a href="#7-3-缓存雪崩" class="headerlink" title="7.3 缓存雪崩"></a>7.3 缓存雪崩</h4><p>缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，        缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p><p>解决方案：</p><ol><li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li><li>如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。</li><li>设置热点数据永远不过期。</li></ol><h3 id="8、如何解决redis的并发竞争问题"><a href="#8、如何解决redis的并发竞争问题" class="headerlink" title="8、如何解决redis的并发竞争问题"></a>8、如何解决redis的并发竞争问题</h3><p>这个问题大致就是，同时有多个子系统去set一个key。这个时候要注意什么呢？大家思考过么。需要说明一下，博主提前百度了一下，发现答案基本都是推荐用redis事务机制。博主<strong>不推荐使用redis的事务机制。</strong>因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，<strong>redis的事务机制，十分鸡肋。</strong></p><ol><li>如果对这个key操作，<strong>不要求顺序</strong><br>这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。</li><li>如果对这个key操作，<strong>要求顺序</strong><br>假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC.<br>期望按照key1的value值按照 valueA–&gt;valueB–&gt;valueC的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。假设时间戳如下</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">系统A key 1 &#123;valueA  3:00&#125;</span><br><span class="line">系统B key 1 &#123;valueB  3:05&#125;</span><br><span class="line">系统C key 1 &#123;valueC  3:10&#125;</span><br></pre></td></tr></table></figure><p>那么，假设系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。</p><p>其他方法，比如利用队列，将set方法变成串行访问也可以。总之，灵活变通。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文围绕以下几个主题：&lt;/p&gt;
&lt;p&gt;1、为什么使用redis&lt;br&gt;2、使用redis有什么缺点&lt;br&gt;3、单线程的redis为什么这么快&lt;br&gt;4、redis的数据类型，以及每种数据类型的使用场景&lt;br&gt;5、redis的过期策略以及内存淘汰机制&lt;br&gt;6、redis和数
      
    
    </summary>
    
    
      <category term="redis" scheme="http://yoursite.com/child/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis-缓存数据库双写一致性方案解析</title>
    <link href="http://yoursite.com/child/2019/09/02/redis-%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>http://yoursite.com/child/2019/09/02/redis-缓存数据库双写一致性/</id>
    <published>2019-09-01T16:00:00.000Z</published>
    <updated>2019-09-04T07:03:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>从理论上来说，设置过期时间是保证缓存数据库最终一致性的解决方案。在这种方案下，我们可以对存入缓存的数据设置过期时间，所有写操作以数据库为准，对缓存操作知识尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，后面的请求自然会从数据库中读取新值然后填回缓存。因此，接下来讨论的思路不依赖于给缓存设置过期时间这个方案。</p><p>本文讨论三种更新策略：</p><ul><li>先更新数据库，再更新缓存</li><li>先删除缓存，再更新数据库</li><li>先更新数据库，再删除缓存</li></ul><p>没有先更新缓存再更新数据库的方案，因为所有的写操作要以数据库为准，这种情况下若更新数据库失败，缓存失效后再次读数据库将取得旧值。</p><h3 id="1、先更新数据库，再更新缓存"><a href="#1、先更新数据库，再更新缓存" class="headerlink" title="1、先更新数据库，再更新缓存"></a>1、先更新数据库，再更新缓存</h3><p>该方案从<strong>线程安全角度</strong>看</p><p>假设同时有请求A和请求B进行更新操作，如下图所示的情况下最终数据库中的数据是B请求的数据，缓存中的数据数A请求的数据，最终出现了不一致的情况。这种情况因为网络情况等原因是可能出现的</p><p><img src="https://wx2.sinaimg.cn/large/87c9e458ly1g6nhtih33dj20fj05aq2v.jpg" alt="更更"></p><p>该方案从<strong>业务场景角度</strong>看</p><ol><li>如果是一个写多读少的场景，使用这种方案会导致数据压根没读到，缓存就被频繁的更新，浪费性能</li><li>如果写入db的值需要经过一系列复杂的计算再写入缓存，那么每次写入缓存前都需要计算缓存值，无疑是在浪费性能</li></ol><p>所以，更新缓存不可取，删除缓存更合适。</p><h3 id="2、先删除缓存，再更新数据库"><a href="#2、先删除缓存，再更新数据库" class="headerlink" title="2、先删除缓存，再更新数据库"></a>2、先删除缓存，再更新数据库</h3><p>首先看该方案会导致不一致的情况：</p><p><img src="https://ws1.sinaimg.cn/large/87c9e458ly1g6nhu1u8qjj20fs0663yi.jpg" alt="删更"></p><p>这种情况就会导致不一致的情形出现，而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。</p><p>那么，<strong>如何解决呢？</strong></p><p><strong>延时双删策略</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String key,Object data)</span></span>&#123;</span><br><span class="line">        redis.delKey(key);</span><br><span class="line">        db.updateData(data);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        redis.delKey(key);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：<br>（1）先淘汰缓存<br>（2）再写数据库<br>（3）休眠1秒，再次淘汰缓存<br>这么做，可以将1秒内所造成的缓存脏数据，再次删除。<br><strong>那么，这个1秒怎么确定的，具体该休眠多久呢？</strong><br>针对上面的情形，读者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p><h3 id="3、先更新数据库，再删除缓存"><a href="#3、先更新数据库，再删除缓存" class="headerlink" title="3、先更新数据库，再删除缓存"></a>3、先更新数据库，再删除缓存</h3><p>首先，先说一下。老外提出了一个缓存更新套路，名为<a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside" target="_blank" rel="noopener">《Cache-Aside pattern》</a>。其中就指出</p><ul><li><strong>失效</strong>：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li><li><strong>命中</strong>：应用程序从cache中取数据，取到后返回。</li><li><strong>更新</strong>：先把数据存到数据库中，成功后，再让缓存失效。</li></ul><p>另外，知名社交网站facebook也在论文<a href="https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf" target="_blank" rel="noopener">《Scaling Memcache at Facebook》</a>中提出，他们用的也是先更新数据库，再删缓存的策略。</p><p><strong>这种情况不存在并发问题么？</strong><br>不是的。假设这会有两个请求，一个请求A做更新操作，一个请求B做查询操作，那么会有如下情形产生<br><img src="https://wx1.sinaimg.cn/large/87c9e458ly1g6nhuewolbj20fs066dfv.jpg" alt="更删"><br>如果发生上述情况，确实是会发生脏数据。</p><p><strong>然而，发生这种情况的必要条件是</strong><br>1、B读db时A还没有完成写db，这样B才能读到旧数据</p><p>2、A写db比B读db先完成，这样A才会在B更新缓存之前删缓存</p><p>因此只有在B请求读db成功但还没有更新缓存之前，A请求更新db结束并执行了删缓存操作，才有可能发生以上的情况，这个方案较第二种方案产生不一致的概率低很多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从理论上来说，设置过期时间是保证缓存数据库最终一致性的解决方案。在这种方案下，我们可以对存入缓存的数据设置过期时间，所有写操作以数据库为准，对缓存操作知识尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，后面的请求自然会从数据库中读取新值然后填回
      
    
    </summary>
    
    
      <category term="redis" scheme="http://yoursite.com/child/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis-键空间通知</title>
    <link href="http://yoursite.com/child/2019/08/02/redis-%E9%94%AE%E7%A9%BA%E9%97%B4%E9%80%9A%E7%9F%A5/"/>
    <id>http://yoursite.com/child/2019/08/02/redis-键空间通知/</id>
    <published>2019-08-01T16:00:00.000Z</published>
    <updated>2019-11-30T09:08:23.770Z</updated>
    
    <content type="html"><![CDATA[<p>需求：redis中缓存了一些状态量，业务需要时刻关注状态量变化</p><p>方案一：轮询检查（各方面性能太差）</p><p>方案二：redis提供的键空间通知机制（redis主动推送，优选）</p><h3 id="1、发布与订阅"><a href="#1、发布与订阅" class="headerlink" title="1、发布与订阅"></a>1、发布与订阅</h3><p><a href="http://doc.redisfans.com/pub_sub/subscribe.html#subscribe" target="_blank" rel="noopener"><em>SUBSCRIBE</em></a> /<a href="http://doc.redisfans.com/pub_sub/unsubscribe.html#unsubscribe" target="_blank" rel="noopener"><em>UNSUBSCRIBE</em></a>/<a href="http://doc.redisfans.com/pub_sub/publish.html#publish" target="_blank" rel="noopener"><em>PUBLISH</em></a> 三个命令实现了发布与订阅信息泛型（Publish/Subscribe messaging paradigm)，在这个实现中，发送者（发送信息的客户端）不是将信息直接发送给特定的接收者（接收信息的客户端），而是将信息发送给频道（channel），然后由频道将信息转发给所有对这个频道感兴趣的订阅者。</p><p>发送者无须知道任何关于订阅者的信息，而订阅者也无须知道是那个客户端给它发送信息，它只要关注自己感兴趣的频道即可。</p><p>对发布者和订阅者进行解构，可以极大地提高系统的扩展性，并得到一个更动态的网络拓扑。</p><p>比如说，要订阅频道 <code>foo</code> 和 <code>bar</code> ，客户端可以使用频道名字作为参数来调用 <em>SUBSCRIBE</em> 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE foo bar</span><br></pre></td></tr></table></figure><p>当有客户端发送信息到这些频道时，Redis 会将传入的信息推送到所有订阅这些频道的客户端里面。</p><p>正在订阅频道的客户端不应该发送除 <em>SUBSCRIBE</em> 和 <em>UNSUBSCRIBE</em> 之外的其他命令。 其中，<em>SUBSCRIBE</em> 可以用于订阅更多频道，而 <em>UNSUBSCRIBE</em> 则可以用于退订已订阅的一个或多个频道。</p><p><em>SUBSCRIBE</em> 和 <em>UNSUBSCRIBE</em>的执行结果会以信息的形式返回，客户端可以通过分析所接收信息的第一个元素，从而判断所收到的内容是一条真正的信息，还是 <em>SUBSCRIBE</em> 或 <em>UNSUBSCRIBE</em> 命令的操作结果。</p><h4 id="1-1-信息格式"><a href="#1-1-信息格式" class="headerlink" title="1.1 信息格式"></a>1.1 信息格式</h4><p>频道转发的每条信息都是一条带有三个元素的多条批量回复。</p><ul><li><p>第一个元素标识了信息的类型，有以下三种类型：</p><ul><li>subscribe： 表示当前客户端成功地订阅了信息第二个元素所指示的频道，而此时信息的第三个元素则记录了目前客户端已订阅频道的总数。</li><li>unsubscribe： 表示当前客户端成功地退订了信息第二个元素所指示的频道，而此时信息的第三个元素记录了客户端目前仍在订阅的频道数量。 当客户端订阅的频道数量降为 <code>0</code> 时，客户端不再订阅任何频道，它可以像往常一样，执行任何 Redis 命令。</li><li>message： 表示这条信息是由某个客户端执行 <em>PUBLISH</em> 命令所发送的，真正的信息。 </li></ul></li><li><p>第二个元素是信息来源的频道。</p></li><li><p>第三个元素则是信息的内容。</p></li></ul><h4 id="1-2-订阅模式"><a href="#1-2-订阅模式" class="headerlink" title="1.2 订阅模式"></a>1.2 订阅模式</h4><p>Redis 的发布与订阅实现支持模式匹配： 客户端可以订阅一个带 <code>*</code> 号的模式，如果某些频道的名字和这个模式匹配，那么当有信息发送给这个/这些频道的时候，客户端也会收到这个/这些频道的信息。</p><p>比如说，执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PSUBSCRIBE news.*</span><br></pre></td></tr></table></figure><p>的客户端将收到来自 <code>news.art.figurative</code> 、 <code>news.music.jazz</code> 等频道的信息。</p><p>客户端订阅的模式里面可以包含多个 glob 风格的通配符，比如 <code>*</code> 、 <code>?</code> 和 <code>[...]</code> ，等等。</p><p>执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUNSUBSCRIBE news.*</span><br></pre></td></tr></table></figure><p>将退订 <code>news.*</code> 模式，其他已订阅的模式不会被影响。</p><p>通过订阅模式接收到的信息，和通过订阅频道接收到的信息，两者的格式不太一样：</p><p>通过订阅模式而接收到的信息的类型为 <code>pmessage</code> ： 这代表有某个客户端通过 <em>PUBLISH</em> 向某个频道发送了信息，而这个频道刚好匹配了当前客户端所订阅的某个模式。 信息的第二个元素记录了被匹配的模式，第三个元素记录了被匹配的频道的名字，最后一个元素则记录了信息的实际内容。</p><p>客户端处理 <em>PSUBSCRIBE</em> 和 <em>PUNSUBSCRIBE</em> 返回值的方式，和客户端处理 <em>SUBSCRIBE</em> 和 <em>UNSUBSCRIBE</em> 的方式类似： 通过对信息的第一个元素进行分析，客户端可以判断接收到的信息是一个真正的信息，还是 <em>PSUBSCRIBE</em> 或 <em>PUNSUBSCRIBE</em> 命令的返回值。</p><h3 id="2、发布什么"><a href="#2、发布什么" class="headerlink" title="2、发布什么"></a>2、发布什么</h3><p>键空间通知使得客户端可以通过订阅频道或模式，来接收那些以某种方式改动了 Redis 数据集的事件。</p><p>以下是一些键空间通知发送的事件的例子：</p><ul><li>所有修改键的命令。</li><li>所有接收到 <em>LPUSH</em> 命令的键。</li><li><code>0</code> 号数据库中所有已过期的键。</li></ul><p>事件通过 Redis 的订阅与发布功能（pub/sub）来进行分发，因此所有支持订阅与发布功能的客户端都可以在无须做任何修改的情况下，直接使用键空间通知功能。</p><p>因为 Redis 目前的订阅与发布功能采取的是发送即忘策略，所以如果你的程序需要可靠事件通知，那么目前的键空间通知可能并不适合你： 当订阅事件的客户端断线时，它会丢失所有在断线期间分发给它的事件。</p><p>未来将会支持更可靠的事件分发，这种支持可能会通过让订阅与发布功能本身变得更可靠来实现，也可能会在 Lua 脚本中对消息的订阅与发布进行监听，从而实现类似将事件推入到列表这样的操作。</p><h4 id="2-1-通知类型"><a href="#2-1-通知类型" class="headerlink" title="2.1 通知类型"></a>2.1 通知类型</h4><p>对于每个修改数据库的操作，键空间通知都会发送两种不同类型的事件。</p><p>比如说，对 <code>0</code> 号数据库的键 <code>mykey</code> 执行 <em>DEL</em> 命令时，系统将分发两条消息，相当于执行以下两个 <em>PUBLISH</em> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH __keyspace@0__:mykey del</span><br><span class="line">PUBLISH __keyevent@0__:del mykey</span><br></pre></td></tr></table></figure><p>订阅第一个频道 <code>__keyspace@0__:mykey</code> 可以接收 <code>0</code> 号数据库中所有修改键 <code>mykey</code> 的事件，而订阅第二个频道 <code>__keyevent@0__:del</code>则可以接收 <code>0</code> 号数据库中所有执行 <code>del</code> 命令的键。</p><p>以 <code>keyspace</code> 为前缀的频道被称为<strong>键空间通知</strong>，而以 <code>keyevent</code> 为前缀的频道则被称为<strong>键事件通知</strong>。</p><p>当 <code>del mykey</code> 命令执行时：</p><ul><li>键空间频道的订阅者将接收到被执行的事件的名字，在这个例子中，就是 <code>del</code> 。</li><li>键事件频道的订阅者将接收到被执行事件的键的名字，在这个例子中，就是 <code>mykey</code> 。</li></ul><h4 id="2-2-配置"><a href="#2-2-配置" class="headerlink" title="2.2 配置"></a>2.2 配置</h4><p>因为开启键空间通知功能需要消耗一些 CPU ，所以在默认配置下，该功能处于关闭状态。</p><p>可以通过修改 <code>redis.conf</code> 文件（<strong>重启生效且一直有效</strong>），或者直接使用 <code>CONFIG SET</code> 命令（<strong>立即生效且重启失效</strong>）来开启或关闭键空间通知功能：</p><ul><li>当 <code>notify-keyspace-events</code> 选项的参数为空字符串时，功能关闭。</li><li>另一方面，当参数不是空字符串时，功能开启。</li></ul><p><code>notify-keyspace-events</code> 的参数可以是以下字符的任意组合，它指定了服务器该发送哪些类型的通知：</p><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">发送的通知</th></tr></thead><tbody><tr><td style="text-align:left"><code>K</code></td><td style="text-align:left">键空间通知，所有通知以 <code>__keyspace@&lt;db&gt;__</code> 为前缀</td></tr><tr><td style="text-align:left"><code>E</code></td><td style="text-align:left">键事件通知，所有通知以 <code>__keyevent@&lt;db&gt;__</code> 为前缀</td></tr><tr><td style="text-align:left"><code>g</code></td><td style="text-align:left"><code>DEL</code> 、 <code>EXPIRE</code> 、 <code>RENAME</code> 等类型无关的通用命令的通知</td></tr><tr><td style="text-align:left"><code>$</code></td><td style="text-align:left">字符串命令的通知</td></tr><tr><td style="text-align:left"><code>l</code></td><td style="text-align:left">列表命令的通知</td></tr><tr><td style="text-align:left"><code>s</code></td><td style="text-align:left">集合命令的通知</td></tr><tr><td style="text-align:left"><code>h</code></td><td style="text-align:left">哈希命令的通知</td></tr><tr><td style="text-align:left"><code>z</code></td><td style="text-align:left">有序集合命令的通知</td></tr><tr><td style="text-align:left"><code>x</code></td><td style="text-align:left">过期事件：每当有过期键被删除时发送</td></tr><tr><td style="text-align:left"><code>e</code></td><td style="text-align:left">驱逐(evict)事件：每当有键因为 <code>maxmemory</code> 政策而被删除时发送</td></tr><tr><td style="text-align:left"><code>A</code></td><td style="text-align:left">参数 <code>g$lshzxe</code> 的别名</td></tr></tbody></table><p>输入的参数中至少要有一个 <code>K</code> 或者 <code>E</code> ，否则的话，不管其余的参数是什么，都不会有任何通知被分发。</p><p>举个例子，如果只想订阅键空间中和列表相关的通知，那么参数就应该设为 <code>Kl</code> ，诸如此类。</p><p>将参数设为字符串 <code>&quot;AKE&quot;</code> 表示发送所有类型的通知。</p><h4 id="2-3-过期通知的发送时间"><a href="#2-3-过期通知的发送时间" class="headerlink" title="2.3 过期通知的发送时间"></a>2.3 过期通知的发送时间</h4><p>我们已经了解了redis的键过期机制为 定期删除 + 惰性删除：</p><ul><li>当一个键被访问时，程序会对这个键进行检查，如果键已经过期，那么该键将被删除。</li><li>底层系统会在后台渐进地查找并删除那些过期的键，从而处理那些已经过期、但是不会被访问到的键。</li></ul><p>当过期键被以上两个程序的任意一个发现、 并且将键从数据库中删除时，Redis 会产生一个 <code>expired</code> 通知。</p><p>Redis 并不保证生存时间（TTL）变为 <code>0</code> 的键会立即被删除： 如果程序没有访问这个过期键，或者带有生存时间的键非常多的话，那么在键的生存时间变为 <code>0</code> ，直到键真正被删除这中间，可能会有一段比较显著的时间间隔。</p><p>因此，Redis 产生 <code>expired</code> 通知的时间为过期键被删除的时候，而不是键的生存时间变为 <code>0</code> 的时候。命令产生的通知</p><h4 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h4><p>以下列表记录了不同命令所产生的不同通知：</p><ul><li><a href="http://doc.redisfans.com/key/del.html#del" target="_blank" rel="noopener"><em>DEL</em></a> 命令为每个被删除的键产生一个 <code>del</code> 通知。</li><li><a href="http://doc.redisfans.com/key/rename.html#rename" target="_blank" rel="noopener"><em>RENAME</em></a> 产生两个通知：为来源键（source key）产生一个 <code>rename_from</code> 通知，并为目标键（destination key）产生一个 <code>rename_to</code> 通知。</li><li><a href="http://doc.redisfans.com/key/expire.html#expire" target="_blank" rel="noopener"><em>EXPIRE</em></a> 和 <a href="http://doc.redisfans.com/key/expireat.html#expireat" target="_blank" rel="noopener"><em>EXPIREAT</em></a> 在键被正确设置过期时间时产生一个 <code>expire</code> 通知。当 <a href="http://doc.redisfans.com/key/expireat.html#expireat" target="_blank" rel="noopener"><em>EXPIREAT</em></a> 设置的时间已经过期，或者 <a href="http://doc.redisfans.com/key/expire.html#expire" target="_blank" rel="noopener"><em>EXPIRE</em></a> 传入的时间为负数值时，键被删除，并产生一个 <code>del</code> 通知。</li><li>每当一个键因为过期而被删除时，产生一个 <code>expired</code> 通知。</li><li><a href="http://doc.redisfans.com/key/sort.html#sort" target="_blank" rel="noopener"><em>SORT</em></a> 在命令带有 <code>STORE</code> 参数时产生一个 <code>sortstore</code> 事件。如果 <code>STORE</code> 指示的用于保存排序结果的键已经存在，那么程序还会发送一个 <code>del</code> 事件。</li><li><a href="http://doc.redisfans.com/string/set.html#set" target="_blank" rel="noopener"><em>SET</em></a> 以及它的所有变种（<a href="http://doc.redisfans.com/string/setex.html#setex" target="_blank" rel="noopener"><em>SETEX</em></a> 、 <a href="http://doc.redisfans.com/string/setnx.html#setnx" target="_blank" rel="noopener"><em>SETNX</em></a> 和 <a href="http://doc.redisfans.com/string/getset.html#getset" target="_blank" rel="noopener"><em>GETSET</em></a>）都产生 <code>set</code> 通知。其中 <a href="http://doc.redisfans.com/string/setex.html#setex" target="_blank" rel="noopener"><em>SETEX</em></a> 还会产生 <code>expire</code> 通知。</li><li><a href="http://doc.redisfans.com/string/mset.html#mset" target="_blank" rel="noopener"><em>MSET</em></a> 为每个键产生一个 <code>set</code> 通知。</li><li><a href="http://doc.redisfans.com/string/setrange.html#setrange" target="_blank" rel="noopener"><em>SETRANGE</em></a> 产生一个 <code>setrange</code> 通知。</li><li><a href="http://doc.redisfans.com/string/incr.html#incr" target="_blank" rel="noopener"><em>INCR</em></a> 、 <a href="http://doc.redisfans.com/string/decr.html#decr" target="_blank" rel="noopener"><em>DECR</em></a> 、 <a href="http://doc.redisfans.com/string/incrby.html#incrby" target="_blank" rel="noopener"><em>INCRBY</em></a> 和 <a href="http://doc.redisfans.com/string/decrby.html#decrby" target="_blank" rel="noopener"><em>DECRBY</em></a> 都产生 <code>incrby</code> 通知。</li><li><a href="http://doc.redisfans.com/string/incrbyfloat.html#incrbyfloat" target="_blank" rel="noopener"><em>INCRBYFLOAT</em></a> 产生 <code>incrbyfloat</code> 通知。</li><li><a href="http://doc.redisfans.com/string/append.html#append" target="_blank" rel="noopener"><em>APPEND</em></a> 产生 <code>append</code> 通知。</li><li><a href="http://doc.redisfans.com/list/lpush.html#lpush" target="_blank" rel="noopener"><em>LPUSH</em></a> 和 <a href="http://doc.redisfans.com/list/lpushx.html#lpushx" target="_blank" rel="noopener"><em>LPUSHX</em></a> 都产生单个 <code>lpush</code> 通知，即使有多个输入元素时，也是如此。</li><li><a href="http://doc.redisfans.com/list/rpush.html#rpush" target="_blank" rel="noopener"><em>RPUSH</em></a> 和 <a href="http://doc.redisfans.com/list/rpushx.html#rpushx" target="_blank" rel="noopener"><em>RPUSHX</em></a> 都产生单个 <code>rpush</code> 通知，即使有多个输入元素时，也是如此。</li><li><a href="http://doc.redisfans.com/list/rpop.html#rpop" target="_blank" rel="noopener"><em>RPOP</em></a> 产生 <code>rpop</code> 通知。如果被弹出的元素是列表的最后一个元素，那么还会产生一个 <code>del</code> 通知。</li><li><a href="http://doc.redisfans.com/list/lpop.html#lpop" target="_blank" rel="noopener"><em>LPOP</em></a> 产生 <code>lpop</code> 通知。如果被弹出的元素是列表的最后一个元素，那么还会产生一个 <code>del</code> 通知。</li><li><a href="http://doc.redisfans.com/list/linsert.html#linsert" target="_blank" rel="noopener"><em>LINSERT</em></a> 产生一个 <code>linsert</code> 通知。</li><li><a href="http://doc.redisfans.com/list/lset.html#lset" target="_blank" rel="noopener"><em>LSET</em></a> 产生一个 <code>lset</code> 通知。</li><li><a href="http://doc.redisfans.com/list/ltrim.html#ltrim" target="_blank" rel="noopener"><em>LTRIM</em></a> 产生一个 <code>ltrim</code> 通知。如果 <a href="http://doc.redisfans.com/list/ltrim.html#ltrim" target="_blank" rel="noopener"><em>LTRIM</em></a> 执行之后，列表键被清空，那么还会产生一个 <code>del</code> 通知。</li><li><a href="http://doc.redisfans.com/list/rpoplpush.html#rpoplpush" target="_blank" rel="noopener"><em>RPOPLPUSH</em></a> 和 <a href="http://doc.redisfans.com/list/brpoplpush.html#brpoplpush" target="_blank" rel="noopener"><em>BRPOPLPUSH</em></a> 产生一个 <code>rpop</code> 通知，以及一个 <code>lpush</code> 通知。两个命令都会保证 <code>rpop</code> 的通知在 <code>lpush</code> 的通知之前分发。如果从键弹出元素之后，被弹出的列表键被清空，那么还会产生一个 <code>del</code> 通知。</li><li><a href="http://doc.redisfans.com/hash/hset.html#hset" target="_blank" rel="noopener"><em>HSET</em></a> 、 <a href="http://doc.redisfans.com/hash/hsetnx.html#hsetnx" target="_blank" rel="noopener"><em>HSETNX</em></a> 和 <a href="http://doc.redisfans.com/hash/hmset.html#hmset" target="_blank" rel="noopener"><em>HMSET</em></a> 都只产生一个 <code>hset</code> 通知。</li><li><a href="http://doc.redisfans.com/hash/hincrby.html#hincrby" target="_blank" rel="noopener"><em>HINCRBY</em></a> 产生一个 <code>hincrby</code> 通知。</li><li><a href="http://doc.redisfans.com/hash/hincrbyfloat.html#hincrbyfloat" target="_blank" rel="noopener"><em>HINCRBYFLOAT</em></a> 产生一个 <code>hincrbyfloat</code> 通知。</li><li><a href="http://doc.redisfans.com/hash/hdel.html#hdel" target="_blank" rel="noopener"><em>HDEL</em></a> 产生一个 <code>hdel</code> 通知。如果执行 <a href="http://doc.redisfans.com/hash/hdel.html#hdel" target="_blank" rel="noopener"><em>HDEL</em></a> 之后，哈希键被清空，那么还会产生一个 <code>del</code> 通知。</li><li><a href="http://doc.redisfans.com/set/sadd.html#sadd" target="_blank" rel="noopener"><em>SADD</em></a> 产生一个 <code>sadd</code> 通知，即使有多个输入元素时，也是如此。</li><li><a href="http://doc.redisfans.com/set/srem.html#srem" target="_blank" rel="noopener"><em>SREM</em></a> 产生一个 <code>srem</code> 通知，如果执行 <a href="http://doc.redisfans.com/set/srem.html#srem" target="_blank" rel="noopener"><em>SREM</em></a> 之后，集合键被清空，那么还会产生一个 <code>del</code> 通知。</li><li><a href="http://doc.redisfans.com/set/smove.html#smove" target="_blank" rel="noopener"><em>SMOVE</em></a> 为来源键（source key）产生一个 <code>srem</code> 通知，并为目标键（destination key）产生一个 <code>sadd</code> 事件。</li><li><a href="http://doc.redisfans.com/set/spop.html#spop" target="_blank" rel="noopener"><em>SPOP</em></a> 产生一个 <code>spop</code> 事件。如果执行 <a href="http://doc.redisfans.com/set/spop.html#spop" target="_blank" rel="noopener"><em>SPOP</em></a> 之后，集合键被清空，那么还会产生一个 <code>del</code> 通知。</li><li><a href="http://doc.redisfans.com/set/sinterstore.html#sinterstore" target="_blank" rel="noopener"><em>SINTERSTORE</em></a> 、 <a href="http://doc.redisfans.com/set/sunionstore.html#sunionstore" target="_blank" rel="noopener"><em>SUNIONSTORE</em></a> 和 <a href="http://doc.redisfans.com/set/sdiffstore.html#sdiffstore" target="_blank" rel="noopener"><em>SDIFFSTORE</em></a> 分别产生 <code>sinterstore</code> 、 <code>sunionostore</code> 和 <code>sdiffstore</code> 三种通知。如果用于保存结果的键已经存在，那么还会产生一个 <code>del</code> 通知。</li><li><a href="http://doc.redisfans.com/sorted_set/zincrby.html#zincrby" target="_blank" rel="noopener"><em>ZINCRBY</em></a> 产生一个 <code>zincr</code> 通知。（译注：非对称，请注意。）</li><li><a href="http://doc.redisfans.com/sorted_set/zadd.html#zadd" target="_blank" rel="noopener"><em>ZADD</em></a> 产生一个 <code>zadd</code> 通知，即使有多个输入元素时，也是如此。</li><li><a href="http://doc.redisfans.com/sorted_set/zrem.html#zrem" target="_blank" rel="noopener"><em>ZREM</em></a> 产生一个 <code>zrem</code> 通知，即使有多个输入元素时，也是如此。如果执行 <a href="http://doc.redisfans.com/sorted_set/zrem.html#zrem" target="_blank" rel="noopener"><em>ZREM</em></a> 之后，有序集合键被清空，那么还会产生一个 <code>del</code> 通知。</li><li><a href="http://doc.redisfans.com/sorted_set/zremrangebyscore.html#zremrangebyscore" target="_blank" rel="noopener"><em>ZREMRANGEBYSCORE</em></a> 产生一个 <code>zrembyscore</code> 通知。（译注：非对称，请注意。）如果用于保存结果的键已经存在，那么还会产生一个 <code>del</code> 通知。</li><li><a href="http://doc.redisfans.com/sorted_set/zremrangebyrank.html#zremrangebyrank" target="_blank" rel="noopener"><em>ZREMRANGEBYRANK</em></a> 产生一个 <code>zrembyrank</code> 通知。（译注：非对称，请注意。）如果用于保存结果的键已经存在，那么还会产生一个 <code>del</code> 通知。</li><li><a href="http://doc.redisfans.com/sorted_set/zinterstore.html#zinterstore" target="_blank" rel="noopener"><em>ZINTERSTORE</em></a> 和 <a href="http://doc.redisfans.com/sorted_set/zunionstore.html#zunionstore" target="_blank" rel="noopener"><em>ZUNIONSTORE</em></a> 分别产生 <code>zinterstore</code> 和 <code>zunionstore</code> 两种通知。如果用于保存结果的键已经存在，那么还会产生一个 <code>del</code> 通知。</li><li>每当一个键因为 <code>maxmemory</code> 政策而被删除以回收内存时，产生一个 <code>evicted</code> 通知。</li></ul><p>所有命令都只在键<strong>真的</strong>被改动了之后，才会产生通知。</p><p>比如说，当 <a href="http://doc.redisfans.com/set/srem.html#srem" target="_blank" rel="noopener"><em>SREM</em></a> 试图删除不存在于集合的元素时，删除操作会执行失败，因为没有真正的改动键，所以这一操作不会发送通知。</p><p>如果对命令所产生的通知有疑问，最好还是使用以下命令，自己来验证一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli config set notify-keyspace-events KEA</span><br><span class="line">$ redis-cli --csv psubscribe &apos;__key*__:*&apos;</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">&quot;psubscribe&quot;,&quot;__key*__:*&quot;,1</span><br></pre></td></tr></table></figure><p>然后，只要在其他终端里用 Redis 客户端发送命令，就可以看到产生的通知了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;pmessage&quot;,&quot;__key*__:*&quot;,&quot;__keyspace@0__:foo&quot;,&quot;set&quot;</span><br><span class="line">&quot;pmessage&quot;,&quot;__key*__:*&quot;,&quot;__keyevent@0__:set&quot;,&quot;foo&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;需求：redis中缓存了一些状态量，业务需要时刻关注状态量变化&lt;/p&gt;
&lt;p&gt;方案一：轮询检查（各方面性能太差）&lt;/p&gt;
&lt;p&gt;方案二：redis提供的键空间通知机制（redis主动推送，优选）&lt;/p&gt;
&lt;h3 id=&quot;1、发布与订阅&quot;&gt;&lt;a href=&quot;#1、发布与订阅&quot;
      
    
    </summary>
    
    
      <category term="redis" scheme="http://yoursite.com/child/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis-数据持久化配置</title>
    <link href="http://yoursite.com/child/2019/08/01/redis-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/child/2019/08/01/redis-数据持久化配置/</id>
    <published>2019-07-31T16:00:00.000Z</published>
    <updated>2019-08-19T13:41:41.779Z</updated>
    
    <content type="html"><![CDATA[<p>redis的数据持久化功能默认是没有开启的，当我们kill掉redis-server进程并重启后，此前所有的缓存数据都会丢失，所以为了防止redis服务器宕机而造成数据丢失，我们应该打开redis的数据持久化功能。</p><p>redis持久化方式有两种：RDB 和 AOF，本文将围绕这两种持久化方式展开。</p><h3 id="1、持久化原理"><a href="#1、持久化原理" class="headerlink" title="1、持久化原理"></a>1、持久化原理</h3><ul><li>RDB的原理是生成当前数据集的快照文件dump.rdb，当服务器宕机重启后，服务器会根据该备份文件恢复数据，备份的是数据。</li><li>AOF的原理是维护一个数据写入日志（aof文件），在服务器执行写入命令的时候，在aof文件尾部添加命令。服务器宕机重启后，自动执行aof文件中的数据写入命令恢复数据。</li></ul><h3 id="2、运行过程"><a href="#2、运行过程" class="headerlink" title="2、运行过程"></a>2、运行过程</h3><h4 id="2-1-RDB方式"><a href="#2-1-RDB方式" class="headerlink" title="2.1 RDB方式"></a>2.1 RDB方式</h4><p>当 Redis 需要保存 <code>dump.rdb</code> 文件时， 服务器执行以下操作：</p><ol><li>Redis 调用 <code>fork()</code> ，同时拥有父进程和子进程。</li><li>子进程将数据集写入到一个临时 RDB 文件中。</li><li>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</li></ol><h4 id="2-2-AOF方式"><a href="#2-2-AOF方式" class="headerlink" title="2.2 AOF方式"></a>2.2 AOF方式</h4><p>每当 Redis 执行一个改变数据集的命令时（比如 <strong>SET</strong>、<strong>INCR</strong>）， 这个命令就会被追加到 AOF 文件的末尾， 当 Redis 重新启时， 程序就可以通过重新执行 AOF 文件中的命令来达到重建数据集的目的。</p><h5 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h5><p>举个例子， 如果你对一个计数器调用了 100 次<strong>INCR</strong> ， 那么仅仅是为了保存这个计数器的当前值， AOF 文件就需要使用 100 条记录。</p><p>然而在实际上， 只使用一条 <strong>SET</strong> 命令已经足以保存计数器的当前值了， 其余 99 条记录实际上都是多余的。</p><p>为了处理这种情况， Redis 支持一种有趣的特性： 可以在不打断服务客户端的情况下， 对 AOF 文件进行重建（rebuild）。</p><p>执行 <a href="http://doc.redisfans.com/server/bgrewriteaof.html#bgrewriteaof" target="_blank" rel="noopener"><em>BGREWRITEAOF</em></a> 命令， Redis 将生成一个新的 AOF 文件， 这个文件包含重建当前数据集所需的最少命令。</p><p>Redis 2.2 需要自己手动执行 <a href="http://doc.redisfans.com/server/bgrewriteaof.html#bgrewriteaof" target="_blank" rel="noopener"><em>BGREWRITEAOF</em></a> 命令； Redis 2.4 则可以自动触发 AOF 重写， 具体信息请查看 2.4 的示例配置文件。</p><h5 id="重写过程"><a href="#重写过程" class="headerlink" title="重写过程"></a>重写过程</h5><p>AOF 重写和 RDB 创建快照一样，都巧妙地利用了copy-on-write机制。</p><ol><li>Redis 执行 <code>fork()</code> ，现在同时拥有父进程和子进程。</li><li>子进程开始将新 AOF 文件的内容写入到临时文件。</li><li>对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾： 这样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。</li><li>当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。</li><li>现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。</li></ol><h3 id="3、优劣势对比"><a href="#3、优劣势对比" class="headerlink" title="3、优劣势对比"></a>3、优劣势对比</h3><table><thead><tr><th style="text-align:center">RDB</th><th style="text-align:center">AOF</th></tr></thead><tbody><tr><td style="text-align:center"><strong>备份策略灵活多样可配置</strong></td><td style="text-align:center"><em>只有三种持久化策略</em></td></tr><tr><td style="text-align:center"><strong>rdb文件内容紧凑，适合灾难恢复</strong></td><td style="text-align:center">-</td></tr><tr><td style="text-align:center"><strong>备份过程不影响redis性能</strong></td><td style="text-align:center"><em>持久化策略决定是否影响redis性能</em></td></tr><tr><td style="text-align:center"><strong>大数据集恢复速度快</strong></td><td style="text-align:center"><em>大数据量恢复速度较慢</em></td></tr><tr><td style="text-align:center"><em>可靠性地，丢失数据概率高</em></td><td style="text-align:center"><strong>持久化可靠性高，丢失数据概率低</strong></td></tr><tr><td style="text-align:center"><em>rdb文件不可读</em></td><td style="text-align:center"><strong>aof文件可读性高，易于分析</strong></td></tr><tr><td style="text-align:center"><em>每次生成快照都需要操作整个数据集</em></td><td style="text-align:center"><strong>aof文件只需要进行追加操作</strong></td></tr></tbody></table><p>总结来说：</p><p>RDB方式备份时费劲，恢复时很给力，持久化可靠性低；AOF方式备份简单，恢复时稍费力，持久化可靠性高。具体使用哪种方式，需要根据具体业务场景进行选择。</p><h3 id="4、配置方式"><a href="#4、配置方式" class="headerlink" title="4、配置方式"></a>4、配置方式</h3><h4 id="4-1-RDB配置"><a href="#4-1-RDB配置" class="headerlink" title="4.1 RDB配置"></a>4.1 RDB配置</h4><h5 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h5><p>RDB通过手动执行命令<strong>SAVE</strong>或者<strong>BGSAVE</strong>生成快照文件，SAVE会阻塞服务器进程直到成功生成备份，不推荐使用；使用BGSAVE，服务器进程会fork一个子进程，异步执行备份，此过程服务器只有在fork()的时候阻塞。</p><h5 id="自动触发-配置文件"><a href="#自动触发-配置文件" class="headerlink" title="自动触发(配置文件)"></a>自动触发(配置文件)</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 停用rdb</span><br><span class="line"><span class="meta">#</span>save ""</span><br><span class="line">save 900 1 #表示900 秒内如果至少有 1 个 key 的值变化，则保存</span><br><span class="line">save 300 10 #表示300 秒内如果至少有 10 个 key 的值变化，则保存</span><br><span class="line">save 60 10000 #表示60 秒内如果至少有 10000 个 key 的值变化，则保存</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>当启用了RDB且最后一次后台保存数据失败，Redis是否停止接收数据，默认yes</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>对于存储到磁盘中的快照，可以设置是否采用LZF进行压缩存储，默认yes</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验</span><br><span class="line"><span class="meta">#</span>但是这样做会增加大约10%的性能消耗，默认yes</span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>设置快照的文件名，默认是 dump.rdb</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名</span><br><span class="line">dir /var/redis/6379</span><br></pre></td></tr></table></figure><h4 id="4-2-AOF配置"><a href="#4-2-AOF配置" class="headerlink" title="4.2 AOF配置"></a>4.2 AOF配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 开启aof</span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> aof文件名称</span><br><span class="line">appendfilename "appendonly.aof"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 三种持久化策略</span><br><span class="line"><span class="meta">#</span> appendfsync always  # 每次修改数据集都会追加一次</span><br><span class="line">appendfsync everysec  # 每1秒追加一次 </span><br><span class="line"><span class="meta">#</span> appendfsync no  # 交给系统控制，linux 系统是30秒</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> If you have latency problems turn this to "yes". Otherwise leave it as</span><br><span class="line"><span class="meta">#</span> "no" that is the safest pick from the point of view of durability.</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 当aof文件增长量达到100%，自动重写（设为0则永不重写）</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"><span class="meta">#</span> 当aof文件小于这个值，不会自动重写</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> </span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> </span><br><span class="line">aof-use-rdb-preamble no</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;redis的数据持久化功能默认是没有开启的，当我们kill掉redis-server进程并重启后，此前所有的缓存数据都会丢失，所以为了防止redis服务器宕机而造成数据丢失，我们应该打开redis的数据持久化功能。&lt;/p&gt;
&lt;p&gt;redis持久化方式有两种：RDB 和 AO
      
    
    </summary>
    
    
      <category term="redis" scheme="http://yoursite.com/child/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>数据库-centos安装配置MySql8.0</title>
    <link href="http://yoursite.com/child/2019/07/31/%E6%95%B0%E6%8D%AE%E5%BA%93-centos%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEMySql8.0/"/>
    <id>http://yoursite.com/child/2019/07/31/数据库-centos安装配置MySql8.0/</id>
    <published>2019-07-31T00:36:00.173Z</published>
    <updated>2019-07-31T01:43:48.415Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL8.0和MySQL5.7具有众多不同之处，此处不述。这里，只简单讲讲在安装过程中遇到的问题之一和解决办法：<br> MySQL8.0安装完成之后的默认密码是多少？如何修改初始密码？</p><h3 id="1-安装MySQL8-0"><a href="#1-安装MySQL8-0" class="headerlink" title="1 安装MySQL8.0"></a>1 安装MySQL8.0</h3><ul><li>yum仓库下载MySQL：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">shell&gt;</span> yum localinstall https://repo.mysql.com//mysql80-community-release-el7-1.noarch.rpm</span><br></pre></td></tr></table></figure><ul><li>yum安装MySQL：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">shell&gt;</span> yum install mysql-community-server</span><br></pre></td></tr></table></figure><h3 id="2-启动MySQL服务"><a href="#2-启动MySQL服务" class="headerlink" title="2 启动MySQL服务"></a>2 启动MySQL服务</h3><ul><li>启动MySQL服务的命令：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">shell&gt;</span> service mysqld start</span><br><span class="line"></span><br><span class="line">Starting mysqld:[ OK ]</span><br></pre></td></tr></table></figure><ul><li>检查MySQL服务器的运行状态：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">shell&gt;</span> sudo service mysqld status</span><br><span class="line"></span><br><span class="line">● mysqld.service - MySQL Server</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/mysqld.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Sun 2018-06-03 18:31:51 CST; 6min ago</span><br><span class="line">     Docs: man:mysqld(8)</span><br><span class="line">           http://dev.mysql.com/doc/refman/en/using-systemd.html</span><br><span class="line">  Process: 5281 ExecStartPre=/usr/bin/mysqld_pre_systemd (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 5299 (mysqld)</span><br><span class="line">   Status: "SERVER_OPERATING"</span><br><span class="line">   CGroup: /system.slice/mysqld.service</span><br><span class="line">           └─5299 /usr/sbin/mysqld</span><br><span class="line"></span><br><span class="line">Jun 03 18:31:50 &#123;your-server-name&#125; systemd[1]: Starting MySQL Server...</span><br><span class="line">Jun 03 18:31:51 &#123;your-server-name&#125; systemd[1]: Started MySQL Server.</span><br></pre></td></tr></table></figure><p>以上信息表示MySQL服务启动成功。</p><h3 id="3-MySQL默认密码和修改密码"><a href="#3-MySQL默认密码和修改密码" class="headerlink" title="3 MySQL默认密码和修改密码"></a>3 MySQL默认密码和修改密码</h3><p>在启动MySQL服务的时候，主要会发生以下4件事</p><ul><li>MySQL Server初始化并启动起来；</li><li>MySQL的data文件夹中生成SSL证书和key文件；</li><li>密码验证组件被安装并且生效；</li><li>创建一个超级管用户<em>‘root‘@’localhost‘</em>。超级用户设置的密码被保存在错误日志文件中，可以通过以下命令查看：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">shell&gt;</span> sudo grep 'temporary password' /var/log/mysqld.log</span><br><span class="line"></span><br><span class="line">2018-06-03T10:15:57.448920Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: 0xxXxxXx?xXX</span><br></pre></td></tr></table></figure><p>通过默认密码登录MySQL服务器，并马上修改密码(<strong>强烈建议</strong>)！！！。</p><p>有些时候使用上面的筛选命令检索不到文件或内容，可以手动查看/var/log/mysqld.log文件获取初始密码。</p><p>用默认密码(0xxXxxXx?xXX)登录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; mysql -uroot -p</span><br></pre></td></tr></table></figure><p>修改密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span> ALTER USER 'root'@'localhost' IDENTIFIED BY 'your-password';</span><br></pre></td></tr></table></figure><h3 id="4-设置允许远程连接"><a href="#4-设置允许远程连接" class="headerlink" title="4 设置允许远程连接"></a>4 设置允许远程连接</h3><p>在终端登录mysql之后查看是否允许远程访问：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use mysql</span><br><span class="line">Reading table information for completion of table and column names</span><br><span class="line">You can turn off this feature to get a quicker startup with -A</span><br><span class="line"></span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select host,user,plugin from user;</span><br><span class="line">+-----------+------------------+-----------------------+</span><br><span class="line">| host      | user             | plugin                |</span><br><span class="line">+-----------+------------------+-----------------------+</span><br><span class="line">| localhost | mysql.infoschema | caching_sha2_password |</span><br><span class="line">| localhost | mysql.session    | caching_sha2_password |</span><br><span class="line">| localhost | mysql.sys        | caching_sha2_password |</span><br><span class="line">| localhost | root             | caching_sha2_password |</span><br><span class="line">+-----------+------------------+-----------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>可以看到最后一行root 用户的host为localhost，要远程访问，需要将它改成%</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update user set host=&apos;%&apos; where user =&apos;root&apos;;</span><br><span class="line">Query OK, 1 row affected (0.07 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select host,user,plugin from user;</span><br><span class="line">+-----------+------------------+-----------------------+</span><br><span class="line">| host      | user             | plugin                |</span><br><span class="line">+-----------+------------------+-----------------------+</span><br><span class="line">| %         | root             | caching_sha2_password |</span><br><span class="line">| localhost | mysql.infoschema | caching_sha2_password |</span><br><span class="line">| localhost | mysql.session    | caching_sha2_password |</span><br><span class="line">| localhost | mysql.sys        | caching_sha2_password |</span><br><span class="line">+-----------+------------------+-----------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>最后刷新权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br><span class="line">Query OK, 0 rows affected (0.10 sec)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MySQL8.0和MySQL5.7具有众多不同之处，此处不述。这里，只简单讲讲在安装过程中遇到的问题之一和解决办法：&lt;br&gt; MySQL8.0安装完成之后的默认密码是多少？如何修改初始密码？&lt;/p&gt;
&lt;h3 id=&quot;1-安装MySQL8-0&quot;&gt;&lt;a href=&quot;#1-安装M
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/child/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MQ-为什么用和什么时候用（转）</title>
    <link href="http://yoursite.com/child/2019/06/21/MQ-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E5%92%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8/"/>
    <id>http://yoursite.com/child/2019/06/21/MQ-为什么用和什么时候用/</id>
    <published>2019-06-20T16:00:00.000Z</published>
    <updated>2019-11-22T14:45:17.323Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://mp.weixin.qq.com/s/Brd-j3IcljcY7BV01r712Q" target="_blank" rel="noopener">原文地址</a></p><h3 id="1、缘起"><a href="#1、缘起" class="headerlink" title="1、缘起"></a>1、缘起</h3><p>一切脱离业务的架构设计与新技术引入都是耍流氓。</p><p>引入一个技术之前，首先应该解答的问题是，这个技术解决什么问题。</p><p>就像微服务分层架构之前，应该首先回答，为什么要引入微服务，微服务究竟解决什么问题（详见《<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651959519&amp;idx=1&amp;sn=065074b135fc9cb243abe897261e1a72&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">互联网架构为什么要做微服务？</a>》）。</p><p>最近分享了几篇MQ相关的文章：</p><p>《<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651959961&amp;idx=1&amp;sn=afec02c8dc6db9445ce40821b5336736&amp;chksm=bd2d07458a5a8e5314560620c240b1c4cf3bbf801fc0ab524bd5e8aa8b8ef036cf755d7eb0f6&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">MQ如何实现延时消息</a>》</p><p>《<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651959966&amp;idx=1&amp;sn=068a2866dcc49335d613d75c4a5d1b17&amp;chksm=bd2d07428a5a8e54162ad8ea8e1e9302dfaeb664cecc453bd16a5f299820755bd2e1e0e17b60&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">MQ如何实现消息必达</a>》</p><p>《<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651960002&amp;idx=1&amp;sn=c0775231bccf002c3178eabe43f1cdcb&amp;chksm=bd2d071e8a5a8e08c3a5287247ea41dee6b2621e6ffafbf909ec1e8a866b7c816eeeea227246&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">MQ如何实现幂等性</a>》</p><p>不少网友询问，究竟什么时候使用MQ，MQ究竟适合什么场景，故有了此文。</p><h3 id="2、MQ是干嘛的"><a href="#2、MQ是干嘛的" class="headerlink" title="2、MQ是干嘛的"></a>2、MQ是干嘛的</h3><p>消息总线（Message Queue），后文称MQ，是一种<strong>跨进程</strong>的通信机制，用于上下游传递消息。</p><p>在互联网架构中，MQ是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务。</p><p>使用了MQ之后，消息发送上游只需要依赖MQ，逻辑上和物理上都不用依赖其他服务。</p><h3 id="3、什么时候不使用MQ"><a href="#3、什么时候不使用MQ" class="headerlink" title="3、什么时候不使用MQ"></a>3、什么时候不使用MQ</h3><p>既然MQ是互联网分层架构中的解耦利器，那所有通讯都使用MQ岂不是很好？这是一个严重的误区，调用与被调用的关系，是无法被MQ取代的。</p><p>MQ的不足是：</p><p>1）系统更复杂，多了一个MQ组件</p><p>2）消息传递路径更长，延时会增加</p><p>3）消息可靠性和重复性互为矛盾，消息不丢不重难以同时保证</p><p>4）上游无法知道下游的执行结果，这一点是很致命的</p><p>举个栗子：用户登录场景，登录页面调用passport服务，passport服务的执行结果直接影响登录结果，此处的“登录页面”与“passport服务”就必须使用调用关系，而不能使用MQ通信。</p><p>无论如何，记住这个结论：调用方实时依赖执行结果的业务场景，请使用调用，而不是MQ。</p><h3 id="4、什么时候使用MQ"><a href="#4、什么时候使用MQ" class="headerlink" title="4、什么时候使用MQ"></a>4、什么时候使用MQ</h3><h4 id="4-1-典型场景一：数据驱动的任务依赖"><a href="#4-1-典型场景一：数据驱动的任务依赖" class="headerlink" title="4.1 典型场景一：数据驱动的任务依赖"></a>4.1 典型场景一：数据驱动的任务依赖</h4><p> 什么是任务依赖，举个栗子，互联网公司经常在凌晨进行一些数据统计任务，这些任务之间有一定的依赖关系，比如：</p><p>1）task3需要使用task2的输出作为输入</p><p>2）task2需要使用task1的输出作为输入</p><p>这样的话，tast1, task2, task3之间就有任务依赖关系，必须task1先执行，再task2执行，载task3执行。</p><p>对于这类需求，常见的实现方式是，使用cron人工排执行时间表：</p><p>1）task1，0:00执行，经验执行时间为50分钟</p><p>2）task2，1:00执行（为task1预留10分钟buffer），经验执行时间也是50分钟</p><p>3）task3，2:00执行（为task2预留10分钟buffer）</p><p>这种方法的坏处是：</p><p>1）如果有一个任务执行时间超过了预留buffer的时间，将会得到错误的结果，因为后置任务不清楚前置任务是否执行成功，此时要手动重跑任务，还有可能要调整排班表</p><p>2）总任务的执行时间很长，总是要预留很多buffer，如果前置任务提前完成，后置任务不会提前开始</p><p>3）如果一个任务被多个任务依赖，这个任务将会称为关键路径，排班表很难体现依赖关系，容易出错</p><p>4）如果有一个任务的执行时间要调整，将会有多个任务的执行时间要调整</p><p>无论如何，采用“cron排班表”的方法，各任务耦合，谁用过谁痛谁知道</p><p>优化方案是，采用MQ解耦：</p><p>1）task1准时开始，结束后发一个“task1 done”的消息</p><p>2）task2订阅“task1 done”的消息，收到消息后第一时间启动执行，结束后发一个“task2 done”的消息</p><p>3）task3同理</p><p>采用MQ的优点是：</p><p>1）不需要预留buffer，上游任务执行完，下游任务总会在第一时间被执行</p><p>2）依赖多个任务，被多个任务依赖都很好处理，只需要订阅相关消息即可</p><p>3）有任务执行时间变化，下游任务都不需要调整执行时间</p><p>需要特别说明的是，MQ只用来传递上游任务执行完成的消息，并不用于传递真正的输入输出数据。</p><h4 id="4-2-典型场景二：上游不关心执行结果"><a href="#4-2-典型场景二：上游不关心执行结果" class="headerlink" title="4.2 典型场景二：上游不关心执行结果"></a>4.2 典型场景二：上游不关心执行结果</h4><p>上游需要关注执行结果时要用“调用”，上游不关注执行结果时，就可以使用MQ了。</p><p>举个栗子，58同城的很多下游需要关注“用户发布帖子”这个事件，比如招聘用户发布帖子后，招聘业务要奖励58豆，房产用户发布帖子后，房产业务要送2个置顶，二手用户发布帖子后，二手业务要修改用户统计数据。</p><p>对于这类需求，常见的实现方式是，使用调用关系：</p><p>帖子发布服务执行完成之后，调用下游招聘业务、房产业务、二手业务，来完成消息的通知，但事实上，这个通知是否正常正确的执行，帖子发布服务根本不关注。</p><p>这种方法的坏处是：</p><p>1）帖子发布流程的执行时间增加了</p><p>2）下游服务当机，可能导致帖子发布服务受影响，上下游逻辑+物理依赖严重</p><p>3）每当增加一个需要知道“帖子发布成功”信息的下游，修改代码的是帖子发布服务，这一点是最恶心的，属于架构设计中典型的依赖倒转，谁用过谁痛谁知道</p><p>优化方案是，采用MQ解耦：</p><p>1）帖子发布成功后，向MQ发一个消息</p><p>2）哪个下游关注“帖子发布成功”的消息，主动去MQ订阅</p><p>采用MQ的优点是：</p><p>1）上游执行时间短</p><p>2）上下游逻辑+物理解耦，除了与MQ有物理连接，模块之间都不相互依赖</p><p>3）新增一个下游消息关注方，上游不需要修改任何代码</p><h4 id="4-3-典型场景三：上游关注执行结果，但执行时间很长"><a href="#4-3-典型场景三：上游关注执行结果，但执行时间很长" class="headerlink" title="4.3 典型场景三：上游关注执行结果，但执行时间很长"></a>4.3 典型场景三：上游关注执行结果，但执行时间很长</h4><p> 有时候上游需要关注执行结果，但执行结果时间很长（典型的是调用离线处理，或者跨公网调用），也经常使用回调网关+MQ来解耦。</p><p>举个栗子，微信支付，跨公网调用微信的接口，执行时间会比较长，但调用方又非常关注执行结果，此时一般怎么玩呢？</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/java%E7%BC%96%E7%A8%8B/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="架构图"></p><p>一般采用“回调网关+MQ”方案来解耦：</p><p>1）调用方直接跨公网调用微信接口</p><p>2）微信返回调用成功，此时并不代表返回成功</p><p>3）微信执行完成后，回调统一网关</p><p>4）网关将返回结果通知MQ</p><p>5）请求方收到结果通知</p><p>这里需要注意的是，不应该由回调网关来调用上游来通知结果，如果是这样的话，每次新增调用方，回调网关都需要修改代码，仍然会反向依赖，使用回调网关+MQ的方案，新增任何对微信支付的调用，都不需要修改代码啦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s/Brd-j3IcljcY7BV01r712Q&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;1、缘起&quot;&gt;&lt;a href=&quot;#1、缘起&quot; clas
      
    
    </summary>
    
    
      <category term="MQ" scheme="http://yoursite.com/child/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>nio-入门篇-应用案例讲解</title>
    <link href="http://yoursite.com/child/2019/05/26/nio-%E5%85%A5%E9%97%A8%E7%AF%87-%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B%E8%AE%B2%E8%A7%A3/"/>
    <id>http://yoursite.com/child/2019/05/26/nio-入门篇-应用案例讲解/</id>
    <published>2019-05-26T02:21:34.000Z</published>
    <updated>2019-06-09T12:14:33.240Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Buffer"><a href="#1-Buffer" class="headerlink" title="1. Buffer"></a>1. Buffer</h3><p>在channel中传输的是buffer中的数据，而不是buffer对象。</p><p>使用Buffer读写数据一般遵循以下四个步骤（buffer为读写主体）：</p><ol><li>写入数据到Buffer</li><li>调用flip()方法</li><li>从Buffer中读取数据</li><li>调用clear()方法或者compact()方法  </li></ol><p>说明：</p><ul><li>当向buffer写入数据时，buffer会记录下写了多少数据。一旦要读取数据，需要通过flip()方法将Buffer从写模式切换到读模式。在读模式下，可以读取之前写入到buffer的所有数据。</li><li>一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用clear()或compact()方法。clear()方法会清空整个缓冲区。compact()方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。<h4 id="1-1-Buffer抽象类"><a href="#1-1-Buffer抽象类" class="headerlink" title="1.1 Buffer抽象类"></a>1.1 Buffer抽象类</h4>Buffer抽象类中定义的常用方法：</li><li><strong>Buffer flip()</strong> flip方法将Buffer从写模式切换到读模式。调用flip()方法会将position设回0，并将limit设置成之前position的值。</li><li><strong>Buffer rewind()</strong> 将position设回0，所以你可以重读Buffer中的所有数据。limit保持不变，仍然表示能从Buffer中读取多少个元素（byte、char等）</li><li><strong>int remaining()</strong> 返回position到limit之间的元素个数（未读出元素个数）</li><li><strong>boolean hasRemaining()</strong> 返回是否还有未读出的数据</li><li><strong>boolean isReadOnly()</strong> 是否此buffer只能读出</li><li><strong>Buffer mark()</strong> 可以标记Buffer中的一个特定position，之后可以通过调用Buffer.reset()方法恢复到这个position。</li><li><strong>Buffer reset()</strong> 恢复到mark()标记的状态</li><li><strong>Buffer clear()</strong> 重置position、limit、capacity和mark，从读模式转换成写模式 </li></ul><p>此外Buffer还声明了几个抽象方法如下，这些方法都是在Buffer的子类中定义的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boolean hasArray();</span><br><span class="line">boolean isReadOnly();</span><br><span class="line">Object array();</span><br><span class="line">int arrayOffset();</span><br><span class="line">boolean isDirect();</span><br></pre></td></tr></table></figure></p><h4 id="1-2-Buffer的类型"><a href="#1-2-Buffer的类型" class="headerlink" title="1.2 Buffer的类型"></a>1.2 Buffer的类型</h4><p>Java NIO 有以下Buffer类型：</p><ul><li>ByteBuffer</li><li>MappedByteBuffer</li><li>CharBuffer</li><li>DoubleBuffer</li><li>FloatBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>ShortBuffer </li></ul><p>这些类都是Buffer的子类，其实也是抽象类，它们在Buffer抽象类的基础上扩展了与数据类型相关的功能，下面以ByteBuffer为例介绍</p><p>扩展的常用方法：</p><ul><li><strong>ByteBuffer compact()</strong> 将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样，设置成capacity。</li><li><strong>byte get()</strong> 获取position所指的byte，并且position加1</li><li><strong>byte get(int index)</strong> 获取指定位置的byte</li><li><strong>ByteBuffer put(byte b)</strong> 将指定的byte写入buffer</li><li><strong>ByteBuffer put(int index,byte b)</strong> 将指定的byte写入buffer的指定位置</li><li>…许多的不同类型的get/put操作</li></ul><h3 id="2-Channel"><a href="#2-Channel" class="headerlink" title="2. Channel"></a>2. Channel</h3><p>Java NIO的通道类似流，但又有些不同：</p><ul><li>既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。</li><li>通道可以异步地读写。</li><li>通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入。</li></ul><p>常见的channel：</p><ol><li>FileChannel 从文件中读写数据。</li><li>DatagramChannel 能通过UDP读写网络中的数据。</li><li>SocketChannel 能通过TCP读写网络中的数据。</li><li>ServerSocketChannel可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。</li></ol><p>本文暂不分析具体的Channel类型，将在下一篇博文中具体阐述。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reads a sequence of bytes from this channel into the given buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Writes a sequence of bytes to this channel from the given buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure></p><p>注意对Channel的read和write的理解容易让人懵圈：   </p><ul><li>channel.read(buffer) 意思是Read from this channel to buffer  </li><li>channel.write(buffer) 意思是Write to this channel from buffer</li></ul><h3 id="3-Selector"><a href="#3-Selector" class="headerlink" title="3. Selector"></a>3. Selector</h3><ol><li>创建：调用Selector类的静态方法open()创建selector对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><ol start="2"><li>注册通道：调用Channel的实例方法将通道注册到selector上<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key = channel.register(selector,Selectionkey.OP_READ);</span><br></pre></td></tr></table></figure></li></ol><p>与Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。</p><p>register()方法的第二个参数是一个“interest集合”，意思是在Selector监听该Channel时对什么事件感兴趣。可以监听四种不同类型的事件：</p><ul><li>connect </li><li>accept</li><li>read</li><li>write</li></ul><p>当以上四种事件就绪的时候，会触发对应的通道事件，通道事件会被selector发现。所以，某个channel成功连接到另一个服务器称为“连接就绪”。一个server socket channel准备好接收新进入的连接称为“接收就绪”。一个有数据可读的通道可以说是“读就绪”。通道等待写数据可以说是“写就绪”。</p><p>这四种事件用SelectionKey的四个常量来表示：</p><ul><li>SelectionKey.OP_CONNECT</li><li>SelectionKey.OP_ACCEPT</li><li>SelectionKey.OP_READ</li><li>SelectionKey.OP_WRITE</li></ul><p>如果对不止一种事件感兴趣，那么可以用“位或”操作符将常量连接起来，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure></p><h4 id="3-1-SelectionKey"><a href="#3-1-SelectionKey" class="headerlink" title="3.1 SelectionKey"></a>3.1 SelectionKey</h4><p>当向Selector注册Channel时，register()方法会返回一个SelectionKey对象。这个对象包含了一些有用的属性：</p><ul><li>interest集合</li><li>ready集合</li><li>Channel</li><li>Selector</li><li>附件对象（可选）</li></ul><p><strong>interest集合</strong><br>可以通过SelectionKey读写interest集合，像这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = selectionKey.interestOps();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isInterestedInAccept  = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT；</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInRead    = interestSet &amp; SelectionKey.OP_READ;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInWrite   = interestSet &amp; SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure></p><p>可以看到，用“位与”操作interest 集合和给定的SelectionKey常量，可以确定某个确定的事件是否在interest 集合中。</p><p><strong>ready集合</strong><br>ready 集合是通道已经准备就绪的操作的集合，是四个常量通过‘或’运算生成的。在一次选择(Selection)之后，你会首先访问这个ready set。Selection将在下一小节进行解释。可以这样访问ready集合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int readySet = selectionKey.readyOps();</span><br></pre></td></tr></table></figure></p><p>可以用像检测interest集合那样的方法，来检测channel中什么事件或操作已经就绪。但是，也可以使用以下四个方法，它们都会返回一个布尔类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.isAcceptable();</span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure><p><strong>Channel &amp; Selector</strong><br>从SelectionKey访问Channel和Selector很简单。如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Channel  channel  = selectionKey.channel();</span><br><span class="line">Selector selector = selectionKey.selector();</span><br></pre></td></tr></table></figure></p><p>在程序中需要对返回的channel做类型转换  </p><p><strong>附件对象</strong><br>可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个给定的通道。例如，可以附加 与通道一起使用的Buffer，或是包含聚集数据的某个对象。使用方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.attach(theObject);</span><br><span class="line">Object attachedObj = selectionKey.attachment();</span><br></pre></td></tr></table></figure></p><p>还可以在用register()方法向Selector注册Channel的时候附加对象。如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);</span><br></pre></td></tr></table></figure></p><h4 id="3-2-Selector选择通道"><a href="#3-2-Selector选择通道" class="headerlink" title="3.2 Selector选择通道"></a>3.2 Selector选择通道</h4><p><strong>select()</strong></p><p>一旦向Selector注册了一或多个通道，就可以调用几个重载的select()方法。这些方法返回你所感兴趣的事件（如连接、接受、读或写）已经准备就绪的那些通道。换句话说，如果你对“读就绪”的通道感兴趣，select()方法会返回读事件已经就绪的那些通道。</p><p>三种select：</p><ul><li>int select() 阻塞方法，阻塞到至少有一个通道在注册的事件上就绪。</li><li>int select(long timeout) 超时返回的阻塞方法</li><li>int selectNow() 非阻塞方法，不管是否有通道就绪，立即返回。如果自上次select之后没有通道就绪，直接返回0</li></ul><p>方法返回的int值表示有多少通道已经就绪。亦即，自上次调用select()方法后有多少通道变成就绪状态。例如第一次调用select()方法，有一个通道变成就绪状态，返回了1，若再次调用select()方法，如果另一个通道就绪了，它会再次返回1，即使对第一个就绪的channel没有做任何操作，现在有两个就绪的通道。</p><p><strong>selectedKeys()</strong></p><p>一旦调用了select()方法，并且返回值表明有一个或更多个通道就绪了，然后可以通过调用selector的selectedKeys()方法，访问“已选择键集（selected key set）”中的就绪通道。如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br></pre></td></tr></table></figure></p><p>可以遍历这个已选择的键集合来访问就绪通道，像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">    SelectionKey key = iter.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">        handleAccept(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">        handleRead(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(key.isWritable() &amp;&amp; key.isValid())&#123;</span><br><span class="line">        handleWrite(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(key.isConnectable())&#123;</span><br><span class="line">        System.out.println(<span class="string">"isConnectable = true"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    iter.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意每次迭代末尾需要调用remove()。Selector不会自己从已选择键集中移除SelectionKey实例，必须在处理完通道时自己移除。下次该通道变成就绪时，Selector会再次将其放入已选择键集中。</p><p><strong>wakeUp()</strong></p><p>某个线程调用select()方法后阻塞了，即使没有通道已经就绪，也有办法让其从select()方法返回。只要让其它线程在第一个线程调用select()方法的那个对象上调用Selector.wakeup()方法即可。阻塞在select()方法上的线程会立马返回。</p><p>如果有其它线程调用了wakeup()方法，但当前没有线程阻塞在select()方法上，下个调用select()方法的线程会立即“醒来（wake up）”。</p><p><strong>close()</strong></p><p>用完Selector后调用其close()方法会关闭该Selector，该方法使注册到该Selector上的所有SelectionKey实例无效，通道本身并不会关闭。</p><h3 id="4-一个完整的案例"><a href="#4-一个完整的案例" class="headerlink" title="4. 一个完整的案例"></a>4. 一个完整的案例</h3><p>客户端程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketChannelClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        client();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">client</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        SocketChannel socketChannel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            socketChannel = SocketChannel.open();</span><br><span class="line">            socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>,<span class="number">8080</span>));</span><br><span class="line">            <span class="keyword">if</span>(socketChannel.finishConnect()) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    String info = <span class="string">"I'm "</span> + i++ + <span class="string">"-th information from client"</span>;</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                    buffer.put(info.getBytes());</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                        System.out.println(buffer);</span><br><span class="line">                        socketChannel.write(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException | InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(socketChannel!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    socketChannel.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>服务器端程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOSocketServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUF_SIZE=<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">8080</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIMEOUT = <span class="number">3000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        selector();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Selector selector = <span class="keyword">null</span>;</span><br><span class="line">        ServerSocketChannel ssc = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            ssc= ServerSocketChannel.open();</span><br><span class="line">            ssc.socket().bind(<span class="keyword">new</span> InetSocketAddress(PORT));</span><br><span class="line">            ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(selector.select(TIMEOUT) == <span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"=="</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">                    SelectionKey key = iter.next();</span><br><span class="line">                    <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                        handleAccept(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                        handleRead(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(key.isWritable() &amp;&amp; key.isValid())&#123;</span><br><span class="line">                        handleWrite(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(key.isConnectable())&#123;</span><br><span class="line">                        System.out.println(<span class="string">"isConnectable = true"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    iter.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(selector!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    selector.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ssc!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    ssc.close();<span class="comment">//关闭ServerSocketChannel</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleAccept</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel ssChannel = (ServerSocketChannel)key.channel();</span><br><span class="line">        SocketChannel sc = ssChannel.accept();</span><br><span class="line">        sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        sc.register(key.selector(), SelectionKey.OP_READ, ByteBuffer.allocateDirect(BUF_SIZE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleRead</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        SocketChannel sc = (SocketChannel)key.channel();</span><br><span class="line">        ByteBuffer buf = (ByteBuffer)key.attachment();</span><br><span class="line">        <span class="keyword">long</span> bytesRead = sc.read(buf);</span><br><span class="line">        <span class="keyword">while</span>(bytesRead&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            buf.flip();</span><br><span class="line">            <span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>)buf.get());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            buf.clear();</span><br><span class="line">            bytesRead = sc.read(buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(bytesRead == -<span class="number">1</span>)&#123;</span><br><span class="line">            sc.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleWrite</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        ByteBuffer buf = (ByteBuffer)key.attachment();</span><br><span class="line">        buf.flip();</span><br><span class="line">        SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">        <span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">            sc.write(buf);</span><br><span class="line">        &#125;</span><br><span class="line">        buf.compact();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Buffer&quot;&gt;&lt;a href=&quot;#1-Buffer&quot; class=&quot;headerlink&quot; title=&quot;1. Buffer&quot;&gt;&lt;/a&gt;1. Buffer&lt;/h3&gt;&lt;p&gt;在channel中传输的是buffer中的数据，而不是buffer对象。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="nio" scheme="http://yoursite.com/child/tags/nio/"/>
    
  </entry>
  
  <entry>
    <title>nio-I/O模型</title>
    <link href="http://yoursite.com/child/2019/05/20/nio-IO%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/child/2019/05/20/nio-IO模型/</id>
    <published>2019-05-19T16:00:00.000Z</published>
    <updated>2019-07-14T13:34:22.634Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇我们讲到了关于TCP/IP协议的一些内容，这些是网络编程的必备知识。在了解NIO之前我们必须要了解一下对应的系统层IO模型，比如java的NIO对应是那种IO模型，阻塞和同步的差异在哪里，又是否相同。了解了这些更方便我们的后续的NIO探解。</p><h3 id="1-同步-异步、阻塞-非阻塞"><a href="#1-同步-异步、阻塞-非阻塞" class="headerlink" title="1. 同步/异步、阻塞/非阻塞"></a>1. 同步/异步、阻塞/非阻塞</h3><p>同步、异步，阻塞、非阻塞，这四种状态常有人分不清，主要是这四种状态的定义本身也不是很明确，所以各种解答的方式都有。常见的分类有以下:</p><ul><li>同步阻塞IO</li><li>同步非阻塞IO</li><li>异步非阻塞IO   </li></ul><p>阻塞是指执行I/O操作的线程，在I/O操作过程中能不能处理其他任务。同步指I/O操作过程中的消息通知机制。</p><p>同步：是否同步体现在消息通信机制上。</p><h4 id="1-1-如何分类"><a href="#1-1-如何分类" class="headerlink" title="1.1 如何分类"></a>1.1 如何分类</h4><p>针对某种IO模型，我们如何分类，可以基于POSIX对同步/异步的定义来判别：同步的I/O操作会导致请求进程阻塞，直到I/O操作完成；而异步的I/O操做则不会引起请求进程阻塞。</p><p>如果说以上的定义依然无法判别，我们可以从输入操作的两个阶段来看：</p><p>一般来说，一个输入操作通常包括两个不同阶段：</p><blockquote><p>（1）等待数据准备好；</p><p>（2）从内核向进程复制数据。</p></blockquote><p>是否同步的判断依据是：针对整个过程，也就是2个阶段，是否有阻塞。</p><p>是否阻塞的判断依据是：按程序（线程）等待消息通知时的状态角度来说的，也就是主要是针对第一阶段来说。</p><h4 id="1-2-举例说明"><a href="#1-2-举例说明" class="headerlink" title="1.2 举例说明"></a>1.2 举例说明</h4><p>我们举例来说：比如说做饭这件事，一般要分为连个步骤。</p><p>1、买菜，准备食材</p><p>2、炒菜，做出饭菜 </p><p><strong>方案一：自己动手。</strong></p><blockquote><p>1、去超市买菜，准备食材（阻塞，当前时段只能做一件事，且需要持续的等待）</p><p>2、回家切菜，炒菜，做饭菜（阻塞，还是自己来处理）</p></blockquote><p> 方案一同步阻塞。首先阶段一是阻塞的，所以认定为阻塞；两个阶段都是阻塞的，认定为同步的。</p><p><strong>方案二：网购食材，自己做饭</strong></p><blockquote><p>1、网上下单，配送食材。（非阻塞的，这期间你可以干其他事）</p><p>2、拿到菜，切菜、炒菜，做饭菜（阻塞）</p></blockquote><p>方案二为同步非阻塞。阶段一为非阻塞，认定为非阻塞。阶段二为阻塞，两阶段中有一个为阻塞，认定为同步。</p><p><strong>方案三：网购食材，请人做饭</strong></p><blockquote><p>1、网上下单，配送食材。（非阻塞的，这期间你可以干其他事）</p><p>2、请小时工，帮忙做这一餐，做好通知我。（非阻塞，期间可以干其他事）</p></blockquote><p>方案三为异步非阻塞。阶段一为非阻塞，认定为非阻塞。阶段二非阻塞，则两阶段中都没有阻塞，认定为异步。</p><p>那么是否有异步阻塞IO模型，没有，要记得异步状态是包含二个阶段的，如果有阻塞的过程，为何还叫异步？</p><h3 id="2-Unix-5种I-O模型"><a href="#2-Unix-5种I-O模型" class="headerlink" title="2. Unix 5种I/O模型"></a>2. Unix 5种I/O模型</h3><p>在<a href="https://link.zhihu.com/?target=http%3A//book.douban.com/subject/1500149/" target="_blank" rel="noopener">《UNIX网络编程：卷一》</a>的第六章书中列出了五种IO模型：</p><ul><li>阻塞式I/O</li><li>非阻塞式I/O</li><li>I/O复用（select，poll，epoll…）</li><li>信号驱动式I/O（SIGIO）</li><li>异步I/O（POSIX的aio_系列函数）</li></ul><h4 id="2-1-阻塞式I-O"><a href="#2-1-阻塞式I-O" class="headerlink" title="2.1 阻塞式I/O"></a>2.1 阻塞式I/O</h4><p>同步阻塞 IO 模型是最常用的一个模型，也是最简单的模型。在linux中，<code>默认情况下所有的socket都是blocking</code>。它符合人们最常见的思考逻辑。</p><p>在这个IO模型中，用户空间的应用程序执行一个系统调用（recvform），这会导致应用程序阻塞，什么也不干，直到数据准备好，等待kernel准备好从网络上接收到的数据报 + 等待收到的报文被从kernel复制到buf中，recvfrom方法才会返回，最后进程再处理数据。</p><p>这就是阻塞式IO模型</p><p><img src="http://wx1.sinaimg.cn/large/87c9e458ly1g48qy5z7m7j20ww0hygqd.jpg" alt="阻塞式I/O"></p><h4 id="2-2-非阻塞式I-O"><a href="#2-2-非阻塞式I-O" class="headerlink" title="2.2 非阻塞式I/O"></a>2.2 非阻塞式I/O</h4><p>非阻塞IO时对一个非阻塞描述符循环调用recvfrom，持续的轮询（polling）,以查看某个操作是否就绪。与阻塞IO不一样，”非阻塞将大的整片时间的阻塞分成N多的小的阻塞, 所以进程不断地有机会 ‘被’ CPU光顾”。</p><p>非阻塞的recvform系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error。进程在返回之后，可以干点别的事情，然后再发起recvform系统调用。如此循环的进行recvform系统调用，检查内核数据，直到数据准备好，再拷贝数据到进程。<strong>拷贝数据整个过程，进程仍然是属于阻塞的状态</strong>。</p><p>这就是非阻塞式IO模型</p><p><img src="http://wx4.sinaimg.cn/large/87c9e458ly1g48r29sz64j20wg0hqtfg.jpg" alt="非阻塞式    i/o"></p><h4 id="2-3-I-O复用"><a href="#2-3-I-O复用" class="headerlink" title="2.3 I/O复用"></a>2.3 I/O复用</h4><p>IO multiplexing就是我们说的select，poll，epoll 。为何叫多路复用，是因为它I/O多路复用可以同时监听多个fd，如此就减少了为每个需要监听的fd开启线程的开销。</p><p>select调用是内核级别的，可以等待多个socket，能实现同时对多个IO端口进行监听<code>，当其中任何一个socket的数据准好了，</code>就能返回进行可读<code>，</code>然后进程再进行recvform系统调用，将数据由内核拷贝到用户进程，这个过程是阻塞的。</p><p>I/O复用模型会用到select、poll、epoll函数，这几个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这几个函数可以同时阻塞多个I/O操作`。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时（不是等到socket数据全部到达再处理, 而是有了一部分数据就会调用用户进程来处理），才真正调用I/O操作函数。</p><p>IO复用有人把其成为同步非阻塞的，也有称为同步阻塞。其实这个是否阻塞还需要看第一个阶段，第一个阶段有的阻塞，有的不阻塞。主要也是阻塞在select阶段，属于用户主动等待阶段，我们且规范为阻塞状态，所以，<code>把IO多路复用归为同步阻塞模式</code>。</p><p>这是IO复用的模型:</p><p><img src="http://wx1.sinaimg.cn/large/87c9e458ly1g48r4580pyj20vc0gc0z0.jpg" alt></p><p>select、poll、epoll的不同</p><p><img src="http://wx3.sinaimg.cn/large/87c9e458ly1g48r54j7btj20wi0giace.jpg" alt="img"></p><h4 id="2-4-信号驱动式I-O"><a href="#2-4-信号驱动式I-O" class="headerlink" title="2.4 信号驱动式I/O"></a>2.4 信号驱动式I/O</h4><p>信号驱动式I/O：首先我们允许Socket进行信号驱动IO,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。</p><p>也就是说第一个阶段，完全是非阻塞的，等数据到达会给一个信号通知，第二个阶段recvfrom还是阻塞过程，和之上无差异。</p><p>信号驱动式I/O 过程如下:</p><p><img src="http://wx2.sinaimg.cn/large/87c9e458ly1g48r5ivr4qj20x40l2wj2.jpg" alt></p><h4 id="2-5-异步I-O"><a href="#2-5-异步I-O" class="headerlink" title="2.5 异步I/O"></a>2.5 异步I/O</h4><p>异步IO不是顺序执行,用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到socket数据准备好了，内核直接复制数据给进程，<code>然后从内核向进程发送通知</code>。<code>IO两个阶段，进程都是非阻塞的</code>。</p><p><img src="http://wx1.sinaimg.cn/large/87c9e458ly1g48r6uzcajj20wo0kkn1r.jpg" alt></p><h4 id="2-6-总结"><a href="#2-6-总结" class="headerlink" title="2.6 总结"></a>2.6 总结</h4><p>针对这5中IO模型，我采用一张图来总结一下。</p><p><img src="http://wx1.sinaimg.cn/large/87c9e458ly1g48r6zq1p4j20zg0mq49j.jpg" alt></p><h3 id="3-java-IO"><a href="#3-java-IO" class="headerlink" title="3. java IO"></a>3. java IO</h3><p>Unix中的五种I/O模型，除信号驱动I/O外，Java对其它四种I/O模型都有所支持。其中Java最早提供的blocking I/O即是同步阻塞I/O，而NIO即是同步非阻塞I/O，同时通过NIO实现的Reactor模式即是I/O复用模型的实现，通过AIO实现的Proactor模式即是异步I/O模型的实现。</p><p>所以说严格意义上来说，通过Reactor模式实现的NIO，和unix中的I/O多路复用是相同的概念，但这是一种编程模型，而不是原生支持。这也是我们下面所要进行的netty讲解的主要思想。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇我们讲到了关于TCP/IP协议的一些内容，这些是网络编程的必备知识。在了解NIO之前我们必须要了解一下对应的系统层IO模型，比如java的NIO对应是那种IO模型，阻塞和同步的差异在哪里，又是否相同。了解了这些更方便我们的后续的NIO探解。&lt;/p&gt;
&lt;h3 id=&quot;1
      
    
    </summary>
    
    
      <category term="nio" scheme="http://yoursite.com/child/tags/nio/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-注解@ConfigurationProperties的正确使用姿势</title>
    <link href="http://yoursite.com/child/2018/10/24/SpringBoot-%E6%B3%A8%E8%A7%A3@ConfigurationProperties%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/"/>
    <id>http://yoursite.com/child/2018/10/24/SpringBoot-注解@ConfigurationProperties的正确使用姿势/</id>
    <published>2018-10-23T16:00:00.000Z</published>
    <updated>2019-11-08T12:55:58.649Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>在编写项目代码时，我们要求更灵活的配置，更好的模块化整合。在 Spring Boot 项目中，为满足以上要求，我们将大量的参数配置在 application.properties 或 application.yml 文件中，通过 <code>@ConfigurationProperties</code> 注解，我们可以方便的获取这些参数值</p><h3 id="2-使用-ConfigurationProperties-配置模块"><a href="#2-使用-ConfigurationProperties-配置模块" class="headerlink" title="2. 使用 @ConfigurationProperties 配置模块"></a>2. 使用 @ConfigurationProperties 配置模块</h3><p>假设我们正在搭建一个发送邮件的模块。在本地测试，我们不想该模块真的发送邮件，所以我们需要一个参数来「开关」 disable 这个功能。另外，我们希望为这些邮件配置一个默认的主题，这样，当我们查看邮件收件箱，通过邮件主题可以快速判断出这是测试邮件</p><p>在 application.yml文件中创建这些参数:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">app:</span> </span><br><span class="line"><span class="attr">  mail:</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">default-subject:</span> <span class="string">This</span> <span class="string">is</span> <span class="string">a</span> <span class="string">Test</span></span><br></pre></td></tr></table></figure><p>我们可以使用 <code>@Value</code> 注解或着使用 Spring <code>Environment</code> bean 访问这些属性，是这种注入配置方式有时显得很笨重。我们将使用更安全的方式(<code>@ConfigurationProperties</code> )来获取这些属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"app.mail"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Boolean enable = Boolean.TRUE;</span><br><span class="line">    <span class="keyword">private</span> String defaultSubject;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取列表类型属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; smtpServer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@ConfigurationProperties</code> 的基本用法非常简单:我们为每个要捕获的外部属性提供一个带有字段的类。请注意以下几点:</p><ul><li>前缀定义了哪些外部属性将绑定到类的字段上</li><li>根据 Spring Boot 宽松的绑定规则，类的属性名称必须与外部属性的名称匹配</li><li>我们可以简单地用一个值初始化一个字段来定义一个默认值</li><li>类本身可以是包私有的</li><li>类的字段必须有公共 setter 方法</li></ul><blockquote><p><strong>Spring 宽松绑定规则 (relaxed binding)</strong>：</p><p>Spring使用一些宽松的绑定属性规则。因此，以下变体都将绑定到 hostName 属性上:</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">app:</span></span><br><span class="line"><span class="attr">  mail:</span> </span><br><span class="line"><span class="attr">    hostName:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">    host-name:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">    host_name:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">    HOST_NAME:</span> <span class="string">localhost</span></span><br></pre></td></tr></table></figure><p>如果我们将 MailProperties 类型的 bean 注入到另一个 bean 中，这个 bean 现在可以以类型安全的方式访问那些外部配置参数的值。</p><p>但是，我们仍然需要让 Spring 知道我们的 @ConfigurationProperties 类存在，以便将其加载到应用程序上下文中。</p><h3 id="3-激活-ConfigurationProperties"><a href="#3-激活-ConfigurationProperties" class="headerlink" title="3. 激活 @ConfigurationProperties"></a>3. 激活 @ConfigurationProperties</h3><p>对于 Spring Boot，创建一个 MailProperties 类型的 bean，我们可以通过下面几种方式将其添加到应用上下文中</p><h4 id="3-1-方式一"><a href="#3-1-方式一" class="headerlink" title="3.1 方式一"></a>3.1 方式一</h4><p>首先，我们可以通过添加 @Component 注解让 Component Scan 扫描到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"app.mail"</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailProperties</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，只有当类所在的包被 Spring <code>@ComponentScan</code> 注解扫描到才会生效，默认情况下，该注解会扫描在主应用类下的所有包结构</p><h4 id="3-2-方式二"><a href="#3-2-方式二" class="headerlink" title="3.2 方式二"></a>3.2 方式二</h4><p>我们也可以通过 Spring 的 Java Configuration 特性实现同样的效果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MailProperties <span class="title">mailProperties</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MailProperties();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要 MailConfiguration 类被 Spring Boot 应用扫描到，我们就可以在应用上下文中访问 MailProperties bean</p><h4 id="3-3-方式三"><a href="#3-3-方式三" class="headerlink" title="3.3 方式三"></a>3.3 方式三</h4><p>我们还可以使用 <code>@EnableConfigurationProperties</code> 注解让我们的类被 Spring Boot 所知道，在该注解中其实是用了<code>@Import(EnableConfigurationPropertiesImportSelector.class)</code> 实现，大家可以看一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(MailProperties.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Properties</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-最佳方式是什么"><a href="#3-4-最佳方式是什么" class="headerlink" title="3.4 最佳方式是什么"></a>3.4 最佳方式是什么</h4><p>所有上述方法都同样有效。然而，我建议模块化你的应用程序，并让每个模块提供自己的<code>@ConfigurationProperties</code> 类，只提供它需要的属性，就像我们在上面的代码中对邮件模块所做的那样。这使得在不影响其他模块的情况下重构一个模块中的属性变得容易。</p><p>因此，我不建议在应用程序类本身上使用 <code>@EnableConfigurationProperties</code>，如许多其他教程中所示，是在特定于模块的 @Configuration 类上使用<code>@EnableConfigurationProperties</code>，该类也可以利用包私有的可见性对应用程序的其余部分隐藏属性。</p><p>所以是<strong>第二种</strong>。</p><h3 id="4-特殊情况操作"><a href="#4-特殊情况操作" class="headerlink" title="4. 特殊情况操作"></a>4. 特殊情况操作</h3><h4 id="4-1-类型不匹配的属性"><a href="#4-1-类型不匹配的属性" class="headerlink" title="4.1 类型不匹配的属性"></a>4.1 类型不匹配的属性</h4><p>如果我们在 application.properties 属性上定义的属性不能被正确的解析会发生什么？假如我们为原本应该为布尔值的属性提供的值为 ‘foo’:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">app:</span></span><br><span class="line"><span class="attr">   mail:</span></span><br><span class="line"><span class="attr">     enable:</span> <span class="string">foo</span></span><br></pre></td></tr></table></figure><p>默认情况下，Spring Boot 将会启动失败，并抛出异常:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Failed to bind properties under &apos;myapp.mail.enabled&apos; to java.lang.Boolean:</span><br><span class="line"></span><br><span class="line">    Property: myapp.mail.enabled</span><br><span class="line">    Value: foo</span><br><span class="line">    Origin: class path resource [application.properties]:1:20</span><br><span class="line">    Reason: failed to convert java.lang.String to java.lang.Boolean</span><br></pre></td></tr></table></figure><p>当我们为属性配置错误的值时，而又不希望 Spring Boot 应用启动失败，我们可以设置 <code>ignoreInvalidFields</code> 属性为 true (默认为 false)，like this：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"app.mail"</span>,ignoreInvalidFields = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailProperties</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，Spring Boot 将会设置 enabled 字段为我们在 Java 代码里设定好的默认值。如果我们没有设置默认值，enabled 将为 null，因为这里定义的是 boolean 的包装类 Boolean</p><h4 id="4-2-未知的属性"><a href="#4-2-未知的属性" class="headerlink" title="4.2 未知的属性"></a>4.2 未知的属性</h4><p>如果我们在 application.yml文件提供了 MailProperties 类中没有字段的属性会发生什么？</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">app:</span></span><br><span class="line"><span class="attr">   mail:</span></span><br><span class="line"><span class="attr">     enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">     default-subject:</span> <span class="string">adaf</span></span><br><span class="line"><span class="attr">     unknow-property:</span> <span class="string">unknow</span></span><br></pre></td></tr></table></figure><p>默认情况下，Spring Boot 会忽略那些不能绑定到 <code>@ConfigurationProperties</code> 类字段的属性</p><p>然而，当配置文件中有一个属性实际上没有绑定到 <code>@ConfigurationProperties</code> 类时，我们可能希望启动失败。也许我们以前使用过这个配置属性，但是它已经被删除了，这种情况我们希望被触发告知手动从 application.properties 删除这个属性</p><p>为了实现上述情况，我们仅需要将 <code>ignoreUnknownFields</code> 属性设置为 false (默认是 true)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"app.mail"</span>,ignoreUnknownFields = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailProperties</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，应用启动时，控制台会反馈我们异常信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Binding to target [Bindable@cf65451 type = com.example.configurationproperties.properties.MailModuleProperties, value = ‘provided‘, annotations = array&lt;Annotation&gt;[@org.springframework.boot.context.properties.ConfigurationProperties(value=myapp.mail, prefix=myapp.mail, ignoreInvalidFields=false, ignoreUnknownFields=false)]] failed:</span><br><span class="line"></span><br><span class="line">    Property: myapp.mail.unknown-property</span><br><span class="line">    Value: foo</span><br><span class="line">    Origin: class path resource [application.properties]:3:29</span><br><span class="line">    Reason: The elements [myapp.mail.unknown-property] were left unbound.</span><br></pre></td></tr></table></figure><blockquote><p>弃用警告??(Deprecation Warning)<br><code>ignoreUnknownFields</code> 在未来 Spring Boot 的版本中会被标记为 deprecated，因为我们可能有两个带有 <code>@ConfigurationProperties</code> 的类，同时绑定到了同一个命名空间 (namespace) 上，其中一个类可能知道某个属性，另一个类却不知道某个属性，这样就会导致启动失败</p></blockquote><h4 id="4-3-启动时校验属性值"><a href="#4-3-启动时校验属性值" class="headerlink" title="4.3 启动时校验属性值"></a>4.3 启动时校验属性值</h4><p>如果我们希望配置参数在传入到应用中时有效的，我们可以通过在字段上添加 <code>bean validation</code> 注解，同时在类上添加 <code>@Validated</code> 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"app.mail"</span>,ignoreInvalidFields = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Boolean enable = Boolean.TRUE;</span><br><span class="line">    <span class="meta">@NotEmpty</span></span><br><span class="line">    <span class="keyword">private</span> String defaultSubject;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们忘记在 application.yml设置 defaultSubject 为空：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">app:</span></span><br><span class="line"><span class="attr">   mail:</span></span><br><span class="line"><span class="attr">     default-subject:</span></span><br></pre></td></tr></table></figure><p>应用启动时，我们将会得到 <code>BindValidationException</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Binding to target org.springframework.boot.context.properties.bind.BindException: Failed to bind properties under ‘myapp.mail‘ to com.example.configurationproperties.properties.MailModuleProperties failed:</span><br><span class="line"></span><br><span class="line">    Property: myapp.mail.enabled</span><br><span class="line">    Value: null</span><br><span class="line">    Reason: must not be null</span><br><span class="line"></span><br><span class="line">    Property: myapp.mail.defaultSubject</span><br><span class="line">    Value: null</span><br><span class="line">    Reason: must not be empty</span><br></pre></td></tr></table></figure><p>当然这些默认的验证注解不能满足你的验证要求，我们也可以自定义注解</p><h4 id="4-4-复杂属性类型"><a href="#4-4-复杂属性类型" class="headerlink" title="4.4 复杂属性类型"></a>4.4 复杂属性类型</h4><h5 id="4-4-1-List-和-Set"><a href="#4-4-1-List-和-Set" class="headerlink" title="4.4.1 List 和 Set"></a>4.4.1 List 和 Set</h5><p>假如，我们为邮件模块提供了一个 SMTP 服务的列表，我们可以添加该属性到 MailModuleProperties 类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"app.mail"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailProperties</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取列表类型属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; smtpServer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们应该在application.yml文件中这样配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">app:</span></span><br><span class="line"><span class="attr">  mail:</span></span><br><span class="line"><span class="attr">    smtp-server:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">10.0</span><span class="number">.23</span><span class="number">.12</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">10.0</span><span class="number">.23</span><span class="number">.61</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">10.0</span><span class="number">.23</span><span class="number">.89</span></span><br></pre></td></tr></table></figure><p>set 集合也是这种方式的配置方式，不再重复书写。另外YAML 是更好的阅读方式，层次分明，所以在实际应用中更推荐大家使用该种方式做数据配置</p><h5 id="4-4-2-Duration"><a href="#4-4-2-Duration" class="headerlink" title="4.4.2 Duration"></a>4.4.2 Duration</h5><p>Spring Boot 内置支持从配置参数中解析 durations (持续时间)，<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-conversion-duration" target="_blank" rel="noopener">官网文档</a> 给出了明确的说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"app.mail"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailProperties</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">    <span class="keyword">private</span> DataSize size;</span><br><span class="line">    <span class="keyword">private</span> Duration time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们既可以配置毫秒数数值，也可配置带有单位的文本:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">app:</span></span><br><span class="line"><span class="attr">  mail:</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    default-subject:</span> <span class="string">This</span> <span class="string">is</span> <span class="string">dev</span> <span class="string">env</span></span><br><span class="line"><span class="attr">    smtp-server:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">10.0</span><span class="number">.23</span><span class="number">.12</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">10.0</span><span class="number">.23</span><span class="number">.61</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">10.0</span><span class="number">.23</span><span class="number">.89</span></span><br><span class="line"><span class="attr">    size:</span> <span class="number">20</span><span class="string">KB</span></span><br><span class="line"><span class="attr">    time:</span> <span class="number">2</span><span class="string">s</span></span><br></pre></td></tr></table></figure><p>官网上已明确说明，配置 duration 不写单位，默认按照毫秒来指定，我们也可已通过 @DurationUnit 来指定单位:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"app.mail"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailProperties</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">    <span class="meta">@DurationUnit</span>(chronoUnit.SECONDS)</span><br><span class="line">    <span class="keyword">private</span> Duration time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用单位如下:</p><ul><li><code>ns</code> for nanoseconds (纳秒)</li><li><code>us</code> for microseconds (微秒)</li><li><code>ms</code> for milliseconds (毫秒)</li><li><code>s</code> for seconds (秒)</li><li><code>m</code> for minutes (分)</li><li><code>h</code> for hours (时)</li><li><code>d</code> for days (天)</li></ul><h5 id="4-4-3-DataSize"><a href="#4-4-3-DataSize" class="headerlink" title="4.4.3  DataSize"></a>4.4.3  DataSize</h5><p>与 Duration 的用法一毛一样，默认单位是 byte (字节)，可以通过 @DataSizeUnit 单位指定:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"app.mail"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailProperties</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">    <span class="meta">@DataSizeUnit</span>(DataUnit.MEGABYTE)</span><br><span class="line">    <span class="keyword">private</span> DataSize size;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，我测试的时候打印出来结果都是以 B (bytes) 来显示</p><p>常见单位如下:</p><ul><li><code>B</code> for bytes</li><li><code>KB</code> for kilobytes</li><li><code>MB</code> for megabytes</li><li><code>GB</code> for gigabytes</li><li><code>TB</code> for terabytes</li></ul><h4 id="4-5-自定义类型"><a href="#4-5-自定义类型" class="headerlink" title="4.5 自定义类型"></a>4.5 自定义类型</h4><p>有些情况，我们想解析配置参数到我们自定义的对象类型上，假设，我们我们设置最大包裹重量:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">app:</span></span><br><span class="line"><span class="attr">  mail:</span></span><br><span class="line"><span class="attr">    max-weight:</span> <span class="number">1</span><span class="string">KG</span></span><br></pre></td></tr></table></figure><p>在 MailProperties 中添加 Weight 属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"app.mail"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailProperties</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">    <span class="keyword">private</span> Weight maxWeight;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以模仿 DataSize 和 Duration 创造自己的 converter (转换器)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightConvert</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Weight</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Weight <span class="title">convert</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将其注册到 Spring Boot 上下文中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationPropertiesBinding</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WeightConvert <span class="title">weightConvert</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WeightConvert();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@ConfigurationPropertiesBinding</code> 注解是让 Spring Boot 知道使用该转换器做数据绑定</p><h3 id="5-使用-Spring-Boot-Configuration-Processor-完成自动补全"><a href="#5-使用-Spring-Boot-Configuration-Processor-完成自动补全" class="headerlink" title="5. 使用 Spring Boot Configuration Processor 完成自动补全"></a>5. 使用 Spring Boot Configuration Processor 完成自动补全</h3><p>我们向项目中添加依赖:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重新 build 项目之后，configuration processor 会为我们创建一个 JSON 文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">文件路径：target/classes/META-INF/spring-configuration-metadata.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"groups"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"app.mail"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"com.pd.properties.properties.MailProperties"</span>,</span><br><span class="line">      <span class="attr">"sourceType"</span>: <span class="string">"com.pd.properties.properties.MailProperties"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"app.message"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"com.pd.properties.properties.MessageProperties"</span>,</span><br><span class="line">      <span class="attr">"sourceType"</span>: <span class="string">"com.pd.properties.properties.MessageProperties"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"properties"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"app.mail.default-subject"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"java.lang.String"</span>,</span><br><span class="line">      <span class="attr">"description"</span>: <span class="string">"默认主题."</span>,</span><br><span class="line">      <span class="attr">"sourceType"</span>: <span class="string">"com.pd.properties.properties.MailProperties"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"app.mail.enable"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"java.lang.Boolean"</span>,</span><br><span class="line">      <span class="attr">"description"</span>: <span class="string">"邮件功能开关."</span>,</span><br><span class="line">      <span class="attr">"sourceType"</span>: <span class="string">"com.pd.properties.properties.MailProperties"</span>,</span><br><span class="line">      <span class="attr">"defaultValue"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"app.mail.smtp-server"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"java.util.List&lt;java.lang.String&gt;"</span>,</span><br><span class="line">      <span class="attr">"description"</span>: <span class="string">"获取列表类型属性"</span>,</span><br><span class="line">      <span class="attr">"sourceType"</span>: <span class="string">"com.pd.properties.properties.MailProperties"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"app.message.from"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"java.lang.String"</span>,</span><br><span class="line">      <span class="attr">"description"</span>: <span class="string">"发送方."</span>,</span><br><span class="line">      <span class="attr">"sourceType"</span>: <span class="string">"com.pd.properties.properties.MessageProperties"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"app.message.size"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"org.springframework.util.unit.DataSize"</span>,</span><br><span class="line">      <span class="attr">"description"</span>: <span class="string">"信息最大大小."</span>,</span><br><span class="line">      <span class="attr">"sourceType"</span>: <span class="string">"com.pd.properties.properties.MessageProperties"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"app.message.time"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"java.time.Duration"</span>,</span><br><span class="line">      <span class="attr">"sourceType"</span>: <span class="string">"com.pd.properties.properties.MessageProperties"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"hints"</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，当我们在 application.properties 和 application.yml 中写配置的时候会有自动提醒</p><p>自动生成的peoperty信息有两种获取途径</p><ul><li>spring从properties bean中自动搜集，description对应字段注释，type对应字段类型，有默认值的字段生成default-vaule等等</li><li>程序员手动编写src\main\resources\META-INF\additional-spring-configuration-metadata.json文件</li></ul><p>程序build的时候，spring将结合上面两种方式生成target/classes/META-INF/spring-configuration-metadata.json文件</p><p><a href="https://www.cnblogs.com/FraserYu/p/11261916.html" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;p&gt;在编写项目代码时，我们要求更灵活的配置，更好的模块化整合。在 Spring Boot 项目中，为满足以上要求，我们将大量
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/child/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>微信支付-异步回调通知</title>
    <link href="http://yoursite.com/child/2018/08/02/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98-%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83%E9%80%9A%E7%9F%A5/"/>
    <id>http://yoursite.com/child/2018/08/02/微信支付-异步回调通知/</id>
    <published>2018-08-01T16:00:00.000Z</published>
    <updated>2019-11-22T05:04:00.617Z</updated>
    
    <content type="html"><![CDATA[<p>应用后台调用统一下单接口时需要指定回调的notify_url，微信支付平台执行统一下单后，会调用该url，发送一个异步通知给应用后台，同时后台需要调用查询微信后台这笔订单的支付结果以及金额，这是一个并行操作，需要注意的是微信后台收到的金额和订单金额需要进行比对，为了防止钓鱼，所以这个查询是有必要的，必须匹配：收到的到账金额 &gt;= 订单金额，具体细节参考<a href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=9_7&amp;index=8" target="_blank" rel="noopener">微信支付开发者文档</a></p><p>好吧，来看一下代码，异步通知地址需要自己配置好，在生成预付单的时候就得传过去，这个地址就是自己的应用后台中的某个rest-controller，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/notice"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notice</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStream inStream = request.getInputStream();</span><br><span class="line">    ByteArrayOutputStream outSteam = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((len = inStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        outSteam.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    outSteam.close();</span><br><span class="line">    inStream.close();</span><br><span class="line">    String result = <span class="keyword">new</span> String(outSteam.toByteArray(), <span class="string">"utf-8"</span>);</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        map = XMLUtil.doXMLParse(result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JDOMException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处调用订单查询接口验证是否交易成功</span></span><br><span class="line">    WXOrderQuery wxpayResult = reqOrderQueryResult(map);</span><br><span class="line">    <span class="keyword">boolean</span> isSucc = wxpayResult.isSuccess();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支付成功，商户处理后同步返回给微信参数</span></span><br><span class="line">    PrintWriter writer = response.getWriter();</span><br><span class="line">    <span class="keyword">if</span> (!isSucc) &#123;</span><br><span class="line">        <span class="comment">// 支付失败， 记录流水失败</span></span><br><span class="line">        System.out.println(<span class="string">"===============支付失败=============="</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        orderService.doWXPayNotice(wxpayResult);</span><br><span class="line">        System.out.println(<span class="string">"===============付款成功，业务处理完毕=============="</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知微信已经收到消息，不要再给我发消息了，否则微信会8连击调用本接口</span></span><br><span class="line">        String noticeStr = setXML(<span class="string">"SUCCESS"</span>, <span class="string">""</span>);</span><br><span class="line">        writer.write(noticeStr);</span><br><span class="line">        writer.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String noticeStr = setXML(<span class="string">"FAIL"</span>, <span class="string">""</span>);</span><br><span class="line">    writer.write(noticeStr);</span><br><span class="line">    writer.flush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">setXML</span><span class="params">(String return_code, String return_msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&lt;xml&gt;&lt;return_code&gt;&lt;![CDATA["</span> + return_code + <span class="string">"]]&gt;&lt;/return_code&gt;&lt;return_msg&gt;&lt;![CDATA["</span> + return_msg + <span class="string">"]]&gt;&lt;/return_msg&gt;&lt;/xml&gt;"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XMLUtil.java是用于解析支付结果通知信息的工具类，用到了</p><p><code>compile group: &#39;jdom&#39;, name: &#39;jdom&#39;, version: &#39;1.0&#39;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * XMLUtil</span></span><br><span class="line"><span class="comment"> * 用于解析微信的异步通知信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhaozhengkang@cetiti.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMLUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析xml,返回第一级元素键值对。如果第一级元素有子节点，则此节点的值是子节点的xml数据。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strxml</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> JDOMException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title">doXMLParse</span><span class="params">(String strxml)</span> <span class="keyword">throws</span> JDOMException, IOException </span>&#123;</span><br><span class="line">        strxml = strxml.replaceFirst(<span class="string">"encoding=\".*\""</span>, <span class="string">"encoding=\"UTF-8\""</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == strxml || <span class="string">""</span>.equals(strxml)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map m = <span class="keyword">new</span> HashMap();</span><br><span class="line">        InputStream in = <span class="keyword">new</span> ByteArrayInputStream(strxml.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">        SAXBuilder builder = <span class="keyword">new</span> SAXBuilder();</span><br><span class="line">        Document doc = builder.build(in);</span><br><span class="line">        Element root = doc.getRootElement();</span><br><span class="line">        List list = root.getChildren();</span><br><span class="line">        Iterator it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">            Element e = (Element) it.next();</span><br><span class="line">            String k = e.getName();</span><br><span class="line">            String v = <span class="string">""</span>;</span><br><span class="line">            List children = e.getChildren();</span><br><span class="line">            <span class="keyword">if</span>(children.isEmpty()) &#123;</span><br><span class="line">                v = e.getTextNormalize();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                v = XMLUtil.getChildrenText(children);</span><br><span class="line">            &#125;</span><br><span class="line">            m.put(k, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        in.close();</span><br><span class="line">        log.error(<span class="string">"doXMLParse  m==="</span>+m.toString());</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取子结点的xml</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> children</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getChildrenText</span><span class="params">(List children)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">if</span>(!children.isEmpty()) &#123;</span><br><span class="line">            Iterator it = children.iterator();</span><br><span class="line">            <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">                Element e = (Element) it.next();</span><br><span class="line">                String name = e.getName();</span><br><span class="line">                String value = e.getTextNormalize();</span><br><span class="line">                List list = e.getChildren();</span><br><span class="line">                sb.append(<span class="string">"&lt;"</span> + name + <span class="string">"&gt;"</span>);</span><br><span class="line">                <span class="keyword">if</span>(!list.isEmpty()) &#123;</span><br><span class="line">                    sb.append(XMLUtil.getChildrenText(list));</span><br><span class="line">                &#125;</span><br><span class="line">                sb.append(value);</span><br><span class="line">                sb.append(<span class="string">"&lt;/"</span> + name + <span class="string">"&gt;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.error(<span class="string">"getChildrenText  sb===="</span>+sb.toString());</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WXOrderQuery <span class="title">reqOrderQueryResult</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">    WXOrderQuery orderQuery = <span class="keyword">new</span> WXOrderQuery();</span><br><span class="line">    orderQuery.setAppid(map.get(<span class="string">"appid"</span>));</span><br><span class="line">    orderQuery.setMch_id(map.get(<span class="string">"mch_id"</span>));</span><br><span class="line">    orderQuery.setTransaction_id(map.get(<span class="string">"transaction_id"</span>));</span><br><span class="line">    orderQuery.setOut_trade_no(map.get(<span class="string">"out_trade_no"</span>));</span><br><span class="line">    orderQuery.setNonce_str(map.get(<span class="string">"nonce_str"</span>));</span><br><span class="line">    String payFlowId = map.get(<span class="string">"attach"</span>);</span><br><span class="line">    orderQuery.setAttach(payFlowId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此处需要密钥PartnerKey，此处直接写死，自己的业务需要从持久化中获取此密钥，否则会报签名错误</span></span><br><span class="line">    orderQuery.setPartnerKey(WXPayContants.partnerKey);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, String&gt; orderMap = orderQuery.reqOrderquery();</span><br><span class="line">    <span class="comment">//此处添加支付成功后，支付金额和实际订单金额是否等价，防止钓鱼</span></span><br><span class="line">    <span class="keyword">if</span> (orderMap.get(<span class="string">"return_code"</span>) != <span class="keyword">null</span> &amp;&amp; </span><br><span class="line">        orderMap.get(<span class="string">"return_code"</span>).equalsIgnoreCase(<span class="string">"SUCCESS"</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (orderMap.get(<span class="string">"trade_state"</span>) != <span class="keyword">null</span> &amp;&amp; </span><br><span class="line">            orderMap.get(<span class="string">"trade_state"</span>).equalsIgnoreCase(<span class="string">"SUCCESS"</span>)) &#123;</span><br><span class="line">            <span class="comment">// 查询订单（交易流水的实际金额），判断微信收到的钱和订单中的钱是否等额</span></span><br><span class="line">            SpPayFlowCargoSource payFlow = spPayFlowCargoSourceService.getPayFlowById(payFlowId);</span><br><span class="line">            String total_fee = map.get(<span class="string">"total_fee"</span>);</span><br><span class="line">            orderQuery.setPayFlow(payFlow);</span><br><span class="line">            Integer db_fee = payFlow.getFee().multiply(<span class="keyword">new</span> BigDecimal(<span class="number">100</span>)).intValue();</span><br><span class="line">            <span class="keyword">if</span> (Integer.parseInt(total_fee) == db_fee) &#123;</span><br><span class="line">                orderQuery.setSuccess(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span> orderQuery;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    orderQuery.setSuccess(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> orderQuery;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这一步，就能判断金额到底对不对，对了那么久成功支付，订单进行下一步流程~</p><p>再次强调，一定要防止钓鱼，另外异步调用的时候需要去查看你的订单或者交易流水是否已经成功了，成功就没有必要继续走，直接return就行</p><p>在高并发场景下，收到的支付结果通知应该发布到MQ，后台另起一线程订阅MQ并做相应处理，如下图：</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/java%E7%BC%96%E7%A8%8B/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="微信支付流程"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;应用后台调用统一下单接口时需要指定回调的notify_url，微信支付平台执行统一下单后，会调用该url，发送一个异步通知给应用后台，同时后台需要调用查询微信后台这笔订单的支付结果以及金额，这是一个并行操作，需要注意的是微信后台收到的金额和订单金额需要进行比对，为了防止钓鱼
      
    
    </summary>
    
    
      <category term="其他" scheme="http://yoursite.com/child/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>源码分析-会用HashMap</title>
    <link href="http://yoursite.com/child/2018/07/21/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BC%9A%E7%94%A8HashMap/"/>
    <id>http://yoursite.com/child/2018/07/21/源码分析-会用HashMap/</id>
    <published>2018-07-21T12:41:36.000Z</published>
    <updated>2019-11-08T12:58:26.825Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一个问题引发的思考"><a href="#一个问题引发的思考" class="headerlink" title="一个问题引发的思考"></a>一个问题引发的思考</h3><p>如果确定只装载100个元素，new HashMap(?)多少是最佳的，why？<br>要弄解答这个问题，第一要知道HashMap的数据结构，第二再弄明白存取数据的逻辑。</p><h3 id="1-首先，我是一个数组"><a href="#1-首先，我是一个数组" class="headerlink" title="1.首先，我是一个数组"></a>1.首先，我是一个数组</h3><p>HashMap本质上是一个数组，数组的每个元素是一个单链表或者红黑树，由0个或多个节点组成。<br>java源码中的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><h4 id="1-1节点类Node-lt-K-V-gt"><a href="#1-1节点类Node-lt-K-V-gt" class="headerlink" title="1.1节点类Node&lt;K,V&gt;"></a>1.1节点类Node&lt;K,V&gt;</h4><p>Node类是HashMap的一个静态内部类，可以将其看成是一个独立的类，只是声明在HashMap类内部而已。下面是源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;//Entry是Map接口中的一个内部接口</span><br><span class="line">    final int hash;//此节点的哈希值，同一个链表上的哈希值不一定相同</span><br><span class="line">    final K key;//键，不能修改</span><br><span class="line">    V value;//值</span><br><span class="line">    Node&lt;K,V&gt; next;//指向下一个节点</span><br><span class="line"> </span><br><span class="line">    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        this.hash = hash;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public final K getKey()        &#123; return key; &#125;</span><br><span class="line">    public final V getValue()      &#123; return value; &#125;</span><br><span class="line">    public final String toString() &#123; return key + &quot;=&quot; + value; &#125;</span><br><span class="line"> </span><br><span class="line">    public final int hashCode() &#123;//此Node类的hashCode方法</span><br><span class="line">        return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public final V setValue(V newValue) &#123;//重新设置节点Value，返回旧Value</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public final boolean equals(Object o) &#123;//判断节点相等的方法，</span><br><span class="line">        if (o == this)//同一个对象，返回true</span><br><span class="line">            return true;</span><br><span class="line">        if (o instanceof Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                return true;//键和值都相等则返回true</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2为啥有链表还有树"><a href="#1-2为啥有链表还有树" class="headerlink" title="1.2为啥有链表还有树"></a>1.2为啥有链表还有树</h4><p>为了提高查询效率，当链表的长度达到阈值的时候会自动将链表树形化，源码中的三个阈值常量如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static final int TREEIFY_THRESHOLD = 8;</span><br><span class="line">static final int UNTREEIFY_THRESHOLD = 6;</span><br><span class="line">static final int MIN_TREEIFY_CAPACITY = 64;</span><br></pre></td></tr></table></figure><ul><li>TREEIFY_THRESHOLD 树形化阈值：当链表长度超过这个值的时候，将链表进行树形化改造</li><li>UNTREEIFY_THRESHOLD 链表化阈值：当节点数低于这个阈值，将红黑树改造成链表。这个值必须必树形化阈值小，避免频繁的转换。</li><li>MIN_TREEIFY_CAPACITY 最小树形化容量：当数组table的长度低于这个值，即使元素链表的长度超过树形化阈值，也不会进行树形化改造，而是对table进行扩容。这个值不能小于4*TREEIFY_THRESHOLD  <h3 id="2-怎么进行数据的存取呢"><a href="#2-怎么进行数据的存取呢" class="headerlink" title="2.怎么进行数据的存取呢"></a>2.怎么进行数据的存取呢</h3><h4 id="2-1hash方法"><a href="#2-1hash方法" class="headerlink" title="2.1hash方法"></a>2.1hash方法</h4>拿到一个&lt;Key,Value&gt;，要存在table的哪个位置呢，这就需要用hash方法来决定了。。。<br>从代码说起：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>key.hashCode()函数调用的是key键值类型自带的哈希函数（与HashMap的hashCode()函数不是同一个），它返回一个32位int类型的散列值。</li><li>考虑到hash值得取值范围太大，不可能创建一个如此大的hash table，因此定位到table的位置只使用hash值的后几位（具体位数与table长度有关）。</li><li>如果只取后几位，碰撞会比较严重，因此就有了扰动函数，将hash值右移16位（高16位移到低16位），再与自身亦或，得到的结果混合了原hash值得高位和低位，以此来加大低位的随机性。</li></ul><h4 id="2-2定位"><a href="#2-2定位" class="headerlink" title="2.2定位"></a>2.2定位</h4><p>最终得到的hash值，将由低位进行定位，定位操作如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n = tab.length</span><br><span class="line">tab[(n - 1) &amp; hash]</span><br></pre></td></tr></table></figure></p><ul><li>数组长度必为2的整数次幂，因此(n-1)相当于低位掩码，与h进行与操作，保留h低位，掩盖高位。</li><li>这里不做取余，是因为取余可能为负数（hashCode为负数的时候）</li><li>不对取余进行模运算，是因为最大的整数Math.abs()会返回负值</li><li>由此可知，对于HashMap的同一个链表的各个节点key值得hash值不一定相同（只是低位相同）</li></ul><h4 id="2-3扩容-resize"><a href="#2-3扩容-resize" class="headerlink" title="2.3扩容(resize)"></a>2.3扩容(resize)</h4><h5 id="默认容量是16"><a href="#默认容量是16" class="headerlink" title="默认容量是16"></a>默认容量是16</h5><p>16是2的整数次幂的原因，在小数据量的情况下16比15或20更能减少key之间的碰撞，而加快查询的效率。 </p><h5 id="容量是15会怎样？"><a href="#容量是15会怎样？" class="headerlink" title="容量是15会怎样？"></a>容量是15会怎样？</h5><p>当数组长度为15的时候，hashcode的值会与14（1110）进行“与”，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率（hash不均匀），降低了查询的效率！<br>所以，在存储大容量数据的时候，最好预先指定hashmap的size为2的整数次幂次方。就算不指定的话，也会以大于且最接近指定值大小的2次幂来初始化的，代码如下(HashMap的构造方法中)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int capacity = 1;  </span><br><span class="line">while (capacity &lt; initialCapacity)   </span><br><span class="line">    capacity &lt;&lt;= 1;  //乘以2</span><br></pre></td></tr></table></figure></p><h5 id="什么时候扩容-amp-怎么扩容"><a href="#什么时候扩容-amp-怎么扩容" class="headerlink" title="什么时候扩容&amp;怎么扩容"></a>什么时候扩容&amp;怎么扩容</h5><p>当hashmap中的元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对hashmap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，所以这是一个通用的操作，很多人对它的性能表示过怀疑，不过想想我们的“均摊”原理，就释然了，而在hashmap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。<br>那么hashmap什么时候进行扩容呢？当hashmap中的元素个数超过数组大小length x loadFactor时，就会进行数组扩容，==<strong>loadFactor的默认值为0.75</strong>==，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过16x0.75=12的时候，就把数组的大小扩展为2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以++如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能++。  </p><h5 id="回到开篇的问题"><a href="#回到开篇的问题" class="headerlink" title="回到开篇的问题"></a>回到开篇的问题</h5><p>当有100个元素new HashMap(100), 但是理论上来讲new HashMap(128)更合适，不过上面已经说过，即使是100，hashmap也自动会将其设置为128。 但是new HashMap(128)还不是更合适的，因为0.75x100 &lt; 100, 也就是说为了让0.75 x size &gt; 100, 我们必须这样new HashMap(256)才最合适，既考虑了&amp;的问题，也避免了resize的问题。 </p><h3 id="3-可以使用自定义的类作为key的类型吗"><a href="#3-可以使用自定义的类作为key的类型吗" class="headerlink" title="3.可以使用自定义的类作为key的类型吗"></a>3.可以使用自定义的类作为key的类型吗</h3><p>可以，但是必须改写key类型的hashcode与equals方法<br>首先计算key的hashcode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。所以，hashcode与equals方法对于找到对应元素是两个关键方法。<br>Hashmap的key可以是任何类型的对象，例如User这种对象，为了保证两个具有相同属性的user的hashcode相同，我们就需要改写hashcode方法，比方把hashcode值的计算与User对象的id关联起来，那么只要user对象拥有相同id，那么他们的hashcode也能保持一致了，这样就可以找到在hashmap数组中的位置了。如果这个位置上有多个元素，还需要用key的equals方法在对应位置的链表中找到需要的元素，所以只改写了hashcode方法是不够的，equals方法也是需要改写滴~当然啦，按正常思维逻辑，equals方法一般都会根据实际的业务内容来定义，例如根据user对象的id来判断两个user是否相等。  </p><hr><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://www.iteye.com/topic/539465" target="_blank" rel="noopener">深入理解HashMap</a><br><a href="https://blog.csdn.net/u010292561/article/details/80472555" target="_blank" rel="noopener">HashMap详解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一个问题引发的思考&quot;&gt;&lt;a href=&quot;#一个问题引发的思考&quot; class=&quot;headerlink&quot; title=&quot;一个问题引发的思考&quot;&gt;&lt;/a&gt;一个问题引发的思考&lt;/h3&gt;&lt;p&gt;如果确定只装载100个元素，new HashMap(?)多少是最佳的，why？&lt;br
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/child/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-并发容器CopyOnWriteArrayList</title>
    <link href="http://yoursite.com/child/2018/05/26/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-CopyOnWrite%E5%AE%B9%E5%99%A8/"/>
    <id>http://yoursite.com/child/2018/05/26/并发编程-CopyOnWrite容器/</id>
    <published>2018-05-26T04:32:12.000Z</published>
    <updated>2019-05-28T14:59:58.865Z</updated>
    
    <content type="html"><![CDATA[<p>Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。</p><h3 id="1-什么是CopyOnWrite容器"><a href="#1-什么是CopyOnWrite容器" class="headerlink" title="1. 什么是CopyOnWrite容器"></a>1. 什么是CopyOnWrite容器</h3><p>CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p><h3 id="2-CopyOnWriteArrayList的实现原理"><a href="#2-CopyOnWriteArrayList的实现原理" class="headerlink" title="2. CopyOnWriteArrayList的实现原理"></a>2. CopyOnWriteArrayList的实现原理</h3><p>在使用CopyOnWriteArrayList之前，我们先阅读其源码了解下它是如何实现的。以下代码是向CopyOnWriteArrayList中add方法的实现（向CopyOnWriteArrayList里添加元素），可以发现在添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        int len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + 1);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读的时候不需要加锁，如果读的时候有多个线程正在向CopyOnWriteArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的CopyOnWriteArrayList。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    return get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK中并没有提供CopyOnWriteMap，我们可以参考CopyOnWriteArrayList来实现一个，基本代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Set;</span><br><span class="line"> </span><br><span class="line">public class CopyOnWriteMap&lt;K, V&gt; implements Map&lt;K, V&gt;, Cloneable &#123;</span><br><span class="line">    private volatile Map&lt;K, V&gt; internalMap;</span><br><span class="line"> </span><br><span class="line">    public CopyOnWriteMap() &#123;</span><br><span class="line">        internalMap = new HashMap&lt;K, V&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public V put(K key, V value) &#123;</span><br><span class="line"> </span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            Map&lt;K, V&gt; newMap = new HashMap&lt;K, V&gt;(internalMap);</span><br><span class="line">            V val = newMap.put(key, value);</span><br><span class="line">            internalMap = newMap;</span><br><span class="line">            return val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public V get(Object key) &#123;</span><br><span class="line">        return internalMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void putAll(Map&lt;? extends K, ? extends V&gt; newData) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            Map&lt;K, V&gt; newMap = new HashMap&lt;K, V&gt;(internalMap);</span><br><span class="line">            newMap.putAll(newData);</span><br><span class="line">            internalMap = newMap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现很简单，只要了解了CopyOnWrite机制，我们可以实现各种CopyOnWrite容器，并且在不同的应用场景中使用。</p><h3 id="3-CopyOnWrite的应用场景"><a href="#3-CopyOnWrite的应用场景" class="headerlink" title="3. CopyOnWrite的应用场景"></a>3. CopyOnWrite的应用场景</h3><p>CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Map;</span><br><span class="line"> </span><br><span class="line">import com.ifeve.book.forkjoin.CopyOnWriteMap;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 黑名单服务</span><br><span class="line"> *</span><br><span class="line"> * @author fangtengfei</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class BlackListServiceImpl &#123;</span><br><span class="line"> </span><br><span class="line">    private static CopyOnWriteMap&lt;String, Boolean&gt; blackListMap = new CopyOnWriteMap&lt;String, Boolean&gt;(</span><br><span class="line">            1000);</span><br><span class="line"> </span><br><span class="line">    public static boolean isBlackList(String id) &#123;</span><br><span class="line">        return blackListMap.get(id) == null ? false : true;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void addBlackList(String id) &#123;</span><br><span class="line">        blackListMap.put(id, Boolean.TRUE);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 批量添加黑名单</span><br><span class="line">     *</span><br><span class="line">     * @param ids</span><br><span class="line">     */</span><br><span class="line">    public static void addBlackList(Map&lt;String,Boolean&gt; ids) &#123;</span><br><span class="line">        blackListMap.putAll(ids);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，但是使用CopyOnWriteMap需要注意两件事情：</p><ol><li>减少扩容开销。根据实际需要，初始化CopyOnWriteMap的大小，避免写时CopyOnWriteMap扩容的开销。</li><li>使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。如使用上面代码里的addBlackList方法。  </li></ol><h3 id="4-CopyOnWrite的缺点"><a href="#4-CopyOnWrite的缺点" class="headerlink" title="4. CopyOnWrite的缺点"></a>4. CopyOnWrite的缺点</h3><p>CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。</p><ul><li>内存占用问题。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。</li></ul><p>针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。</p><ul><li>数据一致性问题。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</li></ul><h3 id="5-相关文章"><a href="#5-相关文章" class="headerlink" title="5. 相关文章"></a>5. 相关文章</h3><p><a href="http://blog.csdn.net/wind5shy/article/details/5396887" target="_blank" rel="noopener">CopyOnWriteArrayList和同步容器的性能验证</a></p><p><a href="http://blog.csdn.net/imzoer/article/details/9751591" target="_blank" rel="noopener">CopyOnWriteArrayList使用简介</a></p><p>　　</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用Co
      
    
    </summary>
    
    
      <category term="并发编程" scheme="http://yoursite.com/child/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-ConcurrentHashMap源码分析</title>
    <link href="http://yoursite.com/child/2018/05/25/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/child/2018/05/25/并发编程-ConcurrentHashMap源码分析/</id>
    <published>2018-05-25T04:35:45.000Z</published>
    <updated>2019-06-12T09:32:31.636Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-重要的属性"><a href="#1-重要的属性" class="headerlink" title="1.重要的属性"></a>1.重要的属性</h3><p>首先来看几个重要的属性，与HashMap相同的就不再介绍了，这里重点解释一下sizeCtl这个属性。可以说它是ConcurrentHashMap中出镜率很高的一个属性，因为它是一个控制标识符，在不同的地方有不同用途，而且它的取值不同，也代表不同的含义。</p><ul><li>负数代表正在进行初始化或扩容操作</li><li>-1代表正在初始化</li><li>-N 表示有N-1个线程正在进行扩容操作</li><li>正数或0代表hash表还没有被初始化，这个数值表示初始化或下一次进行扩容的大小，这一点类似于扩容阈值的概念。还后面可以看到，它的值始终是当前ConcurrentHashMap容量的0.75倍，这与loadfactor是对应的。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//盛装Node元素的数组,它的大小是2的整数次幂</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> hash表初始化或扩容时的一个控制位标识量。</span></span><br><span class="line"><span class="comment"> 负数代表正在进行初始化或扩容操作</span></span><br><span class="line"><span class="comment"> -1代表正在初始化</span></span><br><span class="line"><span class="comment"> -N 表示有N-1个线程正在进行扩容操作</span></span><br><span class="line"><span class="comment"> 正数或0代表hash表还没有被初始化，这个数值表示初始化或下一次进行扩容的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下两个是用来控制扩容的时候 单线程进入的变量</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of bits used for generation stamp in sizeCtl.</span></span><br><span class="line"><span class="comment"> * Must be at least 6 for 32bit arrays.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bit shift for recording size stamp in sizeCtl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span>- RESIZE_STAMP_BITS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>;<span class="comment">// hash值是-1，表示这是一个forwardNode节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>;<span class="comment">// hash值是-2  表示这时一个TreeBin节点</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-重要的类"><a href="#2-重要的类" class="headerlink" title="2.重要的类"></a>2.重要的类</h3><h4 id="2-1-Node"><a href="#2-1-Node" class="headerlink" title="2.1 Node"></a>2.1 Node</h4><p>Node是最核心的内部类，它包装了key-value键值对，所有插入ConcurrentHashMap的数据都包装在这里面。它与HashMap中的定义很相似，但是但是有一些差别它对value和next属性设置了volatile同步锁(与JDK7的Segment相同)，它不允许调用setValue方法直接改变Node的value域，它增加了find方法辅助map.get()方法。</p><h4 id="2-2-TreeNode"><a href="#2-2-TreeNode" class="headerlink" title="2.2 TreeNode"></a>2.2 TreeNode</h4><p>树节点类，另外一个核心的数据结构。当链表长度过长的时候，会转换为TreeNode。但是与HashMap不相同的是，它并不是直接转换为红黑树，而是把这些结点包装成TreeNode放在TreeBin对象中，由TreeBin完成对红黑树的包装。而且TreeNode在ConcurrentHashMap集成自Node类，而并非HashMap中的集成自LinkedHashMap.Entry&lt;K,V&gt;类，也就是说TreeNode带有next指针，这样做的目的是方便基于TreeBin的访问。</p><h4 id="2-3-TreeBin"><a href="#2-3-TreeBin" class="headerlink" title="2.3 TreeBin"></a>2.3 TreeBin</h4><p>这个类并不负责包装用户的key、value信息，而是包装的很多TreeNode节点。它代替了TreeNode的根节点，也就是说在实际的ConcurrentHashMap“数组”中，存放的是TreeBin对象，而不是TreeNode对象，这是与HashMap的区别。另外这个类还带有了读写锁。</p><p>这里仅贴出它的构造方法。可以看到在构造TreeBin节点时，仅仅指定了它的hash值为TREEBIN常量，这也就是个标识为。同时也看到我们熟悉的红黑树构造方法</p><h4 id="2-4-ForwardingNode"><a href="#2-4-ForwardingNode" class="headerlink" title="2.4 ForwardingNode"></a>2.4 ForwardingNode</h4><p>一个用于连接两个table的节点类。它包含一个nextTable指针，用于指向下一张表。而且这个节点的key value next指针全部为null，它的hash值为-1. 这里面定义的find的方法是从nextTable里进行查询节点，而不是以自身为头节点进行查找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A node inserted at head of bins during transfer operations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        <span class="keyword">super</span>(MOVED,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(inth, Object k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// loop to avoid arbitrarily deep recursion on forwarding nodes</span></span><br><span class="line">        outer:<span class="keyword">for</span>(Node&lt;K,V&gt;[] tab = nextTable;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; intn;</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="keyword">null</span>|| tab == <span class="keyword">null</span>|| (n = tab.length) == <span class="number">0</span>||</span><br><span class="line">                (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) == <span class="keyword">null</span>)</span><br><span class="line">                returnnull;</span><br><span class="line">            <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">                inteh; K ek;</span><br><span class="line">                <span class="keyword">if</span>((eh = e.hash) == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == k || (ek != <span class="keyword">null</span>&amp;&amp; k.equals(ek))))</span><br><span class="line">                    returne;</span><br><span class="line">                <span class="keyword">if</span>(eh &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(einstanceofForwardingNode) &#123;</span><br><span class="line">                        tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;</span><br><span class="line">                        continueouter;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        returne.find(h, k);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>((e = e.next) == <span class="keyword">null</span>)</span><br><span class="line">                    returnnull;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Unsafe与CAS"><a href="#3-Unsafe与CAS" class="headerlink" title="3.Unsafe与CAS"></a>3.Unsafe与CAS</h3><p>在ConcurrentHashMap中，随处可以看到U, 大量使用了U.compareAndSwapXXX的方法，这个方法是利用一个CAS算法实现无锁化的修改值的操作，他可以大大降低锁代理的性能消耗。这个算法的基本思想就是不断地去比较当前内存中的变量值与你指定的一个变量值是否相等，如果相等，则接受你指定的修改的值，否则拒绝你的操作。因为当前线程中的值已经不是最新的值，你的修改很可能会覆盖掉其他线程修改的结果。这一点与乐观锁，SVN的思想是比较类似的。</p><h4 id="3-1-unsafe静态块"><a href="#3-1-unsafe静态块" class="headerlink" title="3.1 unsafe静态块"></a>3.1 unsafe静态块</h4><p>unsafe代码块控制了一些属性的修改工作，比如最常用的SIZECTL 。在这一版本的concurrentHashMap中，大量应用来的CAS方法进行变量、属性的修改工作。利用CAS进行无锁操作，可以大大提高性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe U;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SIZECTL;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TRANSFERINDEX;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> BASECOUNT;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CELLSBUSY;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CELLVALUE;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ABASE;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ASHIFT;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">static</span>&#123;</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">           Class&lt;?&gt; k = ConcurrentHashMap.class;</span><br><span class="line">           SIZECTL = U.objectFieldOffset(k.getDeclaredField(<span class="string">"sizeCtl"</span>));</span><br><span class="line">           TRANSFERINDEX = U.objectFieldOffset(k.getDeclaredField(<span class="string">"transferIndex"</span>));</span><br><span class="line">           BASECOUNT = U.objectFieldOffset(k.getDeclaredField(<span class="string">"baseCount"</span>));</span><br><span class="line">           CELLSBUSY = U.objectFieldOffset(k.getDeclaredField(<span class="string">"cellsBusy"</span>));</span><br><span class="line">           Class&lt;?&gt; ck = CounterCell.class;</span><br><span class="line">           CELLVALUE = U.objectFieldOffset(ck.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">           Class&lt;?&gt; ak = Node[].class;</span><br><span class="line">           ABASE = U.arrayBaseOffset(ak);</span><br><span class="line">           intscale = U.arrayIndexScale(ak);</span><br><span class="line">           <span class="keyword">if</span>((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">               thrownewError(<span class="string">"data type scale not a power of two"</span>);</span><br><span class="line">           ASHIFT = <span class="number">31</span>- Integer.numberOfLeadingZeros(scale);</span><br><span class="line">       &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">           thrownewError(e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-三个核心方法"><a href="#3-2-三个核心方法" class="headerlink" title="3.2 三个核心方法"></a>3.2 三个核心方法</h4><p>ConcurrentHashMap定义了三个原子操作，用于对指定位置的节点进行操作。正是这些原子操作保证了ConcurrentHashMap的线程安全。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123;</span><br><span class="line">//获得在i位置上的Node节点</span><br><span class="line">    return(Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123;</span><br><span class="line">    //因此当前线程中的值并不是最新的值，这种修改可能会覆盖掉其他线程的修改结果有点类似于SVN</span><br><span class="line">    returnU.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static final &lt;K,V&gt; voidsetTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v) &#123;</span><br><span class="line">    //利用volatile方法设置节点位置的值</span><br><span class="line">    U.putObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-初始化方法initTable"><a href="#4-初始化方法initTable" class="headerlink" title="4 初始化方法initTable"></a>4 初始化方法initTable</h3><p>对于ConcurrentHashMap来说，调用它的构造方法仅仅是设置了一些参数而已。而整个table的初始化是在向ConcurrentHashMap中插入元素的时候发生的。如调用put、computeIfAbsent、compute、merge等方法的时候，调用时机是检查table==null。</p><p>初始化方法主要应用了关键属性sizeCtl 如果这个值〈0，表示其他线程正在进行初始化，就放弃这个操作。在这也可以看出ConcurrentHashMap的初始化只能由一个线程完成。如果获得了初始化权限，就用CAS方法将sizeCtl置为-1，防止其他线程进入。初始化数组后，将sizeCtl的值改为0.75*n。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; </span><br><span class="line">    int sc;</span><br><span class="line">    while((tab = table) == null|| tab.length == 0) &#123;</span><br><span class="line">        //sizeCtl表示有其他线程正在进行初始化操作，把线程挂起。对于table的初始化工作，只能有一个线程在进行。</span><br><span class="line">        if((sc = sizeCtl) &lt; 0)</span><br><span class="line">            Thread.yield();</span><br><span class="line">        else if(U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line">            //利用CAS方法把sizectl的值置为-1 表示本线程正在进行初始化</span><br><span class="line">            try&#123;</span><br><span class="line">                if((tab = table) == null|| tab.length == 0) &#123;</span><br><span class="line">                    intn = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])newNode&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; 2);//相当于0.75*n 设置一个扩容的阈值</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;finally&#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    returntab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-扩容方法-transfer"><a href="#5-扩容方法-transfer" class="headerlink" title="5 扩容方法 transfer"></a>5 扩容方法 transfer</h3><p>当ConcurrentHashMap容量不足的时候，需要对table进行扩容。这个方法的基本思想跟HashMap是很像的，但是由于它是支持并发扩容的，所以要复杂的多。原因是它支持多线程进行扩容操作，而并没有加锁。我想这样做的目的不仅仅是为了满足concurrent的要求，而是希望利用并发处理去减少扩容带来的时间影响。因为在扩容的时候，总是会涉及到从一个“数组”到另一个“数组”拷贝的操作，如果这个操作能够并发进行，那真真是极好的了。</p><p>整个扩容操作分为两个部分</p><ul><li>第一部分是构建一个nextTable,它的容量是原来的两倍，这个操作是单线程完成的。这个单线程的保证是通过RESIZE_STAMP_SHIFT这个常量经过一次运算来保证的，这个地方在后面会有提到；</li><li>第二个部分就是将原来table中的元素复制到nextTable中，这里允许多线程进行操作。  </li></ul><p>先来看一下单线程是如何完成的：<br>它的大体思想就是遍历、复制的过程。首先根据运算得到需要遍历的次数i，然后利用tabAt方法获得i位置的元素：</p><ol><li>如果这个位置为空，就在原table中的i位置放入forwardNode节点，这个也是触发并发扩容的关键点； </li><li>如果这个位置是Node节点（fh&gt;=0），如果它是一个链表的头节点，就构造一个反序链表，把他们分别放在nextTable的i和i+n的位置上</li><li>如果这个位置是TreeBin节点（fh&lt;0），也做一个反序处理，并且判断是否需要untreefi，把处理的结果分别放在nextTable的i和i+n的位置上</li><li>遍历过所有的节点以后就完成了复制工作，这时让nextTable作为新的table，并且更新sizeCtl为新容量的0.75倍 ，完成扩容。<br>再看一下多线程是如何完成的：</li></ol><p>在代码的69行有一个判断，如果遍历到的节点是forward节点，就向后继续遍历，再加上给节点上锁的机制，就完成了多线程的控制。多线程遍历节点，处理了一个节点，就把对应点的值set为forward，另一个线程看到forward，就向后遍历。这样交叉就完成了复制工作。而且还很好的解决了线程安全的问题。 这个方法的设计实在是让我膜拜。</p><h3 id="6-Put方法"><a href="#6-Put方法" class="headerlink" title="6 Put方法"></a>6 Put方法</h3><p>前面的所有的介绍其实都为这个方法做铺垫。ConcurrentHashMap最常用的就是put和get两个方法。现在来介绍put方法，这个put方法依然沿用HashMap的put方法的思想，根据hash值计算这个新插入的点在table中的位置i，如果i位置是空的，直接放进去，否则进行判断，如果i位置是树节点，按照树的方式插入新的节点，否则把i插入到链表的末尾。ConcurrentHashMap中依然沿用这个思想，有一个最重要的不同点就是ConcurrentHashMap不允许key或value为null值。另外由于涉及到多线程，put方法就要复杂一点。在多线程中可能有以下两个情况</p><ol><li>如果一个或多个线程正在对ConcurrentHashMap进行扩容操作，当前线程也要进入扩容的操作中。这个扩容的操作之所以能被检测到，是因为transfer方法中在空结点上插入forward节点，如果检测到需要插入的位置被forward节点占有，就帮助进行扩容；</li><li>如果检测到要插入的节点是非空且不是forward节点，就对这个节点加锁，这样就保证了线程安全。尽管这个有一些影响效率，但是还是会比hashTable的synchronized要好得多。  </li></ol><p>整体流程就是首先定义不允许key或value为null的情况放入  对于每一个放入的值，首先利用spread方法对key的hashcode进行一次hash计算，由此来确定这个值在table中的位置。</p><p>如果这个位置是空的，那么直接放入，而且不需要加锁操作。</p><p>如果这个位置存在结点，说明发生了hash碰撞，首先判断这个节点的类型。如果是链表节点（fh&gt;0）,则得到的结点就是hash值相同的节点组成的链表的头节点。需要依次向后遍历确定这个新加入的值所在位置。如果遇到hash值与key值都与新加入节点是一致的情况，则只需要更新value值即可。否则依次向后遍历，直到链表尾插入这个结点。如果加入这个节点以后链表长度大于8，就把这个链表转换成红黑树。如果这个节点的类型已经是树节点的话，直接调用树节点的插入方法进行插入新的值。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">publicV put(K key, V value) &#123;</span><br><span class="line">    return putVal(key, value, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** Implementation for put and putIfAbsent */</span><br><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    if(key == null|| value == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    //计算hash值</span><br><span class="line">    int hash = spread(key.hashCode());</span><br><span class="line">    int binCount = 0;</span><br><span class="line">    //死循环 何时插入成功 何时跳出</span><br><span class="line">    for(Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; </span><br><span class="line">        int n, i, fh;</span><br><span class="line">        //如果table为空的话，初始化table</span><br><span class="line">        if(tab == null|| (n = tab.length) == 0)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        //根据hash值计算出在table里面的位置</span><br><span class="line">        else if((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</span><br><span class="line">            //如果这个位置没有值 ，直接放进去，不需要加锁</span><br><span class="line">            if(casTabAt(tab, i, null,new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">                break;  // no lock when adding to empty bin</span><br><span class="line">        &#125;</span><br><span class="line">        //当遇到表连接点时，需要进行整合表的操作</span><br><span class="line">        else if((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        else&#123;</span><br><span class="line">            V oldVal = null;</span><br><span class="line">            //结点上锁  这里的结点可以理解为hash值相同组成的链表的头结点</span><br><span class="line">            synchronized(f) &#123;</span><br><span class="line">                if(tabAt(tab, i) == f) &#123;</span><br><span class="line">                    //fh〉0 说明这个节点是一个链表的节点 不是树的节点</span><br><span class="line">                    if(fh &gt;= 0) &#123;</span><br><span class="line">                        binCount = 1;</span><br><span class="line">                        //在这里遍历链表所有的结点</span><br><span class="line">                        for(Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            //如果hash值和key值相同  则修改对应结点的value值</span><br><span class="line">                            if(e.hash == hash &amp;&amp;((ek = e.key) == key ||(ek != null&amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                if(!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            //如果遍历到了最后一个结点，那么就证明新的节点需要插入 就把它插入在链表尾部</span><br><span class="line">                            if((e = e.next) == null) &#123;</span><br><span class="line">                                pred.next = newNode&lt;K,V&gt;(hash, key,value,null);</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //如果这个节点是树节点，就按照树的方式插入值</span><br><span class="line">                    else if(f instanceof TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = 2;</span><br><span class="line">                        if((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,value)) != null) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            if(!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(binCount != 0) &#123;</span><br><span class="line">                //如果链表长度已经达到临界值8 就需要把链表转换为树结构</span><br><span class="line">                if(binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                if(oldVal != null)</span><br><span class="line">                    return oldVal;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //将当前ConcurrentHashMap的元素数量+1</span><br><span class="line">    addCount(1L, binCount);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以发现JDK8中的实现也是锁分离的思想，只是锁住的是一个Node，而不是JDK7中的Segment，而锁住Node之前的操作是无锁的并且也是线程安全的，建立在之前提到的3个原子操作上。</p><h4 id="6-1-helpTransfer方法"><a href="#6-1-helpTransfer方法" class="headerlink" title="6.1 helpTransfer方法"></a>6.1 helpTransfer方法</h4><p>这是一个协助扩容的方法。这个方法被调用的时候，当前ConcurrentHashMap一定已经有了nextTable对象，首先拿到这个nextTable对象，调用transfer方法。回看上面的transfer方法可以看到，当本线程进入扩容方法的时候会直接进入复制阶段。</p><h4 id="6-2-treeifyBin方法"><a href="#6-2-treeifyBin方法" class="headerlink" title="6.2 treeifyBin方法"></a>6.2 treeifyBin方法</h4><p>这个方法用于将过长的链表转换为TreeBin对象。但是他并不是直接转换，而是进行一次容量判断，如果容量没有达到转换的要求，直接进行扩容操作并返回；如果满足条件才链表的结构抓换为TreeBin ，这与HashMap不同的是，它并没有把TreeNode直接放入红黑树，而是利用了TreeBin这个小容器来封装所有的TreeNode.</p><h3 id="7-get方法"><a href="#7-get方法" class="headerlink" title="7 get方法"></a>7 get方法</h3><p>get方法比较简单，给定一个key来确定value的时候，必须满足两个条件  key相同  hash值相同，对于节点可能在链表或树上的情况，需要分别去查找。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; </span><br><span class="line">    Node&lt;K,V&gt; e, p; </span><br><span class="line">    int n, eh; </span><br><span class="line">    K ek;</span><br><span class="line">    //计算hash值</span><br><span class="line">    int h = spread(key.hashCode());</span><br><span class="line">    //根据hash值确定节点位置</span><br><span class="line">    if((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123;</span><br><span class="line">        //如果搜索到的节点key与传入的key相同且不为null,直接返回这个节点 </span><br><span class="line">        if((eh = e.hash) == h) &#123;</span><br><span class="line">            if((ek = e.key) == key || (ek != null&amp;&amp; key.equals(ek)))</span><br><span class="line">                returne.val;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果eh&lt;0 说明这个节点在树上 直接寻找</span><br><span class="line">        else if(eh &lt; 0)</span><br><span class="line">             return (p = e.find(h, key)) != null ? p.val : null;</span><br><span class="line">         //否则遍历链表 找到对应的值并返回</span><br><span class="line">        while((e = e.next) != null) &#123;</span><br><span class="line">            if(e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != null&amp;&amp; key.equals(ek))))</span><br><span class="line">                return e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-Size相关的方法"><a href="#8-Size相关的方法" class="headerlink" title="8 Size相关的方法"></a>8 Size相关的方法</h3><p>对于ConcurrentHashMap来说，这个table里到底装了多少东西其实是个不确定的数量，因为不可能在调用size()方法的时候像GC的“stop the world”一样让其他线程都停下来让你去统计，因此只能说这个数量是个估计值。对于这个估计值，ConcurrentHashMap也是大费周章才计算出来的。</p><h4 id="8-1-辅助定义"><a href="#8-1-辅助定义" class="headerlink" title="8.1 辅助定义"></a>8.1 辅助定义</h4><p>为了统计元素个数，ConcurrentHashMap定义了一些变量和一个内部类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A padded cell for distributing counts.  Adapted from LongAdder</span><br><span class="line"> * and Striped64.  See their internal docs for explanation.</span><br><span class="line"> */</span><br><span class="line">@sun.misc.Contendedstaticfinalclass CounterCell &#123;</span><br><span class="line">    volatilelongvalue;</span><br><span class="line">    CounterCell(longx) &#123; value = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/******************************************/ </span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 实际上保存的是hashmap中的元素个数  利用CAS锁进行更新</span><br><span class="line"> 但它并不用返回当前hashmap的元素个数</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line">privatetransientvolatile long baseCount;</span><br><span class="line">/**</span><br><span class="line"> * Spinlock (locked via CAS) used when resizing and/or creating CounterCells.</span><br><span class="line"> */</span><br><span class="line">privatetransientvolatile int cellsBusy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Table of counter cells. When non-null, size is a power of 2.</span><br><span class="line"> */</span><br><span class="line">privatetransientvolatile CounterCell[] counterCells;</span><br></pre></td></tr></table></figure><h4 id="8-2-mappingCount与Size方法"><a href="#8-2-mappingCount与Size方法" class="headerlink" title="8.2 mappingCount与Size方法"></a>8.2 mappingCount与Size方法</h4><p>mappingCount与size方法的类似  从Java工程师给出的注释来看，应该使用mappingCount代替size方法 两个方法都没有直接返回basecount 而是统计一次这个值，而这个值其实也是一个大概的数值，因此可能在统计的时候有其他线程正在执行插入或删除操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">publicintsize() &#123;</span><br><span class="line">        longn = sumCount();</span><br><span class="line">        return((n &lt; 0L) ? 0:</span><br><span class="line">                (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">                (int)n);</span><br><span class="line">    &#125;</span><br><span class="line">     /**</span><br><span class="line">     * Returns the number of mappings. This method should be used</span><br><span class="line">     * instead of &#123;@link #size&#125; because a ConcurrentHashMap may</span><br><span class="line">     * contain more mappings than can be represented as an int. The</span><br><span class="line">     * value returned is an estimate; the actual count may differ if</span><br><span class="line">     * there are concurrent insertions or removals.</span><br><span class="line">     *</span><br><span class="line">     * @return the number of mappings</span><br><span class="line">     * @since 1.8</span><br><span class="line">     */</span><br><span class="line">    publiclongmappingCount() &#123;</span><br><span class="line">        longn = sumCount();</span><br><span class="line">        return(n &lt; 0L) ? 0L : n; // ignore transient negative values</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">     finallongsumCount() &#123;</span><br><span class="line">        CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">        longsum = baseCount;</span><br><span class="line">        if(as != null) &#123;</span><br><span class="line">            for(inti = 0; i &lt; as.length; ++i) &#123;</span><br><span class="line">                if((a = as[i]) != null)</span><br><span class="line">                    sum += a.value;//所有counter的值求和</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        returnsum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-addCount方法"><a href="#8-3-addCount方法" class="headerlink" title="8.3 addCount方法"></a>8.3 addCount方法</h4><p>在put方法结尾处调用了addCount方法，把当前ConcurrentHashMap的元素个数+1这个方法一共做了两件事,更新baseCount的值，检测是否进行扩容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">privatefinalvoid addCount(longx,intcheck) &#123;</span><br><span class="line">    CounterCell[] as; longb, s;</span><br><span class="line">    //利用CAS方法更新baseCount的值</span><br><span class="line">    if((as = counterCells) != null||</span><br><span class="line">        !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; longv;intm;</span><br><span class="line">        booleanuncontended = true;</span><br><span class="line">        if(as == null|| (m = as.length - 1) &lt; 0||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(check &lt;= 1)</span><br><span class="line">            return;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    //如果check值大于等于0 则需要检验是否需要进行扩容操作</span><br><span class="line">    if(check &gt;= 0) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; intn, sc;</span><br><span class="line">        while(s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null&amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            intrs = resizeStamp(n);</span><br><span class="line">            //</span><br><span class="line">            if(sc &lt; 0) &#123;</span><br><span class="line">                if((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null||</span><br><span class="line">                    transferIndex &lt;= 0)</span><br><span class="line">                    break;</span><br><span class="line">                 //如果已经有其他线程在执行扩容操作</span><br><span class="line">                if(U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            //当前线程是唯一的或是第一个发起扩容的线程  此时nextTable=null</span><br><span class="line">            elseif(U.compareAndSwapInt(this, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</span><br><span class="line">                transfer(tab,null);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>JDK6,7中的ConcurrentHashmap主要使用Segment来实现减小锁粒度，把HashMap分割成若干个Segment，在put的时候需要锁住Segment，get时候不加锁，使用volatile来保证可见性，当要统计全局时（比如size），首先会尝试多次计算modcount来确定，这几次尝试中，是否有其他线程进行了修改操作，如果没有，则直接返回size。如果有，则需要依次锁住所有的Segment来计算。</p><p>jdk7中ConcurrentHashmap中，当长度过长碰撞会很频繁，链表的增改删查操作都会消耗很长的时间，影响性能,所以jdk8 中完全重写了concurrentHashmap,代码量从原来的1000多行变成了 6000多 行，实现上也和原来的分段式存储有很大的区别。</p><p>主要设计上的变化有以下几点:</p><ol><li>不采用segment而采用node，锁住node来实现减小锁粒度。</li><li>设计了MOVED状态 当resize的中过程中 线程2还在put数据，线程2会帮助resize。</li><li>使用3个CAS操作来确保node的一些操作的原子性，这种方式代替了锁。</li><li>sizeCtl的不同值来代表不同含义，起到了控制的作用。  </li></ol><p>至于为什么JDK8中使用synchronized而不是ReentrantLock，我猜是因为JDK8中对synchronized有了足够的优化吧。</p><hr><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://blog.csdn.net/moakun/article/details/80203568" target="_blank" rel="noopener">JDK1.8 实现解读</a><br><a href="http://www.cnblogs.com/stateis0/p/9062086.html" target="_blank" rel="noopener">扩容源码分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-重要的属性&quot;&gt;&lt;a href=&quot;#1-重要的属性&quot; class=&quot;headerlink&quot; title=&quot;1.重要的属性&quot;&gt;&lt;/a&gt;1.重要的属性&lt;/h3&gt;&lt;p&gt;首先来看几个重要的属性，与HashMap相同的就不再介绍了，这里重点解释一下sizeCtl这个属性。
      
    
    </summary>
    
    
      <category term="并发编程" scheme="http://yoursite.com/child/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-并发工具类</title>
    <link href="http://yoursite.com/child/2018/05/17/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://yoursite.com/child/2018/05/17/并发编程-并发工具类/</id>
    <published>2018-05-17T12:36:12.000Z</published>
    <updated>2019-11-22T14:45:51.059Z</updated>
    
    <content type="html"><![CDATA[<p>在JDK的并发包中提供了几个非常有用的并发工具类。CountDownLatch、CyclicBarrier和Semaphore提供了并发流程控制手段，Exchanger提供了两个线程之间交换数据的手段，本文将配合应用场景介绍该如何使用这几个工具类。</p><h3 id="1-CountDownLatch"><a href="#1-CountDownLatch" class="headerlink" title="1. CountDownLatch"></a>1. CountDownLatch</h3><p>CountDownLatch是JDK 5+里面闭锁的一个实现，他允许一个或多个线程等待其他线程完成各自的工作后再执行。</p><p>闭锁（Latch）：一种同步方法，可以延迟线程的进度直到线程到达某个终点状态。</p><p>与CountDownLatch第一次交互是主线程等待其它的线程，主线程必须在启动其它线程后立即调用await方法，这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。</p><p>其他的N个线程必须引用闭锁对象，因为他们需要通知CountDownLatch对象，他们已经完成了各自的任务，这种机制就是通过调用countDown()方法来完成的。每调用一次这个方法，在构造函数中初始化的count值就减1，所以当N个线程都调用了这个方法count的值等于0，然后主线程就能通过await方法，恢复自己的任务。</p><p>与Join的区别：调用join方法需要等待thread执行完毕才能继续向下执行,而CountDownLatch只需要检查计数器的值为零就可以继续向下执行，相比之下，CountDownLatch更加灵活一些，可以实现一些更加复杂的业务场景。</p><h4 id="1-1-使用场景"><a href="#1-1-使用场景" class="headerlink" title="1.1 使用场景"></a>1.1 使用场景</h4><ol><li>开启多个线程分块下载一个大文件，每个线程只下载固定的一截，最后由另外一个线程来拼接所有的分段。</li><li>应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。</li><li>确保一个计算不会执行，直到所需要的资源被初始化。</li></ol><h4 id="1-2-主要方法"><a href="#1-2-主要方法" class="headerlink" title="1.2 主要方法"></a>1.2 主要方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化计数的次数，不能重置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span></span>; </span><br><span class="line"><span class="comment">//调用此方法则计数减1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span></span>;   </span><br><span class="line"><span class="comment">//得到当前的计数</span></span><br><span class="line"><span class="function">Public Long <span class="title">getCount</span><span class="params">()</span></span>;           </span><br><span class="line"><span class="comment">//调用此方法会一直阻塞当前线程，直到计时器的值为0，除非线程被中断。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException   </span></span><br><span class="line"><span class="function"><span class="comment">//调用此方法会一直阻塞当前线程，直到计时器的值为0，除非线程被中断或者计数器超时，返回false代表计数器超时。</span></span></span><br><span class="line"><span class="function">Public <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br></pre></td></tr></table></figure><h4 id="1-3-使用案例"><a href="#1-3-使用案例" class="headerlink" title="1.3 使用案例"></a>1.3 使用案例</h4><ol><li>latch.countDown(); 建议放到finally语句里。</li><li>对这个计数器的操作都是原子操作，同时只能有一个线程去操作这个计数器。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                count += <span class="number">100</span>;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                latch.countDown();</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        CountDownLatchTest demo = <span class="keyword">new</span> CountDownLatchTest();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">while</span>(i-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(demo.new RunnableTask()).start();</span><br><span class="line">        &#125;</span><br><span class="line">        demo.latch.await();</span><br><span class="line">        System.out.println(demo.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个线程分别对count加100，等三个线程执行完后，主线程输出count的值。输出300</p><h3 id="2-CyclicBarrier"><a href="#2-CyclicBarrier" class="headerlink" title="2. CyclicBarrier"></a>2. CyclicBarrier</h3><p>字面意思是可以循环使用的屏障。他要做的事情是让一组线程到达一个同步点时被阻塞，直到最后一个线程到达同步点，才会打开屏障，所有线程继续运行。</p><p>默认的构造方法 CyclicBarrier(int parties) ，参数代表屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier已经到达屏障，然后被阻塞。</p><h4 id="1-1-使用场景-1"><a href="#1-1-使用场景-1" class="headerlink" title="1.1 使用场景"></a>1.1 使用场景</h4><p>可用于多线程计算数据，最后合并计算结果</p><h4 id="1-2-主要方法-1"><a href="#1-2-主要方法-1" class="headerlink" title="1.2 主要方法"></a>1.2 主要方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span></span></span><br><span class="line"><span class="function"><span class="comment">//barrierAction表示被拦住的线程需要执行的任务</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span></span></span><br><span class="line"><span class="function"><span class="comment">//被拦住的线程调用次函数进入阻塞状态</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//被拦住的线程调用次函数进入阻塞状态，超时唤醒</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">//返回需要被拦住的线程数量</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getParties</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">//查询此屏障是否处于断开状态</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBroken</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回已被拦住的线程数量</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberWaiting</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h4 id="1-3-使用案例-1"><a href="#1-3-使用案例-1" class="headerlink" title="1.3 使用案例"></a>1.3 使用案例</h4><p>初始化线程数为2，加上主线程调用await()3次，所以得出结论主线程调用不计入await次数之内。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier cb = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                count += <span class="number">100</span>;</span><br><span class="line">                cb.await();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunnableTask()).start();</span><br><span class="line">        &#125;</span><br><span class="line">        cb.await();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出200</p><h4 id="1-4-与CountDownLatch的区别"><a href="#1-4-与CountDownLatch的区别" class="headerlink" title="1.4 与CountDownLatch的区别"></a>1.4 与CountDownLatch的区别</h4><ul><li>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置，可以使用多次，所以CyclicBarrier能够处理更为复杂的场景；</li><li>CyclicBarrier还提供了一些其他有用的方法，比如getNumberWaiting()方法可以获得CyclicBarrier阻塞的线程数量，isBroken()方法用来了解阻塞的线程是否被中断；</li><li>CountDownLatch允许一个或多个线程等待一组事件的产生，而CyclicBarrier用于等待其他线程运行到栅栏位置。</li></ul><h3 id="3-Semaphore"><a href="#3-Semaphore" class="headerlink" title="3. Semaphore"></a>3. Semaphore</h3><p>Semaphore是用来控制同事访问特定资源的线程数量，它通过协调各个线程以保证合理的使用公共资源。</p><h4 id="3-1-使用场景"><a href="#3-1-使用场景" class="headerlink" title="3.1 使用场景"></a>3.1 使用场景</h4><p>可用于做流量控制，特别是公用资源有限的场景，比如数据库连接。</p><h3 id="4-Exchanger"><a href="#4-Exchanger" class="headerlink" title="4. Exchanger"></a>4. Exchanger</h3><p>Exchanger类可用于两个线程之间交换信息。可简单地将Exchanger对象理解为一个包含两个格子的容器，通过exchanger方法可以向两个格子中填充信息。当两个格子中的均被填充时，该对象会自动将两个格子的信息交换，然后返回给线程，从而实现两个线程的信息交换。</p><p>Exchanger类仅可用作两个线程的信息交换，当超过两个线程调用同一个exchanger对象时，得到的结果是不确定的，exchanger对象仅关心其包含的两个“格子”是否已被填充数据，当两个格子都填充数据完成时，该对象就认为线程之间已经配对成功，然后开始执行数据交换操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Exchanger&lt;String&gt; exgr = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadpool = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        threadpool.execute(() -&gt; &#123;</span><br><span class="line">            String a = <span class="string">"银行流水A"</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                exgr.exchange(a);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadpool.execute(() -&gt; &#123;</span><br><span class="line">            String b = <span class="string">"银行流水B"</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String a = exgr.exchange(b);</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadpool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在JDK的并发包中提供了几个非常有用的并发工具类。CountDownLatch、CyclicBarrier和Semaphore提供了并发流程控制手段，Exchanger提供了两个线程之间交换数据的手段，本文将配合应用场景介绍该如何使用这几个工具类。&lt;/p&gt;
&lt;h3 id=&quot;
      
    
    </summary>
    
    
      <category term="并发编程" scheme="http://yoursite.com/child/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程-线程池源码详解</title>
    <link href="http://yoursite.com/child/2018/05/15/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/child/2018/05/15/并发编程-线程池源码详解/</id>
    <published>2018-05-15T03:28:21.000Z</published>
    <updated>2019-11-22T05:15:57.400Z</updated>
    
    <content type="html"><![CDATA[<p>阿里巴巴Java手册有一条：<br>【强制】线程资源必须通过线程池提供，禁止在应用程序中显示创建线程。<br>说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程导致消耗完内存或者过度切换的问题。</p><p>简单来说使用线程池有以下几个目的：  </p><ul><li>避免频繁的创建。线程是稀缺资源。</li><li>解耦。线程的创建与执行分开，方便维护。</li><li>线程资源复用。</li></ul><h3 id="1-线程池原理"><a href="#1-线程池原理" class="headerlink" title="1. 线程池原理"></a>1. 线程池原理</h3><p>本文从线程池的创建开始说起，跟着源码分析一下线程池的工作原理，本文源码基于JDK1.8</p><h4 id="1-1-Executors"><a href="#1-1-Executors" class="headerlink" title="1.1 Executors"></a>1.1 Executors</h4><p>Executors有一个私有的默认构造函数，不能实例化，是一个工具类，主要用于提供各种类型线程池创建的静态方法。<br>提供的静态创建方法有：</p><ul><li>newSingleThreadExecutor 创建一个执行器，该执行器使用一个工作线程操作一个无界队列。(但是请注意，如果这个线程在关闭之前的执行过程中由于失败而终止，那么如果需要执行后续任务，将会有一个新的线程代替它。与 newFixedThreadPool(1)不同，返回的executor不能被其他线程重新配置。</li><li>newFixedThreadPool  创建一个线程池，该线程池重用固定数量的线，如果任何线程在关闭之前的执行过程中由于失败而终止，那么如果需要执行后续任务，则会替换一个新线程。池中的线程将一直存在，直到显式关闭为止<br>操作一个共享的无界队列。</li><li>newWorkStealingPool  创建一个线程池，该线程池维护足够的线程以支持给定的并行度级别，并且可以使用多个队列来减少争用。并行度级别对应于积极参与或可用参与任务处理的线程的最大数量。线程的实际数量可以动态地增长和收缩。工作窃取池不能保证所提交任务的执行顺序。</li><li>newCachedThreadPool  创建一个线程池，该线程池根据需要创建新线程，但在可用时将重用以前构造的线程。这些池通常会提高执行许多短期异步任务的程序的性能。如果可用，对execute的调用将重用以前构造的线程。如果没有可用的现有线程，将创建一个新线程并将其添加到池中。未使用60秒的线程将被终止并从缓存中删除。因此，长时间空闲的池不会消耗任何资源。注意，可以使用ThreadPoolExecutor构造函数创建具有相似属性但不同细节(例如超时参数)的池。</li><li>newSingleThreadScheduledExecutor  创建一个单线程执行器，该执行器可以安排命令在给定的延迟之后运行，或者定期执行。(但是请注意，如果这个线程在关闭之前的执行过程中由于失败而终止，那么如果需要执行后续任务，将会有一个新的线程代替它。)，与 newFixedThreadPool(1)不同，返回的executor不能被其他线程重新配置。</li><li>newScheduledThreadPool  创建一个线程池，该线程池可以在给定延迟之后调度命令运行，或者定期执行命令。</li></ul><p>Executors 返回的线程池对象的弊端如下：</p><ol><li>FixedThreadPool 和 SingleThreadPool: 允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。</li><li>CachedThreadPool 和 ScheduledThreadPool: 允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</li></ol><h4 id="1-2-ThreadPoolExecutor"><a href="#1-2-ThreadPoolExecutor" class="headerlink" title="1.2 ThreadPoolExecutor"></a>1.2 ThreadPoolExecutor</h4><p>首先看一下newFixedThreadPool创建方法的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>事实上，大多数类型的线程池创建都是调用new ThreadPoolExecutor(…)创建一个ThreadPoolExecutor对象，只不过初始化参数不同而已。newWorkStealingPool创建时构造的是ForkJoinPool对象，本文不述。</p><p>下面是ThreadPoolExecutor的其中一个构造方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>初始化参数的如下：</p><ul><li>corePoolSize 表示线程池的核心数,线程池保持alive状态的线程数，即使线程是空闲的。</li><li>maximumPoolSize 表示线程池支持的最大的线程个数。</li><li>keepAliveTime 表示池中线程空闲后的生存时间</li><li>unit 表示上一个时间参数的单位</li><li>workQueue 用于存放任务的阻塞队列</li><li>threadFactory 表示创建线程的工厂，一般使用默认的线程创建工厂Excutors.DefaultThreadFactor()</li><li>handler 当队列和最大线程池都满了之后的饱和策略，一般使用默认的handler—AbortPolicy（内部类）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">代码摘自：java.util.concurrent.ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler defaultHandler = <span class="keyword">new</span> AbortPolicy();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</span><br><span class="line">                                             <span class="string">" rejected from "</span> +</span><br><span class="line">                                             e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    handler.rejectedExecution(command, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户也可以自己实现RejectedExecutionHandler接口定义一个handler，当提交的任务因为各种原因被线程池拒绝，就会调用rejectedExecution方法。</p><h5 id="1-2-1-提交任务excute"><a href="#1-2-1-提交任务excute" class="headerlink" title="1.2.1 提交任务excute()"></a>1.2.1 提交任务excute()</h5><p>使用线程池时，通常我们用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threadPool.execute(<span class="keyword">new</span> Job());</span><br></pre></td></tr></table></figure></p><p>这样的方式提交一个任务到线程池中，所以线程池ThreadPoolExecutor的核心逻辑就是execute()函数了，这个方法是在Excutor接口中声明。</p><p>在分析核心逻辑之前，先了解一下线程池重定义的状态，这些状态都和线程的执行密切相关</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">代码摘自：java.util.concurrent.ThreadPoolExecutor</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPCITY = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;<span class="keyword">return</span> c &amp; ~CAPCITY;&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;<span class="keyword">return</span> c &amp; CAPCITY;&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span></span>&#123;<span class="keyword">return</span> rs | wc;&#125;</span><br></pre></td></tr></table></figure><p>分析上面的代码得到下表：</p><table><thead><tr><th>常量名</th><th>二进制</th></tr></thead><tbody><tr><td>CAPCITY</td><td>0001 1111 1111 1111 1111 1111 1111 1111</td></tr><tr><td>RUNNING</td><td>1110 0000 0000 0000 0000 0000 0000 0000</td></tr><tr><td>SHUTDOWN</td><td>0000 0000 0000 0000 0000 0000 0000 0000</td></tr><tr><td>STOP</td><td>0010 0000 0000 0000 0000 0000 0000 0000</td></tr><tr><td>TIDYING</td><td>0100 0000 0000 0000 0000 0000 0000 0000</td></tr><tr><td>TERMINATED</td><td>0110 0000 0000 0000 0000 0000 0000 0000</td></tr></tbody></table><p>由上表可以看出，原子对象ctl的前三位表示状态，后29位记录池中worker的个数，CAPCITY就像是一个掩码，通过掩码可以快速的从ctl中获得当前线程池的运行状态和池中的worker个数。  </p><p>JDK1.8的并发包中不再通过设置阻塞队列的长度来限制任务的提交。阻塞队列的长度初始化之后就不能改变，因此如果担心阻塞队列太大导致内存占用太多，可以从两方面入手：1、初始化的时候选择合适的阻塞队列大小；2、调高corePoolSize或maxmumPoolSize加快任务的处理速度。参数的动态调整见下文。</p><p>线程池状态简述：</p><ul><li>RUNNING 是运行状态，指可以接受任务，执行队列里的任务。</li><li>SHUTDOWN 是指调用了shutdown()函数，不再接受新任务，但是会把队列里的任务执行完毕。</li><li>STOP 是指调用了shutdownNow()函数，不再接受新任务，同时终端正在执行的任务并丢弃队列中的待执行任务。</li><li>TIDYING 指所用任务都执行完毕。</li><li>TERMINATED 终止状态，在调用shutdown()/shutdownNow()中都会尝试更新这个状态。</li></ul><p>下面分析核心代码excute()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">代码摘自：java.util.concurrent.ThreadPoolExecutor</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//1、获取当前线程池的状态</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">//2、当线程数量小于corePoolSize，创建新线程运行</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//线程池线程数大于核心线程数 或者 新增worker失败 会执行下面的代码</span></span><br><span class="line">    <span class="comment">//3、如果线程池处于运行状态，并且写入阻塞队列成功</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">//4、再次检查线程状态，若线程池状态改变（非运行状态），需要从阻塞队列移除该任务，并执行拒绝策略</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">//5、如果线程池状态没有发生变化，判断当前池是否为空，为空就创建一个没有指定具体任务的新线程</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6、如果第一次检查不通过（线程池不处于运行状态或者任务写入队列失败），尝试新建线程，如果失败则执行拒绝策略</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>疑问：addWorker(null, false) 添加了一个没有具体任务的worker，作用是什么？  </p><p>如果线程池中的线程数为0，但任务队列中有需要执行的任务，这时候新建一个没有任务的线程是为了去执行任务队列中的任务。</p><p>下图表示了当有任务提交到线程池后线程池的处理流程：<br><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/execute%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="execute执行流程图">  </p><h5 id="1-2-2-创建工人（线程）"><a href="#1-2-2-创建工人（线程）" class="headerlink" title="1.2.2 创建工人（线程）"></a>1.2.2 创建工人（线程）</h5><p><strong>addWorker(Runnable firstTask, boolean core)</strong></p><p>参数：</p><p>firstTask：    worker线程的初始任务，可以为空<br>core：           true：将corePoolSize作为上限，false：将maximumPoolSize作为上限</p><p>addWorker函数是execute函数的核心逻辑，线程池持有一个HashSet<worker>对象存放池中的workers，每个worker对应一个线程，addWorker的作用就是创建worker执行任务。</worker></p><p><strong>addWorker方法有4种调用方式：</strong></p><ul><li><p>addWorker(command, true)</p></li><li><p>addWorker(command, false)</p></li><li><p>addWorker(null, false)</p></li><li><p>addWorker(null, true)</p></li></ul><p>在execute方法中就使用了前3种，结合这个方法进行以下分析</p><ol><li>线程数小于corePoolSize时，放一个需要处理的task进Workers Set。如果Workers Set长度超过corePoolSize，就返回false</li><li>当队列被放满时，就尝试将这个新来的task直接放入Workers Set，而此时Workers Set的长度限制是maximumPoolSize。如果线程池也满了的话就返回false</li><li>放入一个空的task进workers Set，长度限制是maximumPoolSize。这样一个task为空的worker在线程执行的时候会去任务队列里拿任务，这样就相当于创建了一个新的线程，只是没有马上分配任务</li><li>这个方法就是放一个null的task进Workers Set，而且是在小于corePoolSize时，如果此时Set中的数量已经达到corePoolSize那就返回false，什么也不干。实际使用中是在prestartAllCoreThreads()方法，这个方法用来为线程池预先启动corePoolSize个worker等待从workQueue中获取任务执行</li></ol><p>下面将源代码分成两部分进行分析，第一段代码为<strong>检验模块</strong>，主要判断线程池当前是否为可以添加worker线程的状态，可以则继续下一步，不可以则返回 false，具体分为三种情况：</p><ul><li>线程池状态&gt;shutdown，可能为stop、tidying、terminated，不能添加worker线程</li><li>线程池状态==shutdown，firstTask不为空，不能添加worker线程，因为shutdown状态的线程池不接收新任务</li><li>线程池状态==shutdown，firstTask==null，workQueue为空，不能添加worker线程，因为firstTask为空是为了添加一个没有任务的线程再从workQueue获取task，而workQueue为空，说明添加无任务线程已经没有意义</li></ul><p>当以上的情况都没有发生，在创建worker之前还需要验证一下线程池中的线程数量有没有达到极限，达到极限直接返回false；没达到极限，先CAS修改线程池状态(+1操作)，若修改成功，直接退出检验模块循环，执行下面的<strong>运行模块</strong>。CAS设置状态失败则重新获取运行状态进行二重检验，若线程池状态发生改变，从头开始大循环检验，否则继续小循环执行cas。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">代码摘自：java.util.concurrent.ThreadPoolExecutor</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">        <span class="comment">//状态为 RUNNING 继续往下执行</span></span><br><span class="line">        <span class="comment">//状态为不为RUNNING时，如果状态为SHUTDOWN并且firstTask为null并且阻塞队列空时，可继续向下运行</span></span><br><span class="line">        <span class="comment">//否则返回false，添加worker失败</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">//线程数大于CAPACITY </span></span><br><span class="line">            <span class="comment">//线程数大于corePoolSize或maximumPoolSize（取决于core）</span></span><br><span class="line">            <span class="comment">//否则添加worker失败</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//线程数验证通过，使用CAS对c加1，执行成功则终止大循环继续向下运行</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">//CAS设置失败则重新获取运行状态，若线程池状态发生改变，从头开始大循环，否则继续小循环</span></span><br><span class="line">            c = ctl.get(); </span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二部分为运行模块，直接进入主题，将提交的任务包装成worker对象，加入worker set 并启动该worker的线程，worker插入set需要加锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 二重验证，获取池状态</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                <span class="comment">//状态为RUNNING 则通过继续执行</span></span><br><span class="line">                <span class="comment">//状态为SHUTDOWN并且提交的任务为null 则通过继续执行</span></span><br><span class="line">                <span class="comment">//否则直接执行finally解锁</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// 如果worker中的线程t已经处于运行状态</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();<span class="comment">//抛异常</span></span><br><span class="line">                    workers.add(w);<span class="comment">//将w加入HashSet</span></span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="comment">//更新largestPoolSize，largestPoolSize只能在lock下修改</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>addWorker执行流程总结：</strong></p><ol><li>判断是否可以addworker</li><li>线程池当前线程数量是否超过上限（corePoolSize 或 maximumPoolSize），超过了return false，没超过则对workerCount+1，继续下一步</li><li>在线程池的ReentrantLock保证下，向Workers Set中添加新创建的worker实例，添加完成后解锁，并启动worker线程，只有在新建的线程成功启动的情况下才能返回 true。如果添加worker入Set失败或启动失败，调用addWorkerFailed()逻辑</li></ol><h5 id="1-2-3-worker创建失败的善后处理"><a href="#1-2-3-worker创建失败的善后处理" class="headerlink" title="1.2.3 worker创建失败的善后处理"></a>1.2.3 worker创建失败的善后处理</h5><p>addWorkerFailed()</p><p>当任务执行失败，程序需要进行善后处理，即恢复任务执行过程中对内存的改动，移除Worker set中的worker对象，修改池状态，最后尝试终止线程池。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">代码摘自：java.util.concurrent.ThreadPoolExecutor</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        <span class="comment">//CAS对ctl减1</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="1-2-4-空闲线程怎么从阻塞队列中取任务"><a href="#1-2-4-空闲线程怎么从阻塞队列中取任务" class="headerlink" title="1.2.4 空闲线程怎么从阻塞队列中取任务"></a>1.2.4 空闲线程怎么从阻塞队列中取任务</h5><h3 id="2-配置线程池"><a href="#2-配置线程池" class="headerlink" title="2. 配置线程池"></a>2. 配置线程池</h3><p>流程介绍完了先来总结以下上文提到了几个核心参数在流程中的具体作用，然后介绍应该如何配置。</p><h4 id="2-1-参数详解"><a href="#2-1-参数详解" class="headerlink" title="2.1 参数详解"></a>2.1 参数详解</h4><ol><li>corePoolSize：核心线程数</li></ol><ul><li>核心线程会一直存活，即使没有任务需要执行</li><li>当线程数小于核心线程数时，即使有线程空闲，线程池也会有限创建新的线程</li><li>设置allowCoreThreadTimeout=true（默认是false）时，核心线程会超时关闭</li></ul><ol start="2"><li>maximumPoolSize：最大线程数</li></ol><ul><li>当线程数 &gt;= corePoolSize，且队列已满。线程池会创建新线程来处理  </li><li>当线程数 = maxmumPoolSize，且队列任务已满是，线程会拒绝处理任务  </li></ul><ol start="3"><li>keepAliveTime：线程空闲时间</li></ol><ul><li>当线程空闲时间达到keepAliveTime时，线程会退出，知道线程数量 = corePoolSize  </li><li>如果allowCoreThreadTimeout = true，则会知道线程数量 = 0</li></ul><ol start="4"><li>rejectedExecutionHandler：任务拒绝处理器<br>两种情况会拒绝处理任务： </li></ol><ul><li>当线程数已经达到maxmumPoolSize，且队列已满，会拒绝新任务</li><li>当线程池被调用shutdown()后，会等待线程池里的任务执行完毕，再shutdown。如果在调用shutdown()和线程池真正shutdown之间提交任务，会拒绝新任务</li></ul><p>线程池会调用rejectedExecutionHandler来处理这个任务。如果没有设置默认是AbortPolicy，会抛出异常，<br>ThreadPoolExecutor类有几个内部实现类来处理这类情况：  </p><blockquote><p>AbortPolicy 丢弃任务，抛运行时异常<br>CallerRunsPolicy 执行任务，调用Runnable的run强制执行。<br>DiscardPolicy 忽视，什么都不会发生<br>DiscardOldestPolicy 如果是应为第一种情况被拒绝，则从阻塞队列中踢出最先进入队列（最后一个执行）的任务，然后再次提交当前任务。</p></blockquote><p>实现RejectedExecutionHandler接口，可自定义处理器处理reject。</p><h4 id="2-2-参数配置"><a href="#2-2-参数配置" class="headerlink" title="2.2 参数配置"></a>2.2 参数配置</h4><p>默认值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">corePoolSize=<span class="number">1</span></span><br><span class="line">maxPoolSize=Integer.MAX_VALUE</span><br><span class="line">keepAliveTime=<span class="number">60</span>s</span><br><span class="line">allowCoreThreadTimeout=<span class="keyword">false</span></span><br><span class="line">rejectedExecutionHandler=AbortPolicy()</span><br></pre></td></tr></table></figure></p><p>如何设置，需要根据几个值来决定：  </p><ul><li>tasks ：系统每秒任务数，假设为500~1000</li><li>taskcost：单任务耗时，假设为0.1s</li><li>responsetime：系统允许容忍的最大响应时间，假设为1s</li></ul><p>做几个计算：<br>corePoolSize = 系统每秒任务数/单线程每秒任务数 = 系统每秒任务数/（1/单任务耗时）<br>corePoolSize = tasks/(1/taskcost) =tasks<em>taskcout =  (500~1000)</em>0.1 = 50~100 。  corePoolSize设置应该大于50，根据8020原则，如果80%的系统每秒任务数小于800，那么corePoolSize设置为80即可  </p><p>maxPoolSize = （最大任务数-队列容量）/每个线程每秒处理能力 = 最大线程数<br>计算可得 maxPoolSize = (1000-80)/10 = 92<br>队列容量在初始化池的时候指定，一旦指定不能修改</p><p>rejectedExecutionHandler：根据具体情况来决定，任务不重要可丢弃，任务重要则要利用一些缓冲机制来处理</p><p>keepAliveTime和allowCoreThreadTimeout采用默认通常能满足<br>以上都是理想值，实际情况下要根据机器性能来决定。如果在未达到最大线程数的情况机器cpu load已经满了，则需要通过升级硬件和优化代码，降低taskcost来处理。</p><h4 id="2-3-参数动态调整"><a href="#2-3-参数动态调整" class="headerlink" title="2.3 参数动态调整"></a>2.3 参数动态调整</h4><p>用户可以通过corePoolSize和maxmumPoolSize的getter/setter进行访问和设置，具体怎么设置需要根据当前池中一些状态变量进行判断，如：</p><ul><li>getLargestPoolSize() 获取到目前为止达到过的最大线程数</li><li>getPoolSize() 获取当前线程数</li><li>getQueue().size() 获取当前阻塞队列任务数</li></ul><h3 id="3-关闭线程池"><a href="#3-关闭线程池" class="headerlink" title="3. 关闭线程池"></a>3. 关闭线程池</h3><p>关闭线程池无非就是两个方法 shutdown()/shutdownNow()。</p><p>但他们有着重要的区别：</p><ul><li>shutdown() 执行后停止接受新任务，会把队列的任务执行完毕。</li><li>shutdownNow() 也是停止接受新任务，但会中断所有的任务，将线程池状态变为 stop。</li></ul><p>两个方法都会中断线程，用户可自行判断是否需要响应中断。<br>shutdownNow() 要更简单粗暴，可以根据实际场景选择不同的方法。</p><p>通常是按照以下方式关闭线程池的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    pool.execute(<span class="keyword">new</span> Job());</span><br><span class="line">&#125;</span><br><span class="line">pool.shutdown();</span><br><span class="line"><span class="keyword">while</span> (!pool.awaitTermination(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    LOGGER.info(<span class="string">"线程还在执行。。。"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">LOGGER.info(<span class="string">"一共处理了【&#123;&#125;】"</span>, (end - start));</span><br></pre></td></tr></table></figure></p><p>pool.awaitTermination(1, TimeUnit.SECONDS) 会每隔一秒钟检查一次是否执行完毕（状态为 TERMINATED），当从 while 循环退出时就表明线程池已经完全终止了。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;阿里巴巴Java手册有一条：&lt;br&gt;【强制】线程资源必须通过线程池提供，禁止在应用程序中显示创建线程。&lt;br&gt;说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程导致消耗完内存或者过
      
    
    </summary>
    
    
      <category term="并发编程" scheme="http://yoursite.com/child/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
