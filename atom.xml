<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>黑风雅过吟</title>
  
  <subtitle>不积跬步无以至千里</subtitle>
  <link href="/zzkenyon.github.io/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/child/"/>
  <updated>2020-05-22T11:54:43.915Z</updated>
  <id>http://yoursite.com/child/</id>
  
  <author>
    <name>Zhao Zhengkang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MyBatis-给源码加中文注释(转)</title>
    <link href="http://yoursite.com/child/2020/04/24/MyBatis-%E7%BB%99%E6%BA%90%E7%A0%81%E5%8A%A0%E4%B8%AD%E6%96%87%E6%B3%A8%E9%87%8A(%E8%BD%AC)/"/>
    <id>http://yoursite.com/child/2020/04/24/MyBatis-给源码加中文注释(转)/</id>
    <published>2020-04-23T16:00:00.000Z</published>
    <updated>2020-05-22T11:54:43.915Z</updated>
    
    <content type="html"><![CDATA[<p>我们在看框架源码的时候，如果没有注释，看起来会比较吃力。所以如果能够一边看源码一边自己加中文注释，下次阅读的时候就会轻松很多。</p><p>问题是：通过maven下载的jar，查看源码，实际上看到的是经过反编译的class文件，是不能够修改的（提示：file is read only）。<br>如果把当前maven下载的jar包强行关联到自己下载的源码，又有可能会出现字节码跟源码文件不一致的情况（提示：Library source does not match the bytecode for class），导致debug的时候无法进入代码。</p><p>如果要保证源码和字节码一致，最好的办法当然是在本地把下载的源码编译生成jar包，上传到本地maven仓库，再引用这个jar。</p><p>以MyBatis为例，如果我们要给MyBatis源码加上中文注释（以IDEA操作为例）</p><p><a href="https://mp.weixin.qq.com/s/v0ihaPsuyGufdc_ImEqX8A" target="_blank" rel="noopener">原文连接</a></p><h4 id="1、配置Maven"><a href="#1、配置Maven" class="headerlink" title="1、配置Maven"></a>1、配置Maven</h4><p>因为需要用Maven打包编译源代码，所以第一步是检查Maven的配置。</p><p>第一个是环境变量，需要在系统变量中添加MAVEN_HOME，配置Maven主路径，例如“E:\dev\apache-maven-3.5.4”，确保mvn命令可以使用。</p><p>第二个是检查Maven的配置。Maven运行时，默认会使用conf目录下的settings.xml配置，例如：E:\dev\apache-maven-3.5.4\conf\settings.xml。</p><p>为了保证下载速度，建议配置成国内的aliyun中央仓库（此处需要自行搜索）。</p><p>并且，settings.xml中的localRepository应该和IDEA中打开的项目设置中的Local repository保持一致（例如：E:\repository）。否则项目引入依赖时，无法读取到编译后的jar包。</p><h4 id="2、下载编译MyBatis源码"><a href="#2、下载编译MyBatis源码" class="headerlink" title="2、下载编译MyBatis源码"></a>2、下载编译MyBatis源码</h4><p>因为MyBatis源码编译依赖parent项目的源码，所以第一步是编译parent项目。</p><p>先从git clone两个工程的项目（截止2020年4月，最新版本是3.5.4）。</p><p>以在E盘根目录下载为例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/mybatis/parent</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/mybatis/mybatis-3</span><br></pre></td></tr></table></figure><p>打开mybatis-3中的pom.xml文件，查看parent的版本号，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>31<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>确定parent版本是31（记住这个数字）。</p><p>把mybatis版本号改成自定义的版本号，避免跟官方版本号冲突（加上了-snapshot）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.4-snapshot<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><p>进入parent目录，切换项目分支（不能在默认的master分支中编译），工程名后面的数字就是前面看到的parent版本号。</p><p>开始编译parent项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> parent</span><br><span class="line"></span><br><span class="line">git checkout mybatis-parent-31</span><br><span class="line"></span><br><span class="line">mvn install</span><br></pre></td></tr></table></figure><p>接下来编译mybatis工程，进入mybatis-3目录，切换到最新3.5.4分支（不能在默认的master分支中编译）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd ../mybatis-3</span><br><span class="line"></span><br><span class="line">git checkout mybatis-3.5.4</span><br><span class="line"></span><br><span class="line">mvn clean</span><br><span class="line"></span><br><span class="line">mvn install -DskipTests=true -Dmaven.test.skip=true -Dlicense.skip=true</span><br></pre></td></tr></table></figure><p>编译完毕，本地仓库就会出现一个编译后的jar包，例如：E:\repository\org\mybatis\mybatis\3.5.4-snapshot\mybatis-3.5.4-snapshot.jar</p><p>在我们的项目中就可以引入这个jar包了（version是自定义的version）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.4-snapshot<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3、关联jar包到源码"><a href="#3、关联jar包到源码" class="headerlink" title="3、关联jar包到源码"></a>3、关联jar包到源码</h4><p>本地编译的jar包已经有了，接下来是把jar包和源码关联起来。</p><p>Project Structure —— Libries —— Maven: org.mybatis:mybatis:3.5.4-snapshot —— 在原来的Sources上面点+（加号） —— 选择到下载的源码路径，例如：E:\mybatis-3\src\main\java，点击OK</p><p>关联好之后，开始打断点debug，就会进入到本地的源码，可以给本地的源码加上注释了。</p><h4 id="4、注意"><a href="#4、注意" class="headerlink" title="4、注意"></a>4、注意</h4><p>1、如果之前打开过类的字节码文件，本地可能有缓存，一样会有“Library source does not match the bytecode for class”的提示。解决办法：File —— Invalidate Caches and Restart（IDEA会重启）。</p><p>2、如果添加注释导致了debug的当前行跟实际行不一致，再把mybatis3工程编译一次即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们在看框架源码的时候，如果没有注释，看起来会比较吃力。所以如果能够一边看源码一边自己加中文注释，下次阅读的时候就会轻松很多。&lt;/p&gt;
&lt;p&gt;问题是：通过maven下载的jar，查看源码，实际上看到的是经过反编译的class文件，是不能够修改的（提示：file is rea
      
    
    </summary>
    
      <category term="ORM框架" scheme="http://yoursite.com/child/categories/ORM%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Mybatis" scheme="http://yoursite.com/child/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>RPC-手写RPC调用过程</title>
    <link href="http://yoursite.com/child/2020/04/19/%E5%88%86%E5%B8%83%E5%BC%8F-%E6%89%8B%E5%86%99RPC%E8%B0%83%E7%94%A8/"/>
    <id>http://yoursite.com/child/2020/04/19/分布式-手写RPC调用/</id>
    <published>2020-04-18T16:00:00.000Z</published>
    <updated>2020-05-22T11:45:12.708Z</updated>
    
    <content type="html"><![CDATA[<p>rpc 全称remote procedure call 远程过程调用，是一种分布式服务调用协议。</p><p>需求：分布式环境下，服务A想要调用服务B的某方法，就像调用自己本地的方法一样</p><p>分析：</p><ul><li>首先，服务A需要知道服务B提供了哪些方法，并且知道这些方法的调用方式（参数列表，返回类型）</li><li>其次，服务A需要将调用的方法和参数发送给服务B，B接收到之后本地调用获得结果，再将结果发送给服务A</li></ul><p>设计：</p><ul><li>要提供一套统一的接口让调用方服务A知道有哪些方法可供调用，服务B作为接口的实现方。</li><li>服务A要提供接口的代理类工厂，本地调用接口方法时，代理类能将调用请求发送出去。</li><li>数据传输方面，暂不考虑性能，使用BIO以及JDK序列化方式</li></ul><p>开始编码：</p><p>提供一套接口：创建maven项目rpc-api，项目中添加接口文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHelloService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口中还需要指定一个简要的rpc协议，调用方和服务方都要遵循此协议</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcRequest</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="keyword">private</span> Object[] args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将rpc-api install到本地仓库。</p><p>调用方服务A：创建maven项目rpc-client，pom中添加依赖rpc-api</p><p>先来写main方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">        RpcProxyFactory rpcProxyFactory = <span class="keyword">new</span> RpcProxyFactory();</span><br><span class="line">        IHelloService helloService = </span><br><span class="line">          rpcProxyFactory.newProxyInstance(IHelloService.class,<span class="string">"localhost"</span>,<span class="number">8080</span>);</span><br><span class="line">        Object o = helloService.sayHello(<span class="string">"zzk"</span>);</span><br><span class="line">        System.out.println((String) o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程很清晰：</p><ol><li>创建代理工厂<code>RpcProxyFactory</code></li><li>使用代理工厂类生成指定接口的代理对象</li><li>调用接口方法获取结果</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">newProxyInstance</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; interfaceClass, <span class="keyword">final</span> String host, <span class="keyword">final</span> <span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T)Proxy.newProxyInstance(interfaceClass.getClassLoader(),<span class="keyword">new</span> Class&lt;?&gt;[] &#123;interfaceClass&#125;,</span><br><span class="line">                <span class="keyword">new</span> RemoteInvocationHandler(host,port));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理方式我选用的是jdk的动态代理，创建代理对象需要传进三个参数</p><ul><li>类加载器</li><li>需要代理的接口</li><li>触发管理类</li></ul><p>前两个参数都是现成的，编写触发管理类代码，实现<code>InvocationHandler</code>接口，通过代理对象调用接口方法都会进到invoke方法中来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RemoteInvocationHandler</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        RpcRequest rpcRequest = <span class="keyword">new</span> RpcRequest();</span><br><span class="line">        rpcRequest.setClassName(method.getDeclaringClass().getName());</span><br><span class="line">        rpcRequest.setMethodName(method.getName());</span><br><span class="line">        rpcRequest.setArgs(args);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RpcNetTransport(host,port).send(rpcRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>invoke 方法负责将请求参数序列化，并发送出去，这里使用一个类专门负责发送：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcNetTransport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcNetTransport</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">send</span><span class="params">(RpcRequest rpcRequest)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(Socket socket = <span class="keyword">new</span> Socket(host,port);</span><br><span class="line">            ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream());</span><br><span class="line">            ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream())) &#123;</span><br><span class="line">            out.writeObject(rpcRequest);</span><br><span class="line">            <span class="keyword">return</span> in.readObject();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此调用发代码完成</p><p>再来看服务方B的代码编写：创建maven项目，引入依赖rpc-api、spring-context来管理对象</p><p>首先服务方应该实现接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">IHelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"request sayHello from : "</span> + content);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Response: hello, "</span> + content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器需要接收请求，代码思想：启动监听指定端口，这里使用了spring的<code>InitializingBean</code>接口，创建RpcServer时，当port设置成功之后会执行<code>afterPropertiesSet()</code>方法启动监听。</p><p>此外，我们将对象交给spring管理后，当请求进来我们需要找到正确service去执行，我的做法是让<code>RpcServer</code>实现<code>ApplicationContextAware</code>接口，这样RpcServer可以在<code>setApplicationContext</code>方法中，将所有的service对象取出来缓存，请求进来直接在缓存中找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcServer</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>,<span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; serviceObjs = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// socket 通信 发布服务</span></span><br><span class="line">        <span class="keyword">try</span> (ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(port))&#123;</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                Socket socket = serverSocket.accept();</span><br><span class="line">                pool.execute(<span class="keyword">new</span> ProcessorHandler(socket,serviceObjs));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取容器中的服务bean 封装成map</span></span><br><span class="line">        Map&lt;String,Object&gt; beans = </span><br><span class="line">          applicationContext.getBeansWithAnnotation(RpcService.class);</span><br><span class="line">        <span class="keyword">for</span>(Object service : beans.values())&#123;</span><br><span class="line">            Class&lt;?&gt; clazz = service.getClass();</span><br><span class="line">            String serviceKey = rpcService.value().getName();</span><br><span class="line">            serviceObjs.put(serviceKey,service);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当获取请求之后，丢给线程池进行执行，那我继续编写线程池执行任务代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessorHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; serviceObj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProcessorHandler</span><span class="params">(Socket socket,Map&lt;String,Object&gt; serviceObj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        <span class="keyword">this</span>.serviceObj = serviceObj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</span><br><span class="line">             ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream()))&#123;</span><br><span class="line"></span><br><span class="line">            RpcRequest rpcRequest = (RpcRequest) in.readObject();</span><br><span class="line">            Object result = invoke(rpcRequest);</span><br><span class="line">            out.writeObject(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">invoke</span><span class="params">(RpcRequest rpcRequest)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        Object[] args = rpcRequest.getArgs();</span><br><span class="line">        Class&lt;?&gt;[] types = <span class="keyword">new</span> Class[args.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++)&#123;</span><br><span class="line">            types[i]= args[i].getClass();</span><br><span class="line">        &#125;</span><br><span class="line">        Class clazz = Class.forName(rpcRequest.getClassName());</span><br><span class="line">        Method method = clazz.getMethod(rpcRequest.getMethodName(),types);</span><br><span class="line">        String serviceKey = rpcRequest.getClassName() + rpcRequest.getVersion();</span><br><span class="line">        <span class="keyword">return</span> method.invoke(serviceObj.get(serviceKey),args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然是线程池执行的任务，肯定是Runnable对象，run方法的逻辑很清晰：从socket中获取请求对象，丢给invoke返回结果，在通过socket发送出去。</p><p>重点在invoke方法：通过反射的方式对方法进行调用</p><p>还有spring的最后一步，配置和启动:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"com.pd"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RpcServer <span class="title">rpcServer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RpcServer(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context =</span><br><span class="line">                <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line">        context.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><p>先启动rpc-server  再启动rpc-client</p><p>结果：<code>Response: hello, zzk</code></p><p>总结流程图示：</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/rpc/rpc%E5%9F%BA%E7%A1%80%E8%B0%83%E7%94%A8.png" alt="rpc-基础流程"></p><p><a href="https://github.com/zzkenyon/rpc-learn.git" target="_blank" rel="noopener">参考代码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;rpc 全称remote procedure call 远程过程调用，是一种分布式服务调用协议。&lt;/p&gt;
&lt;p&gt;需求：分布式环境下，服务A想要调用服务B的某方法，就像调用自己本地的方法一样&lt;/p&gt;
&lt;p&gt;分析：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，服务A需要知道服务B提供了哪些
      
    
    </summary>
    
      <category term="分布式架构技术" scheme="http://yoursite.com/child/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="RPC" scheme="http://yoursite.com/child/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>CSRF攻击与防御（转）</title>
    <link href="http://yoursite.com/child/2020/04/14/%E5%85%B6%E4%BB%96-CSRF%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1/"/>
    <id>http://yoursite.com/child/2020/04/14/其他-CSRF攻击与防御/</id>
    <published>2020-04-13T16:00:00.000Z</published>
    <updated>2020-06-12T00:32:49.804Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.phpddt.com/reprint/csrf.html" target="_blank" rel="noopener">转载地址</a></p><p><strong>CSRF概念：</strong>CSRF跨站点请求伪造(Cross—Site Request Forgery)，跟XSS攻击一样，存在巨大的危害性，你可以这样来理解：攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 如下：其中Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。</p><h4 id="CSRF攻击攻击原理及过程如下："><a href="#CSRF攻击攻击原理及过程如下：" class="headerlink" title="CSRF攻击攻击原理及过程如下："></a>CSRF攻击攻击原理及过程如下：</h4><ol><li><p>用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；</p></li><li><p>在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；</p></li><li><p>用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；</p></li><li><p>网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；</p></li><li><p>浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 </p></li></ol><h4 id="CSRF攻击实例"><a href="#CSRF攻击实例" class="headerlink" title="CSRF攻击实例"></a>CSRF攻击实例</h4><p>受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求 <a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2" target="_blank" rel="noopener">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2</a> 可以使 Bob 把 1000000 的存款转到 bob2 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。</p><p>黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行：<a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory。但是这个请求来自" target="_blank" rel="noopener">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory。但是这个请求来自</a> Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。</p><p>这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码： src=”<a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory" target="_blank" rel="noopener">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</a> ”，并且通过广告等诱使 Bob 来访问他的网站。当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。 </p><h4 id="CSRF漏洞检测："><a href="#CSRF漏洞检测：" class="headerlink" title="CSRF漏洞检测："></a>CSRF漏洞检测：</h4><p>检测CSRF漏洞是一项比较繁琐的工作，最简单的方法就是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。</p><p>随着对CSRF漏洞研究的不断深入，不断涌现出一些专门针对CSRF漏洞进行检测的工具，如CSRFTester，CSRF Request Builder等。</p><p>以CSRFTester工具为例，CSRF漏洞检测工具的测试原理如下：使用CSRFTester进行测试时，首先需要抓取我们在浏览器中访问过的所有链接以及所有的表单等信息，然后通过在CSRFTester中修改相应的表单等信息，重新提交，这相当于一次伪造客户端请求。如果修改后的测试请求成功被网站服务器接受，则说明存在CSRF漏洞，当然此款工具也可以被用来进行CSRF攻击。</p><h4 id="防御CSRF攻击："><a href="#防御CSRF攻击：" class="headerlink" title="防御CSRF攻击："></a>防御CSRF攻击：</h4><h4 id="（1）验证-HTTP-Referer-字段"><a href="#（1）验证-HTTP-Referer-字段" class="headerlink" title="（1）验证 HTTP Referer 字段"></a>（1）验证 HTTP Referer 字段</h4><p>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 <a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory，用户必须先登陆" target="_blank" rel="noopener">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory，用户必须先登陆</a> bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。</p><p>这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。</p><p>然而，这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。</p><p>即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。</p><h4 id="（2）在请求地址中添加-token-并验证"><a href="#（2）在请求地址中添加-token-并验证" class="headerlink" title="（2）在请求地址中添加 token 并验证"></a>（2）在请求地址中添加 token 并验证</h4><p>CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p><p>这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 <a href="http://url?csrftoken=tokenvalue。" target="_blank" rel="noopener">http://url?csrftoken=tokenvalue。</a> 而对于 POST 请求来说，要在 form 的最后加上 <input type="hidden" name="csrftoken" value="tokenvalue">，这样就把 token 以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。</p><p>该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。</p><h4 id="（3）在-HTTP-头中自定义属性并验证"><a href="#（3）在-HTTP-头中自定义属性并验证" class="headerlink" title="（3）在 HTTP 头中自定义属性并验证"></a>（3）在 HTTP 头中自定义属性并验证</h4><p>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</p><p>然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.phpddt.com/reprint/csrf.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;转载地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CSRF概念：&lt;/strong&gt;CSRF跨站点请求伪造(Cros
      
    
    </summary>
    
      <category term="其他" scheme="http://yoursite.com/child/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/child/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>分布式-logstash配置文件编写</title>
    <link href="http://yoursite.com/child/2020/04/09/%E5%88%86%E5%B8%83%E5%BC%8F-logstash%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99/"/>
    <id>http://yoursite.com/child/2020/04/09/分布式-logstash配置文件编写/</id>
    <published>2020-04-08T16:00:00.000Z</published>
    <updated>2020-06-12T00:27:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>贴一下配置好的logstash配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">input&#123;</span><br><span class="line">tcp&#123;</span><br><span class="line">port=&gt;4675</span><br><span class="line">codec=&gt;json</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter&#123;</span><br><span class="line">mutate&#123;</span><br><span class="line">gsub=&gt;[&quot;message&quot;,&quot;[\\]&quot;,&quot;&quot;]</span><br><span class="line">&#125;</span><br><span class="line">json&#123;</span><br><span class="line">source=&gt;&quot;message&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">output&#123;</span><br><span class="line">elasticsearch&#123;</span><br><span class="line">action=&gt;index</span><br><span class="line">host=&gt;localhost:9092</span><br><span class="line">index=&gt;&quot;dmp_audit_logs_%&#123;[+YYYY-MM-dd]&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置中主要分为三部分input、filter、output，这三部分是logstash pipeline中的三个元素，其中input和output是必须的，filter是可选的。</p><h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><p>配置数据的输入源</p><p>控制台输入 </p><p>文件输入  </p><p>插件输入（beat）  </p><p>中间件输入（kafka）</p><p>应用日志输入（日志appender）</p><p>最简单的输入源配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input&#123; stdin&#123;&#125; &#125;</span><br><span class="line">output&#123; stdout&#123;&#125; &#125;  <span class="comment">//控制台输出</span></span><br></pre></td></tr></table></figure><p>这样就配置了一个控制台输入和输出，启动logstash在控制台输入一条消息：hello logstash</p><p>控制台输出如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "@timestamp" =&gt; 2020-06-10T00:29:46.056Z,</span><br><span class="line">       "message" =&gt; "hello logstash",</span><br><span class="line">      "@version" =&gt; "1",</span><br><span class="line">          "host" =&gt; "zzk-redis.novalocal"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>logstash会自动给消息加上时间戳和版本信息，以及消息来源的ip，这里由于是本地发送的消息，所以host显示的是主机名</p><p>需求：将系统日志以json格式直接发送到logstash服务器</p><p>项目中配置logAppender，将日志直接发送给logshatsh的10514端口，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">input&#123;</span><br><span class="line">tcp&#123;</span><br><span class="line">port=&gt;<span class="number">10514</span>    <span class="comment">// 配置logstash监听4675端口</span></span><br><span class="line">codec=&gt;json   <span class="comment">// 配置数据解析方式为json</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>在生产环境中，当服务器访问量较大，连续执行日志写出动作，出现了tcp拆包的问题，见下图：</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/%E7%BD%91%E7%BB%9C/logstash%E6%8B%86%E5%8C%85%E9%97%AE%E9%A2%98.png" alt></p><p>可以看到，一条日志被拆成了两份，导致json解析失败。</p><p>所以高并发场景下，直接将日志写出到logstash是不可取的。</p><p>在中间加一层kafka就能解决上述问题，logAppender直接将日志文件写出到kafka中，logstash配置输入源为kafka，kafka作为消息中间件，一定不存在tcp拆包问题。</p><h4 id="output"><a href="#output" class="headerlink" title="output"></a>output</h4><p>配置数据输出目的地：</p><p>标准输出</p><p>es输出</p><p>中间件输出</p><p>需求：将日志数据输出到es存储</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">output&#123;</span><br><span class="line">elasticsearch&#123;</span><br><span class="line">action=&gt;index</span><br><span class="line">host=&gt;localhost:<span class="number">9092</span></span><br><span class="line">index=&gt;<span class="string">"dmp_audit_logs_%&#123;[+YYYY-MM-dd]&#125;"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>action=&gt;index表示是插入索引操作</p><p>host=&gt;localhost:9092 es的host</p><p>index=&gt;”dmp_audit_logs_%{[+YYYY-MM-dd]}”  表示插入的索引名称</p><p>配置完input和output就可以收集数据上传到es啦，那么logstash肯定不是只有这么简单的收集&amp;上传操作，logstash主要解决的问题是将乱七八糟各式各样的日志文件，整理成统一的格式上传到es，方便es进行统计分析。最主要的功能是在可选的filter模块实现的。</p><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>我在上传审计日志的过程中，遇到一些问题：</p><p>审计日志主要是采集了用户的一些请求信息，将这些信息转换成json字符串之后，字串携带了大量的转义反斜杠，将这个字串直接上传到logstash，发现审计信息不能解析出来，还是以json字串形式存放在message字段中，我的需求是将所有的信息都解析成独立的字段。</p><p>字串去反斜杠</p><p>去反斜杠的操作不能再在java中执行，因为java并不知道反斜杠的存在</p><p>因此需要在logshtash中进行配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">filter&#123;</span><br><span class="line">mutate&#123;</span><br><span class="line">gsub=&gt;[<span class="string">"message"</span>,<span class="string">"[\\]"</span>,<span class="string">""</span>] <span class="comment">// 去掉反斜杠</span></span><br><span class="line">&#125;</span><br><span class="line">json&#123;</span><br><span class="line">source=&gt;<span class="string">"message"</span>  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gsub 操作：将制定字段中的 某字串 替换成 另一个字符（串）</p><p>json操作： 对制定字段的信息执行反json操作，获取字段信息</p><p>以上就解决了将java审计日志上传至es的配置</p><p>filter可以对数据字段进行很多的操作，本业务场景中并没有用到，可以参考一以下链接</p><p><a href="https://cloud.tencent.com/developer/article/1353068" target="_blank" rel="noopener">一文快速上手Logstash</a></p><p><a href="https://www.cnblogs.com/wzxmt/p/11031110.html" target="_blank" rel="noopener">logstash配置文件详解</a></p><p><a href="https://www.jianshu.com/p/0b89c07021f4" target="_blank" rel="noopener">Logstash输出到Elasticsearch笔记</a></p><p><a href="https://www.cnblogs.com/yangwenbo214/p/9831081.html" target="_blank" rel="noopener">Logstash替换字符串</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;贴一下配置好的logstash配置文件&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li
      
    
    </summary>
    
      <category term="分布式架构技术" scheme="http://yoursite.com/child/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ElasticSearch" scheme="http://yoursite.com/child/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>ELK统一日志管理</title>
    <link href="http://yoursite.com/child/2020/04/07/%E5%88%86%E5%B8%83%E5%BC%8F-ELK%E7%BB%9F%E4%B8%80%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/child/2020/04/07/分布式-ELK统一日志管理/</id>
    <published>2020-04-06T16:00:00.000Z</published>
    <updated>2020-06-12T00:42:20.960Z</updated>
    
    <content type="html"><![CDATA[<h4 id="ElasticSearch部署"><a href="#ElasticSearch部署" class="headerlink" title="ElasticSearch部署"></a>ElasticSearch部署</h4><p>下载解压改配置文件/config/elasticsearch.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cluster.name:</span> <span class="string">my-application</span></span><br><span class="line"><span class="string">node.name:</span> <span class="string">node-1</span></span><br><span class="line"><span class="string">network.host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="string">http.port:</span> <span class="number">9200</span></span><br><span class="line"><span class="string">cluster.initial_master_nodes:</span> <span class="string">["node-1"]</span></span><br></pre></td></tr></table></figure><p>启动es命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/app/elasticSearch</span><br><span class="line"><span class="comment">#后台启动</span></span><br><span class="line">./bin/elasticksearch -d</span><br></pre></td></tr></table></figure><h4 id="Kibana部署"><a href="#Kibana部署" class="headerlink" title="Kibana部署"></a>Kibana部署</h4><p>下载解压改配置文件/config/kibana.yml：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">port:</span> <span class="number">5601</span></span><br><span class="line"><span class="string">server.host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="string">elasticsearch.hosts:</span> <span class="string">["ip:port","ip:port"]</span></span><br></pre></td></tr></table></figure><p>启动kibana命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/app/kibana</span><br><span class="line"><span class="comment">#后台启动</span></span><br><span class="line">nohup ./bin/kibana &amp;</span><br></pre></td></tr></table></figure><h4 id="logstash部署"><a href="#logstash部署" class="headerlink" title="logstash部署"></a>logstash部署</h4><p>启动logstash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/app/logstash/bin</span><br><span class="line"><span class="comment">#测试</span></span><br><span class="line">logstash --path.settings ../config/ -f ../config/logstash.conf --config.test_and_exit</span><br><span class="line"><span class="comment">#启动</span></span><br><span class="line">logstash -f ../config/logstash-es.conf</span><br><span class="line"><span class="comment">#查看端口监听状态以及pid</span></span><br><span class="line">netstat -lntp |grep 10514</span><br></pre></td></tr></table></figure><p>logstash-es.conf 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    tcp &#123;</span><br><span class="line">        port =&gt; 10514</span><br><span class="line">        codec =&gt; json</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  grok &#123;</span><br><span class="line">    match=&gt;&#123;<span class="string">"message"</span>=&gt; <span class="string">"%&#123;IP:client&#125; %&#123;WORD:method&#125; %&#123;URIPATHPARAM:request&#125; %&#123;NUMBER:bytes&#125; %&#123;NUMBER:duration&#125;"</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">stdout&#123;</span><br><span class="line">codec=&gt;rubydebug <span class="comment">#美化输出</span></span><br><span class="line">&#125;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">        action =&gt; <span class="string">"index"</span></span><br><span class="line">        hosts =&gt; [<span class="string">"10.0.12.72:9200"</span>]</span><br><span class="line">        index =&gt; <span class="string">"dmp_audit_logs_%&#123;[+YYYY-MM-dd]&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>logback.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">"false"</span> <span class="attr">scan</span>=<span class="string">"false"</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"console"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;MM-dd HH:mm:ss.SSS&#125; %-5level [%logger&#123;50&#125;] - %msg%n</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"logstash"</span> <span class="attr">class</span>=<span class="string">"net.logstash.logback.appender.LogstashTcpSocketAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"Encoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">destination</span>&gt;</span>10.0.12.72:10514<span class="tag">&lt;/<span class="name">destination</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> <span class="attr">class</span>=<span class="string">"net.logstash.logback.encoder.LogstashEncoder"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--%&#123;appName&#125;中的appName需要在属性中配置，作为字段写入到doc中--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">customFields</span>&gt;</span>&#123;"appname":"dmp"&#125;<span class="tag">&lt;/<span class="name">customFields</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">connectionStrategy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">roundRobin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">connectionTTL</span>&gt;</span>5 minutes<span class="tag">&lt;/<span class="name">connectionTTL</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">roundRobin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">connectionStrategy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"console"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.cetiti.es.controller"</span> <span class="attr">level</span>=<span class="string">"INFO"</span> <span class="attr">addtivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"logstash"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>参考文档：</p><p><a href="https://www.jianshu.com/p/d66bfe7e9127" target="_blank" rel="noopener">ELK-概念</a></p><p><a href="https://www.cnblogs.com/wangzhuxing/p/9665905.html" target="_blank" rel="noopener">logback+ELK日志搭建</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;ElasticSearch部署&quot;&gt;&lt;a href=&quot;#ElasticSearch部署&quot; class=&quot;headerlink&quot; title=&quot;ElasticSearch部署&quot;&gt;&lt;/a&gt;ElasticSearch部署&lt;/h4&gt;&lt;p&gt;下载解压改配置文件/config/e
      
    
    </summary>
    
      <category term="分布式架构技术" scheme="http://yoursite.com/child/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ElasticSearch" scheme="http://yoursite.com/child/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>系统审计日志需求分析及方案</title>
    <link href="http://yoursite.com/child/2020/04/06/%E4%B8%9A%E5%8A%A1-%E7%B3%BB%E7%BB%9F%E5%AE%A1%E8%AE%A1%E6%97%A5%E5%BF%97%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/child/2020/04/06/业务-系统审计日志需求分析以及方案/</id>
    <published>2020-04-05T16:00:00.000Z</published>
    <updated>2020-06-12T00:34:52.099Z</updated>
    
    <content type="html"><![CDATA[<p>在一个完整的信息系统里面，日志系统是一个非常重要的功能组成部分。它可以记录下系统所产生的所有行为，并按照某种规范表达出来。我们可以使用日志系统所记录的信息为系统进行排错，优化系统的性能，或者根据这些信息调整系统的行为。在安全领域，日志可以反应出很多的安全攻击行为，比如登录错误，异常访问等。日志还能告诉你很多关于网络中所发生事件的信息，包括性能信息、故障检测和入侵检测。日志会成为在事故发生后查明“发生了什么”的一个很好的“取证”信息来源。日志可以为审计进行审计跟踪。</p><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p><strong><em>审计日志在哪里执行记录操作？</em></strong></p><p>controller层？service层？dao层？</p><p>controller层最先接触到request请求，如果我们要对分析用户的行为，那么日志应该在c层记录</p><p>service层是向c层提供服务的，整合了数据访问、数据计算等任务，如果要分析系统服务性能、那么日志应该打在s层</p><p>dao层是数据访问层，主要负责数据库的读写任务，如果要对数据访问接口的性能进行分析，那么日志应该在dao层</p><p><strong><em>审计日志内容怎么存储？</em></strong></p><p>日志文件？关系？es？</p><p>写日志文件是对磁盘顺序写操作，操作效率高，但是有两个缺点：一是不利于检索，一是日志文件存储在本地，分布式环境下不利于日志统一管理，因此日志文件不适合审计日志的存储</p><p>关系型数据，中小型系统可以使用，随着日志越来越多，检索效率降低，可以根据日志时间或者日志类型分表存储，缺点是日志分析不是很方便</p><p>ES，卓越的检索效率，集群部署方便扩展的特点，是审计日志最好的存储方式，自带分析统计功能，可以实时统计</p><p><strong><em>审计日志要记录哪些内容？</em></strong></p><p>针对用户分析日志：请求用户、请求ip地址、请求参数、</p><p>针对服务分析日志：服务接口执行时间、调用次数、堆栈大小，继而可以分析出服务的调用频率、平均耗时</p><p>用户行为分析：</p><ul><li><p>登录日志：记录登录时间、登录ip地址、登录用户、登录结果</p></li><li><p>业务访问日志：记录操作时间、用户Ip地址、访问接口、请求参数、请求结果</p></li></ul><h3 id="确定方案"><a href="#确定方案" class="headerlink" title="确定方案"></a>确定方案</h3><p>spring-aop  +  自定义注解  +  elk</p><p>aop面向切面的思想可以将记录日志逻辑 从 业务逻辑中解耦出来</p><p>自定义注解可以 更灵活的 指定切面</p><p>es存储日志，便于扩展，利于检索和分析</p><h3 id="方案实现"><a href="#方案实现" class="headerlink" title="方案实现"></a>方案实现</h3><p>所有的外部请求都会经过网关，网关负责登录，考虑到登录与业务访问需要记录的日志内容不太相同，所以登录模块单独设计一个注解，业务模块可以共用一个注解。</p><p>登录模块：</p><p>业务模块：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在一个完整的信息系统里面，日志系统是一个非常重要的功能组成部分。它可以记录下系统所产生的所有行为，并按照某种规范表达出来。我们可以使用日志系统所记录的信息为系统进行排错，优化系统的性能，或者根据这些信息调整系统的行为。在安全领域，日志可以反应出很多的安全攻击行为，比如登录错
      
    
    </summary>
    
      <category term="业务" scheme="http://yoursite.com/child/categories/%E4%B8%9A%E5%8A%A1/"/>
    
    
      <category term="ElasticSearch" scheme="http://yoursite.com/child/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>mysql-innoDB架构分析</title>
    <link href="http://yoursite.com/child/2020/01/02/mysql-innoDB%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/child/2020/01/02/mysql-innoDB架构分析/</id>
    <published>2020-01-01T16:00:00.000Z</published>
    <updated>2020-05-22T11:52:38.724Z</updated>
    
    <content type="html"><![CDATA[<p>先上一张官网的架构图，本文将按照架构图中的组件逐一分析。</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/mysql/innodb-architecture.png" alt="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/mysql/innodb-architecture.png"></p><h4 id="1-buffer-pool"><a href="#1-buffer-pool" class="headerlink" title="1. buffer pool"></a>1. buffer pool</h4><p>按照局部性原理，将预期会使用到的数据缓存到内存中，避免每次读取数据都需要进行磁盘i/o，提升i/o性能，这块存放缓存的内存区域就是buffer pool。</p><p>buffer pool 是一种降低磁盘访问的机制。</p><p>磁盘访问通常以页为单位。</p><p>缓存池常见的实现方式是LRU（链表实现，为了减少数据移动），管理磁盘页。</p><p>缓存池管理方式–LRU（链表实现，为了减少数据移动）</p><p>普通LRU会有以下问题：</p><ul><li>预读取失效，预读取的页不会真正被读取<ul><li>优化思路：让预读失效页尽快出内存，真正读取页才挪到LRU头部</li><li>方案：分代管理，预读取进入老生代，真正读取再进入新生代</li></ul></li><li>缓冲池污染，要批量扫描大量数据，导致缓冲池中的热点页被大量替换出去<ul><li>方案：在老生代设置停留时间，只有被真正读取并且停留时间达到阈值，才会移步新生代</li></ul></li></ul><p><strong>innoDB 的buffer pool 对应参数</strong></p><p>参数：innodb_buffer_pool_size</p><p>介绍：配置缓冲池的大小，在内存允许的情况下，DBA往往会建议调大这个参数，越多数据和索引放到内存里，数据库的性能会越好。 </p><p>参数：innodb_old_blocks_pct</p><p>介绍：老生代占整个LRU链长度的比例，默认是37，即整个LRU中新生代与老生代长度比例是63:37。</p><p><em>画外音：如果把这个参数设为100，就退化为普通LRU了。</em></p><p>参数：innodb_old_blocks_time</p><p>介绍：老生代停留时间窗口，单位是毫秒，默认是1000，即同时满足“被访问”与“在老生代停留时间超过1秒”两个条件，才会被插入到新生代头部。</p><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651962450&amp;idx=1&amp;sn=ce17c4da8d20ce275f75d0f2ef5e40c9&amp;chksm=bd2d098e8a5a809834aaa07da0d7546555385543fb6d687a7cf94d183ab061cd301a76547411&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Buffer pool 参考链接</a></p><p>对于读请求，buffer pool 能够减少磁盘的io，提高性能，那么对于写请求呢？change buffer此时登场。</p><h4 id="2-Change-Buffer"><a href="#2-Change-Buffer" class="headerlink" title="2. Change Buffer"></a>2. Change Buffer</h4><p>而对于写请求的优化，就是使用change buffer 来降低磁盘io的</p><p>主要应用于<strong>不在缓冲池中的非唯一普通索引页的写操作</strong></p><p>如果要写的页写已经在缓冲池中了是怎样一个写流程？</p><p>为什么唯一索引不适用呢？</p><p>唯一索引的话每次插入操作都需要检查索引的唯一性</p><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651962467&amp;idx=1&amp;sn=899ea157b0fc6f849ec80a4d055a309b&amp;chksm=bd2d09bf8a5a80a972a2e16a190ed7dffe03f89015ead707bdfcc5aeb8388fb278f397c125f1&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">change buffer 参考</a></p><p>相关参数：</p><p><strong>参数</strong>：innodb_change_buffer_max_size</p><p><strong>介绍</strong>：配置写缓冲的大小，占整个缓冲池的比例，默认值是25%，最大值是50%。</p><p><em>画外音：写多读少的业务，才需要调大这个值，读多写少的业务，25%其实也多了。</em></p><p><strong>参数</strong>：innodb_change_buffering</p><p><strong>介绍</strong>：配置哪些写操作启用写缓冲，可以设置成all/none/inserts/deletes等。</p><h4 id="3-Log-buffer"><a href="#3-Log-buffer" class="headerlink" title="3. Log buffer"></a>3. Log buffer</h4><p>知其然，知其所以然。思路比结论重要</p><p>事务提交时，事务日志为什么要先写到log buffer 在写到os cache中呢？</p><p>虽然是内存操作，但是日志写到os cache中需要进行上下文切换切换到内核态，每次事务提交都直接写则每次都要切换到内核态。先写到log buffer中，将每次写优化为批量写，减少上下文切换次数。</p><p><em>这个优化思路很常见，高并发的MQ落盘，高并发的业务数据落盘，都可以使用。</em></p><h4 id="4-AHI–Adaptive-Hash-Index"><a href="#4-AHI–Adaptive-Hash-Index" class="headerlink" title="4. AHI–Adaptive Hash Index"></a>4. AHI–Adaptive Hash Index</h4><p>自适应哈希索引</p><p><strong>为什么叫自适应？</strong></p><p>用户不能创建，是mysql优化器自行判断，需要时创建</p><p><strong>既然是hash，key是什么，value是什么？</strong></p><p>key是索引键值</p><p>value是索引记录的页面位置</p><p>所以hash索引是索引的索引</p><p><strong>为什么要用哈希索引进行优化？</strong></p><p>通过附加索引查询数据时，有时候会进行回表查询，这样会导致查询连路很长降低查询效率</p><p><strong>哪些业务适用，哪些业务不适用？</strong></p><p>单行记录查询、索引范围查询、记录数不多能全部放到内存中—-适用</p><p>业务中有大量join、like时，AHI的维护会成为负担，建议手动关闭。</p><h4 id="5-redo-log"><a href="#5-redo-log" class="headerlink" title="5. redo log"></a>5. redo log</h4><p>有单独文章讲解</p><h4 id="6-double-write-buffer"><a href="#6-double-write-buffer" class="headerlink" title="6. double write buffer"></a>6. double write buffer</h4><p>知其然，知其所以然。思路比结论重要</p><p><strong>解决什么问题？</strong></p><p>innoDB数据页大小是16k，文件系统中的数据页（后称系统页）大小是4K，那么写数据库时我们将一页数据页落盘，需要刷写4页系统页，如果在此过程中系统掉电，将造成磁盘数据页损坏（例如，前两页系统页已被刷写，后两页未刷写）。</p><p><strong>如何解决？</strong></p><p>DWB缓存即将刷写的数据页。。</p><p>DWB具有两层架构，分为内存和磁盘</p><p>当有数据要落盘时：</p><p>第一步：将内存中修改后的数据页memcopy到dwb内存中</p><p>第二步：将dwb内存中的数据页写入dwb磁盘</p><p>第三步：将dwb中的数据页落盘到磁盘数据页</p><p>假使第二步掉电，磁盘数据页也还是完整的，可以通过redo log进行恢复</p><p>假如第三笔掉电，dwb中的数据页也是完整的，可以直接落盘</p><p><strong>性能影响大吗？</strong></p><p>第一步属于内存操作，速度很快</p><p>第二步属于磁盘顺序追加写，1秒几万次没问题</p><p>第三步不属于额外操作</p><p>另外，dwb 由128页组成，容量2MB，会分两次刷入dwb磁盘，每次1M，速度也很快</p><p><em>有第三方评测，性能损失约为10%</em></p><p>可以通过：</p><p>show global status like “%dblwr%” 查看dwb使用情况</p><p>Innodb_dblwr_pages_written 记录dwb中的写入页数</p><p>Innodb_dblwr_writes 记录dwb的写入次数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先上一张官网的架构图，本文将按照架构图中的组件逐一分析。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/mysql/innodb-architecture.png&quot; alt=&quot;https
      
    
    </summary>
    
      <category term="数据库技术" scheme="http://yoursite.com/child/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/child/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql-redo log写流程分析(转)</title>
    <link href="http://yoursite.com/child/2020/01/02/mysql-redo%20log%E5%86%99%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/child/2020/01/02/mysql-redo log写流程分析/</id>
    <published>2020-01-01T16:00:00.000Z</published>
    <updated>2020-05-22T11:52:20.859Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://mp.weixin.qq.com/s/-Hx2KKYMEQCcTC-ADEuwVA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/-Hx2KKYMEQCcTC-ADEuwVA</a></p><p>为什么我的事务提交了，还会丢失数据呢？</p><p>这要从innoDB的一个参数说起</p><p><em>innodb_flush_log_at_trx_commit</em></p><p>参数的字面意思是innodb在事务提交时更新日志的方式，这个参数有 0，1，2 三种取值，表示有三种方式更新日志</p><p>首先我们要弄清楚事务提交时会更新那些日志呢？</p><p>前滚日志redo log 和 回滚日志undo log ，这两者称为innodb的事务日志。</p><p>事务提交后，存储引擎要将事务对数据的修改刷写到磁盘上以保证事务的ACID特性</p><blockquote><p><strong>A</strong>: atomicity-原子性</p><p><strong>C</strong>: consistency-一致性</p><p><strong>I</strong>: isolation-隔离性</p><p><strong>D</strong>: durability-持久性</p></blockquote><p>这个刷盘，是一个随机写，随机写性能较低，如果每次事务提交都刷盘，会极大影响数据库的性能。</p><p>知其然，知其所以然。思路比结论重要</p><p>所以为了优化随机写带来的低性能，架构设计中有两个常见的优化方法：</p><p>（1）先写日志(write log first)，将随机写优化为<strong>顺序写</strong>；</p><p>（2）将每次写优化为<strong>批量写</strong>；</p><p>这两个优化，InnoDB都用上了。</p><p>先说第一个优化，将对数据的修改先顺序写到日志里，这个日志就是redo log。</p><p>假如某一时刻，数据库崩溃，还没来得及将数据页刷盘，数据库重启时，会重做redo log里的内容，以保证已提交事务对数据的影响被刷到磁盘上。因此，redo log 又称为重做日志。</p><p>一句话，redo log是为了保证已提交事务的ACID特性，同时能够提高数据库性能的技术。</p><p>既然redo log能保证事务的ACID特性，那为什么还会出现，水友提问中出现的“数据库奔溃，丢数据”的问题呢？一起看下redo log的实现细节。</p><p><strong>redo log的三层架构</strong></p><p>画了一个丑图，简单说明下redo log的三层架构：</p><ul><li><strong>粉色</strong>，是InnoDB的一项很重要的内存结构(In-Memory Structure)，日志缓冲区(Log Buffer)，这一层，是MySQL应用程序用户态</li><li><strong>屎黄色</strong>，是操作系统的缓冲区(OS cache)，这一层，是OS内核态</li><li><strong>蓝色</strong>，是落盘的日志文件</li></ul><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/mysql/redolog-1.PNG" alt="redolog-1"></p><p><strong>redo log最终落盘的步骤如何？</strong></p><p><strong>首先</strong>，事务提交的时候，会写入Log Buffer，这里调用的是MySQL自己的函数WriteRedoLog；</p><p><strong>接着</strong>，只有当MySQL发起系统调用写文件write时，Log Buffer里的数据，才会写到OS cache。注意，MySQL系统调用完write之后，就认为文件已经写完，如果不flush，什么时候落盘，是操作系统决定的；</p><blockquote><p>画外音：<strong>有时候打日志，明明</strong>printf<strong>了，</strong>tail -f**却看不到，就是这个原因，这个细节在《明明打印到文件了，为啥tail -f看不到》一文里说过，此处不再展开。</p></blockquote><p><strong>最后</strong>，由操作系统（当然，MySQL也可以主动flush）将OS cache里的数据，最终fsync到磁盘上；</p><p><strong>操作系统为什么要缓冲数据到</strong>OS cache里，而不直接刷盘呢？</p><p>这里就是将“每次写”优化为“批量写”，以提高操作系统性能。</p><p><strong>数据库为什么要缓冲数据到Log Buffer</strong>里，而不是直接write呢？</p><p>这也是“每次写”优化为“批量写”思路的体现，以提高数据库性能。</p><blockquote><p>画外音：这个优化思路，非常常见，高并发的MQ落盘，高并发的业务数据落盘，都可以使用。</p></blockquote><p>redo log的三层架构，MySQL做了一次批量写优化，OS做了一次批量写优化，确实能极大提升性能，但有什么副作用吗？</p><blockquote><p>画外音：有优点，必有缺点。</p></blockquote><p>这个<strong>副作用</strong>，就是可能丢失数据：</p><p>（1）事务提交时，将redo log写入Log Buffer，就会认为事务提交成功；</p><p>（2）如果写入Log Buffer的数据，write入OS cache之前，数据库崩溃，就会出现数据丢失；</p><p>（3）如果写入OS cache的数据，fsync入磁盘之前，操作系统奔溃，也可能出现数据丢失；</p><blockquote><p>画外音：如上文所说，应用程序系统调用完write之后（不可能每次write后都立刻flush，这样写日志很蠢），就认为写成功了，操作系统何时fsync，应用程序并不知道，如果操作系统崩溃，数据可能丢失。</p></blockquote><p>任何脱离业务的技术方案都是耍流氓：</p><p>（1）有些业务允许低效，但不允许一丁点数据丢失；</p><p>（2）有些业务必须高性能高吞吐，能够容忍少量数据丢失；</p><p><strong>MySQL是如何折衷的呢？</strong></p><p>MySQL有一个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_flush_log_at_trx_commit</span><br></pre></td></tr></table></figure><p>能够控制事务提交时，刷redo log的策略。</p><p>目前有<strong>三种策略</strong>：</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/mysql/redolog-2.PNG" alt="redolog-2"></p><p><strong>策略一：最佳性能</strong>(innodb_flush_log_at_trx_commit=0)</p><p>每隔一秒，才将Log Buffer中的数据批量write入OS cache，同时MySQL主动fsync。</p><p>这种策略，如果数据库奔溃，有一秒的数据丢失。</p><p><strong>策略二：强一致</strong>(innodb_flush_log_at_trx_commit=1)</p><p>每次事务提交，都将Log Buffer中的数据write入OS cache，同时MySQL主动fsync。</p><p>这种策略，是InnoDB的默认配置，为的是保证事务ACID特性。</p><p><strong>策略三：折衷</strong>(innodb_flush_log_at_trx_commit=2)</p><p>每次事务提交，都将Log Buffer中的数据write入OS cache；</p><p>每隔一秒，MySQL主动将OS cache中的数据批量fsync。</p><p><em>画外音：**磁盘IO次数不确定，因为操作系统的fsync频率并不是MySQL能控制的。</em></p><p>这种策略，如果操作系统奔溃，最多有一秒的数据丢失。</p><blockquote><p>画外音：因为OS也会fsync，MySQL主动fsync的周期是一秒，所以最多丢一秒数据。</p></blockquote><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/mysql/redolog-3.PNG" alt="redolog-3"></p><p>讲了这么多，回到水友的提问上来，数据库崩溃，重启后丢失了数据，有很大的可能，是将innodb_flush_log_at_trx_commit参数设置为0了，这位水友最好和DBA一起检查一下InnoDB的配置。</p><p>可能有水友要问，<strong>高并发的业务，InnoDB运用哪种刷盘策略最合适？</strong></p><p>高并发业务，行业最佳实践，是使用<strong>第三种折衷配置</strong>（=2），这是因为：</p><ol><li>配置为2和配置为0，性能差异并不大，因为将数据从Log Buffer拷贝到OS cache，虽然跨越用户态与内核态，但毕竟只是内存的数据拷贝，速度很快；</li><li>配置为2和配置为0，安全性差异巨大，操作系统崩溃的概率相比MySQL应用程序崩溃的概率，小很多，设置为2，只要操作系统不奔溃，也绝对不会丢数据。</li></ol><p><strong>总结</strong></p><p>一、为了保证事务的ACID特性，理论上每次事务提交都应该刷盘，但此时效率很低，有两种优化方向：</p><ol><li>随机写优化为顺序写；</li><li>每次写优化为批量写；</li></ol><p>二、redo log是一种顺序写，它有三层架构：</p><ol><li>MySQL应用层：Log Buffer</li><li>OS内核层：OS cache</li><li>OS文件：log file</li></ol><p>三、为了满足不用业务对于吞吐量与一致性的需求，MySQL事务提交时刷redo log有三种策略：</p><ul><li>0：每秒write一次OS cache，同时fsync刷磁盘，性能好；</li><li>1：每次都write入OS cache，同时fsync刷磁盘，一致性好；</li><li>2：每次都write入OS cache，每秒fsync刷磁盘，折衷；</li></ul><p>四、高并发业务，行业内的最佳实践，是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_flush_log_at_trx_commit=2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/-Hx2KKYMEQCcTC-ADEuwVA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/-Hx2KKYMEQCcTC
      
    
    </summary>
    
      <category term="数据库技术" scheme="http://yoursite.com/child/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/child/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>redis-热key问题</title>
    <link href="http://yoursite.com/child/2020/01/02/redis-%E7%83%AD%E7%82%B9key%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/child/2020/01/02/redis-热点key问题/</id>
    <published>2020-01-01T16:00:00.000Z</published>
    <updated>2020-05-22T12:12:41.683Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/rjzheng/p/10874537.html" target="_blank" rel="noopener">原文链接</a></p><p>所谓热key问题就是，突然有几十万的请求去访问redis上的某个特定key。那么，这样会造成流量过于集中，达到物理网卡上限，从而导致这台redis的服务器宕机。<br>那接下来这个key的请求，就会直接怼到你的数据库上，导致你的服务不可用。</p><h3 id="1-怎么发现热key"><a href="#1-怎么发现热key" class="headerlink" title="1. 怎么发现热key"></a>1. 怎么发现热key</h3><p><strong><em>方法一:凭借业务经验，进行预估哪些是热key</em></strong><br>其实这个方法还是挺有可行性的。比如某商品在做秒杀，那这个商品的key就可以判断出是热key。</p><p>缺点很明显，并非所有业务都能预估出哪些key是热key。</p><p><strong><em>方法二:在客户端进行收集</em></strong><br>这个方式就是在操作redis之前，加入一行代码进行数据统计。那么这个数据统计的方式有很多种，也可以是给外部的通讯系统发送一个通知信息。缺点就是对客户端代码造成入侵。</p><p><strong><em>方法三:在Proxy层做收集</em></strong><br>有些集群架构是下面这样的，Proxy可以是Twemproxy，是统一的入口。可以在Proxy层做收集上报，但是缺点很明显，并非所有的redis集群架构都有proxy。</p><p><img src="https://img2018.cnblogs.com/blog/725429/201905/725429-20190516112209464-1290077151.png" alt="img"></p><p><strong><em>方法四:用redis自带命令</em></strong></p><ol><li>monitor命令，该命令可以实时抓取出redis服务器接收到的命令，然后写代码统计出热key是啥。当然，也有现成的分析工具可以给你使用，比如<code>redis-faina</code>。但是该命令在高并发的条件下，有内存增暴增的隐患，还会降低redis的性能。</li><li>hotkeys参数，redis 4.0.3提供了redis-cli的热点key发现功能，执行redis-cli时加上–hotkeys选项即可。但是该参数在执行的时候，如果key比较多，执行起来比较慢。</li></ol><p>缺点是对redis性能影响较大</p><p><strong><em>方法五:自己抓包评估</em></strong><br>Redis客户端使用TCP协议与服务端进行交互，通信协议采用的是RESP。自己写程序监听端口，按照RESP协议规则解析数据，进行分析。缺点就是开发成本高，维护困难，有丢包可能性。</p><p>以上五种方案，各有优缺点。根据自己业务场景进行抉择即可。那么发现热key后，如何解决呢？</p><h3 id="2-如何解决"><a href="#2-如何解决" class="headerlink" title="2. 如何解决"></a>2. 如何解决</h3><p>目前业内的方案有两种</p><p><strong><em>方案一：利用二级缓存</em></strong><br>比如利用<code>ehcache</code>，或者一个<code>HashMap</code>都可以。在你发现热key以后，把热key加载到系统的JVM中。<br>针对这种热key请求，会直接从jvm中取，而不会走到redis层。<br>假设此时有十万个针对同一个key的请求过来,如果没有本地缓存，这十万个请求就直接怼到同一台redis上了。<br>现在假设，你的应用层有50台机器，OK，你也有jvm缓存了。这十万个请求平均分散开来，每个机器有2000个请求，会从JVM中取到value值，然后返回数据。避免了十万个请求怼到同一台redis上的情形。</p><p><strong><em>方案二：备份热key</em></strong><br>这个方案也很简单。不要让key走到同一台redis上不就行了。我们把这个key，在多个redis上都存一份不就好了。接下来，有热key请求进来的时候，我们就在有备份的redis上随机选取一台，进行访问取值，返回数据。<br>假设redis的集群数量为N，步骤如下图所示</p><p><img src="https://img2018.cnblogs.com/blog/725429/201905/725429-20190516112222759-656135438.png" alt="img"></p><p>注:不一定是2N，你想取3N，4N都可以，看要求。<br>伪代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> M = N * <span class="number">2</span></span><br><span class="line"><span class="comment">//生成随机数</span></span><br><span class="line">random = GenRandom(<span class="number">0</span>, M)</span><br><span class="line"><span class="comment">//构造备份新key</span></span><br><span class="line">bakHotKey = hotKey + “_” + random</span><br><span class="line">data = redis.GET(bakHotKey)</span><br><span class="line"><span class="keyword">if</span> data == NULL &#123;</span><br><span class="line">    data = GetFromDB()</span><br><span class="line">    redis.SET(bakHotKey, expireTime + GenRandom(<span class="number">0</span>,<span class="number">5</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-业内方案"><a href="#3-业内方案" class="headerlink" title="3. 业内方案"></a>3. 业内方案</h3><p>OK，其实看完上面的内容，大家可能会有一个疑问。</p><blockquote><p><strong>有办法在项目运行过程中，自动发现热key，然后程序自动处理么？</strong></p></blockquote><p>嗯，好问题，那我们来讲讲业内怎么做的。其实只有两步</p><ol><li>监控热key</li><li>通知系统做处理</li></ol><p>正巧，前几天有赞出了一篇《有赞透明多级缓存解决方案（TMC）》，里头也有提到热点key问题，我们刚好借此说明</p><ul><li>监控热key</li></ul><p>在监控热key方面，有赞用的是<strong><em>方式二：在客户端进行收集</em></strong>。<br>在《有赞透明多级缓存解决方案（TMC）》中有一句话提到</p><blockquote><p><strong>TMC 对原生jedis包的JedisPool和Jedis类做了改造，在JedisPool初始化过程中集成TMC“热点发现”+“本地缓存”功能Hermes-SDK包的初始化逻辑。</strong></p></blockquote><p>也就说人家改写了jedis原生的jar包，加入了Hermes-SDK包。<br>那Hermes-SDK包用来干嘛？<br>OK，就是做<strong>热点发现</strong>和<strong>本地缓存</strong>。</p><p>从监控的角度看，该包对于Jedis-Client的每次key值访问请求，Hermes-SDK 都会通过其通信模块将key访问事件异步上报给Hermes服务端集群，以便其根据上报数据进行“热点探测”。</p><p>当然，这只是其中一种方式，有的公司在监控方面用的是方式五:<strong>自己抓包评估</strong>。</p><p>具体是这么做的，先利用flink搭建一套流式计算系统。然后自己写一个抓包程序抓redis监听端口的数据，抓到数据后往kafka里丢。接下来，流式计算系统消费kafka里的数据，进行数据统计即可，也能达到监控热key的目的。</p><ul><li>通知系统做处理</li></ul><p>在这个角度，有赞用的是上面的<strong><em>解决方案一:利用二级缓存进行处理</em></strong>。</p><p>有赞在监控到热key后，Hermes服务端集群会通过各种手段通知各业务系统里的Hermes-SDK，告诉他们:”老弟，这个key是热key，记得做本地缓存。”</p><p>于是Hermes-SDK就会将该key缓存在本地，对于后面的请求。Hermes-SDK发现这个是一个热key，直接从本地中拿，而不会去访问集群。</p><p>除了这种通知方式以外。我们也可以这么做，比如你的流式计算系统监控到热key了，往zookeeper里头的某个节点里写。然后你的业务系统监听该节点，发现节点数据变化了，就代表发现热key。最后往本地缓存里写，也是可以的。</p><p>通知方式各种各样，大家可以自由发挥。本文只是提供一个思路。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/rjzheng/p/10874537.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所谓热key问题就是，突然有几十万的请求去访问redis上的某个
      
    
    </summary>
    
      <category term="noSql" scheme="http://yoursite.com/child/categories/noSql/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/child/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>reids-5.0版本的高可用集群搭建</title>
    <link href="http://yoursite.com/child/2019/12/31/redis-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/child/2019/12/31/redis-集群搭建/</id>
    <published>2019-12-30T16:00:00.000Z</published>
    <updated>2020-05-22T12:12:57.988Z</updated>
    
    <content type="html"><![CDATA[<p>Redis系统介绍：</p><p><a href="https://www.jianshu.com/p/2a23257af57b" target="_blank" rel="noopener">Redis的基础介绍与安装使用步骤</a><br><a href="https://www.jianshu.com/p/c95c8450c5b6" target="_blank" rel="noopener">Redis的基础数据结构与使用</a><br><a href="https://www.jianshu.com/p/4e6b7809e10a" target="_blank" rel="noopener">Redis核心原理</a><br><a href="https://www.jianshu.com/p/8045b92fafb2" target="_blank" rel="noopener">Redis 5 之后版本的高可用集群搭建</a><br><a href="https://www.jianshu.com/p/6355d0827aea" target="_blank" rel="noopener">Redis 5 版本的高可用集群的水平扩展</a><br><a href="https://www.jianshu.com/p/e6894713a6d5" target="_blank" rel="noopener">Redis 5 集群选举原理分析</a><br><a href="https://www.jianshu.com/p/575544f68615" target="_blank" rel="noopener">Redis 5 通信协议解析以及手写一个Jedis客户端</a></p><hr><h4 id="1-集群方案比较："><a href="#1-集群方案比较：" class="headerlink" title="1. 集群方案比较："></a>1. 集群方案比较：</h4><h5 id="1-1-哨兵模式："><a href="#1-1-哨兵模式：" class="headerlink" title="1.1 哨兵模式："></a>1.1 哨兵模式：</h5><p>在redis3.0以前的版本要实现集群一般是借助哨兵sentinel工具来监控master节点的状态，如果master节点异常，则会做主从切换，将某一台slave作为master，哨兵的配置略微复杂，并且性能和高可用性等各方面表现一般，特别是在主从切换的瞬间存在访问瞬断的情况，而且哨兵模式只有一个主节点对外提供服务，没法支持很高的并发，且单个主节点内存也不宜设置得过大，否则会导致持久化文件过大，影响数据恢复或主从同步的效率。</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/redis/redis-cluster%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.png" alt="哨兵模式"></p><h5 id="1-2-高可用集群模式："><a href="#1-2-高可用集群模式：" class="headerlink" title="1.2 高可用集群模式："></a>1.2 高可用集群模式：</h5><p>redis集群是一个由多个主从节点群组成的分布式服务器群，它具有复制、高可用和分片特性。Redis集群不需要sentinel哨兵也能完成节点移除和故障转移的功能。需要将每个节点设置成集群模式，这种集群模式没有中心节点，可水平扩展，据官方文档称可以线性扩展到上万个节点(官方推荐不超过1000个节点)。redis集群的性能和高可用性均优于之前版本的哨兵模式，且集群配置非常简单。</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/redis/redis-cluster%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84.png" alt="高可用架构"></p><h4 id="2-开始搭建"><a href="#2-开始搭建" class="headerlink" title="2. 开始搭建"></a>2. 开始搭建</h4><h5 id="2-1-安装redis"><a href="#2-1-安装redis" class="headerlink" title="2.1 安装redis"></a>2.1 安装redis</h5><p>参考之前博客：Redis的基础介绍与安装使用步骤：<a href="https://www.jianshu.com/p/2a23257af57b" target="_blank" rel="noopener">https://www.jianshu.com/p/2a23257af57b</a></p><p>下载地址：<a href="http://redis.io/download" target="_blank" rel="noopener">http://redis.io/download</a></p><p>1、安装gcc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc</span><br></pre></td></tr></table></figure><p>2、把下载好的redis-5.0.2.tar.gz放在/usr/local文件夹下，并解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-5.0.2.tar.gz</span><br><span class="line">tar xzf redis-5.0.2.tar.gz</span><br><span class="line"><span class="built_in">cd</span> redis-5.0.2</span><br></pre></td></tr></table></figure><p>3、进入到解压好的redis-5.0.2目录下，进行编译与安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp; make install</span><br></pre></td></tr></table></figure><p>4、启动并指定配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/redis-server redis.conf</span><br></pre></td></tr></table></figure><p>（注意要使用后台启动，所以修改redis.conf里的daemonize改为yes)</p><p>5、验证启动是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure><p>6、进入redis客户端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/redis/redis-5.0.2/src</span><br><span class="line">./redis-cli</span><br></pre></td></tr></table></figure><p>7、退出客户端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>8、退出redis服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pkill redis-server</span><br><span class="line"><span class="built_in">kill</span> 进程号</span><br><span class="line">src/redis-cli shutdown</span><br></pre></td></tr></table></figure><h5 id="2-2-集群搭建"><a href="#2-2-集群搭建" class="headerlink" title="2.2 集群搭建"></a>2.2 集群搭建</h5><p>redis集群需要至少要三个master节点，我们这里搭建三个master节点，并且给每个master再搭建一个slave节点，总共6个redis节点，这里用一台机器（可以多台机器部署，修改一下ip地址就可以了）部署6个redis实例，三主三从，搭建集群的步骤如下：</p><p><strong>第一步：</strong>在机器的/usr/local下创建文件夹redis-cluster，然后在其下面创建6个文件夾如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/<span class="built_in">local</span>/redis-cluster</span><br><span class="line"></span><br><span class="line">mkdir 8001 8002 8003 8004 8005 8006</span><br></pre></td></tr></table></figure><p><strong>第二步：</strong>把之前的redis.conf配置文件copy到8001下，修改如下内容：</p><blockquote><p>1）daemonize yes</p><p>2）port 8001（分别对每个机器的端口号进行设置）</p><p>3）dir /usr/local/redis-cluster/8001/（指定数据文件存放位置，必须要指定不同的目录位置，不然会丢失数据）</p><p>4）cluster-enabled yes（启动集群模式）</p><p>5）cluster-config-file nodes-8001.conf（集群节点信息文件，这里800x最好和port对应上）</p><p>6）cluster-node-timeout 5000</p><p>7)  bind 127.0.0.1（去掉bind绑定访问ip信息）</p><p>8)  protected-mode  no   （关闭保护模式）</p><p>9）appendonly yes</p><p>如果要设置密码需要增加如下配置：</p><p>10）requirepass xxx     (设置redis访问密码)</p><p>11）masterauth  xxx     (设置集群节点间访问密码，跟上面一致)</p></blockquote><p><strong>第三步：</strong>把修改后的配置文件，copy到8002-8006，修改第2、3、5项里的端口号，可以用批量替换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%s/源字符串/目的字符串/g</span><br></pre></td></tr></table></figure><p><strong>第四步：</strong>分别启动6个redis实例，然后检查是否启动成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/redis-5.0.7/src/redis-server /usr/<span class="built_in">local</span>/redis-cluster/800*/redis.conf</span><br></pre></td></tr></table></figure><p><strong>第五步：</strong>用redis-cli创建整个redis集群(redis5以前的版本集群是依靠ruby脚本redis-trib.rb实现)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/redis-5.0.7/src/redis-cli -a xxx --cluster create --cluster-replicas 1 192.168.2.116:8001 192.168.2.116:8002 192.168.2.116:8003 192.168.2.116:8004 192.168.2.116:8005 192.168.2.116:8006</span><br></pre></td></tr></table></figure><p>代表为每个创建的主服务器节点创建一个从服务器节点</p><p><strong>第六步：</strong>验证集群：</p><p>1）连接任意一个客户端即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-cli -c -a xxx -h 192.168.2.116 -p 8001</span><br></pre></td></tr></table></figure><p>提示：-a访问服务端密码，-c表示集群模式，指定ip地址和端口号</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/redis-5.0.2/src/redis-cli -a xxx -c -h 192.168.2.116 -p 8001</span><br></pre></td></tr></table></figure><p>注意这里进入到8002了，redirected。</p><p>2）进行验证： cluster info（查看集群信息）、cluster nodes（查看节点列表）</p><p>3）进行数据操作验证</p><p>4）关闭集群则需要逐个进行关闭，使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/redis/src/redis-cli -a xxx -c -h 192.168.2.116 -p 8001 shutdown</span><br></pre></td></tr></table></figure><h4 id="3-设置开机自启"><a href="#3-设置开机自启" class="headerlink" title="3. 设置开机自启"></a>3. 设置开机自启</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/init.d/redis</span><br></pre></td></tr></table></figure><p>将如下代码粘贴进去：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/src/sh</span></span><br><span class="line"><span class="comment"># chkconfig: 2345 80 90</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Simple Redis init.d script conceived to work on Linux systems</span></span><br><span class="line"><span class="comment"># as it does use of the /proc filesystem.</span></span><br><span class="line">​</span><br><span class="line">REDISPORT1=8001</span><br><span class="line">REDISPORT2=8002</span><br><span class="line">REDISPORT3=8003</span><br><span class="line">REDISPORT4=8004</span><br><span class="line">REDISPORT5=8005</span><br><span class="line">REDISPORT6=8006</span><br><span class="line">EXEC=/usr/<span class="built_in">local</span>/redis-5.0.7/src/redis-server</span><br><span class="line">CLIEXEC=/usr/<span class="built_in">local</span>/redis-5.0.7/src/redis-cli</span><br><span class="line">​</span><br><span class="line">PIDFILE=/var/run/redis_<span class="variable">$&#123;REDISPORT1&#125;</span>.pid</span><br><span class="line">​</span><br><span class="line">CONF1=<span class="string">"/usr/local/redis-cluster/<span class="variable">$&#123;REDISPORT1&#125;</span>/redis.conf"</span></span><br><span class="line">CONF2=<span class="string">"/usr/local/redis-cluster/<span class="variable">$&#123;REDISPORT2&#125;</span>/redis.conf"</span></span><br><span class="line">CONF3=<span class="string">"/usr/local/redis-cluster/<span class="variable">$&#123;REDISPORT3&#125;</span>/redis.conf"</span></span><br><span class="line">CONF4=<span class="string">"/usr/local/redis-cluster/<span class="variable">$&#123;REDISPORT4&#125;</span>/redis.conf"</span></span><br><span class="line">CONF5=<span class="string">"/usr/local/redis-cluster/<span class="variable">$&#123;REDISPORT5&#125;</span>/redis.conf"</span></span><br><span class="line">CONF6=<span class="string">"/usr/local/redis-cluster/<span class="variable">$&#123;REDISPORT6&#125;</span>/redis.conf"</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></span><br><span class="line">    start)</span><br><span class="line">        <span class="keyword">if</span> [ -f <span class="variable">$PIDFILE</span> ]</span><br><span class="line">        <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"<span class="variable">$PIDFILE</span> exists, process is already running or crashed"</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"Starting Redis cluster server..."</span></span><br><span class="line">                <span class="variable">$EXEC</span> <span class="variable">$CONF1</span> &amp;</span><br><span class="line">                <span class="variable">$EXEC</span> <span class="variable">$CONF2</span> &amp;</span><br><span class="line">                <span class="variable">$EXEC</span> <span class="variable">$CONF3</span> &amp;</span><br><span class="line">                <span class="variable">$EXEC</span> <span class="variable">$CONF4</span> &amp;</span><br><span class="line">                <span class="variable">$EXEC</span> <span class="variable">$CONF5</span> &amp;</span><br><span class="line">                <span class="variable">$EXEC</span> <span class="variable">$CONF6</span> &amp;</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"启动成功..."</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        ;;</span><br><span class="line">    stop)</span><br><span class="line">        <span class="keyword">if</span> [ ! -f <span class="variable">$PIDFILE</span> ]</span><br><span class="line">        <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"<span class="variable">$PIDFILE</span> does not exist, process is not running"</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                PID=$(cat <span class="variable">$PIDFILE</span>)</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"Stopping ..."</span></span><br><span class="line">                <span class="variable">$CLIEXEC</span> -p <span class="variable">$REDISPORT1</span> shutdown</span><br><span class="line">                <span class="variable">$CLIEXEC</span> -p <span class="variable">$REDISPORT2</span> shutdown</span><br><span class="line">                <span class="variable">$CLIEXEC</span> -p <span class="variable">$REDISPORT3</span> shutdown</span><br><span class="line">                <span class="variable">$CLIEXEC</span> -p <span class="variable">$REDISPORT4</span> shutdown</span><br><span class="line">                <span class="variable">$CLIEXEC</span> -p <span class="variable">$REDISPORT5</span> shutdown</span><br><span class="line">                <span class="variable">$CLIEXEC</span> -p <span class="variable">$REDISPORT6</span> shutdown</span><br><span class="line">                <span class="keyword">while</span> [ -x /proc/<span class="variable">$&#123;PID&#125;</span> ]</span><br><span class="line">                <span class="keyword">do</span></span><br><span class="line">                    <span class="built_in">echo</span> <span class="string">"Waiting for Redis cluster to shutdown ..."</span></span><br><span class="line">                    sleep 1</span><br><span class="line">                <span class="keyword">done</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"Redis cluster stopped"</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Please use start or stop as first argument"</span></span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>添加权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /etc/init.d/redis</span><br></pre></td></tr></table></figure><p>加入开机启动服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --add redis</span><br></pre></td></tr></table></figure><p>使用命令进行开启或关闭redis集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service redis start </span><br><span class="line">service redis stop</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/8045b92fafb2" target="_blank" rel="noopener">原文连接</a></p><p><a href="https://blog.csdn.net/qq_37859539/article/details/83715803" target="_blank" rel="noopener">https://blog.csdn.net/qq_37859539/article/details/83715803</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Redis系统介绍：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/2a23257af57b&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Redis的基础介绍与安装使用步骤&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https
      
    
    </summary>
    
      <category term="noSql" scheme="http://yoursite.com/child/categories/noSql/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/child/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>mysql-innodb的事务管理与锁</title>
    <link href="http://yoursite.com/child/2019/11/23/mysql-innodb%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E4%B8%8E%E9%94%81/"/>
    <id>http://yoursite.com/child/2019/11/23/mysql-innodb的事务管理与锁/</id>
    <published>2019-11-22T16:00:00.000Z</published>
    <updated>2020-05-22T11:52:56.185Z</updated>
    
    <content type="html"><![CDATA[<p>典型的事务场景：下单、转账</p><p><strong>事物的定义：事务是DBMS执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成</strong></p><p>MYSQL中支持事务的数据引擎：innodb  ndb</p><h5 id="1、数据库事务的四大特性是什么？"><a href="#1、数据库事务的四大特性是什么？" class="headerlink" title="1、数据库事务的四大特性是什么？"></a>1、数据库事务的四大特性是什么？</h5><p>原子性  Atomicity   由undo log保证</p><p>一致性  Consistent   数据完整性</p><p>隔离性   Isolation  不同事务之间处理同一段数据应当是隔离的互不干扰的</p><p>持久性   Durable  redo log</p><p><strong>原子性、隔离性和持久性最终都是为了实现一致性。</strong></p><h5 id="2、什么时候会出现事务、结束事务？"><a href="#2、什么时候会出现事务、结束事务？" class="headerlink" title="2、什么时候会出现事务、结束事务？"></a>2、什么时候会出现事务、结束事务？</h5><p>当我们执行单条语句的时候，会默认开启事务</p><p>mysql 参数 autocommit 默认为 on 开启状态，执行单条查询语句不需要显示的声明事务、提交事务</p><p>show global VARIABLE like ‘autocommit’  显示该参数的全局值</p><p>show session VARIABLE like ‘autocommit’ 显示当前会话该参数的值</p><p>set session autocommit=off; 关闭autocommit后，需要手动提交</p><p><strong>手动开启事务，两种方式</strong>  </p><p>start TRANSACATION;    </p><p> begin; </p><p>事务的结束：</p><p>提交结束 commit;</p><p>回滚结束 rollback；</p><p>连接断开 会话结束 -&gt; 事务结束</p><h5 id="3、事务并发带来的问题有哪些？"><a href="#3、事务并发带来的问题有哪些？" class="headerlink" title="3、事务并发带来的问题有哪些？"></a>3、事务并发带来的问题有哪些？</h5><p>脏读（读未提交）：事务A执行一条查询，事务B修改了这部分数据但没提交，导致A读取到事务B没有提交的数据，事务B可能回滚导致事务A读取到的数据是脏数据。</p><p>不可重复读：事务A执行一条查询后，事务B对这部分数据执行了update/delete并提交了，导致事务A再次查询时与上一次的查询结果不一致，称为不可重复度。</p><p>幻读：事务A执行一条范围查询后，事务B在此范围insert了若干条数据，导致事务A再次执行该查询是记录数增多，产生幻读。</p><p>以上三个问题称为数据库的读一致性问题，必须由数据库自己提供一定的事务隔离机制来解决</p><h5 id="4、SQL92-标准"><a href="#4、SQL92-标准" class="headerlink" title="4、SQL92 标准"></a>4、SQL92 标准</h5><p>许多数据库专家联合制定了一个标准，建议数据库厂商都按照这个标准提供一定的事务隔离级别，来解决事务并发问题。</p><p>看一下SQL92标准的官网：<a href="http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt" target="_blank" rel="noopener">http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt</a></p><p>在官网搜索_iso，会看到一张表格：</p><table><thead><tr><th style="text-align:left">Level</th><th>P1</th><th>P2</th><th>P3</th></tr></thead><tbody><tr><td style="text-align:left">READ UNCOMMITTED</td><td>Possible</td><td>Possible</td><td>Possible</td></tr><tr><td style="text-align:left">READ COMMITTED</td><td>Not Possible</td><td>Possible</td><td>Possible</td></tr><tr><td style="text-align:left">REPEATABLE READ</td><td>Not Possible</td><td>Not Possible</td><td>Possible</td></tr><tr><td style="text-align:left">SERIALIZABLE</td><td>Not Possible</td><td>Not Possible</td><td>Not Possible</td></tr></tbody></table><p>这里定义了四个隔离级别，右边的P1P2P3就是代表事务并发的三个问题，脏读，不可重复度，幻读。Possible表示在这个隔离级别下该问题有可能发生，Not Possible表示解决了该问题。</p><ul><li>Read Uncommited 未提交读</li></ul><p>顾名思义，事务可以读取到其他事物未提交的数据，使用这种隔离级别其实并未解决以上的任何问题</p><ul><li>Read Commited  已提交读</li></ul><p>只能读到其他事物已经提交了的数据，解决了脏读问题</p><ul><li>Repeatable Read  可重复读</li></ul><p>事务重复读取，保证重复读取数据一致，解决了不可重复度的问题</p><ul><li>Serializable 串行化</li></ul><p>事务串行化运行，没有并发自然没有不一性问题产生，但是严重影响效率，不推荐使用</p><p>不同的厂商或者数据库引擎在实现以上标准时会有一些差异。Oracle只实现了两种RC和Serializable，Innodb对以上的四种隔离级别都进行了实现，值得一提的是，innodb 对Repeatable Read 这一级别的实现同时也解决了幻读的问题，因此这一级别是innodb的默认事务隔离级别。</p><h5 id="5、innodb是如何实现的呢"><a href="#5、innodb是如何实现的呢" class="headerlink" title="5、innodb是如何实现的呢?"></a>5、innodb是如何实现的呢?</h5><p>如果要解决读一致性的问题 ，保证一个事务前后两次读取数据一致，实现事务隔离级别，应该怎么做 </p><p>方案一 ： LBCC 基于锁的并发控制</p><p>方案二： MVCC 基于多版本的并发控制  生成一个数据请求时间点的一致性数据，并用这个快照来提供一定级别的一致性读取。</p><p>首先介绍MVCC的实现原理</p><p>从三个隐藏字段开始</p><p>InnoDB为每行记录都实现了三个隐藏字段</p><p>DB_ROW_ID   6字节：行标识</p><p>DB_TRX_ID  6字节：插入或更新行的最后一个事务ID，自动递增（理解为创建版本号）</p><p>DB_ROLL_PTR：  7字节：回滚指针（理解为删除版本号）</p><p>mvcc核心思想，一个事务根据自己的事务id进行判断，</p><p>只能查询到创建版本号比我的事务ID小的  和  删除版本号比我事务ID大的记录  </p><p>innodb的锁：</p><p>锁的模式：</p><p>行锁—共享锁 和 排它锁</p><p>表所 — 意向排他锁 和 意向共享锁</p><p>为什么需要 表级别的意向锁</p><p>意向锁可以理解为表的锁标志</p><p>一个事务尝试给一张表加上表锁，前提是没有其他任何事务已经锁定了这张表的任意一行，那么需要检索所有的行确定没有锁。意向锁是又来避免这种检索的</p><p>锁的作用：</p><p>锁的算法：在什么时候锁定什么范围</p><p>记录锁</p><p>间隙锁</p><p>邻键锁</p><p>插入意向锁 </p><p>自增锁</p><p>解决资源竞争的问题</p><p>锁到底锁住了什么？</p><p>锁住的是索引</p><p>问题1 一张表没有索引或者没用到索引为什么会锁表？</p><p>一张表不可能没有索引，没有显示声明索引的表，隐藏的row_id字段会作为聚集索引。。。如果查询语句没有用到索引，那只能走全表扫描，就会锁住全表</p><p>问题2 为什么锁住辅助索引，会导致主键索引也被锁住？</p><p>回表</p><p>记录锁 —- 唯一索引 等值查询 精确匹配时</p><p>间隙锁—- 锁定记录不存在的范围区间，主要用来控制插入，不同间隙的锁互相不影响</p><p>邻键锁 —- 锁定查询的范围，包含记录和区间，执行了范围查询时会用到邻键锁，是行锁的默认锁定方式，以上两种是邻键锁的特殊情况</p><p>innodb在RR实现里就解决幻读问题 就是依靠邻 键锁</p><p>共享锁和排他锁   行所</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;典型的事务场景：下单、转账&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事物的定义：事务是DBMS执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MYSQL中支持事务的数据引擎：innodb  ndb&lt;/p&gt;
&lt;h5 id=&quot;1、数据库事务的四大
      
    
    </summary>
    
      <category term="数据库技术" scheme="http://yoursite.com/child/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/child/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>彻底理解cookie/session/token</title>
    <link href="http://yoursite.com/child/2019/11/23/%E5%85%B6%E4%BB%96-%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3cookie%EF%BC%8Csession%EF%BC%8Ctoken/"/>
    <id>http://yoursite.com/child/2019/11/23/其他-彻底理解cookie，session，token/</id>
    <published>2019-11-22T16:00:00.000Z</published>
    <updated>2020-06-12T00:38:05.261Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/moyand/p/9047978.html" target="_blank" rel="noopener">原文链接</a></p><p>发展史</p><p>1、 很久很久以前，Web基本上就是文档的浏览而已，既然是浏览，作为服务器，不需要记录谁在某一段时间里都浏览了什么文 档，每次请求都是一个新的HTTP协议，就是请求加响应，尤其是我不用记住是谁刚刚发了 HTTP请求，每个请求对我来说都是 全新的。这段时间很嗨皮</p><p>2、 但是随着交互式Web应用的兴起，像在线购物网站，需要登录的网站等等，马上就面临一个问题，那就是要管理会话，必须记住 哪些人登录系统，哪些人往自己的购物车中放商品，也就是说我必须把每个人区分开，这就是一个不小的挑战，因为HTTP请求是 无状态的，所以想出的办法就是给大家发一个会话标识(session id),说白了就是一个随机的字串，每个人收到的都不一样，每次大 家向我发起HTTP请求的时候，把这个字符串给一并捎过来，这样我就能区分开谁是谁了</p><p>3、 这样大家很嗨皮了，可是服务器就不嗨皮了，每个人只需要保存自己的session id，而服务器要保存所有人的session id !如果 访问服务器多了，就得由成千上万，甚至几十万个。这对服务器说是一个巨大的开销，严重的限制了服务器扩展能力，比如说我用两个机器组成了一个集群，小F通过机器A登录了系 统，那session id会保存在机器A上，假设小F的下一次请求被转发到机器B怎么办？机器B可没有小F的session id啊。</p><p>有时候会采用_点小伎俩：session sticky,就是让小 F的请求一直粘连在机器A上，但是这也不管用，要是机器A挂掉了，还得转 到机器B去。那只好做session的复制了，把session id在两个机器之间搬来搬去，快累死了。</p><p>后来有个叫Memcached的支了招：把session id 集中存储到一个地方，所有的机器都来访问这个地方的数据，这样一来，就不用复制了。但是增加了单点失败的可能性，要是那个负责session的机器挂了，所有的人都得重新登录一遍，估计的被人骂死。后来也尝试把这个单点的机器搞成集群，增加可靠性，但是不管如何，这个小小的session对我来说是一个称重的负担。</p><p>4  于是就有人一直在思考，我为什么要保存这个可恶的session呢，让每个客户端去保存该多好可是如果不保存这些session id 怎么验证客户端发给我的session id 的确是我生成的呢？如果不去验证，我们都不知道他们是不是合法的登录用户，那些不怀好意的家伙们就能伪造session id 为所欲为了</p><p>哦，对了 关键点就是验证</p><p>比如说，小F已经登陆了系统，我给他发一个令牌（Token），里面包含了小F的user id ，下一次小F再次通过Http请求访问我的时候，把这个token通过http header带过来不就可以了。不过这和session id 没有本质区别啊 ，任何人都可以伪造，所以我的想点办法让别人伪造不了。</p><p>那就对数据做一个签名吧，比如说我用HMAC-SHA256算法，加上一个只我才知道的秘钥，对数据做一个签名，把这个签名和数据一起作为token，由于秘钥被人不知道，就无法伪造了。</p><p>这个token我们不保存，当小F把这个token发给我的时候，我在用同样的算法和密钥对数据在计算一次签名，和token中带的签名做个比较：如果相同，我就知道小F已经登陆过了，并且可以直接取到小F的user id；若果不相同，数据部分肯定被人篡改过，我就回复发送者：对不起，没有验证。</p><p>Token中的数据是明文保存的（虽然我会用Base64做下编码，但那不是加密），还是可以被别人看到的，所以我不能在其中保存像密码这样的敏感信息当然，如果一个人的token被别人偷走了，那我也没办法，我也会任为小偷就是合法用户，这其实和一个人的session id 被别人偷走是一样的。</p><p>这样一来，我就不保存session id 了，我只是生成token，然后验证token。用计算时间换区存储空间解除了session id 这个负担，可以说是一身轻松，我的机器集群现在可以轻松的做水平扩展，用户访问量增大，直接加机器就行。这种无状态的感觉实在太好了！</p><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>cookie是一个非常具体的东西，指的就是浏览器里能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。cookie有服务器生成，发送给浏览器，浏览器吧cookie一kv的形式保存到某个目录下的文本文件内，下一次请求同一域名时会把该cookie发送给服务器。由于cookie是存在客户端上的没所以浏览器加入了一些限制确保cookie不会给恶意使用，同事不会占据太多磁盘空间。所以每个域的cookie数量是有限的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/moyand/p/9047978.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;发展史&lt;/p&gt;
&lt;p&gt;1、 很久很久以前，Web基本上就是文档的浏览
      
    
    </summary>
    
      <category term="其他" scheme="http://yoursite.com/child/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/child/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>netty源码分析之PipeLine</title>
    <link href="http://yoursite.com/child/2019/11/21/nio-netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BPipeLine/"/>
    <id>http://yoursite.com/child/2019/11/21/nio-netty源码分析之PipeLine/</id>
    <published>2019-11-20T16:00:00.000Z</published>
    <updated>2020-05-22T11:49:23.176Z</updated>
    
    <content type="html"><![CDATA[<p>Channel创建的时候会创建一个PipeLine，并且PipeLine也持有Channel对象的引用，二者是互相引用的关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractChannel.class</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    pipeline = newChannelPipeline();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> DefaultChannelPipeline <span class="title">newChannelPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPipeline(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractChannel 是Channel接口的第一个抽象实现类，其中就声明了对pipeline的引用，在看pipeLine的初始化，创建了一个DefaultChannelPipeline ，构造函数将正在构造的channel对象传进去，看构造器源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultChannelPipeline</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">"channel"</span>);</span><br><span class="line">    succeededFuture = <span class="keyword">new</span> SucceededChannelFuture(channel, <span class="keyword">null</span>);</span><br><span class="line">    voidPromise =  <span class="keyword">new</span> VoidChannelPromise(channel, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>);</span><br><span class="line">    head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.prev = head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一步就是将传入的channel对象存下来，然后创建头结点head和尾结点tail组成一个初始的双向链表。</p><p>ok，至此我们可以了解到PipeLine 数据结构是一个双向链表，头结点是HeadContext对象，尾结点是TailContext对象，而头尾节点都是 AbstractChannelHandlerContext 的子类。</p><p>那我们要弄清楚pipeLine的工作方式，肯定要先搞搞明白组成它的节点AbstractChannelHandlerContext 到底是个啥。</p><h4 id="PipeLine节点分析"><a href="#PipeLine节点分析" class="headerlink" title="PipeLine节点分析"></a>PipeLine节点分析</h4><p>AbstractChannelHandlerContext 是实现了ChannelHandlerContext 的抽象类，我们根据字面意思理解，ChannelHandlerContext 就是执行 ChannelHandler的上下文，<strong>上下文应该包含该Handler的执行逻辑，并且负责这段逻辑的调用，以及调用结果的处理</strong>。</p><p>而ChannelHandler我们应该很熟悉了，用来处理客户端请求或者服务器响应的一些处理器。</p><p>服务器对客户端请求的处理，一般来说都是要分步骤执行的，一个常见的例子就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">接受请求得到byteBuf--&gt;解码得到request对象--&gt;对request鉴权--&gt;处理reques得到response</span><br><span class="line"></span><br><span class="line">--&gt;对response编码得到byteBuf并发送响应</span><br></pre></td></tr></table></figure><p>对于以上流程，服务器程序中需要调用<code>pipeline.addLast(new xxxxHandler())</code>方法加入到pipeline中Handler有：DecodeHandler–&gt;LoginHandler–&gt;BussinessHandler–&gt;EncodeHandler ，跟进addLast方法调用最终会到达</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultChannelPipeline</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//1 检查是否重复添加</span></span><br><span class="line">        checkMultiplicity(handler);</span><br><span class="line">        <span class="comment">//2 创建节点 DefaultChannelHandlerContext类型</span></span><br><span class="line">        newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line">        <span class="comment">//3 添加节点  双向链表操作</span></span><br><span class="line">        addLast0(newCtx);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4 回调用户方法</span></span><br><span class="line">    callHandlerAdded0(newCtx);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">newContext</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//group为null，因此childExecutor(group)也返回null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelHandlerContext(<span class="keyword">this</span>, childExecutor(group), name, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultChannelHandlerContext</span></span><br><span class="line">DefaultChannelHandlerContext(</span><br><span class="line">        DefaultChannelPipeline pipeline, EventExecutor executor, String name, ChannelHandler handler) &#123;</span><br><span class="line">    <span class="comment">// 将参数回传到父类，保存Handler的引用</span></span><br><span class="line">    <span class="keyword">super</span>(pipeline, executor, name, handler.getClass());</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractChannelHandlerContext</span></span><br><span class="line">AbstractChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor,</span><br><span class="line">                              String name, Class&lt;? extends ChannelHandler&gt; handlerClass) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = ObjectUtil.checkNotNull(name, <span class="string">"name"</span>);</span><br><span class="line">    <span class="keyword">this</span>.pipeline = pipeline;</span><br><span class="line">    <span class="keyword">this</span>.executor = executor; <span class="comment">// null</span></span><br><span class="line">    <span class="keyword">this</span>.executionMask = mask(handlerClass); <span class="comment">// 生成一个掩码 可以快读判断这个Handler重载了哪些方法</span></span><br><span class="line">    ordered = executor == <span class="keyword">null</span> || executor <span class="keyword">instanceof</span> OrderedEventExecutor; <span class="comment">// ture</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，addLast方法将用户写的Handler包装成了一个 DefaultChannelPipeline ，加入到了双向链表的tail节点之前。pipeline节点就拥有了handler执行逻辑。</p><p>接下来要弄清楚的是，ChannelHandlerContext 是怎样调用这些逻辑的，ChannelHandlerContext继承了ChannelInboundInvoker, ChannelOutboundInvoker这两个接口，里面定义的方法就是用来调用handler逻辑。</p><p>那为什么要继承两个接口呢？</p><p>Handler 有 in 和 out 之分，但是HandlerContext没有，所以为了既能调用inhandler逻辑又能调用outhandler逻辑，就继承了两个接口。</p><p>老版本的netty，AbstractChannelHandlerContext 有两个bool属性InBound 和outBound，<code>InBound=true</code>表示该节点是inBound，<code>outBound=true</code>表示该节点是outBound，当然也可能同时为true。在我阅读的源代码版本（4.1.50）中已经删除了这两个属性，取而代之的是属性<strong><em>executionMask</em></strong>，通过使用该属性可以在事件传播时，快速的判断出该节点中的Handler在inBound方向和outBound方向有没有重载某事件处理逻辑。此处将另外分析。</p><p>最后要弄明白的是，handler的执行结果应该怎么处理？</p><p>我们不要忘了，pipeLine是一个双向链表，在一个上下文节点中，我们可以很方便的获取到前一个或者后一个上下文节点，当前的节点执行完handler逻辑之后，调用ChannelInboundInvoker或者ChannelOutboundInvoker定义的方法（AbstractChannelHandlerContext对这些方法做了实现），就可以将当前的执行结果传递给下一个节点或者上一个节点。这将取决于事件的类型是inBound还是outBound。</p><h4 id="事件传播"><a href="#事件传播" class="headerlink" title="事件传播"></a>事件传播</h4><p>在此分别选取一种事件传播的源码看一下</p><p><strong>inBound事件</strong></p><p>看一个inBound事件，当unsafe中执行<code>pipeline.fireChannelRead()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultChannelPipeline</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最先调用的是head节点的channelRead方法，此处是静态方法调用</span></span><br><span class="line">    AbstractChannelHandlerContext.invokeChannelRead(head, msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractChannelHandlerContext</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最最核心的就是这个静态调用，负责传播的核心方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="string">"msg"</span>), next);</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">      next.invokeChannelRead(m);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            next.invokeChannelRead(m);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是实例方法，在某节点中确定下一个执行节点，确定了之后将执行静态调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">fireChannelRead</span><span class="params">(<span class="keyword">final</span> Object msg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 又是这个静态调用</span></span><br><span class="line">    invokeChannelRead(findContextInbound(MASK_CHANNEL_READ), msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 寻找下一个节点的逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextInbound</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</span><br><span class="line">    EventExecutor currentExecutor = executor();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// 这里可以看出inBound事件是向后传播的</span></span><br><span class="line">      ctx = ctx.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (skipContext(ctx, currentExecutor, mask, MASK_ONLY_INBOUND));</span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体负责执行handler逻辑的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          ((ChannelInboundHandler) handler()).channelRead(<span class="keyword">this</span>, msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          invokeExceptionCaught(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fireChannelRead(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在handler <code>channelRead()</code>逻辑最后，都会调用一下<code>ctx.channelRead</code>，将事件传播下去</p><p><strong>outBound事件</strong></p><p>再看一个outBound事件传播的代，当我们在某handler中执行 <code>ctx.pipeline().writeAndFlush()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultChannelPipeline</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tail.write(msg, promise); <span class="comment">//pipeline直接找tail</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractChannelHandlerContext</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">write</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> write(msg, newPromise());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">write</span><span class="params">(<span class="keyword">final</span> Object msg, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    write(msg, <span class="keyword">false</span>, promise);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, <span class="keyword">boolean</span> flush, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(msg, <span class="string">"msg"</span>);</span><br><span class="line">   ...</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound(flush ?</span><br><span class="line">            (MASK_WRITE | MASK_FLUSH) : MASK_WRITE);</span><br><span class="line">    <span class="keyword">final</span> Object m = pipeline.touch(msg, next);</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">            next.invokeWriteAndFlush(m, promise);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.invokeWrite(m, promise); <span class="comment">// 执行这里</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> WriteTask task = WriteTask.newInstance(next, m, promise, flush);</span><br><span class="line">        <span class="keyword">if</span> (!safeExecute(executor, task, promise, m, !flush)) &#123;</span><br><span class="line">            task.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 寻找下一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextOutbound</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</span><br><span class="line">    EventExecutor currentExecutor = executor();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      ctx = ctx.prev;<span class="comment">// 往前找</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (skipContext(ctx, currentExecutor, mask, MASK_ONLY_OUTBOUND));</span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeWrite</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">        invokeWrite0(msg, promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        write(msg, promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行handler逻辑的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeWrite0</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ((ChannelOutboundHandler) handler()).write(<span class="keyword">this</span>, msg, promise);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        notifyOutboundHandlerException(t, promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在handler的write方法中最后，都会调用一下<code>ctx.write()</code>将时间传播上去</p><p>inBound事件传播是从head节点开始，到tail节点结束。tail节点，作为InBoundHandler实现了所有的inBound事件处理方法，而实现的逻辑是空的，即不作任何处理，以结束inBound事件的传播。</p><p>OutBound事件传播是从tail节点开始，到head节点结束，head节点作为OutBoundHandler，实现了所有的outBound事件处理方法，将所有的outBoud事件委托给unsafe执行相应的底层逻辑。</p><p>整理一下思路：对于in 和 out 应该站在pipeLine的角度去理解，比如新连接channel注册成功之后，会调用<code>pipeline().fireChannelActive()</code>，向pipeline中传入事件，这种就是in事件；而writeAndFlush操作，需要跳出pipeline调用unSafe来向channel中写数据，因此是一个out事件。</p><p>至此，还有一点需要分析，那就是异常的传播。</p><h4 id="异常传播"><a href="#异常传播" class="headerlink" title="异常传播"></a>异常传播</h4><p>我们通常在业务代码中，会加入一个异常处理器，统一处理pipeline过程中的所有的异常，并且，一般该异常处理器需要加载自定义节点的最末尾</p><p>此类ExceptionHandler一般继承自 <code>ChannelDuplexHandler</code>，标识该节点既是一个inBound节点又是一个outBound节点，我们分别分析一下inBound事件和outBound事件过程中，ExceptionHandler是如何才处理这些异常的</p><p><strong>inBound异常</strong></p><p>我们以数据的读取为例，看下netty是如何传播在这个过程中发生的异常</p><p>我们前面已经知道，对于每一个节点的数据读取都会调用<code>AbstractChannelHandlerContext.invokeChannelRead()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractChannelHandlerContext</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ((ChannelInboundHandler) handler()).channelRead(<span class="keyword">this</span>, msg);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        notifyHandlerException(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到该节点最终委托到其内部的ChannelHandler处理channelRead，而在最外层catch整个Throwable，因此，我们在如下用户代码中的异常会被捕获</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object data)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(...); </span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段业务代码中的 <code>BusinessException</code> 会被 <code>BusinessHandler</code>所在的节点捕获，进入到 <code>notifyHandlerException(t);</code>往下传播，我们看下它是如何传播的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractChannelHandlerContext</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyHandlerException</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 略去了非关键代码，读者可自行分析</span></span><br><span class="line">    invokeExceptionCaught(cause);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeExceptionCaught</span><span class="params">(<span class="keyword">final</span> Throwable cause)</span> </span>&#123;</span><br><span class="line">    handler().exceptionCaught(<span class="keyword">this</span>, cause);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，此Hander中异常优先由此Handelr中的<code>exceptionCaught</code>方法来处理，默认情况下，如果不覆写此Handler中的<code>exceptionCaught</code>方法，调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ChannelInboundHandlerAdapter</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ctx.fireExceptionCaught(cause);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractChannelHandlerContext</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">fireExceptionCaught</span><span class="params">(<span class="keyword">final</span> Throwable cause)</span> </span>&#123;</span><br><span class="line">    invokeExceptionCaught(next, cause);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了这里，已经很清楚了，如果我们在自定义Handler中没有处理异常，那么默认情况下该异常将一直传递下去，遍历每一个节点，直到最后一个自定义异常处理器ExceptionHandler来终结，收编异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Exceptionhandler extends ChannelDuplexHandler &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 处理该异常，并终止异常的传播</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了这里，你应该知道为什么异常处理器要加在pipeline的最后了吧？</p><p><strong>outBound异常</strong></p><p>然而对于outBound事件传播过程中所发生的异常，该<code>Exceptionhandler</code>照样能完美处理，为什么？</p><p>我们以前面提到的<code>writeAndFlush</code>方法为例，来看看outBound事件传播过程中的异常最后是如何落到<code>Exceptionhandler</code>中去的</p><p>前面我们知道，<code>channel.writeAndFlush()</code>方法最终也会调用到节点的 <code>invokeFlush0()</code>方法（write机制比较复杂，我们留到后面的文章中将）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractChannelHandlerContext</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeWriteAndFlush</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">        invokeWrite0(msg, promise);</span><br><span class="line">        invokeFlush0();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        writeAndFlush(msg, promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeFlush0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ((ChannelOutboundHandler) handler()).flush(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        notifyHandlerException(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>invokeFlush0()</code>会委托其内部的ChannelHandler的flush方法，我们一般实现的即是ChannelHandler的flush方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeFlush0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ((ChannelOutboundHandler) handler()).flush(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        notifyHandlerException(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好，假设在当前节点在flush的过程中发生了异常，都会被 <code>notifyHandlerException(t);</code>捕获，该方法会和inBound事件传播过程中的异常传播方法一样，也是轮流找下一个异常处理器，而如果异常处理器在pipeline最后面的话，一定会被执行到，这就是为什么该异常处理器也能处理outBound异常的原因</p><p>关于为啥 <code>ExceptionHandler</code> 既能处理inBound，又能处理outBound类型的异常的原因，总结一点就是，在任何节点中发生的异常都会往下一个节点传递，最后终究会传递到异常处理器</p><h4 id="Handler热插拔"><a href="#Handler热插拔" class="headerlink" title="Handler热插拔"></a>Handler热插拔</h4><p>netty 还有个最大的特性之一就是Handler可插拔，可以做到动态编织pipeline，比如在首次建立连接的时候，需要通过进行权限认证，在认证通过之后，就可以将此context移除，下次pipeline在传播事件的时候就就不会调用到权限认证处理器。</p><p>新连接接入时，ServerBootstrapAcceptor 会给新的NioSocketChannel 添加一个InBoundHandler叫ChannelInitialzer，添加成功之后会触发handlerAdded方法，该方法会调用重载的initialChannel方法初始化新连接的pipeline，结束后会调用pipeline.remove 删除此handler，这里也是热插拔的体现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Channel创建的时候会创建一个PipeLine，并且PipeLine也持有Channel对象的引用，二者是互相引用的关系。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp
      
    
    </summary>
    
      <category term="I/O和网络编程" scheme="http://yoursite.com/child/categories/I-O%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="netty" scheme="http://yoursite.com/child/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>mysql-innodb的索引</title>
    <link href="http://yoursite.com/child/2019/11/20/mysql-innodb%E7%9A%84%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/child/2019/11/20/mysql-innodb的索引/</id>
    <published>2019-11-19T16:00:00.000Z</published>
    <updated>2020-05-22T11:52:48.108Z</updated>
    
    <content type="html"><![CDATA[<p>数据库索引是数据库管理系统中一个排序的<strong>数据结构</strong>，以协助快速查询更新数据库表中数据</p><p>索引类型：normal普通索引、unique唯一索引、全文索引</p><h4 id="索引用什么数据结构？"><a href="#索引用什么数据结构？" class="headerlink" title="索引用什么数据结构？"></a>索引用什么数据结构？</h4><p>有序列表？不行，插入有问题</p><p>单链表？不行，查找有问题</p><p>AVL树？平衡开销大，数据量大导致树太高，查询效率低下，单页存储数据量小</p><p>B树 不支持范围查询，查询效率不稳定</p><p>B+树  最牛逼</p><h4 id="何为B-树？"><a href="#何为B-树？" class="headerlink" title="何为B+树？"></a>何为B+树？</h4><p>度（分叉数）为m的B+树每个节点能存储的记录数为m-1</p><p>所有的行数据都存在叶子结点，中间节点都是索引值，用来排序。</p><p>innodb的页默认大小为16KB，B+树的索引节点即为一页</p><p>那么一棵高度为2的B+数至少能存多少数据？</p><p>假设主键为自增的bigint类型，占8字节，B+树指针为6字节，一页能存放的索引数量是16KB/14B=1170</p><p>即至少有1170页即18MB存放行数据。而实际上这个这个值应该比计算出来的要大，原因是理论上一个叶节点中可能存放的记录数应该是1-1170行，但是1170是按照<u>主键大小+指针大小</u>计算出来的值，真正的行数据肯定还会有其他的字段，因此叶节点不能存放1170行数据是肯定的，那么多出来的行数据就会使用新的页进行存储并通过指针进行连接，这部分页并没有直接与B+树的中间节点连接，所以也无法进行精确计算。</p><p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">数据结构可视化网站</a></p><h4 id="主键索引有三种情形"><a href="#主键索引有三种情形" class="headerlink" title="主键索引有三种情形"></a>主键索引有三种情形</h4><p>有primaryKey –使用主键组织数据存储</p><p>没有主键，存在unique字段– 使用该unique字段组织数据存储</p><p>没有主键，没有unique字段–使用隐藏字段_rowid组织数据</p><h4 id="使用索引的注意点"><a href="#使用索引的注意点" class="headerlink" title="使用索引的注意点"></a>使用索引的注意点</h4><p>回表查询：命中辅助索引后，根据辅助索引查询到的主键，再去主键索引中查询数据，称为回表</p><p>覆盖索引：组成联合索引的字段包含了所需查询的字段，查询到辅助索引页即可得到结果，无需回表查询</p><ol><li><p>为什么不建议使用Select * ？</p><p>阻止了覆盖索引生效，导致回表查询，使用指定列的sql能节省数据库内存占用，提高数据传输效率</p></li><li><p>索引的最左匹配原则是什么意思？</p><p>有联合索引 index(A,B,C)</p><p>查询时，使用A、A&amp;B 、A&amp;B&amp;C 查询都能命中该索引，且与字段顺序无关，即B&amp;A也能命中</p><p>A&amp;C  B&amp;C  B&amp;C  B  C  都不符合最左匹配原则，不能命中</p></li><li><p>模糊匹配可以用到索引吗？</p><p>like %abc 不能命中索引，like abc%可以命中</p><p>因此我们得出结论：前导模糊匹配不能命中索引</p></li><li><p>负向查询 !=  not in &lt;&gt; 能不能用到索引？</p><p>能不能用到索引是优化器决定的，优化器基于开销判断，一般不推荐使用负向查询</p></li><li><p>为什么推荐递增字段做主键索引？</p><p>InnoDB的索引底层是B+树，且通过主键索引来组织数据存储。如果使用自增主键，那么每次插入新的记录，就会顺序添加到当前索引节点的后续位置（右边），当写满一页就会开辟新页，这样就会形成一个近似顺序填满的紧凑结构，插入过程无需移动已有数据。</p><p>而如果使用uuid或者身份证号这种不规则的数据作为主键索引，那么插入数据时，相当于随机插入，导致已有数据频繁移动，磁盘io开销变大，且可能产生大量的叶碎片</p></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>使用索引应注意以下几点：</p><ul><li>负向查询不能命中索引</li><li>前导模糊查询不能命中索引</li><li>数据区分度不大不宜建立索引</li><li>在属性上进行计算不能命中索引</li></ul><p>并非周知的sql实践：</p><ul><li>业务存在大量单条查询，实用hash索引效率高</li><li>允许为null的字段有大坑，单列索引不存null值，复合索引不存全为null的值，设置为not null 或者设置默认值</li><li>固定范围取值的字段使用枚举类型而不是字符串</li></ul><p>小众实用的规则：</p><ul><li>明确返回结果数量，实用limit能提升查询效率</li><li>把计算放到业务层而不是数据库层</li><li>强制类型转换会扫描全表</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数据库索引是数据库管理系统中一个排序的&lt;strong&gt;数据结构&lt;/strong&gt;，以协助快速查询更新数据库表中数据&lt;/p&gt;
&lt;p&gt;索引类型：normal普通索引、unique唯一索引、全文索引&lt;/p&gt;
&lt;h4 id=&quot;索引用什么数据结构？&quot;&gt;&lt;a href=&quot;#索引用什么数
      
    
    </summary>
    
      <category term="数据库技术" scheme="http://yoursite.com/child/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/child/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>netty源码分析之新连接接入</title>
    <link href="http://yoursite.com/child/2019/11/18/nio-netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%96%B0%E8%BF%9E%E6%8E%A5%E6%8E%A5%E5%85%A5/"/>
    <id>http://yoursite.com/child/2019/11/18/nio-netty源码分析之新连接接入/</id>
    <published>2019-11-17T16:00:00.000Z</published>
    <updated>2020-05-22T12:09:10.899Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道服务端启动后，会有一条boss线程在运行着，负责接受客户端的新连接。boss线程具体运行的逻辑在NioEventLoop的<code>run()</code>方法中，这里不做具体体分析，只截取本文关心的代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NioEventLoop</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  strategy = select(curDeadlineNanos);</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">if</span> (strategy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        processSelectedKeys();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>典型的jdk nio 的代码逻辑，先select，再处理selectedKey，跟进处理代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NioEventLoop</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (selectedKeys != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 优化过的处理 一般会进这里</span></span><br><span class="line">        processSelectedKeysOptimized();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 正常处理</span></span><br><span class="line">        processSelectedKeysPlain(selector.selectedKeys());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeysOptimized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; selectedKeys.size; ++i) &#123;</span><br><span class="line">        <span class="keyword">final</span> SelectionKey k = selectedKeys.keys[i];</span><br><span class="line">        selectedKeys.keys[i] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> Object a = k.attachment();</span><br><span class="line">      <span class="comment">// 从selectedKey中取出的附件是NioSocketChannel对象</span></span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) &#123;</span><br><span class="line">          <span class="comment">// 继续跟进</span></span><br><span class="line">            processSelectedKey(k, (AbstractNioChannel) a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;</span><br><span class="line">            processSelectedKey(k, task);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (needsToSelectAgain) &#123;</span><br><span class="line">            selectedKeys.reset(i + <span class="number">1</span>);</span><br><span class="line">            selectAgain();</span><br><span class="line">            i = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//注意：所有通道注册的时候都没有第一时间指定监听事件，而ops==0 时，这里默认是监听读就绪事件</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">          unsafe.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException ignored) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到最终调用了<code>unsafe.read()</code>方法，注意这里处理的是 NioServerSocketChannel 上的读。</p><p>这里我们要清楚，netty能读到的数据分为两种类型，对于NioServerSocketChannel来说，它只负责接收新连接，所以读到的是建立连接的请求，netty将这类数据称为 message 。对于已经接入的客户端连接，读到的是业务请求，netty将这类数据成为 byte。</p><p>由于这里处理的是新连接接入，<code>read()</code>方法将进入 <em>AbstractNioMessageChannel.NioMessageUnsafe</em> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NioMessageUnsafe</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">eventLoop</span><span class="params">()</span>.<span class="title">inEventLoop</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">        <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line">        <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();</span><br><span class="line">        allocHandle.reset(config);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line">        Throwable exception = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">// 不断的读取消息，可以猜到读取的是一个个NioSocketChannel对象</span></span><br><span class="line">                    <span class="keyword">int</span> localRead = doReadMessages(readBuf);</span><br><span class="line">                    ...</span><br><span class="line">                &#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">int</span> size = readBuf.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">                readPending = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 这里向NioServerSocketChannel 的pipeline中传进ChannelRead事件,参数是读取到的NioSocketChannel</span></span><br><span class="line">                pipeline.fireChannelRead(readBuf.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            readBuf.clear();</span><br><span class="line">            allocHandle.readComplete();</span><br><span class="line">            pipeline.fireChannelReadComplete();</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;        </span><br><span class="line">            <span class="keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">                removeReadOp();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点在<code>doReadMessages()</code> 方法，该方法将调用到底层的jdk的<code>accept()</code>得到的 SocketChannel ，并将其包装成netty的 NioSocketChannel  并add 到 buf 中，上层的<code>read()</code>方法可以直接访问 buf。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NioServerSocketChannel</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadMessages</span><span class="params">(List&lt;Object&gt; buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// accept得到SocketChannel对象</span></span><br><span class="line">    SocketChannel ch = SocketUtils.accept(javaChannel());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 根据SocketChannel对象 创建NioSocketChannel</span></span><br><span class="line">            buf.add(<span class="keyword">new</span> NioSocketChannel(<span class="keyword">this</span>, ch));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>doReadMessages()</code> 调用完之后，我们再回到<code>read()</code>方法，可以看到<strong>将读取到每个 NioSocketChannel 作为参数</strong>调用了 NioServerSocketChannel 的 <code>pipeline.channalRead(buf.get(i))</code> 方法，这个调用会产生什么反应呢？</p><p>原来服务器端启动时，初始化 NioServerSocketChannel  阶段向 PipeLine 中 添加了一个 ServerBootstrapAcceptor ，后文称接收器，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ServerBootstrap</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    ChannelPipeline p = channel.pipeline(); <span class="comment">// 这里是NioServerSocketChannel的pipeline</span></span><br><span class="line">    p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> </span>&#123;</span><br><span class="line">          ...</span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化结束后， NioServerSocketChannel 的 pipeline 有以下几个节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head--&gt;ServerBootstrapAcceptor--&gt;tail</span><br></pre></td></tr></table></figure><p>再看这个接收器ServerBootstrapAcceptor，它是 NioServerSocketChannel 的一个 InBound 事件处理器，<code>read()</code>方法调用<code>pipeline.channalRead(buf.get(i))</code>时，会首先进入head执行channelRead 方法，head只是简单的向下传播此事件，然后进入 ServerBootstrapAcceptor 的 channelRead 方法，我们来看具体做了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ServerBootstrapAcceptor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Channel child = (Channel) msg;</span><br><span class="line">            <span class="comment">//1、向NioSocketChannel的PipeLine中 add ChannelInitializer</span></span><br><span class="line">            child.pipeline().addLast(childHandler);</span><br><span class="line">  <span class="comment">//2. 设置options和attrs</span></span><br><span class="line">            setChannelOptions(child, childOptions, logger);</span><br><span class="line">            setAttributes(child, childAttrs);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//3. 异步执行通道注册，监听事件尚未指定，未指定默认监听读就绪</span></span><br><span class="line">                childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                            forceClose(child, future.cause());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                forceClose(child, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>原来是对读取到的 NioSocketChannel 执行了初始化，该方法主要对 NioSocketChannel 做了三件事：</p><ol><li>添加用户代码中指定的 InBound 事件处理器 ChannelInitializer 用于初始化NioSocketChannel，该handle主要是向NioSocketChannel 中 add 一系列事件处理器 ，执行完成之后将会被<code>remove</code>掉。</li><li>设置用户代码中指定的 NioSocketChannel 的 options 和 attrs</li><li>使用 childGroup 线程池执行 NioSocketChannel 注册任务</li></ol><p>childGroup 会使用 chooser 选择分配一条线程（EventLoop）给 NioSocketChannel，之后所有该channel的任务都将由这条线程执行。</p><p>注册过程与NioServerSocketChannel的注册流程一致，最终会调用到 <em>AbstractChannel.AbstractUnsafe</em> 类的 <code>register0 ()</code>方法进行注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line">        <span class="comment">//1. 执行注册</span></span><br><span class="line">            doRegister(); </span><br><span class="line">            neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">            registered = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//2.传入事件handlerAdded</span></span><br><span class="line">            pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line">            safeSetSuccess(promise);</span><br><span class="line">        <span class="comment">//3.传入事件channelRegistered</span></span><br><span class="line">            pipeline.fireChannelRegistered();</span><br><span class="line">            <span class="comment">//4.注册成功则传入事件channelActice</span></span><br><span class="line">            <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                  pipeline.fireChannelActive();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                  beginRead();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            ...</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用jdk底层注册channel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">    selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，注册时并没有设置感兴趣的事件，第二个参数为0，第三个参数则是将netty封装后的NioSocketChannel 当做附件，放到了selectionKey中，之后select出的selectionKey中都将带有netty的channel对象，这种设计实现了netty channel 与 jdk channel 的映射。</p><p>继续往下看，注册完之后，会调用一系列的pipeline方法，handlerAdded、channelRegistered、channelActive，这里我们要明白，从 unsafe 中调用 pipeline 的方法，<strong>调用进入 pipeline传入的事件我们称之为 inbound 事件</strong>。</p><p>其中 channelActive 为流程中的重要一环，pipeLine调用后首先会调用head节点的channelActive方法，我们看一下head的channelActive源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HeadCotext</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 向下传递事件</span></span><br><span class="line">    ctx.fireChannelActive();</span><br><span class="line">    <span class="comment">// 如果设置为自动读，autoRead 默认为true，则调用channel的read方法</span></span><br><span class="line">    readIfIsAutoRead();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readIfIsAutoRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (channel.config().isAutoRead()) &#123;</span><br><span class="line">      channel.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>往下看调用链：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractChannel</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Channel <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pipeline.read();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再跟进</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultChannelPipeline</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tail.read();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用到了tail的read方法, tail 的 read 方法是继承自父类 AbstractChannelHandlerContext：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractChannelHandlerContext</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// read方法 将从tail开始往前检索，找到实现了read方法的OutBoundHandler，将找到head节点</span></span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound(MASK_READ);</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeRead();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Tasks tasks = next.invokeTasks;</span><br><span class="line">        <span class="keyword">if</span> (tasks == <span class="keyword">null</span>) &#123;</span><br><span class="line">            next.invokeTasks = tasks = <span class="keyword">new</span> Tasks(next);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.execute(tasks.invokeReadTask);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑也很清晰，从 tail 开始，向前调用重载了read方法的OutboundHandler，直到head节点，看一下head节点的 <code>read()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">unsafe.beginRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用到了 unsafe 的 beginRead方法，这里我们需要明白<strong>从 pipeline 中不断调用最终到达unsafe 的调用链，称为OutBound 事件传播，调用出pipeline</strong>，所以 read 是一个outbound事件。</p><p>继续跟源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">beginRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    doBeginRead();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractNioChannel</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SelectionKey selectionKey = <span class="keyword">this</span>.selectionKey;</span><br><span class="line">        <span class="keyword">if</span> (!selectionKey.isValid()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        readPending = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> interestOps = selectionKey.interestOps();</span><br><span class="line">        <span class="comment">// interestOps &amp; OP_READ 若果没有监听读就绪事件 do it</span></span><br><span class="line">        <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;</span><br><span class="line">            selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>重点是最后一行，设置监听事件为读就绪。</p><p>一个连接从接入，到注册，到设置监听读就绪，之后，客户端与服务器便能正常的通信了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们知道服务端启动后，会有一条boss线程在运行着，负责接受客户端的新连接。boss线程具体运行的逻辑在NioEventLoop的&lt;code&gt;run()&lt;/code&gt;方法中，这里不做具体体分析，只截取本文关心的代码片段：&lt;/p&gt;
&lt;figure class=&quot;highlig
      
    
    </summary>
    
      <category term="I/O和网络编程" scheme="http://yoursite.com/child/categories/I-O%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="netty" scheme="http://yoursite.com/child/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>netty源码分析之服务端启动</title>
    <link href="http://yoursite.com/child/2019/11/15/nio-netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8/"/>
    <id>http://yoursite.com/child/2019/11/15/nio-netty源码分析之服务端启动/</id>
    <published>2019-11-14T16:00:00.000Z</published>
    <updated>2020-06-08T03:19:57.812Z</updated>
    
    <content type="html"><![CDATA[<p>首先贴一段简单的服务器启动代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  NioEventLoopGroup parent = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>); </span><br><span class="line">  NioEventLoopGroup children = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">  ServerBootstrap bs = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">  bs.group(parent,children)</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> ServerHandler())</span><br><span class="line">    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;()&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">          ch.pipeline().addLast(<span class="keyword">new</span> Spliter());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  bs.bind(<span class="number">8080</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码逻辑：</p><p>1、创建了一个线程池 parent，其中只有一个线程，主要负责接受新连接</p><p>2、创建另一个线程池 children，线程个数为默认值，核心数的2倍，主要负责处理客户端channel上的各种事件</p><p>3、创建服务器启动引导对象，将两个线程池通过 group 方法设置进去</p><p>4、使用 channel 方法指定服务器使用的i/o模型为nio</p><p>5、使用 handler 方法给服务器的 NioServerSocketChannel 的pipeline添加节点。</p><p>6、使用childHandler 方法指定新连接接入过程中客户端 NioSocketChannel 初始化方法，主要给这些channe l的 PipeLine 添加节点</p><p>7、通过 bind(8080) 方法启动服务绑定到8080端口</p><blockquote><p>对于Reactor线程模型一直有一点疑惑，worker线程池的工作方式是一条channel分配一条线程执行所有的业务逻辑，但是boss线程池面对是仅有一条的NioServerSocketChannel，为什么还需要线程池来处理呢？</p><p>实际上bossGroup中有多个NioEventLoop线程，每个NioEventLoop绑定一个端口，也就是说，如果程序只需要监听1个端口的话，bossGroup里面只需要有一个NioEventLoop线程就行了。</p></blockquote><p>本文的主要讲述的是服务端的启动流程，所以以bind方法为入口，源码节选关键代码块。</p><p>bind方法定义在 ServerBootstrap 类的父类 AbstractBootstrap中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractBootstrap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> doBind(localAddress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 核心 初始化通道 注册通道</span></span><br><span class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">        ChannelPromise promise = channel.newPromise();</span><br><span class="line">        <span class="comment">// 核心 绑定监听端口</span></span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>doBind</code>方法中主要有两个核心方法 <code>initAndRegister()</code>和<code>doBind0()</code>，前者主要负责创建、初始化、注册NioServerSocketChannel，后者负责将创建的通绑定到指定端口并启动服务。</p><p>下面我们逐一来分析，首先是<code>initAndRegister()</code>，看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建</span></span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑清晰，先创建，再初始化，再注册。</p><p><strong>创建</strong>：见文章开头服务器启动代码，调用ServerBootstrap的<code>channel()</code>方法设置io模式的时候：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractBootstrap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> channelFactory(<span class="keyword">new</span> ReflectiveChannelFactory&lt;C&gt;(</span><br><span class="line">            ObjectUtil.checkNotNull(channelClass, <span class="string">"channelClass"</span>)</span><br><span class="line">    ));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channelFactory</span><span class="params">(ChannelFactory&lt;? extends C&gt; channelFactory)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">this</span>.channelFactory = channelFactory;</span><br><span class="line">    <span class="keyword">return</span> self();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已经指定了 channelFactory 为 ReflectiveChannelFactory , 所以创建语句<code>channelFactory.newChannel()</code>会调用到ReflectiveChannelFactory的<code>newChannel()</code>方法，源码就不贴了，就是反射调用指定类型的默认构造函数创建一个Channel对象，io模型为NIO时，创建的是NioServerSocketChannel对象。</p><p><strong>初始化</strong>： <code>init(channel)</code>调用到ServerBootstrap的init</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ServerBootstrap</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置options</span></span><br><span class="line">    setChannelOptions(channel, newOptionsArray(), logger);</span><br><span class="line">    <span class="comment">// 设置 attrs</span></span><br><span class="line">    setAttributes(channel, attrs0().entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY));</span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line">    <span class="comment">// 设置新接入channel的options和attrs</span></span><br><span class="line">    <span class="keyword">final</span> EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line">    <span class="keyword">final</span> ChannelHandler currentChildHandler = childHandler;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class="line">    <span class="keyword">synchronized</span> (childOptions) &#123;</span><br><span class="line">        currentChildOptions = childOptions.entrySet().toArray(EMPTY_OPTION_ARRAY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs = childAttrs.entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY);</span><br><span class="line">    <span class="comment">// 向NioServerSocketChannel中添加用户自定义Handler，最后添加用于处理新连接的ServerBootstrapAcceptor</span></span><br><span class="line">    p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            ChannelHandler handler = config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向serverChannel的流水线处理器中加入了一个 ServerBootstrapAcceptor，</span></span><br><span class="line">            <span class="comment">// 从名字上就可以看出来，这是一个接入器，专门接受新请求</span></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注册</strong>：<code>config().group().register(channel)</code>经过一系列调用，最终进入最终会调用到 <em>AbstractChannel.AbstractUnsafe</em> 类的 <code>register0 ()</code>方法进行注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractChannel.AbstractUnsafe</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line">        <span class="comment">//1. 执行注册</span></span><br><span class="line">            doRegister(); </span><br><span class="line">            neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">            registered = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//2.传入事件handlerAdded</span></span><br><span class="line">            pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line">            safeSetSuccess(promise);</span><br><span class="line">        <span class="comment">//3.传入事件channelRegistered</span></span><br><span class="line">            pipeline.fireChannelRegistered();</span><br><span class="line">            <span class="comment">//4.注册成功判断是否激活，是则传入事件channelActice</span></span><br><span class="line">            <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                  pipeline.fireChannelActive();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                  beginRead();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            ...</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用jdk底层注册channel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractChannel.AbstractUnsafe</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">    selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，注册时并没有设置感兴趣的事件，第二个参数为0，第三个参数则是将netty封装后的NioSocketChannel 当做附件，放到了selectionKey中，之后select出的selectionKey中都将带有netty的channel对象，这种设计实现了netty channel 与 jdk channel 的映射。</p><p>注册完成之后会会进行一次判断<code>isActive()</code>，对于NioServerSocketChannel来说，到这里并没有激活，因为NioServerSocketChannel 的激活条件是<code>isOpen() &amp;&amp; javaChannel().socket().isBound()</code>，channel需要open且已绑定端口，目前只完成了注册还未进行绑定，所以这里不能触发<code>channelActive</code>事件。</p><p>而对于NioSocketChannel来说，判断条件是<code>ch.isOpen() &amp;&amp; ch.isConnected()</code>，open并已连接，所以NioSocketChannel 一般是在此处触发<code>channelActive</code>事件。</p><p><code>initAndRegister()</code>执行完，来到了<code>dBind0()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractBootstrap</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doBind0</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    channel.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (regFuture.isSuccess()) &#123;</span><br><span class="line">                channel.bind(localAddress, promise)</span><br><span class="line">                  .addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                promise.setFailure(regFuture.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唯一的逻辑就是提交了一个异步任务，调用<code>channel.bind()</code>方法。</p><p>对于channel来说bind是一个outBound事件，<code>channel.bind()</code>会继续调用<code>pipeline.bind()</code>，继续往下掉用<code>tail.bind()</code>，然后就是一个节点一个节点往前传，最终调用到head节点的<code>bind</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    unsafe.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到unsafe我就开心，因为马上要干活了，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractChannel.AbstractUnsafe</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ...<span class="comment">//略过一大堆判断</span></span><br><span class="line">    <span class="comment">// 连接是否激活 绑定之前时false</span></span><br><span class="line">    <span class="keyword">boolean</span> wasActive = isActive();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 关键点</span></span><br><span class="line">        doBind(localAddress);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;&#125;</span><br><span class="line">    <span class="comment">// 之前未激活 现在已激活</span></span><br><span class="line">    <span class="keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;</span><br><span class="line">        <span class="comment">//触发连接激活事件</span></span><br><span class="line">        invokeLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    safeSetSuccess(promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终<code>unsafe.doBind()</code>调用到了NioServerSocketChannel中的<code>doBind()</code>，兜了一个大圈还是回到了原点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NioServerSocketChannel</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里调用jdk nio的api 进行绑定</span></span><br><span class="line">        javaChannel().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是底层jdk的逻辑了，这里执行完成，serverSocket就算是真正的启动了起来。</p><p>再回到<code>unsafe.doBind()</code>，成功后触发<code>pipeline.fireChannelActive()</code>，我们现在都有经验了，这种inBound事件，调用一大圈最终都是从head节点开始执行，来看head的<code>channelActive()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HeadCotext</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 向下传递事件</span></span><br><span class="line">    ctx.fireChannelActive();</span><br><span class="line">    <span class="comment">// 如果设置为自动读，autoRead 默认为true，则调用channel的read方法</span></span><br><span class="line">    readIfIsAutoRead();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readIfIsAutoRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (channel.config().isAutoRead()) &#123;</span><br><span class="line">      channel.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>往下看调用链：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractChannel</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Channel <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pipeline.read();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再跟进</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultChannelPipeline</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tail.read();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用到了tail的read方法, tail 的 read 方法是继承自父类 AbstractChannelHandlerContext：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractChannelHandlerContext</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// read方法 将从tail开始往前检索，找到实现了read方法的OutBoundHandler，将找到head节点</span></span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound(MASK_READ);</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeRead();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑也很清晰，从 tail 开始，向前调用重载了read方法的OutboundHandler，直到head节点，看一下head节点的 <code>read()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">unsafe.beginRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用到了 unsafe 的 beginRead方法，这里我们需要明白<strong>从 pipeline 中不断调用最终到达unsafe 的调用链，称为OutBound 事件传播，调用出pipeline</strong>，所以 read 是一个outbound事件。</p><p>继续跟源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractChannel.AbstractUnsafe</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">beginRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    doBeginRead();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractNioChannel</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SelectionKey selectionKey = <span class="keyword">this</span>.selectionKey;</span><br><span class="line">        <span class="keyword">if</span> (!selectionKey.isValid()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        readPending = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> interestOps = selectionKey.interestOps();</span><br><span class="line">        <span class="comment">// 若果没有监听指定的事件 do it 这里readInterestOp = OP_ACCEPT</span></span><br><span class="line">        <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;</span><br><span class="line">            selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>重点是最后一行，设置监听事件为OP_ACCEPT。至此 NioServerSocketChannel 注册成功并监听OP_ACCEPT事件，客户端连接放马过来吧。</p><p>下一篇分析客户端新连接入流程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先贴一段简单的服务器启动代码&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2
      
    
    </summary>
    
      <category term="I/O和网络编程" scheme="http://yoursite.com/child/categories/I-O%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="netty" scheme="http://yoursite.com/child/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>netty源码分析之异步编程</title>
    <link href="http://yoursite.com/child/2019/11/08/nio-netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/child/2019/11/08/nio-netty源码分析之异步编程/</id>
    <published>2019-11-07T16:00:00.000Z</published>
    <updated>2020-05-22T11:50:24.572Z</updated>
    
    <content type="html"><![CDATA[<p>异步编程的目标是：提交一个任务给线程池，在任务执行期间，提交者可以执行其他的逻辑，当提交的任务执行完成，通知提交者来获取执行结果</p><p>jdk并发包中的异步编程是通过Future<v> 接口实现的：</v></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型V是任务执行结果的类型。</p><p>我们通过如下方式提交任务给线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool.submit(<span class="keyword">new</span> Callable&lt;String&gt;()-&gt;&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"zpd"</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>submit接收一个Callable类型的任务，但是我们知道，线程池一般都是通过execut方法来执行任务，且execute只接受Runnable类型的任务，Callable任务又是怎么执行的？</p><p>那我们来看一下submit方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractExecutorService</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到Callable又被封装成了FutureTask对象再执行，FutureTask实现了RunnableFuture接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来FutureTask就是Runnable和Future的合体，意味着Callable被封装成RunnableFuture之后，即可以直接丢给execut方法执行，又能使用Future接口的方法实现异步功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">    <span class="comment">// 执行过程</span></span><br><span class="line"><span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line">    <span class="comment">// 执行结果或者异常</span></span><br><span class="line">  <span class="keyword">private</span> Object outcome;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FutureTask类的两个关键对象，其中一个就是对提交的Callable对象的引用。</p><p>这里我整理一下：最终被线程池执行的对象是FutureTask，它本身是一个Runnable，且持有一个Callable对象，因此线程池执行它的时候，一定是执行它的run方法，而run方法内部肯定调用了Callable对象的call方法，因为提交的任务逻辑就是call方法。</p><p>submit方法对Runnable类型的任务也做了适配。看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractExecutorService</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在传入Runnable型任务的时候，由于其执行体没有返回值，因此还需要传入另一个参数来代表执行完成的返回结果，这样在将Runnable封装成FutureTask时，可以使用适配器将Runnable任务和 result 转换成一个Callable，再去构建  FutureTask对象</p><p>贴出两个newTaskFor方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractExecutorService</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我看到网上一些资料对比callable与runnable的区别：</p><p>1、callable 有返回值，runnable不支持返回值</p><p>2、callable 可以抛出异常，runnable则不支持</p><p>我认为这样对比的意义不大，因为这两个接口本来既不是一个层级的，Runnable是可以直接被线程执行的，而Callable需要通过再封装成Runnable，并在封装层的run方法调用中才能执行，call方法可以有返回值，可以抛异常也只是针对封装层的FutureTask对象而言，返回的结果给了FutureTask，异常也抛给了FutureTask，用户想要获取返回值或者异常，需要主动的写代码获取。</p><p>因此Future异步任务的执行过程，并不是真正的异步，最主要的问题是没有实现回调，只能称为同步非阻塞。所以在java8中又新增了一个真正的异步函数，CompletableFuture</p><p>Java 8 中新增加了一个类：CompletableFuture，它提供了非常强大的 Future 的扩展功能，最重要的是实现了回调的功能。</p><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Copypublic <span class="class"><span class="keyword">class</span> <span class="title">CallableFutureTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"start"</span>);</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 异步非阻塞</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                System.out.println(<span class="string">"sleep done"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"done"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CompletableFuture.runAsync()</code>方法提供了异步执行无返回值任务的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CopyExecutorService executorService = Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"result"</span>;</span><br><span class="line">&#125;, executorService);</span><br></pre></td></tr></table></figure><p><code>CompletableFuture.supplyAsync()</code>方法提供了异步执行有返回值任务的功能。</p><p>CompletableFuture源码中有四个静态方法用来执行异步任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Copypublic <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span>&#123;..&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier,Executor executor)</span></span>&#123;..&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable)</span></span>&#123;..&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable,</span></span></span><br><span class="line"><span class="function"><span class="params">Executor executor)</span></span>&#123;..&#125;</span><br></pre></td></tr></table></figure><p>前面两个可以看到是带返回值的方法，后面两个是不带返回值的方法。同时支持传入自定义的线程池，如果不传入线程池的话默认是使用 <code>ForkJoinPool.commonPool()</code>作为它的线程池执行异步代码。</p><p><strong>合并两个异步任务</strong></p><p>如果有两个任务需要异步执行，且后面需要对这两个任务的结果进行合并处理，CompletableFuture 也支持这种处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CopyExecutorService executorService = Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Task1"</span>;</span><br><span class="line">&#125;, executorService);</span><br><span class="line">CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Task2"</span>;</span><br><span class="line">&#125;, executorService);</span><br><span class="line">CompletableFuture&lt;String&gt; future = future1.thenCombineAsync(future2, (task1, task2) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> task1 + task2; <span class="comment">// return "Task1Task2" String</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过 <code>CompletableFuture.thenCombineAsync()</code>方法获取两个任务的结果然后进行相应的操作。</p><p><strong>下一个依赖上一个的结果</strong></p><p>如果第二个任务依赖第一个任务的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CopyExecutorService executorService = Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Task1"</span>;</span><br><span class="line">&#125;, executorService);</span><br><span class="line">CompletableFuture&lt;String&gt; future = future1.thenComposeAsync(task1 -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> task1 + <span class="string">"Task2"</span>; <span class="comment">// return "Task1Task2" String</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, executorService);</span><br></pre></td></tr></table></figure><p><code>CompletableFuture.thenComposeAsync()</code>支持将第一个任务的结果传入第二个任务中。</p><p><strong>常用 API 介绍</strong></p><ol><li>拿到上一个任务的结果做后续操作，上一个任务完成后的动作</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Copypublic CompletableFuture&lt;T&gt;     <span class="title">whenComplete</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> Throwable&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt;     <span class="title">whenCompleteAsync</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> Throwable&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt;     <span class="title">whenCompleteAsync</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> Throwable&gt; action, Executor executor)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt;     <span class="title">exceptionally</span><span class="params">(Function&lt;Throwable,? extends T&gt; fn)</span></span></span><br></pre></td></tr></table></figure><p>上面四个方法表示在当前阶段任务完成之后下一步要做什么。whenComplete 表示在当前线程内继续做下一步，带 Async 后缀的表示使用新线程去执行。</p><ol><li><p>拿到上一个任务的结果做后续操作，使用 handler 来处理逻辑，可以返回与第一阶段处理的返回类型不一样的返回类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copypublic &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt;  <span class="title">handle</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T,Throwable,? extends U&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt;  <span class="title">handleAsync</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T,Throwable,? extends U&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt;  <span class="title">handleAsync</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T,Throwable,? extends U&gt; fn, Executor executor)</span></span></span><br></pre></td></tr></table></figure><p>Handler 与 whenComplete 的区别是 handler 是可以返回一个新的 CompletableFuture 类型的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CopyCompletableFuture&lt;Integer&gt; f1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hahaha"</span>;</span><br><span class="line">&#125;).handle((r, e) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>拿到上一个任务的结果做后续操作， thenApply方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copypublic &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt;  <span class="title">thenApply</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt;  <span class="title">thenApplyAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt;  <span class="title">thenApplyAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn, Executor executor)</span></span></span><br></pre></td></tr></table></figure><p>注意到 thenApply 方法的参数中是没有 Throwable，这就意味着如有有异常就会立即失败，不能在处理逻辑内处理。且 thenApply 返回的也是新的 CompletableFuture。 这就是它与前面两个的区别。</p></li><li><p>拿到上一个任务的结果做后续操作，可以不返回任何值，thenAccept方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Copypublic CompletableFuture&lt;Void&gt;  <span class="title">thenAccept</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt;  <span class="title">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt;  <span class="title">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action, Executor executor)</span></span></span><br></pre></td></tr></table></figure><p>看这里的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CopyCompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"result"</span>;</span><br><span class="line">&#125;).thenAccept(r -&gt; &#123;</span><br><span class="line">  System.out.println(r);</span><br><span class="line">&#125;).thenAccept(r -&gt; &#123;</span><br><span class="line">  System.out.println(r);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>执行完毕是不会返回任何值的。</p></li></ol><p>CompletableFuture 的特性提现在执行完 runAsync 或者 supplyAsync 之后的操作上。CompletableFuture 能够将回调放到与任务不同的线程中执行，也能将回调作为继续执行的同步函数，在与任务相同的线程中执行。它避免了传统回调最大的问题，那就是能够将控制流分离到不同的事件处理器中。</p><p>另外当你依赖 CompletableFuture 的计算结果才能进行下一步的时候，无需手动判断当前计算是否完成，可以通过 CompletableFuture 的事件监听自动去完成。</p><p>netty 异步任务的实现Future/Promise异步模型</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;异步编程的目标是：提交一个任务给线程池，在任务执行期间，提交者可以执行其他的逻辑，当提交的任务执行完成，通知提交者来获取执行结果&lt;/p&gt;
&lt;p&gt;jdk并发包中的异步编程是通过Future&lt;v&gt; 接口实现的：&lt;/v&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight 
      
    
    </summary>
    
      <category term="I/O和网络编程" scheme="http://yoursite.com/child/categories/I-O%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="netty" scheme="http://yoursite.com/child/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>netty源码分析之线程模型</title>
    <link href="http://yoursite.com/child/2019/11/01/nio-netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/child/2019/11/01/nio-netty源码分析之线程模型/</id>
    <published>2019-10-31T16:00:00.000Z</published>
    <updated>2020-06-04T02:57:50.095Z</updated>
    
    <content type="html"><![CDATA[<p>一个NioEventLoop对应于Reactor模型中的一个从Reactor线程，它持有一个Thread引用，可以简单将NioEventLoop理解为一个用于处理channel事件的线程。</p><p>一个channel上的事件只能被同一个线程处理，NioEventLoop线程对channel事件的处理是一个串行化无锁执行过程，我们在初始化channel的时候在pipeline中添加了一系列的Handler（编解码、数据处理等），这些Handler的处理需要遵循一个固定的顺序，netty底层使用同一个线程按照这个顺序串行执行，避免了多个线程处理同一个channel需要使用锁同步产生的开销，这叫<strong>串行化无锁编程</strong></p><p>一个NioEventLoop可以处理多个channel的就绪事件，即同一个nio线程可以处理多条连接的请求，这叫<strong>多路复用</strong></p><h4 id="Channel指定evenloop"><a href="#Channel指定evenloop" class="headerlink" title="Channel指定evenloop"></a>Channel指定evenloop</h4><p>Channel的EventLoop是在注册的时候指定的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>group().register(channel)</code>在boss线程池中注册Channel，boss调用<code>next()</code>方法获取一个EventLoop对象来注册channel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SingleThreadEventLoop</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(promise, <span class="string">"promise"</span>);</span><br><span class="line">    promise.channel().unsafe().register(<span class="keyword">this</span>, promise);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终会调用channel的unsafe对象完成注册，并在此时将this EventLoop 作为参数传进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractChannel.AbstractUnsafe</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册的时候完成了eventLoop的指定。</p><h4 id="reactor线程启动"><a href="#reactor线程启动" class="headerlink" title="reactor线程启动"></a>reactor线程启动</h4><p>netty对于线程的创建采取的懒加载模式，第一次提交任务的时候才会创建线程。</p><p>NioServerSocketChannel 第一次提交任务，是在<strong>注册</strong>的时候</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractChannel.AbstractUnsafe</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop; <span class="comment">// 刚指定了channel的eventLoop</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123; <span class="comment">// 还是主线程在执行，返回false</span></span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">//来到这里提交注册任务</span></span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>eventLoop.execute()</code>可以向NioEventLoop中提交一个任务，这个方法继承自父类SingleThreadEventExecutor </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SingleThreadEventExecutor </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task, <span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断当前线程是不是this对象的线程</span></span><br><span class="line">    <span class="comment">// 还是主线程在执行，返回false</span></span><br><span class="line">    <span class="keyword">boolean</span> inEventLoop = inEventLoop();</span><br><span class="line">    <span class="comment">//将task加入EventLoop持有的任务队列</span></span><br><span class="line">    addTask(task);</span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop) &#123;</span><br><span class="line">      <span class="comment">//如果执行此代码的线程不是eventloop线程，创建新线程并启动</span></span><br><span class="line">      startThread();</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进<code>startThread()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SingleThreadEventExecutor </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (state == ST_NOT_STARTED) &#123;</span><br><span class="line">    <span class="keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;</span><br><span class="line">      <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        doStartThread();</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继续跟进     </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 创建新线程</span></span><br><span class="line">    executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 设置eventLoop持有线程为执行这段代码的线程</span></span><br><span class="line">            thread = Thread.currentThread();</span><br><span class="line">            ...</span><br><span class="line">            SingleThreadEventExecutor.<span class="keyword">this</span>.run();</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再调用了<code>doStartThread</code>方法，这个方法是启动线程的核心逻辑了，在执行<code>doStartThread</code>的时候，会调用eventLoop内部的一个用于<strong>新建线程的执行器</strong><code>execute()</code>方法，注意与上面的区别，此执行器默认为ThreadPerTaskExecutor类型，创建新线程后将NioEventLoop的主体逻辑<code>run()</code>提交进去，并启动。</p><p>ThreadPerTaskExecutor 在每次执行execute 方法的时候都会通过DefaultThreadFactory创建一个FastThreadLocalThread线程，而这个线程就是netty中的reactor线程实体，创建线程源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory threadFactory;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPerTaskExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = ObjectUtil.checkNotNull(threadFactory, <span class="string">"threadFactory"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        threadFactory.newThread(command).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下：</p><ol><li>我们在new一个NioEventLoopGroup的时候，它会持有一个NioEventLoop数组，每个NioEventLoop会持有一个Thread引用，就是reactor线程了。 </li><li>netty对于线程的初始化采取的懒加载模式，当我们没有用到某个NioEventLoop时，它的线程时没有创建的。</li><li>当我们通过<code>group().next()</code>获取到一个NioEventLoop，并向其提交任务，这时就会触发线程的创建-任务提交-启动。创建是通过 ThreadPerTaskExecutor 和 DefaultThreadFactory 两个类执行的，新线程执行的任务是 NioEventLoop 的主体逻辑run方法。</li></ol><h4 id="reactor线程执行"><a href="#reactor线程执行" class="headerlink" title="reactor线程执行"></a>reactor线程执行</h4><p>回到主线逻辑中，创建的线程中执行了<code>SingleThreadEventExecutor.this.run();</code>即reactor线程的主体逻辑，贴一下主要代码片段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ...</span><br><span class="line">        strategy = select(curDeadlineNanos);</span><br><span class="line">        ...</span><br><span class="line">        processSelectedKeys();</span><br><span class="line">        ...     </span><br><span class="line">        ranTasks = runAllTasks(<span class="number">0</span>); </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法内部是一个无限循环，一旦启动将一直运行。</p><p>从以上代码中可以看出，线程一直在循环做三件事情</p><ol><li>执行select</li><li>处理就绪的channel</li><li>执行任务队列中的任务</li></ol><p>下面我们分别分析以上三个步骤</p><h5 id="select阶段"><a href="#select阶段" class="headerlink" title="select阶段"></a>select阶段</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> selectCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> strategy;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());</span><br><span class="line">                <span class="keyword">switch</span> (strategy) &#123;</span><br><span class="line">                <span class="comment">// hasTask 时continue</span></span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 由于NIO不支持忙碌等待，因此要选择跳过</span></span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.BUSY_WAIT:</span><br><span class="line">                <span class="comment">// 当没有可调度任务时 strategy = SelectStrategy.SELECT</span></span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">                    <span class="comment">// 获取现在到下一个计划任务调度执行之间的时间，没有定时任务返回-1</span></span><br><span class="line">                    <span class="keyword">long</span> curDeadlineNanos = nextScheduledTaskDeadlineNanos();</span><br><span class="line">                    <span class="keyword">if</span> (curDeadlineNanos == -<span class="number">1L</span>) &#123;</span><br><span class="line">                        <span class="comment">//NONE 是Integer.maxValue</span></span><br><span class="line">                        curDeadlineNanos = NONE;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 设定原子量</span></span><br><span class="line">                    nextWakeupNanos.set(curDeadlineNanos);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!hasTasks()) &#123;</span><br><span class="line">                            strategy = select(curDeadlineNanos);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// fall through</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// select计数器+1</span></span><br><span class="line">            selectCnt++;</span><br><span class="line">            ...</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="处理阶段"><a href="#处理阶段" class="headerlink" title="处理阶段"></a>处理阶段</h5><h5 id="执行队列任务"><a href="#执行队列任务" class="headerlink" title="执行队列任务"></a>执行队列任务</h5><p>netty中的task的常见使用场景：</p><ul><li>用户自定义普通任务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ctx.channel().eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们跟进<code>execute</code>方法，看重点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    addTask(task);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>execute</code>方法调用 <code>addTask</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (!offerTask(task)) &#123;</span><br><span class="line">        reject(task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用<code>offerTask</code>方法，如果offer失败，那就调用<code>reject</code>方法，通过默认的 <code>RejectedExecutionHandler</code> 直接抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">offerTask</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> taskQueue.offer(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟到<code>offerTask</code>方法，基本上task就落地了，netty内部使用一个<code>taskQueue</code>将task保存起来，那么这个<code>taskQueue</code>又是何方神圣？</p><p>我们查看 <code>taskQueue</code> 定义的地方和被初始化的地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Runnable&gt; taskQueue;</span><br><span class="line"></span><br><span class="line">taskQueue = newTaskQueue(<span class="keyword">this</span>.maxPendingTasks);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Queue&lt;Runnable&gt; <span class="title">newTaskQueue</span><span class="params">(<span class="keyword">int</span> maxPendingTasks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(maxPendingTasks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现 <code>taskQueue</code>在NioEventLoop中默认是阻塞队列，老版本（4.1.6）中使用mpsc队列，即多生产者单消费者队列，netty使用mpsc，方便的将外部线程的task聚集，在reactor线程内部用单线程来串行执行，此处为什么要做此改变？</p><p>在本节讨论的任务场景中，所有代码的执行都是在reactor线程中的，所以，所有调用 <code>inEventLoop()</code> 的地方都返回true，既然都是在reactor线程中执行，那么其实这里的阻塞队列其实没有发挥真正的作用。</p><ul><li>非当前reactor线程调用channel的各种方法</li></ul><p>这种情况在push系统中比较常见，一般在业务线程里面，根据用户的标识，找到对应的channel引用，然后调用write类方法向该用户推送消息，就会进入到这种场景</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// non reactor thread</span></span><br><span class="line">channel.write(...)</span><br></pre></td></tr></table></figure><p>关于channel.write()类方法的调用链，后面会单独拉出一篇文章来深入剖析，这里，我们只需要知道，最终write方法串至以下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, <span class="keyword">boolean</span> flush, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">            next.invokeWriteAndFlush(m, promise);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.invokeWrite(m, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        AbstractWriteTask task;</span><br><span class="line">        <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">            task = WriteAndFlushTask.newInstance(next, m, promise);</span><br><span class="line">        &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">            task = WriteTask.newInstance(next, m, promise);</span><br><span class="line">        &#125;</span><br><span class="line">        safeExecute(executor, task, promise, m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>外部线程在调用<code>write</code>的时候，<code>executor.inEventLoop()</code>会返回false，直接进入到else分支，将write封装成一个<code>WriteTask</code>（这里仅仅是write而没有flush，因此<code>flush</code>参数为false）, 然后调用 <code>safeExecute</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">safeExecute</span><span class="params">(EventExecutor executor, Runnable runnable, ChannelPromise promise, Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    executor.execute(runnable);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来的调用链就进入到第一种场景了，但是和第一种场景有个明显的区别就是，第一种场景的调用链的发起线程是reactor线程，第二种场景的调用链的发起线程是用户线程，用户线程可能会有很多个，显然多个线程并发写<code>taskQueue</code>可能出现线程同步问题，此时阻塞队列的作用展现出来了。</p><ul><li>用户自定义定时任务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ctx.channel().eventLoop().schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">60</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>第三种场景就是定时任务逻辑了，用的最多的便是如上方法：在一定时间之后执行任务</p><p>我们跟进<code>schedule</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="keyword">long</span> delay, TimeUnit unit) &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> schedule(<span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(</span><br><span class="line">            <span class="keyword">this</span>, command, <span class="keyword">null</span>, ScheduledFutureTask.deadlineNanos(unit.toNanos(delay))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>ScheduledFutureTask</code>, 将用户自定义任务再次包装成一个netty内部的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(<span class="keyword">final</span> ScheduledFutureTask&lt;V&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    scheduledTaskQueue().add(task);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了这里，我们有点似曾相识，在非定时任务的处理中，netty通过一个阻塞队列将任务落地，这里，是否也有一个类似的队列来承载这类定时任务呢？带着这个疑问，我们继续向前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">Queue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue() &#123;</span><br><span class="line">    <span class="keyword">if</span> (scheduledTaskQueue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        scheduledTaskQueue = <span class="keyword">new</span> DefaultPriorityQueue&lt;ScheduledFutureTask&lt;?&gt;&gt;(</span><br><span class="line">                    SCHEDULED_FUTURE_TASK_COMPARATOR,</span><br><span class="line">                    <span class="comment">// Use same initial capacity as java.util.PriorityQueue</span></span><br><span class="line">                    <span class="number">11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> scheduledTaskQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>果不其然，<code>scheduledTaskQueue()</code> 方法，会返回一个优先级队列，然后调用 <code>add</code> 方法将定时任务加入到队列中去，但是，这里为什么要使用优先级队列，而不需要考虑多线程的并发？</p><p>因为我们现在讨论的场景，调用链的发起方是reactor线程，不会存在多线程并发这些问题</p><p>但是，万一有的用户在reactor之外执行定时任务呢？虽然这类场景很少见，但是netty作为一个无比健壮的高性能io框架，必须要考虑到这种情况。</p><p>对此，netty的处理是，如果是在外部线程调用schedule，netty将添加定时任务的逻辑封装成一个普通的task，这个task的任务是添加[添加定时任务]的任务，而不是添加定时任务，其实也就是第二种场景，这样，对 <code>PriorityQueue</code>的访问就变成单线程，即只有reactor线程</p><blockquote><p>完整的schedule方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(<span class="keyword">final</span> ScheduledFutureTask&lt;V&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inEventLoop()) &#123;</span><br><span class="line">        scheduledTaskQueue().add(task);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 进入到场景二，进一步封装任务</span></span><br><span class="line">        execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                scheduledTaskQueue().add(task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在阅读源码细节的过程中，我们应该多问几个为什么？这样会有利于看源码的时候不至于犯困！比如这里，为什么定时任务要保存在优先级队列中，我们可以先不看源码，来思考一下优先级对列的特性</p><p>优先级队列按一定的顺序来排列内部元素，内部元素必须是可以比较的，联系到这里每个元素都是定时任务，那就说明定时任务是可以比较的，那么到底有哪些地方可以比较？</p><p>每个任务都有一个下一次执行的截止时间，截止时间是可以比较的，截止时间相同的情况下，任务添加的顺序也是可以比较的，就像这样，阅读源码的过程中，一定要多和自己对话，多问几个为什么</p><p>带着猜想，我们研究与一下<code>ScheduledFutureTask</code>，抽取出关键部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledFutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">PromiseTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ScheduledFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextTaskId = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> START_TIME = System.nanoTime();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">nanoTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.nanoTime() - START_TIME;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = nextTaskId.getAndIncrement();</span><br><span class="line">    <span class="comment">/* 0 - no repeat, &gt;0 - repeat at fixed rate, &lt;0 - repeat with fixed delay */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> periodNanos;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 精简过的代码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里，我们一眼就找到了<code>compareTo</code> 方法，<code>cmd+u</code>跳转到实现的接口，发现就是<code>Comparable</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ScheduledFutureTask&lt;?&gt; that = (ScheduledFutureTask&lt;?&gt;) o;</span><br><span class="line">    <span class="keyword">long</span> d = deadlineNanos() - that.deadlineNanos();</span><br><span class="line">    <span class="keyword">if</span> (d &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id &lt; that.id) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == that.id) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入到方法体内部，我们发现，两个定时任务的比较，确实是先比较任务的截止时间，截止时间相同的情况下，再比较id，即任务添加的顺序，如果id再相同的话，就抛Error</p><p>这样，在执行定时任务的时候，就能保证最近截止时间的任务先执行</p><p>下面，我们再来看下netty是如何来保证各种定时任务的执行的，netty里面的定时任务分以下三种</p><p>1.若干时间后执行一次<br> 2.每隔一段时间执行一次<br> 3.每次执行结束，隔一定时间再执行一次</p><p>netty使用一个 <code>periodNanos</code> 来区分这三种情况，正如netty的注释那样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 0 - no repeat, &gt;0 - repeat at fixed rate, &lt;0 - repeat with fixed delay */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> periodNanos;</span><br></pre></td></tr></table></figure><p>了解这些背景之后，我们来看下netty是如何来处理这三种不同类型的定时任务的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (periodNanos == <span class="number">0</span>) &#123;</span><br><span class="line">        V result = task.call();</span><br><span class="line">        setSuccessInternal(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        task.call();</span><br><span class="line">        <span class="keyword">long</span> p = periodNanos;</span><br><span class="line">        <span class="keyword">if</span> (p &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            deadlineNanos += p;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            deadlineNanos = nanoTime() - p;</span><br><span class="line">        &#125;</span><br><span class="line">            scheduledTaskQueue.add(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>if (periodNanos == 0)</code> 对应 <code>若干时间后执行一次</code> 的定时任务类型，执行完了该任务就结束了。</p><p>否则，进入到else代码块，先执行任务，然后再区分是哪种类型的任务，<code>periodNanos</code>大于0，表示是以固定频率执行某个任务，和任务的持续时间无关，然后，设置该任务的下一次截止时间为本次的截止时间加上间隔时间<code>periodNanos</code>，否则，就是每次任务执行完毕之后，间隔多长时间之后再次执行，截止时间为当前时间加上间隔时间，<code>-p</code>就表示加上一个正的间隔时间，最后，将当前任务对象再次加入到队列，实现任务的定时执行</p><p>netty内部的任务添加机制了解地差不多之后，我们就可以查看reactor第三部曲是如何来调度这些任务的</p><p><a href="https://www.jianshu.com/p/0d0eece6d467" target="_blank" rel="noopener">https://www.jianshu.com/p/0d0eece6d467</a></p><p><a href="https://www.jianshu.com/p/467a9b41833e" target="_blank" rel="noopener">https://www.jianshu.com/p/467a9b41833e</a></p><p><a href="https://www.jianshu.com/p/58fad8e42379" target="_blank" rel="noopener">https://www.jianshu.com/p/58fad8e42379</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个NioEventLoop对应于Reactor模型中的一个从Reactor线程，它持有一个Thread引用，可以简单将NioEventLoop理解为一个用于处理channel事件的线程。&lt;/p&gt;
&lt;p&gt;一个channel上的事件只能被同一个线程处理，NioEventLoo
      
    
    </summary>
    
      <category term="I/O和网络编程" scheme="http://yoursite.com/child/categories/I-O%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="netty" scheme="http://yoursite.com/child/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>epoll高效运行的原理</title>
    <link href="http://yoursite.com/child/2019/10/26/nio-epoll%E9%AB%98%E6%95%88%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/child/2019/10/26/nio-epoll高效运行原理/</id>
    <published>2019-10-25T16:00:00.000Z</published>
    <updated>2020-06-08T03:05:50.661Z</updated>
    
    <content type="html"><![CDATA[<p>nio非阻塞牛逼在哪里？</p><p>要解答这个问题首先要清楚bio的痛点在哪里。</p><p>假如我们的服务使用bio模型，服务器启动之后需要一条线程一直监听端口上是否有连接请求发过来，如果没有请求，这条线程就一直等着；</p><p>等了好久好久终于来了一个请求连接，连接建立成功后，又要开始等业务请求，由于网络慢或者其他原因又等了一千年；</p><p>终于拿到了请求，电光火石间处理完拿到响应数据，准备响应出去，这时候发现由于不明原因，一千五百年之前的一条响应还没有发送出去，占据了内核缓冲区，这时候害得等，等前一条响应发出去才能将本次的响应写入缓冲区。。。沧海桑田</p><p>当然这里可以使用多线程优化，但是没有解决根本问题，那就是线程等太久的问题。</p><p>这时候nio模式横空出世，牛逼在不用等。nio在linux平台基于epoll实现的</p><p>接下来的疑问</p><p>1、epoll是基于事件的，那么有哪些事件，事件由谁来触发？</p><p>2、jdk nio是怎么和epoll实现对接的？</p><p>带着这两个疑问，查阅了网上一些文章，大概能解答以上两点疑惑</p><p>链接：<a href="https://baijiahao.baidu.com/s?id=1641172494287388070&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">彻底搞懂epoll高效运行的原理</a></p><p>epoll是一种I/O事件通知机制，是linux 内核实现IO多路复用的一个实现。</p><p>IO多路复用是指，在一个操作里同时监听多个输入输出源，在其中一个或多个输入输出源可用的时候返回，然后对其的进行读写操作。</p><p><strong>事件</strong></p><p>可读事件，当文件描述符关联的内核读缓冲区可读，则触发可读事件。(可读：内核缓冲区非空，有数据可以读取)</p><p>可写事件，当文件描述符关联的内核写缓冲区可写，则触发可写事件。(可写：内核缓冲区不满，有空闲空间可以写入）</p><p><strong>epoll的通俗解释是：一种当文件描述符的内核缓冲区非空时发出可读信号通知、当写缓冲区不满时发出可写信号通知的机制</strong></p><h4 id="epoll的API"><a href="#epoll的API" class="headerlink" title="epoll的API"></a>epoll的API</h4><p>epoll的核心是3个API，核心数据结构是：1个红黑树和1个链表</p><p><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/rpc/epoll%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86.png" alt="epoll"></p><p><strong>1. int epoll_create(int size);</strong><br>创建一个epoll对象，返回对象的句柄，后面两个操作都以句柄为核心。</p><p>参数size用来表示要监听的fd数量的最大值，之后版本的Linux已弃用该参数。</p><p><strong>2.int epoll_ctl(int epfd, int op, int fd, struct epoll_event* event);</strong><br>epoll的事件注册接口，负责将被监听的描述符添加到红黑树或从红黑树中删除或者对监听事件进行修改。<br>参数 epfd 表示epoll对象句柄；<br>参数 op 表示动作，用三个宏来表示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EPOLL_CTL_ADD <span class="comment">//注册新的fd到epfd中；</span></span><br><span class="line">EPOLL_CTL_MOD <span class="comment">//修改已经注册的fd的监听事件；</span></span><br><span class="line">EPOLL_CTL_DEL <span class="comment">//从epfd中删除一个fd；</span></span><br></pre></td></tr></table></figure><p>参数 fd 是需要监听的fd</p><p>参数 event 表示此次注册的事件，struct epoll_event结构如下：</p><p>data域是唯一能给出描述符信息的字段，所以在调用epoll_ctl加入一个需要监测的描述符时，一定要在此域写入描述符相关信息；</p><p>events域是bit mask，描述一组epoll事件，在epoll_ctl调用中解释为：描述符所期望的epoll事件，可多选。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">表示某个fd上某事件被触发了</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">__uint32_t</span> events; <span class="comment">// 在被监测的文件描述符上实际发生的事件。</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr; <span class="comment">// 指向用户自定义数据 </span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">//注册的文件描述符</span></span><br><span class="line">    <span class="keyword">__uint32_t</span> u32; <span class="comment">//32-bit integer</span></span><br><span class="line">    <span class="keyword">__uint64_t</span> u64; <span class="comment">//64-bit integer</span></span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure><p>常用的epoll事件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EPOLLIN <span class="comment">//表示对应的文件描述符可以读（包括对端SOCKET正常关闭）</span></span><br><span class="line">EPOLLOUT <span class="comment">//表示对应的文件描述符可以写</span></span><br><span class="line">EPOLLET <span class="comment">//将 EPOLL设为边缘触发</span></span><br><span class="line">EPOLLONESHOT <span class="comment">//第一次进行通知，之后不再监测</span></span><br><span class="line">EPOLLPRI <span class="comment">//由带外数据触发</span></span><br><span class="line">EPOLLERR <span class="comment">//描述符产生错误时触发，默认检测事件</span></span><br><span class="line">EPOLLHUP <span class="comment">//本端描述符产生一个挂断事件，默认监测事件</span></span><br><span class="line">EPOLLRDHUP <span class="comment">//对端描述符产生一个挂断事件</span></span><br></pre></td></tr></table></figure><h4 id="epoll的两种触发方式"><a href="#epoll的两种触发方式" class="headerlink" title="epoll的两种触发方式"></a>epoll的两种触发方式</h4><p>epoll监控多个文件描述符的I/O事件。epoll支持边缘触发(edge trigger，ET)或水平触发（level trigger，LT)，通过epoll_wait等待I/O事件，如果当前没有可用的事件则阻塞调用线程。</p><p>select和poll只支持LT工作模式，epoll的默认的工作模式是LT模式。</p><p><strong>1.水平触发的时机</strong></p><p>对于读操作，只要缓冲不为空，LT模式返回读就绪。对于写操作，只要缓冲区还不满，LT模式会返回写就绪。</p><p>当被监控的文件描述符上有可读写事件发生时，<code>epoll_wait()</code>会通知处理程序去读写。如果这次没有把数据一次性全部读写完(如读写缓冲区太小)，那么下次调用 <code>epoll_wait()</code>时，它还会通知你在上没读写完的文件描述符上继续读写，当然如果你一直不去读写，它会一直通知你。如果系统中有大量你不需要读写的就绪文件描述符，而它们每次都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率。</p><p><strong>2.边缘触发的时机</strong></p><p>对于读操作，以下三种情况会触发读就绪事件：</p><ul><li><p>当缓冲区由不可读变为可读的时候，即缓冲区由空变为不空的时候；</p></li><li><p>当有新数据到达时，即缓冲区中的待读数据变多的时候；</p></li><li><p>当缓冲区有数据可读，且应用进程对相应的描述符进行EPOLL_CTL_MOD 修改EPOLLIN事件时（设置监听读就绪时）；</p></li></ul><p>响应的对于写操作，以下情况会触发写就绪事件：</p><ul><li>当缓冲区由不可写变为可写时。</li><li>当有旧数据被发送走，即缓冲区中的内容变少的时候。</li><li>当缓冲区有空间可写，且应用进程对相应的描述符进行EPOLL_CTL_MOD 修改EPOLLOUT事件时。</li></ul><p>当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它不会通知你，就是说只会通知一次，直到该文件描述符上触发第二次可读写事件时才会再次通知。这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符。</p><p>举例1：</p><p>读缓冲区刚开始是空的读缓冲区写入2KB数据，水平触发和边缘触发模式此时都会发出可读信号收到信号通知后，读取了1KB的数据，读缓冲区还剩余1KB数据，水平触发会再次进行通知，而边缘触发不会再进行通知</p><p>举例2：（以脉冲的高低电平为例）</p><p>水平触发：0为无数据，1为有数据。缓冲区有数据则一直为1，则一直触发。边缘触发发：0为无数据，1为有数据，只要在0变到1的上升沿才触发。</p><p>JDK在Linux已经默认使用epoll方式，但是JDK的epoll采用的是水平触发，而Netty重新实现了epoll机制，采用边缘触发方式，netty epoll transport 暴露了更多的nio没有的配置参数，如 TCP_CORK, SO_REUSEADDR等等；另外像Nginx也采用边缘触发。</p><h4 id="epoll与select、poll的对比"><a href="#epoll与select、poll的对比" class="headerlink" title="epoll与select、poll的对比"></a>epoll与select、poll的对比</h4><p><strong>1. 用户态将文件描述符传入内核的方式</strong></p><ul><li><p>select：创建3个文件描述符集并拷贝到内核中，分别监听读、写、异常动作。这里受到单个进程可以打开的fd数量限制，默认是1024。</p></li><li><p>poll：将传入的struct pollfd结构体数组拷贝到内核中进行监听。</p></li><li><p>epoll：执行epoll_create会在内核的高速cache区中建立一颗红黑树以及就绪链表(该链表存储已经就绪的文件描述符)。接着用户执行的epoll_ctl函数添加文件描述符会在红黑树上增加相应的结点。</p></li></ul><p><strong>2. 内核态检测文件描述符读写状态的方式</strong></p><ul><li>select：采用轮询方式，遍历所有fd，最后返回一个描述符读写操作是否就绪的mask掩码，根据这个掩码给fd_set赋值。</li><li>poll：同样采用轮询方式，查询每个fd的状态，如果就绪则在等待队列中加入一项并继续遍历。</li><li>epoll：采用回调机制。在执行epoll_ctl的add操作时，不仅将文件描述符放到红黑树上，而且也注册了回调函数，内核在检测到某文件描述符可读/可写时会调用回调函数，该回调函数将文件描述符放在就绪链表中。</li></ul><p><strong>3. 找到就绪的文件描述符并传递给用户态的方式</strong></p><ul><li>select：将之前传入的fd_set拷贝传出到用户态并返回就绪的文件描述符总数。用户态并不知道是哪些文件描述符处于就绪态，需要遍历来判断。</li><li>poll：将之前传入的fd数组拷贝传出用户态并返回就绪的文件描述符总数。用户态并不知道是哪些文件描述符处于就绪态，需要遍历来判断。</li><li>epoll：epoll_wait只用观察就绪链表中有无数据即可，最后将链表的数据返回给数组并返回就绪的数量。内核将就绪的文件描述符放在传入的数组中，所以只用遍历依次处理即可。这里返回的文件描述符是通过mmap让内核和用户空间共享同一块内存实现传递的，减少了不必要的拷贝。</li></ul><p><strong>4. 重复监听的处理方式</strong></p><ul><li>select：将新的监听文件描述符集合拷贝传入内核中，继续以上步骤。</li><li>poll：将新的struct pollfd结构体数组拷贝传入内核中，继续以上步骤。</li><li>epoll：无需重新构建红黑树，直接沿用已存在的即可。</li></ul><h4 id="epoll更高效的原因"><a href="#epoll更高效的原因" class="headerlink" title="epoll更高效的原因"></a><strong>epoll更高效的原因</strong></h4><p>select和poll的动作基本一致，只是poll采用链表来进行文件描述符的存储，而select采用fd标注位来存放，所以select会受到最大连接数的限制，而poll不会。</p><p>select、poll、epoll虽然都会返回就绪的文件描述符数量。但是select和poll并不会明确指出是哪些文件描述符就绪，而epoll会。造成的区别就是，系统调用返回后，调用select和poll的程序需要遍历监听的整个文件描述符找到是谁处于就绪，而epoll则直接处理即可。select、poll都需要将有关文件描述符的数据结构拷贝进内核，最后再拷贝出来。而epoll创建的有关文件描述符的数据结构本身就存于内核态中，系统调用返回时利用mmap()文件映射内存加速与内核空间的消息传递：即epoll使用mmap减少复制开销。select、poll采用轮询的方式来检查文件描述符是否处于就绪态，而epoll采用回调机制。造成的结果就是，随着fd的增加，select和poll的效率会线性降低，而epoll不会受到太大影响，除非活跃的socket很多。epoll的边缘触发模式效率高，系统不会充斥大量不关心的就绪文件描述符虽然epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;nio非阻塞牛逼在哪里？&lt;/p&gt;
&lt;p&gt;要解答这个问题首先要清楚bio的痛点在哪里。&lt;/p&gt;
&lt;p&gt;假如我们的服务使用bio模型，服务器启动之后需要一条线程一直监听端口上是否有连接请求发过来，如果没有请求，这条线程就一直等着；&lt;/p&gt;
&lt;p&gt;等了好久好久终于来了一个请求连接
      
    
    </summary>
    
      <category term="I/O和网络编程" scheme="http://yoursite.com/child/categories/I-O%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="nio" scheme="http://yoursite.com/child/tags/nio/"/>
    
  </entry>
  
  <entry>
    <title>git规范的commit message（转）</title>
    <link href="http://yoursite.com/child/2019/10/23/%E5%85%B6%E4%BB%96-git%E8%A7%84%E8%8C%83%E7%9A%84Commit%20Message/"/>
    <id>http://yoursite.com/child/2019/10/23/其他-git规范的Commit Message/</id>
    <published>2019-10-22T16:00:00.000Z</published>
    <updated>2020-06-12T00:32:37.078Z</updated>
    
    <content type="html"><![CDATA[<p>git上每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>(<span class="tag">&lt;<span class="name">scope</span>&gt;</span>): <span class="tag">&lt;<span class="name">subject</span>&gt;</span></span><br><span class="line">// 空一行</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">// 空一行</span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中，Header 是必需的，Body 和 Footer 可以省略。</p><p>不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。</p><h3 id="Header-必需"><a href="#Header-必需" class="headerlink" title="Header(必需)"></a>Header(必需)</h3><ul><li><p><strong>type(必需)</strong> 用于说明 commit 的类别</p><blockquote><ul><li>feat：新功能（feature）</li><li>fix：修补bug</li><li>docs：文档（documentation）</li><li>style： 格式（不影响代码运行的变动）</li><li>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</li><li>test：增加测试</li><li>chore：构建过程或辅助工具的变动</li><li>revert：用于以前的 commit，则必须以<code>revert:</code>开头，后面跟着被撤销 Commit 的 Header。</li></ul></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">revert: feat(pencil): add &apos;graphiteWidth&apos; option</span><br><span class="line"></span><br><span class="line">This reverts commit 667ecc1654a317a13331b17617d973392f415f02.</span><br></pre></td></tr></table></figure><p>Body部分的格式是固定的，必须写成<code>This reverts commit &amp;lt;hash&gt;.</code>，其中的<code>hash</code>是被撤销 commit 的 SHA 标识符。</p><p>如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的<code>Reverts</code>小标题下面。</p><p>如果<strong>type</strong>为<code>feat</code>和<code>fix</code>，则该 commit 将肯定出现在 Change log 之中。其他情况（<code>docs</code>、<code>chore</code>、<code>style</code>、<code>refactor</code>、<code>test</code>）由你决定，要不要放入 Change log，建议是不要。</p><p><strong>scope</strong> 用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p><p><strong>subject(必需)</strong> 是 commit 目的的简短描述，不超过50个字符。</p><blockquote><ul><li>以动词开头，使用第一人称现在时，比如<code>change</code>，而不是<code>changed</code>或<code>changes</code></li><li>第一个字母小写</li><li>结尾不加句号（<code>.</code>）</li></ul></blockquote><h3 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h3><p>Body 部分是对本次 commit 的详细描述，可以分成多行。</p><p>有两个注意点:</p><ul><li>使用第一人称现在时，比如使用<code>change</code>而不是<code>changed</code>或<code>changes</code>。</li><li>应该说明代码变动的动机，以及与以前行为的对比。</li></ul><h3 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h3><p>Footer 部分只用于两种情况。</p><ul><li><p><strong>不兼容变动</strong></p><p>如果当前代码与上一个版本不兼容，则 Footer 部分以<code>BREAKING CHANGE</code>开头，后面是对变动的描述、以及变动理由和迁移方法。</p></li><li><p><strong>关闭 Issue</strong></p><p>如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。</p><blockquote><p>Closes #234</p></blockquote><p>也可以一次关闭多个 issue 。</p><blockquote><p>Closes #123, #245, #992</p></blockquote></li></ul><p><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2016%2F01%2Fcommit_message_change_log.html" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;git上每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;l
      
    
    </summary>
    
      <category term="其他" scheme="http://yoursite.com/child/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="git" scheme="http://yoursite.com/child/tags/git/"/>
    
  </entry>
  
</feed>
