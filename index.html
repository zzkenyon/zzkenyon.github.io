<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-源码分析-会用HashMap" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/21/源码分析-会用HashMap/" class="article-date">
  <time datetime="2018-07-21T12:41:36.000Z" itemprop="datePublished">2018-07-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/21/源码分析-会用HashMap/">源码分析-会用HashMap</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一个问题引发的思考"><a href="#一个问题引发的思考" class="headerlink" title="一个问题引发的思考"></a>一个问题引发的思考</h3><p>如果确定只装载100个元素，new HashMap(?)多少是最佳的，why？<br>要弄解答这个问题，第一要知道HashMap的数据结构，第二再弄明白存取数据的逻辑。</p>
<h3 id="1-首先，我是一个数组"><a href="#1-首先，我是一个数组" class="headerlink" title="1.首先，我是一个数组"></a>1.首先，我是一个数组</h3><p>HashMap本质上是一个数组，数组的每个元素是一个单链表或者红黑树，由0个或多个节点组成。<br>java源码中的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>
<h4 id="1-1节点类Node-lt-K-V-gt"><a href="#1-1节点类Node-lt-K-V-gt" class="headerlink" title="1.1节点类Node&lt;K,V&gt;"></a>1.1节点类Node&lt;K,V&gt;</h4><p>Node类是HashMap的一个静态内部类，可以将其看成是一个独立的类，只是声明在HashMap类内部而已。下面是源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;//Entry是Map接口中的一个内部接口</span><br><span class="line">    final int hash;//此节点的哈希值，同一个链表上的哈希值不一定相同</span><br><span class="line">    final K key;//键，不能修改</span><br><span class="line">    V value;//值</span><br><span class="line">    Node&lt;K,V&gt; next;//指向下一个节点</span><br><span class="line"> </span><br><span class="line">    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        this.hash = hash;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public final K getKey()        &#123; return key; &#125;</span><br><span class="line">    public final V getValue()      &#123; return value; &#125;</span><br><span class="line">    public final String toString() &#123; return key + &quot;=&quot; + value; &#125;</span><br><span class="line"> </span><br><span class="line">    public final int hashCode() &#123;//此Node类的hashCode方法</span><br><span class="line">        return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public final V setValue(V newValue) &#123;//重新设置节点Value，返回旧Value</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public final boolean equals(Object o) &#123;//判断节点相等的方法，</span><br><span class="line">        if (o == this)//同一个对象，返回true</span><br><span class="line">            return true;</span><br><span class="line">        if (o instanceof Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                return true;//键和值都相等则返回true</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-2为啥有链表还有树"><a href="#1-2为啥有链表还有树" class="headerlink" title="1.2为啥有链表还有树"></a>1.2为啥有链表还有树</h4><p>为了提高查询效率，当链表的长度达到阈值的时候会自动将链表树形化，源码中的三个阈值常量如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static final int TREEIFY_THRESHOLD = 8;</span><br><span class="line">static final int UNTREEIFY_THRESHOLD = 6;</span><br><span class="line">static final int MIN_TREEIFY_CAPACITY = 64;</span><br></pre></td></tr></table></figure>
<ul>
<li>TREEIFY_THRESHOLD 树形化阈值：当链表长度超过这个值的时候，将链表进行树形化改造</li>
<li>UNTREEIFY_THRESHOLD 链表化阈值：当节点数低于这个阈值，将红黑树改造成链表。这个值必须必树形化阈值小，避免频繁的转换。</li>
<li>MIN_TREEIFY_CAPACITY 最小树形化容量：当数组table的长度低于这个值，即使元素链表的长度超过树形化阈值，也不会进行树形化改造，而是对table进行扩容。这个值不能小于4*TREEIFY_THRESHOLD  <h3 id="2-怎么进行数据的存取呢"><a href="#2-怎么进行数据的存取呢" class="headerlink" title="2.怎么进行数据的存取呢"></a>2.怎么进行数据的存取呢</h3><h4 id="2-1hash方法"><a href="#2-1hash方法" class="headerlink" title="2.1hash方法"></a>2.1hash方法</h4>拿到一个&lt;Key,Value&gt;，要存在table的哪个位置呢，这就需要用hash方法来决定了。。。<br>从代码说起：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>key.hashCode()函数调用的是key键值类型自带的哈希函数（与HashMap的hashCode()函数不是同一个），它返回一个32位int类型的散列值。</li>
<li>考虑到hash值得取值范围太大，不可能创建一个如此大的hash table，因此定位到table的位置只使用hash值的后几位（具体位数与table长度有关）。</li>
<li>如果只取后几位，碰撞会比较严重，因此就有了扰动函数，将hash值右移16位（高16位移到低16位），再与自身亦或，得到的结果混合了原hash值得高位和低位，以此来加大低位的随机性。</li>
</ul>
<h4 id="2-2定位"><a href="#2-2定位" class="headerlink" title="2.2定位"></a>2.2定位</h4><p>最终得到的hash值，将由低位进行定位，定位操作如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n = tab.length</span><br><span class="line">tab[(n - 1) &amp; hash]</span><br></pre></td></tr></table></figure></p>
<ul>
<li>数组长度必为2的整数次幂，因此(n-1)相当于低位掩码，与h进行与操作，保留h低位，掩盖高位。</li>
<li>这里不做取余，是因为取余可能为负数（hashCode为负数的时候）</li>
<li>不对取余进行模运算，是因为最大的整数Math.abs()会返回负值</li>
<li>由此可知，对于HashMap的同一个链表的各个节点key值得hash值不一定相同（只是低位相同）</li>
</ul>
<h4 id="2-3扩容-resize"><a href="#2-3扩容-resize" class="headerlink" title="2.3扩容(resize)"></a>2.3扩容(resize)</h4><h5 id="默认容量是16"><a href="#默认容量是16" class="headerlink" title="默认容量是16"></a>默认容量是16</h5><p>16是2的整数次幂的原因，在小数据量的情况下16比15或20更能减少key之间的碰撞，而加快查询的效率。 </p>
<h5 id="容量是15会怎样？"><a href="#容量是15会怎样？" class="headerlink" title="容量是15会怎样？"></a>容量是15会怎样？</h5><p>当数组长度为15的时候，hashcode的值会与14（1110）进行“与”，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率（hash不均匀），降低了查询的效率！<br>所以，在存储大容量数据的时候，最好预先指定hashmap的size为2的整数次幂次方。就算不指定的话，也会以大于且最接近指定值大小的2次幂来初始化的，代码如下(HashMap的构造方法中)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int capacity = 1;  </span><br><span class="line">while (capacity &lt; initialCapacity)   </span><br><span class="line">    capacity &lt;&lt;= 1;  //乘以2</span><br></pre></td></tr></table></figure></p>
<h5 id="什么时候扩容-amp-怎么扩容"><a href="#什么时候扩容-amp-怎么扩容" class="headerlink" title="什么时候扩容&amp;怎么扩容"></a>什么时候扩容&amp;怎么扩容</h5><p>当hashmap中的元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对hashmap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，所以这是一个通用的操作，很多人对它的性能表示过怀疑，不过想想我们的“均摊”原理，就释然了，而在hashmap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。<br>那么hashmap什么时候进行扩容呢？当hashmap中的元素个数超过数组大小length x loadFactor时，就会进行数组扩容，==<strong>loadFactor的默认值为0.75</strong>==，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过16x0.75=12的时候，就把数组的大小扩展为2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以++如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能++。  </p>
<h5 id="回到开篇的问题"><a href="#回到开篇的问题" class="headerlink" title="回到开篇的问题"></a>回到开篇的问题</h5><p>当有100个元素new HashMap(100), 但是理论上来讲new HashMap(128)更合适，不过上面已经说过，即使是100，hashmap也自动会将其设置为128。 但是new HashMap(128)还不是更合适的，因为0.75x100 &lt; 100, 也就是说为了让0.75 x size &gt; 100, 我们必须这样new HashMap(256)才最合适，既考虑了&amp;的问题，也避免了resize的问题。 </p>
<h3 id="3-可以使用自定义的类作为key的类型吗"><a href="#3-可以使用自定义的类作为key的类型吗" class="headerlink" title="3.可以使用自定义的类作为key的类型吗"></a>3.可以使用自定义的类作为key的类型吗</h3><p>可以，但是必须改写key类型的hashcode与equals方法<br>首先计算key的hashcode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。所以，hashcode与equals方法对于找到对应元素是两个关键方法。<br>Hashmap的key可以是任何类型的对象，例如User这种对象，为了保证两个具有相同属性的user的hashcode相同，我们就需要改写hashcode方法，比方把hashcode值的计算与User对象的id关联起来，那么只要user对象拥有相同id，那么他们的hashcode也能保持一致了，这样就可以找到在hashmap数组中的位置了。如果这个位置上有多个元素，还需要用key的equals方法在对应位置的链表中找到需要的元素，所以只改写了hashcode方法是不够的，equals方法也是需要改写滴~当然啦，按正常思维逻辑，equals方法一般都会根据实际的业务内容来定义，例如根据user对象的id来判断两个user是否相等。  </p>
<hr>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://www.iteye.com/topic/539465" target="_blank" rel="noopener">深入理解HashMap</a><br><a href="https://blog.csdn.net/u010292561/article/details/80472555" target="_blank" rel="noopener">HashMap详解</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/21/源码分析-会用HashMap/" data-id="cjw02os6l0018l2i7mytko8f8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码分析/">源码分析</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-并发编程-线程池源码详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/15/并发编程-线程池源码详解/" class="article-date">
  <time datetime="2018-05-15T03:28:21.000Z" itemprop="datePublished">2018-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/15/并发编程-线程池源码详解/">并发编程-线程池源码详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>阿里巴巴Java手册有一条：<br>【强制】线程资源必须通过线程池提供，禁止在应用程序中显示创建线程。<br>说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程导致消耗完内存或者过度切换的问题。</p>
<p>简单来说使用线程池有以下几个目的：  </p>
<ul>
<li>避免频繁的创建。线程是稀缺资源。</li>
<li>解耦。线程的创建与执行分开，方便维护。</li>
<li>线程资源复用。</li>
</ul>
<h3 id="1-线程池原理"><a href="#1-线程池原理" class="headerlink" title="1. 线程池原理"></a>1. 线程池原理</h3><p>本文从线程池的创建开始说起，跟着源码分析一下线程池的工作原理，本文源码基于JDK1.8</p>
<h4 id="1-1-Executors"><a href="#1-1-Executors" class="headerlink" title="1.1 Executors"></a>1.1 Executors</h4><p>Executors有一个私有的默认构造函数，不能实例化，是一个工具类，主要用于提供各种类型线程池创建的静态方法。<br>提供的静态创建方法有：</p>
<ul>
<li>newSingleThreadExecutor 创建一个执行器，该执行器使用一个工作线程操作一个无界队列。(但是请注意，如果这个线程在关闭之前的执行过程中由于失败而终止，那么如果需要执行后续任务，将会有一个新的线程代替它。与 newFixedThreadPool(1)不同，返回的executor不能被其他线程重新配置。</li>
<li>newFixedThreadPool  创建一个线程池，该线程池重用固定数量的线，如果任何线程在关闭之前的执行过程中由于失败而终止，那么如果需要执行后续任务，则会替换一个新线程。池中的线程将一直存在，直到显式关闭为止<br>操作一个共享的无界队列。</li>
<li>newWorkStealingPool  创建一个线程池，该线程池维护足够的线程以支持给定的并行度级别，并且可以使用多个队列来减少争用。并行度级别对应于积极参与或可用参与任务处理的线程的最大数量。线程的实际数量可以动态地增长和收缩。工作窃取池不能保证所提交任务的执行顺序。</li>
<li>newCachedThreadPool  创建一个线程池，该线程池根据需要创建新线程，但在可用时将重用以前构造的线程。这些池通常会提高执行许多短期异步任务的程序的性能。如果可用，对execute的调用将重用以前构造的线程。如果没有可用的现有线程，将创建一个新线程并将其添加到池中。未使用60秒的线程将被终止并从缓存中删除。因此，长时间空闲的池不会消耗任何资源。注意，可以使用ThreadPoolExecutor构造函数创建具有相似属性但不同细节(例如超时参数)的池。</li>
<li>newSingleThreadScheduledExecutor  创建一个单线程执行器，该执行器可以安排命令在给定的延迟之后运行，或者定期执行。(但是请注意，如果这个线程在关闭之前的执行过程中由于失败而终止，那么如果需要执行后续任务，将会有一个新的线程代替它。)，与 newFixedThreadPool(1)不同，返回的executor不能被其他线程重新配置。</li>
<li>newScheduledThreadPool  创建一个线程池，该线程池可以在给定延迟之后调度命令运行，或者定期执行命令。</li>
</ul>
<p>Executors 返回的线程池对象的弊端如下：</p>
<ol>
<li>FixedThreadPool 和 SingleThreadPool: 允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。</li>
<li>CachedThreadPool 和 ScheduledThreadPool: 允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</li>
</ol>
<h4 id="1-2-ThreadPoolExecutor"><a href="#1-2-ThreadPoolExecutor" class="headerlink" title="1.2 ThreadPoolExecutor"></a>1.2 ThreadPoolExecutor</h4><p>首先看一下newFixedThreadPool创建方法的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>事实上，大多数类型的线程池创建都是调用new ThreadPoolExecutor(…)创建一个ThreadPoolExecutor对象，只不过初始化参数不同而已。newWorkStealingPool创建时构造的是ForkJoinPool对象，本文不述。</p>
<p>下面是ThreadPoolExecutor的其中一个构造方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler handler) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>初始化参数的如下：</p>
<ul>
<li>corePoolSize 表示线程池的核心数,线程池保持alive状态的线程数，即使线程是空闲的。</li>
<li>maximumPoolSize 表示线程池支持的最大的线程个数。</li>
<li>keepAliveTime 表示池中线程空闲后的生存时间</li>
<li>unit 表示上一个时间参数的单位</li>
<li>workQueue 用于存放任务的阻塞队列</li>
<li>threadFactory 表示创建线程的工厂，一般使用默认的线程创建工厂Excutors.DefaultThreadFactor()</li>
<li>handler 当队列和最大线程池都满了之后的饱和策略，一般使用默认的handler—AbortPolicy（内部类）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">代码摘自：java.util.concurrent.ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">private static final RejectedExecutionHandler defaultHandler = new AbortPolicy();</span><br><span class="line"></span><br><span class="line">public static class AbortPolicy implements RejectedExecutionHandler &#123;</span><br><span class="line">    public AbortPolicy() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">        throw new RejectedExecutionException(&quot;Task &quot; + r.toString() +</span><br><span class="line">                                             &quot; rejected from &quot; +</span><br><span class="line">                                             e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final void reject(Runnable command) &#123;</span><br><span class="line">    handler.rejectedExecution(command, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户也可以自己实现RejectedExecutionHandler接口定义一个handler，当提交的任务因为各种原因被线程池拒绝，就会调用rejectedExecution方法。</p>
<h5 id="1-2-1-excute"><a href="#1-2-1-excute" class="headerlink" title="1.2.1 excute()"></a>1.2.1 excute()</h5><p>使用线程池时，通常我们用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threadPool.execute(new Job());</span><br></pre></td></tr></table></figure></p>
<p>这样的方式提交一个任务到线程池中，所以线程池ThreadPoolExecutor的核心逻辑就是execute()函数了，这个方法是在Excutor接口中声明。</p>
<p>在分析核心逻辑之前，先了解一下线程池重定义的状态，这些状态都和线程的执行密切相关</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">代码摘自：java.util.concurrent.ThreadPoolExecutor</span><br><span class="line">private static final int COUNT_BITS = Integer.SIZE - 3;</span><br><span class="line"></span><br><span class="line">private static final int CAPCITY = (1 &lt;&lt; COUNT_BITS) - 1;</span><br><span class="line"></span><br><span class="line">private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int STOP       =  1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">private static int runStateOf(int c)&#123;return c &amp; ~CAPCITY;&#125;</span><br><span class="line">private static int workerCountOf(int c)&#123;return c &amp; CAPCITY;&#125;</span><br><span class="line">private static int ctlOf(int rs, int wc)&#123;return rs | wc;&#125;</span><br></pre></td></tr></table></figure>
<p>分析上面的代码得到下表：<br>常量名| 二进制<br>—|—<br>CAPCITY | 0001 1111 1111 1111 1111 1111 1111 1111<br>RUNNING | 1110 0000 0000 0000 0000 0000 0000 0000<br>SHUTDOWN | 0000 0000 0000 0000 0000 0000 0000 0000<br>STOP | 0010 0000 0000 0000 0000 0000 0000 0000<br>TIDYING | 0100 0000 0000 0000 0000 0000 0000 0000<br>TERMINATED | 0110 0000 0000 0000 0000 0000 0000 0000</p>
<p>由上表可以看出，原子对象ctl的前三位表示状态，后29位记录池中worker的个数，CAPCITY就像是一个掩码，通过掩码可以快速的从ctl中获得当前线程池的运行状态和池中的worker个数。  </p>
<p>JDK1.8的并发包中不再通过设置阻塞队列的长度来限制任务的提交。阻塞队列的长度初始化之后就不能改变，因此如果担心阻塞队列太大导致内存占用太多，可以从两方面入手：1、初始化的时候选择合适的阻塞队列大小；2、调高corePoolSize或maxmumPoolSize加快任务的处理速度。参数的动态调整见下文。</p>
<p>线程池状态简述：</p>
<ul>
<li>RUNNING 是运行状态，指可以接受任务，执行队列里的任务。</li>
<li>SHUTDOWN 是指调用了shutdown()函数，不再接受新任务，但是会把队列里的任务执行完毕。</li>
<li>STOP 是指调用了shutdownNow()函数，不再接受新任务，同时终端正在执行的任务并丢弃队列中的待执行任务。</li>
<li>TIDYING 指所用任务都执行完毕。</li>
<li>TERMINATED 终止状态，在调用shutdown()/shutdownNow()中都会尝试更新这个状态。</li>
</ul>
<p>下面分析核心代码excute()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">代码摘自：java.util.concurrent.ThreadPoolExecutor</span><br><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    if (command == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    //1、获取当前线程池的状态</span><br><span class="line">    int c = ctl.get();</span><br><span class="line">    //2、当线程数量小于corePoolSize，创建新线程运行</span><br><span class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        if (addWorker(command, true))</span><br><span class="line">            return;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    //3、如果线程池处于运行状态，并且写入阻塞队列成功</span><br><span class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        int recheck = ctl.get();</span><br><span class="line">        //4、双重检查，再次获取线程状态；如果线程池状态改变（非运行状态），需要从阻塞队列移除任务，并执行拒绝策略</span><br><span class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        //5、如果第二次检查通过，判断当前池是否为空，为空就创建新线程并执行</span><br><span class="line">        else if (workerCountOf(recheck) == 0)</span><br><span class="line">            addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">    //6、如果第一次检查不通过（线程池不处于运行状态或者任务写入队列失败），尝试新建线程，如果失败则执行拒绝策略</span><br><span class="line">    else if (!addWorker(command, false))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下图表示了当有任务提交到线程池后线程池的处理流程：<br><img src="http://ws2.sinaimg.cn/large/87c9e458ly1g2zlek6nldj20pj0azmxo.jpg" alt="未命名文件">  </p>
<h5 id="1-2-2-addWorker"><a href="#1-2-2-addWorker" class="headerlink" title="1.2.2 addWorker()"></a>1.2.2 addWorker()</h5><p>addWorker函数是excute函数的核心逻辑—创建线程执行任务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">代码摘自：java.util.concurrent.ThreadPoolExecutor</span><br><span class="line">private final ReentrantLock mainLock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">    retry:</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        int rs = runStateOf(c);</span><br><span class="line">        //状态为 RUNNING 继续往下执行</span><br><span class="line">        //状态为不为RUNNING时，如果状态为SHUTDOWN并且firstTask为null并且阻塞队列空时，可继续向下运行</span><br><span class="line">        //否则返回false，添加worker失败</span><br><span class="line">        if (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == null &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            return false;</span><br><span class="line">        </span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int wc = workerCountOf(c);</span><br><span class="line">            //线程数大于CAPACITY </span><br><span class="line">            //线程数大于corePoolSize或maximumPoolSize（取决于core）</span><br><span class="line">            //否则添加worker失败</span><br><span class="line">            if (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                return false;</span><br><span class="line">            //线程数验证通过，使用CAS对c加1，执行成功则终止大循环继续向下运行</span><br><span class="line">            if (compareAndIncrementWorkerCount(c))</span><br><span class="line">                break retry;</span><br><span class="line">            //CAS设置失败则重新获取运行状态，若线程池状态发生改变，从头开始大循环，否则继续小循环</span><br><span class="line">            c = ctl.get(); </span><br><span class="line">            if (runStateOf(c) != rs)</span><br><span class="line">                continue retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean workerStarted = false;</span><br><span class="line">    boolean workerAdded = false;</span><br><span class="line">    Worker w = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        w = new Worker(firstTask);</span><br><span class="line">        final Thread t = w.thread;</span><br><span class="line">        if (t != null) &#123;</span><br><span class="line">            final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                // 二重验证，获取池状态</span><br><span class="line">                int rs = runStateOf(ctl.get());</span><br><span class="line">                //状态为RUNNING 则通过继续执行</span><br><span class="line">                //状态为SHUTDOWN并且提交的任务为null 则通过继续执行</span><br><span class="line">                //否则直接执行finally解锁</span><br><span class="line">                if (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;</span><br><span class="line">                    if (t.isAlive()) // 如果worker中的线程t已经处于运行状态</span><br><span class="line">                        throw new IllegalThreadStateException();//抛异常</span><br><span class="line">                    workers.add(w);//将w加入HashSet</span><br><span class="line">                    int s = workers.size();</span><br><span class="line">                    //更新largestPoolSize，largestPoolSize只能在lock下修改</span><br><span class="line">                    if (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            if (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    return workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="1-2-3-addWorkerFailed"><a href="#1-2-3-addWorkerFailed" class="headerlink" title="1.2.3 addWorkerFailed()"></a>1.2.3 addWorkerFailed()</h5><p>当任务执行失败，程序需要进行善后处理，即恢复任务执行过程中对内存的改动，移除set中的worker对象，修改池状态，最后尝试终止线程池。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">代码摘自：java.util.concurrent.ThreadPoolExecutor</span><br><span class="line">private void addWorkerFailed(Worker w) &#123;</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (w != null)</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        //CAS对ctl减1</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-配置线程池"><a href="#2-配置线程池" class="headerlink" title="2. 配置线程池"></a>2. 配置线程池</h3><p>流程介绍完了先来总结以下上文提到了几个核心参数在流程中的具体作用，然后介绍应该如何配置。</p>
<h4 id="2-1-参数详解"><a href="#2-1-参数详解" class="headerlink" title="2.1 参数详解"></a>2.1 参数详解</h4><ol>
<li>corePoolSize：核心线程数</li>
</ol>
<ul>
<li>核心线程会一直存活，即使没有任务需要执行</li>
<li>当线程数小于核心线程数时，即使有线程空闲，线程池也会有限创建新的线程</li>
<li>设置allowCoreThreadTimeout=true（默认是false）时，核心线程会超时关闭</li>
</ul>
<ol start="2">
<li>maximumPoolSize：最大线程数</li>
</ol>
<ul>
<li>当线程数 &gt;= corePoolSize，且队列已满。线程池会创建新线程来处理  </li>
<li>当线程数 = maxmumPoolSize，且队列任务已满是，线程会拒绝处理任务  </li>
</ul>
<ol start="3">
<li>keepAliveTime：线程空闲时间</li>
</ol>
<ul>
<li>当线程空闲时间达到keepAliveTime时，线程会退出，知道线程数量 = corePoolSize  </li>
<li>如果allowCoreThreadTimeout = true，则会知道线程数量 = 0</li>
</ul>
<ol start="4">
<li>rejectedExecutionHandler：任务拒绝处理器<br>两种情况会拒绝处理任务： </li>
</ol>
<ul>
<li>当线程数已经达到maxmumPoolSize，且队列已满，会拒绝新任务</li>
<li>当线程池被调用shutdown()后，会等待线程池里的任务执行完毕，再shutdown。如果在调用shutdown()和线程池真正shutdown之间提交任务，会拒绝新任务</li>
</ul>
<p>线程池会调用rejectedExecutionHandler来处理这个任务。如果没有设置默认是AbortPolicy，会抛出异常，<br>ThreadPoolExecutor类有几个内部实现类来处理这类情况：  </p>
<blockquote>
<p>AbortPolicy 丢弃任务，抛运行时异常<br>CallerRunsPolicy 执行任务，调用Runnable的run强制执行。<br>DiscardPolicy 忽视，什么都不会发生<br>DiscardOldestPolicy 如果是应为第一种情况被拒绝，则从阻塞队列中踢出最先进入队列（最后一个执行）的任务，然后再次提交当前任务。</p>
</blockquote>
<p>实现RejectedExecutionHandler接口，可自定义处理器处理reject。</p>
<h4 id="2-2-参数配置"><a href="#2-2-参数配置" class="headerlink" title="2.2 参数配置"></a>2.2 参数配置</h4><p>默认值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">corePoolSize=1</span><br><span class="line">maxPoolSize=Integer.MAX_VALUE</span><br><span class="line">keepAliveTime=60s</span><br><span class="line">allowCoreThreadTimeout=false</span><br><span class="line">rejectedExecutionHandler=AbortPolicy()</span><br></pre></td></tr></table></figure></p>
<p>如何设置，需要根据几个值来决定：  </p>
<ul>
<li>tasks ：系统每秒任务数，假设为500~1000</li>
<li>taskcost：单任务耗时，假设为0.1s</li>
<li>responsetime：系统允许容忍的最大响应时间，假设为1s</li>
</ul>
<p>做几个计算：<br>corePoolSize = 系统每秒任务数/单线程每秒任务数 = 系统每秒任务数/（1/单任务耗时）<br>corePoolSize = tasks/(1/taskcost) =tasks<em>taskcout =  (500~1000)</em>0.1 = 50~100 。  corePoolSize设置应该大于50，根据8020原则，如果80%的系统每秒任务数小于800，那么corePoolSize设置为80即可  </p>
<p>maxPoolSize = （最大任务数-队列容量）/每个线程每秒处理能力 = 最大线程数<br>计算可得 maxPoolSize = (1000-80)/10 = 92<br>队列容量在初始化池的时候指定，一旦指定不能修改</p>
<p>rejectedExecutionHandler：根据具体情况来决定，任务不重要可丢弃，任务重要则要利用一些缓冲机制来处理</p>
<p>keepAliveTime和allowCoreThreadTimeout采用默认通常能满足<br>以上都是理想值，实际情况下要根据机器性能来决定。如果在未达到最大线程数的情况机器cpu load已经满了，则需要通过升级硬件和优化代码，降低taskcost来处理。</p>
<h4 id="2-3-参数动态调整"><a href="#2-3-参数动态调整" class="headerlink" title="2.3 参数动态调整"></a>2.3 参数动态调整</h4><p>用户可以通过corePoolSize和maxmumPoolSize的getter/setter进行访问和设置，具体怎么设置需要根据当前池中一些状态变量进行判断，如：</p>
<ul>
<li>getLargestPoolSize() 获取到目前为止达到过的最大线程数</li>
<li>getPoolSize() 获取当前线程数</li>
<li>getQueue().size() 获取当前阻塞队列任务数</li>
</ul>
<h3 id="3-关闭线程池"><a href="#3-关闭线程池" class="headerlink" title="3. 关闭线程池"></a>3. 关闭线程池</h3><p>关闭线程池无非就是两个方法 shutdown()/shutdownNow()。</p>
<p>但他们有着重要的区别：</p>
<ul>
<li>shutdown() 执行后停止接受新任务，会把队列的任务执行完毕。</li>
<li>shutdownNow() 也是停止接受新任务，但会中断所有的任务，将线程池状态变为 stop。</li>
</ul>
<p>两个方法都会中断线程，用户可自行判断是否需要响应中断。<br>shutdownNow() 要更简单粗暴，可以根据实际场景选择不同的方法。</p>
<p>通常是按照以下方式关闭线程池的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">for (int i = 0; i &lt;= 5; i++) &#123;</span><br><span class="line">    pool.execute(new Job());</span><br><span class="line">&#125;</span><br><span class="line">pool.shutdown();</span><br><span class="line">while (!pool.awaitTermination(1, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    LOGGER.info(&quot;线程还在执行。。。&quot;);</span><br><span class="line">&#125;</span><br><span class="line">long end = System.currentTimeMillis();</span><br><span class="line">LOGGER.info(&quot;一共处理了【&#123;&#125;】&quot;, (end - start));</span><br></pre></td></tr></table></figure></p>
<p>pool.awaitTermination(1, TimeUnit.SECONDS) 会每隔一秒钟检查一次是否执行完毕（状态为 TERMINATED），当从 while 循环退出时就表明线程池已经完全终止了。 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/15/并发编程-线程池源码详解/" data-id="cjw02os6x001kl2i72z74jhdn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发编程/">并发编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-并发编程-ThreadLocal原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/03/并发编程-ThreadLocal原理/" class="article-date">
  <time datetime="2018-05-03T12:58:11.000Z" itemprop="datePublished">2018-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/03/并发编程-ThreadLocal原理/">并发编程-ThreadLocal原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ThreadLocal是一个本地线程副本变量工具类，ThreadLocal的实例代表了一个线程局部的变量，主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。</p>
<h3 id="1-我是什么"><a href="#1-我是什么" class="headerlink" title="1. 我是什么"></a>1. 我是什么</h3><ul>
<li>是让线程拥有独占的变量</li>
<li>它通过set、get方法进行设值和取值操作</li>
<li>它可以覆盖initialValue方法设置初始值，在没进行set之前调用get会调用初始化方法，一个线程只会调用一次</li>
<li>每个线程都会有一个指向threadLocal的弱引用，只要线程一直存活或者该threadLocal实例能被访问到，就不会被GC清理掉。当jvm内存溢出时，会清理掉值为Null的弱引用。</li>
</ul>
<h3 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2. 使用方法"></a>2. 使用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    ThreadLocal&lt;String&gt; stringThreadLocal = new ThreadLocal&lt;String&gt;()&#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected String initialValue()&#123;</span><br><span class="line">            return &quot;default string&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    for(int i = 0; i&lt; 10; i++)&#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            stringThreadLocal.set(Thread.currentThread().getName());</span><br><span class="line">            System.out.println(stringThreadLocal.get());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-我在一个map里"><a href="#3-我在一个map里" class="headerlink" title="3. 我在一个map里"></a>3. 我在一个map里</h3><p>每个线程都有一个ThreadLocalMap对象，map中存放了(ThreadLocal<t>,t)键值对<br><img src="http://ws1.sinaimg.cn/mw690/87c9e458gy1g2dhy5bvohj20me0n9q49.jpg" alt="timg">  </t></p>
<h4 id="3-1-get源码"><a href="#3-1-get源码" class="headerlink" title="3.1 get源码"></a>3.1 get源码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取当前线程内部的ThreadLocalMap</li>
<li>map存在则获取当前ThreadLocal对应的值</li>
<li>不存在则调用setInitialValue进行初始化</li>
</ul>
<h4 id="3-2-setInitialValue-源码"><a href="#3-2-setInitialValue-源码" class="headerlink" title="3.2 setInitialValue()源码"></a>3.2 setInitialValue()源码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private T setInitialValue() &#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用重载的initialValue方法获取初始值</li>
<li>获取当前线程的ThreadLocalMap</li>
<li>map存在则将初始值put进去</li>
<li>map不存在则使用初始值为当前线程创建ThreadLocalMap</li>
</ul>
<h4 id="3-3-set-T-value-源码"><a href="#3-3-set-T-value-源码" class="headerlink" title="3.3 set(T value)源码"></a>3.3 set(T value)源码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取当前线程内部的ThreadLocalMap</li>
<li>map存在则把当前ThreadLocal和value添加到map中</li>
<li>map不存在则创建一个ThreadLocalMap，保存到当前线程内部</li>
</ul>
<p><strong>小结</strong><br>每个线程都有一个ThreadLocalMap类型的私有变量，当为线程添加ThreadLocal对象时，就是保存到了这个map中，所以线程之间不会相互干扰。</p>
<h3 id="4-我还有一个大坑"><a href="#4-我还有一个大坑" class="headerlink" title="4. 我还有一个大坑"></a>4. 我还有一个大坑</h3><p>ThreadLocal使用不当，会引发内存泄露的问题<br>ThreadLocal对象存在thread对象中，只要线程没有死亡，该对象就不会被回收</p>
<p>remove()源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void remove() &#123;</span><br><span class="line">     ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">     if (m != null)</span><br><span class="line">         m.remove(this);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>获取当前线程内部的ThreadLocalMap，存在则从map中删除这个ThreadLocal对象。</li>
</ul>
<h3 id="5-无处不在的map"><a href="#5-无处不在的map" class="headerlink" title="5. 无处不在的map"></a>5. 无处不在的map</h3><p>分析完4个公开方法的源码，发现每个方法都离不开ThreadLocalMap类，下面分析一下这个无处不在的map。</p>
<ul>
<li>ThreadLocalMap是一个自定义的Hashmap，专门用来保存线程的ThreadLocal变量</li>
<li>它的操作仅限于ThreadLocal类中，不对外暴露</li>
<li>这个类被用在Thread类的私有变量threadLocals和inheritableThreadLocals上</li>
<li>为了能够保存大量且存活时间较长的threadLocal实例，hash table entries采用了WeakReferences作为key的类型</li>
<li>一旦hash table运行空间不足，key为null的entry就会被清理掉</li>
</ul>
<p><strong>源码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static class ThreadLocalMap &#123;</span><br><span class="line">    static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">        Object value;</span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            super(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final int INITIAL_CAPACITY = 16;</span><br><span class="line"></span><br><span class="line">    private Entry[] table;</span><br><span class="line"></span><br><span class="line">    private int size = 0;</span><br><span class="line"></span><br><span class="line">    private int threshold; // Default to 0</span><br><span class="line"></span><br><span class="line">    private void setThreshold(int len) &#123;</span><br><span class="line">        threshold = len * 2 / 3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        table = new Entry[INITIAL_CAPACITY];</span><br><span class="line">        int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);</span><br><span class="line">        table[i] = new Entry(firstKey, firstValue);</span><br><span class="line">        size = 1;</span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/03/并发编程-ThreadLocal原理/" data-id="cjw02os5t0008l2i7boor87il" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发编程/">并发编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-并发编程-并发工具类" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/27/并发编程-并发工具类/" class="article-date">
  <time datetime="2018-04-27T12:36:12.000Z" itemprop="datePublished">2018-04-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/27/并发编程-并发工具类/">并发编程-并发工具类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在JDK的并发包中提供了几个非常有用的并发工具类。CountDownLatch、CyclicBarrier和Semaphore提供了并发流程控制手段，Exchanger提供了两个线程之间交换数据的手段，本文将配合应用场景介绍该如何使用这几个工具类。</p>
<h3 id="1-CountDownLatch"><a href="#1-CountDownLatch" class="headerlink" title="1. CountDownLatch"></a>1. CountDownLatch</h3><p>CountDownLatch是JDK 5+里面闭锁的一个实现，他允许一个或多个线程等待其他线程完成各自的工作后再执行。</p>
<p>闭锁（Latch）：一种同步方法，可以延迟线程的进度直到线程到达某个终点状态。</p>
<p>与CountDownLatch第一次交互是主线程等待其它的线程，主线程必须在启动其它线程后立即调用await方法，这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。</p>
<p>其他的N个线程必须引用闭锁对象，因为他们需要通知CountDownLatch对象，他们已经完成了各自的任务，这种机制就是通过调用countDown()方法来完成的。每调用一次这个方法，在构造函数中初始化的count值就减1，所以当N个线程都调用了这个方法count的值等于0，然后主线程就能通过await方法，恢复自己的任务。</p>
<p>与Join的区别：调用join方法需要等待thread执行完毕才能继续向下执行,而CountDownLatch只需要检查计数器的值为零就可以继续向下执行，相比之下，CountDownLatch更加灵活一些，可以实现一些更加复杂的业务场景。</p>
<h4 id="1-1-使用场景"><a href="#1-1-使用场景" class="headerlink" title="1.1 使用场景"></a>1.1 使用场景</h4><ol>
<li>开启多个线程分块下载一个大文件，每个线程只下载固定的一截，最后由另外一个线程来拼接所有的分段。</li>
<li>应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。</li>
<li>确保一个计算不会执行，直到所需要的资源被初始化。</li>
</ol>
<h4 id="1-2-主要方法"><a href="#1-2-主要方法" class="headerlink" title="1.2 主要方法"></a>1.2 主要方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//初始化计数的次数，不能重置</span><br><span class="line">public CountDownLatch(int count); </span><br><span class="line">//调用此方法则计数减1</span><br><span class="line">public void countDown();   </span><br><span class="line">//得到当前的计数</span><br><span class="line">Public Long getCount();           </span><br><span class="line">//调用此方法会一直阻塞当前线程，直到计时器的值为0，除非线程被中断。</span><br><span class="line">public void await() throws InterruptedException   </span><br><span class="line">//调用此方法会一直阻塞当前线程，直到计时器的值为0，除非线程被中断或者计数器超时，返回false代表计数器超时。</span><br><span class="line">Public boolean await(long timeout, TimeUnit unit)</span><br></pre></td></tr></table></figure>
<h4 id="1-3-使用案例"><a href="#1-3-使用案例" class="headerlink" title="1.3 使用案例"></a>1.3 使用案例</h4><ol>
<li>latch.countDown(); 建议放到finally语句里。</li>
<li>对这个计数器的操作都是原子操作，同时只能有一个线程去操作这个计数器。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class CountDownLatchTest &#123;</span><br><span class="line">    private final CountDownLatch latch = new CountDownLatch(3);</span><br><span class="line">    private final ReentrantLock lock = new ReentrantLock();</span><br><span class="line">    private int count;</span><br><span class="line"></span><br><span class="line">    public int getCount()&#123;</span><br><span class="line">        return this.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class RunnableTask implements Runnable&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                count += 100;</span><br><span class="line">            &#125;finally &#123;</span><br><span class="line">                latch.countDown();</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException&#123;</span><br><span class="line">        CountDownLatchTest demo = new CountDownLatchTest();</span><br><span class="line">        int i = 3;</span><br><span class="line">        while(i-- &gt; 0)&#123;</span><br><span class="line">            new Thread(demo.new RunnableTask()).start();</span><br><span class="line">        &#125;</span><br><span class="line">        demo.latch.await();</span><br><span class="line">        System.out.println(demo.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三个线程分别对count加100，等三个线程执行完后，主线程输出count的值。输出300</p>
<h3 id="2-CyclicBarrier"><a href="#2-CyclicBarrier" class="headerlink" title="2. CyclicBarrier"></a>2. CyclicBarrier</h3><p>字面意思是可以循环使用的屏障。他要做的事情是让一组线程到达一个同步点时被阻塞，直到最后一个线程到达同步点，才会打开屏障，所有线程继续运行。</p>
<p>默认的构造方法 CyclicBarrier(int parties) ，参数代表屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier已经到达屏障，然后被阻塞。</p>
<h4 id="1-1-使用场景-1"><a href="#1-1-使用场景-1" class="headerlink" title="1.1 使用场景"></a>1.1 使用场景</h4><p>可用于多线程计算数据，最后合并计算结果</p>
<h4 id="1-2-主要方法-1"><a href="#1-2-主要方法-1" class="headerlink" title="1.2 主要方法"></a>1.2 主要方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//初始化</span><br><span class="line">public CyclicBarrier(int parties)</span><br><span class="line">//barrierAction表示被拦住的线程需要执行的任务</span><br><span class="line">public CyclicBarrier(int parties, Runnable barrierAction)</span><br><span class="line">//被拦住的线程调用次函数进入阻塞状态</span><br><span class="line">public int await()</span><br><span class="line">//被拦住的线程调用次函数进入阻塞状态，超时唤醒</span><br><span class="line">public int await(long timeout, TimeUnit unit)</span><br><span class="line">public void reset() </span><br><span class="line">//返回需要被拦住的线程数量</span><br><span class="line">public int getParties() </span><br><span class="line">//查询此屏障是否处于断开状态</span><br><span class="line">public boolean isBroken()</span><br><span class="line">//返回已被拦住的线程数量</span><br><span class="line">public int getNumberWaiting()</span><br></pre></td></tr></table></figure>
<h4 id="1-3-使用案例-1"><a href="#1-3-使用案例-1" class="headerlink" title="1.3 使用案例"></a>1.3 使用案例</h4><p>初始化线程数为2，加上主线程调用await()3次，所以得出结论主线程调用不计入await次数之内。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class CyclicBarrierTest &#123;</span><br><span class="line">    private static CyclicBarrier cb = new CyclicBarrier(2);</span><br><span class="line">    private static ReentrantLock lock = new ReentrantLock();</span><br><span class="line">    private static int count;</span><br><span class="line">    public static class RunnableTask implements Runnable&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                count += 100;</span><br><span class="line">                cb.await();</span><br><span class="line">            &#125;catch (Throwable e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        for(int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            new Thread(new RunnableTask()).start();</span><br><span class="line">        &#125;</span><br><span class="line">        cb.await();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出200</p>
<h4 id="1-4-与CountDownLatch的区别"><a href="#1-4-与CountDownLatch的区别" class="headerlink" title="1.4 与CountDownLatch的区别"></a>1.4 与CountDownLatch的区别</h4><ul>
<li>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置，可以使用多次，所以CyclicBarrier能够处理更为复杂的场景；</li>
<li>CyclicBarrier还提供了一些其他有用的方法，比如getNumberWaiting()方法可以获得CyclicBarrier阻塞的线程数量，isBroken()方法用来了解阻塞的线程是否被中断；</li>
<li>CountDownLatch允许一个或多个线程等待一组事件的产生，而CyclicBarrier用于等待其他线程运行到栅栏位置。</li>
</ul>
<h3 id="3-Semaphore"><a href="#3-Semaphore" class="headerlink" title="3. Semaphore"></a>3. Semaphore</h3><p>Semaphore是用来控制同事访问特定资源的线程数量，它通过协调各个线程以保证合理的使用公共资源。</p>
<h4 id="3-1-使用场景"><a href="#3-1-使用场景" class="headerlink" title="3.1 使用场景"></a>3.1 使用场景</h4><p>可用于做流量控制，特别是公用资源有限的场景，比如数据库连接。</p>
<h3 id="4-Exchanger"><a href="#4-Exchanger" class="headerlink" title="4. Exchanger"></a>4. Exchanger</h3><p>Exchanger类可用于两个线程之间交换信息。可简单地将Exchanger对象理解为一个包含两个格子的容器，通过exchanger方法可以向两个格子中填充信息。当两个格子中的均被填充时，该对象会自动将两个格子的信息交换，然后返回给线程，从而实现两个线程的信息交换。</p>
<p>Exchanger类仅可用作两个线程的信息交换，当超过两个线程调用同一个exchanger对象时，得到的结果是不确定的，exchanger对象仅关心其包含的两个“格子”是否已被填充数据，当两个格子都填充数据完成时，该对象就认为线程之间已经配对成功，然后开始执行数据交换操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class ExchangerTest &#123;</span><br><span class="line">    private static Exchanger&lt;String&gt; exgr = new Exchanger&lt;&gt;();</span><br><span class="line">    private static ExecutorService threadpool = Executors.newFixedThreadPool(3);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        threadpool.execute(() -&gt; &#123;</span><br><span class="line">            String a = &quot;银行流水A&quot;;</span><br><span class="line">            try &#123;</span><br><span class="line">                exgr.exchange(a);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadpool.execute(() -&gt; &#123;</span><br><span class="line">            String b = &quot;银行流水B&quot;;</span><br><span class="line">            try &#123;</span><br><span class="line">                String a = exgr.exchange(b);</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125; catch (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadpool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/27/并发编程-并发工具类/" data-id="cjw02os5u0009l2i7lmk8cmth" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发编程/">并发编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-并发编程-共享式AQS源码详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/25/并发编程-共享式AQS源码详解/" class="article-date">
  <time datetime="2018-04-25T12:36:12.000Z" itemprop="datePublished">2018-04-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/25/并发编程-共享式AQS源码详解/">并发编程-共享式AQS源码详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>上篇文章详细的阐述了AQS在独占模式下的底层原理，本篇主要讲述共享式同步器的原理。</p>
<h3 id="1-acquireShared-int"><a href="#1-acquireShared-int" class="headerlink" title="1. acquireShared(int)"></a>1. acquireShared(int)</h3><p>此方式是共享模式下线程获取贡献资源的入口，他会获取指定量的资源，获取成功直接返回，失败则进入等待队列，知道获取到资源为止，整个过程忽略终端。下面看源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    //</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected int tryAcquireShared(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 tryAcquireShared 依然需要自定义同步器去实现，但是AQS已经将返回值的语义定义好了，重载该函数的时候执行逻辑要符合下列语义：<br>-返回负值表示获取失败</p>
<ul>
<li>返回0表示获取成功，但是没有剩余资源</li>
<li>返回正数表示获取成功，还有剩余资源</li>
</ul>
<p>tryAcquireShared获取失败则执行 doAcquireShared 方法，看下面源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireShared(int arg) &#123;</span><br><span class="line">        //将线程以共享方式加入同步队列尾部</span><br><span class="line">        final Node node = addWaiter(Node.SHARED);</span><br><span class="line">        //获取失败吗，默认true（失败）</span><br><span class="line">        boolean failed = true;</span><br><span class="line">        try &#123;</span><br><span class="line">            //记录等待过程是否被中断过</span><br><span class="line">            boolean interrupted = false;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                //拿到前驱节点</span><br><span class="line">                final Node p = node.predecessor();</span><br><span class="line">                if (p == head) &#123;//如果前驱是头结点</span><br><span class="line">                    //尝试获取</span><br><span class="line">                    int r = tryAcquireShared(arg);</span><br><span class="line">                    if (r &gt;= 0) &#123;</span><br><span class="line">                        //自己获取资源的同时，如果还有剩余资源,唤醒后继节点</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = null; // help GC</span><br><span class="line">                        if (interrupted)//补上中断标志</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = false;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //前驱不是头结点，获取失败后寻找安全点</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>整个过程与acquireQueued()很相似，区别在于唤醒等待线程的条件不同。setHeadAndPropagate方法在setHead()的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line">    Node h = head; //与独占式不同原head并没有释放资源</span><br><span class="line">    setHead(node);</span><br><span class="line">    </span><br><span class="line">    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||</span><br><span class="line">        (h = head) == null || h.waitStatus &lt; 0) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        if (s == null || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-releaseShared"><a href="#2-releaseShared" class="headerlink" title="2. releaseShared()"></a>2. releaseShared()</h3><p>上一小节已经把acquireShared()说完了，这一小节就来讲讲它的反操作releaseShared()吧。此方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。下面是releaseShared()的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。例如，资源总量是13，A（5）和B（7）分别获取到资源并发运行，C（4）来时只剩1个资源就需要等待。A在运行过程中释放掉2个资源量，然后tryReleaseShared(2)返回true唤醒C，C一看只有3个仍不够继续等待；随后B又释放2个，tryReleaseShared(2)返回true唤醒C，C一看有5个够自己用了，然后C就可以跟A和B一起运行。而ReentrantReadWriteLock读锁的tryReleaseShared()只有在完全释放掉资源（state=0）才返回true，所以自定义同步器可以根据需要决定tryReleaseShared()的返回值。</p>
<h4 id="2-1-doReleaseShared"><a href="#2-1-doReleaseShared" class="headerlink" title="2.1 doReleaseShared()"></a>2.1 doReleaseShared()</h4><p>此方法主要用于唤醒后继。下面是它的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void doReleaseShared() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h != tail) &#123;</span><br><span class="line">            int ws = h.waitStatus;</span><br><span class="line">            if (ws == Node.SIGNAL) &#123;</span><br><span class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                    continue;            // loop to recheck cases</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ws == 0 &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                continue;                // loop on failed CAS</span><br><span class="line">        &#125;</span><br><span class="line">        if (h == head)                   // loop if head changed</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-Semaphore"><a href="#3-Semaphore" class="headerlink" title="3. Semaphore"></a>3. Semaphore</h3><p>一个具象化的例子：<br>停车场运作，假设停车场有10个车位，刚开始都是空的。如果同时来了11辆车，看守者只能允许10辆车进入，另一辆排队等候，当有车为空出来，等候车辆进入填满空车位。Semaphore就相当于停车场看守者。</p>
<p>和RentrantLock不同Semaphore没有实现Lock接口，获取资源有响应中断模式和忽略中断模式，中断模式获取资源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void acquire() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(1);</span><br><span class="line">&#125;</span><br><span class="line">public void acquire(int i) throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>释放资源统一使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void release() &#123;</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br><span class="line">public void release(int i) &#123;</span><br><span class="line">    sync.releaseShared(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部同步器sync重载的tryAcquireShared-tryRealseShared源码如下，代码逻辑简单易懂，实现自定义的同步器一般也只需要实现这几个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//非公平</span><br><span class="line">final int nonfairTryAcquireShared(int acquires) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int available = getState();</span><br><span class="line">        int remaining = available - acquires;</span><br><span class="line">        if (remaining &lt; 0 ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            return remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//公平</span><br><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        if (hasQueuedPredecessors())</span><br><span class="line">            return -1;</span><br><span class="line">        int available = getState();</span><br><span class="line">        int remaining = available - acquires;</span><br><span class="line">        if (remaining &lt; 0 ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            return remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected final boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int current = getState();</span><br><span class="line">        int next = current + releases;</span><br><span class="line">        if (next &lt; current) // overflow</span><br><span class="line">            throw new Error(&quot;Maximum permit count exceeded&quot;);</span><br><span class="line">        if (compareAndSetState(current, next))</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/25/并发编程-共享式AQS源码详解/" data-id="cjw02os5s0005l2i79zhdod3b" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发编程/">并发编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-nginx入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/23/nginx入门/" class="article-date">
  <time datetime="2018-04-23T07:17:36.000Z" itemprop="datePublished">2018-04-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/23/nginx入门/">nginx入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现。</p>
<h3 id="1、正向代理与反向代理"><a href="#1、正向代理与反向代理" class="headerlink" title="1、正向代理与反向代理"></a>1、正向代理与反向代理</h3><h4 id="1-1-正向代理：代理服务器代表的是客户端，代理对服务器端透明。"><a href="#1-1-正向代理：代理服务器代表的是客户端，代理对服务器端透明。" class="headerlink" title="1.1 正向代理：代理服务器代表的是客户端，代理对服务器端透明。"></a>1.1 正向代理：代理服务器代表的是客户端，代理对服务器端透明。</h4><p>正向代理的应用场景：  </p>
<ul>
<li>vpn  </li>
<li>缓存，加速访问资源  </li>
<li>对客户端访问授权，上网进行认证  </li>
<li>记录用户的上网记录，对外隐藏用户信息  </li>
</ul>
<p>正向代理产品：CCProxy  </p>
<h4 id="1-2-反向代理：代理服务器代表的是服务器端，代理对客户端透明"><a href="#1-2-反向代理：代理服务器代表的是服务器端，代理对客户端透明" class="headerlink" title="1.2 反向代理：代理服务器代表的是服务器端，代理对客户端透明"></a>1.2 反向代理：代理服务器代表的是服务器端，代理对客户端透明</h4><p>反向代理的应用场景：</p>
<ul>
<li>保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击</li>
<li>负载均衡  </li>
</ul>
<p>反向代理产品：Nginx  </p>
<p><img src="http://ws1.sinaimg.cn/mw690/87c9e458gy1g2cldja14kj20rm0op7wh.jpg" alt="正向代理和反向代理">  </p>
<h3 id="2、nginx安装"><a href="#2、nginx安装" class="headerlink" title="2、nginx安装"></a>2、nginx安装</h3><h4 id="2-1-安装环境"><a href="#2-1-安装环境" class="headerlink" title="2.1 安装环境"></a>2.1 安装环境</h4><ul>
<li>yum -y install wget      #安装下载工具</li>
<li>yum install -y gcc gcc-c++        #安装gcc编译环境</li>
<li>yum install -y pcre-devel          #安装PERE库</li>
<li>yum -y install openssl openssl-devel    #安装OpenSsl库</li>
</ul>
<h4 id="2-2-准备安装nginx"><a href="#2-2-准备安装nginx" class="headerlink" title="2.2 准备安装nginx"></a>2.2 准备安装nginx</h4><ul>
<li>wget <a href="http://nginx.org/download/nginx-1.14.0.tar.gz" target="_blank" rel="noopener">http://nginx.org/download/nginx-1.14.0.tar.gz</a>   #下载</li>
<li>tar -zxf nginx-1.14.0.tar.gz             #解压</li>
<li>cd nginx-1.14.0 </li>
<li>sed -i -e’s/1.14.0//g’ -e’ s/nginx\//WS/g’ -e’s/“NGINX”/“WS”/g’ src/core/nginx.h    #隐藏版本号(安全性考虑，爆出有些版本的nginx存在漏洞，容易被攻击)</li>
</ul>
<h4 id="2-3编译安装nginx"><a href="#2-3编译安装nginx" class="headerlink" title="2.3编译安装nginx"></a>2.3编译安装nginx</h4><ul>
<li>useradd www      #添加用户，不添加默认为nobody</li>
<li>./configure –user=www –group=www –prefix=/usr/local/nginx –with-http_ssl_module</li>
<li>make &amp; make install</li>
</ul>
<h3 id="3、nginx的五种负载分配算法"><a href="#3、nginx的五种负载分配算法" class="headerlink" title="3、nginx的五种负载分配算法"></a>3、nginx的五种负载分配算法</h3><h4 id="3-1-round-robin（默认）"><a href="#3-1-round-robin（默认）" class="headerlink" title="3.1 round robin（默认）"></a>3.1 round robin（默认）</h4><p>轮询方式，依次将请求分配到各个后台服务器中，默认的负载均衡方式。<br>适用于后台机器性能一致的情况。<br>挂掉的机器可以自动从服务列表中剔除。</p>
<h4 id="3-2-weight"><a href="#3-2-weight" class="headerlink" title="3.2 weight"></a>3.2 weight</h4><p>根据权重来分发请求到不同的机器中，指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream bakend &#123;    </span><br><span class="line">    server 192.168.0.14 weight=10;    </span><br><span class="line">    server 192.168.0.15 weight=10;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-3-IP-hash"><a href="#3-3-IP-hash" class="headerlink" title="3.3 IP_hash"></a>3.3 IP_hash</h4><p>根据请求者ip的hash值将请求发送到后台服务器中，可以保证来自同一ip的请求被打到固定的机器上，可以解决session问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream bakend &#123;    </span><br><span class="line">	ip_hash;    </span><br><span class="line">	server 192.168.0.14:88;    </span><br><span class="line">	server 192.168.0.15:80;    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-4-url-hash（第三方）"><a href="#3-4-url-hash（第三方）" class="headerlink" title="3.4 url_hash（第三方）"></a>3.4 url_hash（第三方）</h4><p>根据请求的url的hash值将请求分到不同的机器中，当后台服务器为缓存的时候效率高。<br>例如：<br>在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;    </span><br><span class="line">    server squid1:3128;    </span><br><span class="line">    server squid2:3128;    </span><br><span class="line">    hash $request_uri;    </span><br><span class="line">    hash_method crc32;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-5-fair（第三方）"><a href="#3-5-fair（第三方）" class="headerlink" title="3.5 fair（第三方）"></a>3.5 fair（第三方）</h4><p>根据后台响应时间来分发请求，响应时间短的分发的请求多。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;    </span><br><span class="line">    server server1;    </span><br><span class="line">    server server2;    </span><br><span class="line">    fair;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/23/nginx入门/" data-id="cjw02os5q0004l2i7sgqauz39" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-并发编程-独占式AQS源码详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/19/并发编程-独占式AQS源码详解/" class="article-date">
  <time datetime="2018-04-19T12:36:12.000Z" itemprop="datePublished">2018-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/19/并发编程-独占式AQS源码详解/">并发编程-独占式AQS源码详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-框架概述"><a href="#1-框架概述" class="headerlink" title="1. 框架概述"></a>1. 框架概述</h3><p>AQS是AbstractQueuedSynchronizer的简称，抽象队列同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类的实现都依赖于它，比如常用的ReentrantLock/CountDownLatch/Semaphore…</p>
<p>AQS维护了一个volatile int state 代表共享资源，一个FIFO线程等待队列用来记录争用资源而进入等待的线程，这里有一点需要强调，AQS同步队列中的线程是处于WAITING状态的，而竞争synchronized同步块的线程是处于BLOCKING状态的。</p>
<p>AQS定义了两种组员共享方式：Exclusive 和 Share</p>
<p>自定义同步器在实现时只需要实现共享资源state的获取与释放方式，至于具体的线程等待队列的维护，AQS已经实现好了。自定义同步器是现实需要实现的几个方法：</p>
<ul>
<li>isHeldExclusively() 该线程是否正在独占资源，只有用到Condition才需要实现它</li>
<li>tryAcquire(int) 独占方式获取资源，获取成功返回ture</li>
<li>tryRelease(int) 独占方式释放资源，释放成功返回ture</li>
<li>tryAcquireShared(int) 共享方式获取资源，负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>
<li>tryReleaseShared(int) 共享方式释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li>
</ul>
<p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p>
<p>再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p>
<h3 id="2-源码详解"><a href="#2-源码详解" class="headerlink" title="2. 源码详解"></a>2. 源码详解</h3><p>本节依照acquire-release、acquireShared-releaseShared的次序来讲解AQS的源码实现。</p>
<h4 id="2-1-acquire-int"><a href="#2-1-acquire-int" class="headerlink" title="2.1 acquire(int)"></a>2.1 acquire(int)</h4><p>该方法是在独占模式下获取共享资源的底层入口，如果获取资源成功tryAcquire返回true，该函数直接返回，且整个过程忽略中断的影响；否则调用addWaiter将线程包装成Node对象进入阻塞队列，并不断acquireQueued获取资源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数流程如下：</p>
<ol>
<li>tryAcquire() 尝试直接去获取资源，如果成功则直接返回；</li>
<li>addWaiter() 将该线程加入等待队列的尾部，并标记为独占模式；</li>
<li>acquireQueued() 使线程在等待队列中尝试获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li>
<li>如果线程在等待过程中被中断过，它是不响应的（关于中断的介绍请参考文章线程中断），获取资源后通过selfInterrupt()，将该线程的中断标志置为true。</li>
</ol>
<h5 id="2-1-1-tryAcquire-int"><a href="#2-1-1-tryAcquire-int" class="headerlink" title="2.1.1 tryAcquire(int)"></a>2.1.1 tryAcquire(int)</h5><p>此方法尝试获取独占资源，如果成功返回true，否则返回false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AQS中该方法没有具体的执行逻辑，这是因为这是AQS定义DE1一个方法模板，具体的实现需要自定义同步类自己完成，能不能重入，竞争资源时可不可以加塞，都需要子类自己设计。如果子类没有实现该方法，就会调用AQS的默认实现，如上直接抛出异常。</p>
<h5 id="2-1-2-addWaiter-Node"><a href="#2-1-2-addWaiter-Node" class="headerlink" title="2.1.2 addWaiter(Node)"></a>2.1.2 addWaiter(Node)</h5><p>此方法作用是将当前线程加入到阻塞队列的队尾，并返回当前线程所在节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">    Node node = new Node(Thread.currentThread(), mode);</span><br><span class="line">    // 尝试快速入队</span><br><span class="line">    Node pred = tail;</span><br><span class="line">    if (pred != null) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //快速入队失败，调用enq方法入队</span><br><span class="line">    enq(node);</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>先介绍一下Node，Node节点是对每一个竞争同步代码的线程的封装，主要包含了当前线程对象以及线程的状态。变量waitStatus表示当前Node节点的等待状态，共有4中取值CANCELLED、SIGNAL、CONDITION、PROPAGATE</p>
<ul>
<li>CANCELLED ： 值为1，表示当前节点处于结束状态，在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该Node节点</li>
<li>SIGNAL 值为-1，表示当前节点线程取消或者释放资源的时候，需要unpark其后继节点</li>
<li>CONDITION 值为-2，表示当前节点处于条件队列，在转变（状态被设为0）之前不会被当做同步队列节点</li>
<li>PROPAGATE 值为-3，与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态</li>
<li>0 代表初始状态。</li>
</ul>
<h5 id="2-1-3-enq-Node"><a href="#2-1-3-enq-Node" class="headerlink" title="2.1.3 enq(Node)"></a>2.1.3 enq(Node)</h5><p>此方法用于将node加入队尾。源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        if (t == null) &#123; // Must initialize</span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你看过AtomicInteger.getAndIncrement()函数源码，那么相信你一眼便看出这段代码的精华。CAS自旋volatile变量，是一种很经典的用法。</p>
<h5 id="2-1-4-acquireQueued-Node-int"><a href="#2-1-4-acquireQueued-Node-int" class="headerlink" title="2.1.4 acquireQueued(Node, int)"></a>2.1.4 acquireQueued(Node, int)</h5><p>通过tryAcquire()和addWaiter()，该线程获取资源失败，已经被放入等待队列尾部了，下一步该干什么？进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了。这个函数非常关键，上源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    //获取资源失败了吗，true就是失败了</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        //标识等待过程中是否被中断过</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            //获得当前节点的前驱</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            //如果前驱是head，那就有资格去尝试获取</span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                //获取资源成功，将自己设置成head</span><br><span class="line">                setHead(node);</span><br><span class="line">                //help GC，原头结点断开与队列的链接，等待被回收</span><br><span class="line">                p.next = null; </span><br><span class="line">                failed = false;//表示获取资源成功</span><br><span class="line">                return interrupted; </span><br><span class="line">            &#125;</span><br><span class="line">            //先判断此次获取失败后可不可以 WAITTING，如果不能，继续重复循环</span><br><span class="line">            //执行park让线程进入WAITTING状态，并判断等待过程中有没有中断，发生过就改状态</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么怎么判断线程是不是应该执行park()呢？继续看下面代码，shouldParkAfterFailedAcquire方法主要用于检查状态，看看自己是否真的可以去休息了（进入waiting状态），万一排在队列前边的线程都放弃了只是瞎站着，那就需要往前加塞。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">    //获取前驱节点的状态</span><br><span class="line">    int ws = pred.waitStatus;</span><br><span class="line">    //如果前驱节点状态是SIGNAL，说明前驱节点释放资源后会通知本节点，可以安全的执行park()</span><br><span class="line">    if (ws == Node.SIGNAL)</span><br><span class="line">        return true;</span><br><span class="line">    if (ws &gt; 0) &#123;</span><br><span class="line">        //如果前驱节点是取消状态CANCELLED，执行加塞操作，跳过所有取消节点</span><br><span class="line">        do &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //如果前驱节点状态正常有效，那就把前驱节点的状态设置成SIGNAL，前驱节点执行完释放资源就会通知本节点</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    //返回false表示此次循环不能更改线程状态，返回到acquireQueued方法即系执行循环获取资源</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个流程用一句话概括，如果前驱结点的状态不是SIGNAL，那么自己就不能放心去休息，需要去找个安全的休息点，找到安全点后可以再尝试下看能不能获取资源，再次获取失败就可以放心进入WAITTING状态。</p>
<p>parkAndCheckInterrupt方法就是让线程执行park()进入WAITTINGZ状态，并返回该线程的中断标志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">    LockSupport.park(this);</span><br><span class="line">    return Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，Thread.interrupted()方法在获取线程中断标志的同事会将该标志复位为false</p>
<h5 id="2-1-5-小结"><a href="#2-1-5-小结" class="headerlink" title="2.1.5 小结"></a>2.1.5 小结</h5><p>源码再贴一遍：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">        if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>获取独占资源流程如下：<br><img src="https://zzk-markdown.oss-cn-hangzhou.aliyuncs.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/aqs.jpg" alt="AQS流程图"></p>
<ol>
<li>调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回；</li>
<li>没成功，则addWaiter()将该线程加入等待队列的尾部；</li>
<li>acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li>
<li>如果线程在等待过程中被中断过，它是不响应的，并且中断标志被Thread.interrupted()重置为false了，所以获取资源后才再进行自我中断selfInterrupt()，将中断标志重置为true。</li>
</ol>
<h4 id="2-2-release-int"><a href="#2-2-release-int" class="headerlink" title="2.2 release(int)"></a>2.2 release(int)</h4><p>release是独占模式下线程释放共享资源的底层接口。它会释放指定量的资源，如果彻底释放了（即state=0），它会唤醒等待队列里的其他线程来获取资源。<br>源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">        if (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">                unparkSuccessor(h);//唤醒后继节点</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>逻辑并不复杂。它调用tryRelease()来释放资源。有一点需要注意的是，它是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了。所以自定义同步器在设计tryRelease()的时候要明确这一点</p>
<h5 id="2-2-1-tryRelease-int"><a href="#2-2-1-tryRelease-int" class="headerlink" title="2.2.1 tryRelease(int)"></a>2.2.1 tryRelease(int)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected boolean tryRelease(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟tryAcquire()一样，这个方法是需要独占模式的自定义同步器去实现的。正常来说，tryRelease()都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可(state-=arg)，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，release()是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回true，否则返回false。</p>
<h5 id="2-2-2-unparkSuccessor-Node"><a href="#2-2-2-unparkSuccessor-Node" class="headerlink" title="2.2.2 unparkSuccessor(Node)"></a>2.2.2 unparkSuccessor(Node)</h5><p>此方法用于唤醒等待队列中下一个线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">        //获取当前节点的状态</span><br><span class="line">        int ws = node.waitStatus;</span><br><span class="line">        if (ws &lt; 0)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, 0);//置0</span><br><span class="line">        //获取下一个将唤醒的节点</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        //若后继节点已取消，找到最靠近head的有效节点</span><br><span class="line">        if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">            s = null;</span><br><span class="line">            for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                //waitStatus&lt;=0的都是有效节点，都可以唤醒</span><br><span class="line">                if (t.waitStatus &lt;= 0)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        if (s != null)</span><br><span class="line">            LockSupport.unpark(s.thread);//唤醒</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>一句话概括，用用unpark()唤醒等待队列中最前边的那个有效线程。</p>
<h3 id="3-ReentrantLock"><a href="#3-ReentrantLock" class="headerlink" title="3. ReentrantLock"></a>3. ReentrantLock</h3><p>ReentrantLock自身没有继承AQS，但是它持有一个AQS的子类Sync的对象实例sync，Sync又派生了两个子类 FairSync 和 NonfairSync。ReentrantLock实例化时，无参的默认构造函数会使用NonfairSync对sync进行初始化；而接受一个布尔型变量的构造函数根据用户传入的参数决定使用公平锁还是非公平锁。</p>
<p>公平性是针对锁获取而言的，如果是公平锁，那么锁的获取顺序应该符合请求的绝对时间顺序，也就是FIFO，该原则保证公平的代价是进行大量的线程切换。非公平锁虽然可能造成线程饥饿，但是极少的线程切换保证了其更大的吞吐量，因此ReentrantLock默认实现非公平锁。</p>
<h4 id="3-1-获取锁"><a href="#3-1-获取锁" class="headerlink" title="3.1 获取锁"></a>3.1 获取锁</h4><p>下面代码是非公平锁和公平锁分别获取资源的操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    //获取当前线程对象</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    int c = getState();</span><br><span class="line">    if (c == 0) &#123;//如果资源空闲，CAS设置状态量</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果资源被占用，判断持有锁的线程是不是本线程，是的话重入</span><br><span class="line">    else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0) // overflow</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重入锁的意义就是持有锁的线程可以多次重复进入临界区，而不需要在同步队列中等待，每次进入状态量加1，进入几次就要释放几次，释放1次状态量减1，当状态量为0时，完全释放资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    int c = getState();</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">    //注意与非公平锁的区别</span><br><span class="line">        if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较以上两个获取资源的函数，发现唯一的区别在于公平锁在设置状态量之前多做了一次判断 !hasQueuedPredecessors()，该函数返回是否有线程排在当前线程前面，如果没有则可以获得锁。hasQueuedPredecessors源码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final boolean hasQueuedPredecessors() &#123;</span><br><span class="line">        Node t = tail; // Read fields in reverse initialization order</span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        //队列中不止一个线程</span><br><span class="line">        //并且第二个线程节点为空或者第二个节点不是是自己</span><br><span class="line">        return h != t &amp;&amp;</span><br><span class="line">            ((s = h.next) == null || s.thread != Thread.currentThread());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-2-释放锁"><a href="#3-2-释放锁" class="headerlink" title="3.2 释放锁"></a>3.2 释放锁</h4><p>释放操作没有公平与非公平之分，所以释放操作是在父类Sync中实现，下面看源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    int c = getState() - releases;</span><br><span class="line">    //如果当前线程不是占用线程，抛异常</span><br><span class="line">    if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    boolean free = false;</span><br><span class="line">    //状态量等于0，才是真正释放</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        free = true;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为释放锁之前，当前线程还持有锁，其他线程无权访问，所以修改状态没有用CAS，直接使用setState</p>
<p>共享式同步器 请看下一篇 并发编程-共享式AQS源码详解</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/19/并发编程-独占式AQS源码详解/" data-id="cjw02os6w001jl2i722wsj484" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发编程/">并发编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-spring-HV参数校验" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/02/spring-HV参数校验/" class="article-date">
  <time datetime="2018-04-02T07:39:40.000Z" itemprop="datePublished">2018-04-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/02/spring-HV参数校验/">spring-HV参数校验</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>参数验证是一个常见的问题，无论是前端还是后台，都需对用户输入进行验证，以此来保证系统数据的正确性。对于web来说，有些人可能理所当然的想在前端验证就行了，但这样是非常错误的做法，前端代码对于用户来说是透明的，稍微有点技术的人就可以绕过这个验证，直接提交数据到后台。无论是前端网页提交的接口，还是提供给外部的接口，参数验证随处可见，也是必不可少的。前端做验证只是为了用户体验，比如控制按钮的显示隐藏，单页应用的路由跳转等等。后端才是最终的保障。总之，一切用户的输入都是不可信的。</p>
<h3 id="1、gradle依赖"><a href="#1、gradle依赖" class="headerlink" title="1、gradle依赖"></a>1、gradle依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;org.springframework.boot:spring-boot-starter-validation&apos;</span><br></pre></td></tr></table></figure>
<h3 id="2、常用约束"><a href="#2、常用约束" class="headerlink" title="2、常用约束"></a>2、常用约束</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Null             被注释的元素必须为 null     </span><br><span class="line">@NotNull          被注释的元素必须不为 null     </span><br><span class="line">@AssertTrue       被注释的元素必须为 true     </span><br><span class="line">@AssertFalse      被注释的元素必须为 false     </span><br><span class="line">@Min(value)       被注释的元素必须是一个数字，其值必须大于等于指定的最小值     </span><br><span class="line">@Max(value)       被注释的元素必须是一个数字，其值必须小于等于指定的最大值     </span><br><span class="line">@DecimalMin(value)  被注释的元素必须是一个数字，其值必须大于等于指定的最小值 </span><br><span class="line">@DecimalMax(value)  被注释的元素必须是一个数字，其值必须小于等于指定的最大值</span><br><span class="line">@Size(max=, min=)   被注释的元素的大小必须在指定的范围内     </span><br><span class="line">@Digits (integer, fraction)  被注释的元素必须是一个数字，其值必须在可接受的范围内     </span><br><span class="line">@Past   被注释的元素必须是一个过去的日期     </span><br><span class="line">@Future     被注释的元素必须是一个将来的日期     </span><br><span class="line">@Pattern(regex=,flag=)  被注释的元素必须符合指定的正则表达式Hibernate Validator附加的constraint     </span><br><span class="line">@NotBlank(message =)   验证字符串非null，且长度必须大于0     </span><br><span class="line">@Email  被注释的元素必须是电子邮箱地址     </span><br><span class="line">@Length(min=,max=)  被注释的字符串的大小必须在指定的范围内     </span><br><span class="line">@NotEmpty   被注释的字符串的必须非空     </span><br><span class="line">@Range(min=,max=,message=)  被注释的元素必须在合适的范围内</span><br></pre></td></tr></table></figure>
<h3 id="3、使用方法"><a href="#3、使用方法" class="headerlink" title="3、使用方法"></a>3、使用方法</h3><ul>
<li>在model类中使用注解约束字段</li>
<li>接口中需要校验的model对象前使用@Valid注解，并在接口方法参数列表中增加BindingResult对象来接受校验错误信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(value = &quot;/demo&quot;)</span><br><span class="line">    public Integer addDemo(@Valid @RequestBody Demo demo, BindingResult bindingResult)&#123;</span><br><span class="line">        if(bindingResult.hasErrors())&#123;</span><br><span class="line">            for(ObjectError error : bindingResult.getAllErrors())&#123;</span><br><span class="line">                throw new DemoException(DemoExceptionEnum.PARAM_ERROR.getCode(),error.getDefaultMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return demoService.insert(demo);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>注意：如果在一个接口中有多个参数需要校验，那么每一个参数都需要定义一个BindingResult对象来接收校验结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void test()(@RequestBody @Valid DemoModel demo, BindingResult result)</span><br><span class="line"></span><br><span class="line">public void test()(@RequestBody @Valid DemoModel demo, BindingResult result,@RequestBody @Valid DemoModel demo2, BindingResult result2)</span><br></pre></td></tr></table></figure>
<h3 id="4、深入使用"><a href="#4、深入使用" class="headerlink" title="4、深入使用"></a>4、深入使用</h3><h4 id="4-1-配置校验模式"><a href="#4-1-配置校验模式" class="headerlink" title="4.1 配置校验模式"></a>4.1 配置校验模式</h4><ul>
<li>默认的校验模式为<strong>普通模式</strong>，普通模式下会校验完所有的属性然后返回所有的校验失败信息</li>
<li>可配置为<strong>快速失败返回模式</strong>，只要有一个属性校验失败则立即返回</li>
</ul>
<blockquote>
<p>配置方式</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ValidatorConfiguration &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Validator validator()&#123;</span><br><span class="line">        ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )</span><br><span class="line">                .configure()</span><br><span class="line">            　　/**设置validator模式为快速失败返回*/</span><br><span class="line">                .addProperty( &quot;hibernate.validator.fail_fast&quot;, &quot;true&quot; )</span><br><span class="line">                .buildValidatorFactory();</span><br><span class="line">        Validator validator = validatorFactory.getValidator();</span><br><span class="line"></span><br><span class="line">        return validator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-分组校验"><a href="#4-2-分组校验" class="headerlink" title="4.2 分组校验"></a>4.2 分组校验</h4><ul>
<li><p>使用场景：针对同一个model类，不同的接口需要对不同的属性进行校验  </p>
<blockquote>
<p>例如，数据插入接口与数据更新接口需要校验的参数是不同的</p>
<ul>
<li>使用方法  <ol>
<li>在model类中定义内部接口 </li>
<li>约束增加组别属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;    public class Demo&#123;</span><br><span class="line">&gt;        public interface AddGorup&#123;&#125;</span><br><span class="line">&gt;        public interface UpdateGroup&#123;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
</blockquote>
<pre><code>@Range(min = 1,max = Integer.MAX_VALUE,groups = {UpdateGroup.class})
private Integer id;
@Email(groups = {AddGroup.class,UpdateGroup.class})
private String email;
@Past(groups = {UpdateGroup.class})
private Date birthday; 
</code></pre><p>  }</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   3. 在接口中使用@Validated(&#123;Demo.AddGroup.class&#125;)来注解参数，表示该参数使用AddGroup来进行校验</span><br><span class="line">     </span><br><span class="line">     &gt;约束的groups属性中可以填写多个接口名，表示该参数加入多个组进行校验</span><br><span class="line">   4. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 4.3 自定义约束</span><br><span class="line">- 创建约束标注</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>@Target({ElementType.METHOD,ElementType.ANNOTATION_TYPE,ElementType.FIELD,ElementType.PARAMETER})<br>@Retention(RetentionPolicy.RUNTIME)<br>@Constraint(validatedBy = DemoConstraintValidator.class)<br>@Documented<br>public @interface DemoConstraint {<br>    String message() default “default message”;<br>    Class&lt;?&gt;[] groups() default {};<br>    Class&lt;? extends Payload&gt;[] payload() default {};<br>    E value();//约束中设置的value值<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 实现一个验证器</span><br></pre></td></tr></table></figure></p>
<p>/**</p>
<ul>
<li>T  自定义的约束注解类型DemoConstraint</li>
<li><p>V  需要检验的参数类型<br>public class DemoConstraintValidator implements ConstraintValidator&lt;T, V&gt;{<br> private E value;//注入设置的具体约束<br> @Override<br> public void initialize(T t) {</p>
<pre><code>this.value = t.value();
</code></pre><p> }</p>
<p> @Override<br> public boolean isValid(V v, ConstraintValidatorContext constraintValidatorContext) {</p>
<pre><code>//根据value 对 参数v 进行一些判断
return true;
if(!isValid) {
    constraintContext.disableDefaultConstraintViolation();
    constraintContext.buildConstraintViolationWithTemplate(&quot;new default message&quot;).addConstraintViolation();
    return false;
}
</code></pre><p> }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  &gt;T表示创建的注解，V表示该约束校验的数据类型</span><br><span class="line">- 定义默认的验证错误信息  </span><br><span class="line">可以通过ConstraintValidatorContext修改默认的message信息，一旦使用，在注解中给message赋值将不起作用（一般情况下不推荐使用）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 4.4 检验组序列</span><br><span class="line">默认情况下，约束的计算没有特定的顺序，这与它们属于哪个组无关。然而，在某些情况下，控制约束求值的顺序是有用的，例如，我们可以要求在检查汽车的道路价值之前，首先通过所有默认的汽车约束。最后，在我们开车离开之前，我们检查了实际司机的约束条件。为了实现这样的顺序，需要定义一个新的接口，并使用@GroupSequence对其进行注释，以定义必须验证组的顺序。</span><br><span class="line">~~~</span><br><span class="line">注意：</span><br><span class="line">如果这个校验组序列中有一个约束条件没有通过验证的话, 那么此约束条件后面的都不会再继续被校验了.</span><br><span class="line">~~~</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>@GroupSequence({Default.class, CarChecks.class, DriverChecks.class})<br>public interface OrderedChecks {<br>}<br><code>`</code></p>
<h3 id="5、-Valid-amp-Validated"><a href="#5、-Valid-amp-Validated" class="headerlink" title="5、@Valid  &amp; @Validated"></a>5、@Valid  &amp; @Validated</h3><table>
<thead>
<tr>
<th>用法</th>
<th style="text-align:center">@valid</th>
<th style="text-align:center">@validated</th>
</tr>
</thead>
<tbody>
<tr>
<td>类名前</td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>类属性前</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>方法前</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>入参前</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li>类名前是否加@Validated只影响@RequestParam注解的参数校验，如要进行校验，必须加。  </li>
<li>不需要分组校验的情况下，接口入参之前只能注解@Valid才能正常校验</li>
<li>需要分组校验的时候，接口入参之前需要使用@Validated({GroupA.class,…})才能正常校验</li>
<li>@Valid用在类成员属性名之前，是为了实现嵌套校验</li>
</ul>
</blockquote>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://docs.jboss.org/hibernate/validator/4.2/reference/zh-CN/html_single/#preface" target="_blank" rel="noopener">官方文档</a><br><a href="https://www.cnblogs.com/mr-yang-localhost/p/7812038.html" target="_blank" rel="noopener">springboot使用hibernate validator校验</a><br><a href="https://blog.csdn.net/qq_27680317/article/details/79970590" target="_blank" rel="noopener">@Validated和@Valid区别</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/02/spring-HV参数校验/" data-id="cjw02os6j0013l2i7kuc9rar3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/">spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-并发编程-线程中断" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/20/并发编程-线程中断/" class="article-date">
  <time datetime="2018-03-20T12:36:12.000Z" itemprop="datePublished">2018-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/20/并发编程-线程中断/">并发编程-线程中断</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>中断可以理解为现成的一个标识位属性，它表示一个运行中的线程是否被被其他线程进行了中断操作。中断好比其他线程对该线程打了个招呼，其他线程通过调用该线程的interrupt()方法对其进行中断操作。</p>
<p>线程通过检查自身是否被中断来进行响应，线程通过方法 isInterrupted()来进行判断是否被中断，也可以调用静态方法Thread.interrupted()对当前线程的中断标识进行复位。如果该线程已经处于中介状态，即使该线程被中断过，在调用该线程对象的isInterrupted()时依旧会返回false。</p>
<p>本篇将从以下两个方面来介绍Java中对线程中断机制的具体实现：</p>
<ol>
<li>Java中对线程中断所提供的API支持</li>
<li>线程在不同状态下对于中断所产生的反应</li>
</ol>
<h3 id="1-Java中线程中断的API"><a href="#1-Java中线程中断的API" class="headerlink" title="1. Java中线程中断的API"></a>1. Java中线程中断的API</h3><p>在以前的jdk版本中，我们使用stop方法中断线程，但是现在的jdk版本中已经不再推荐使用该方法了，反而由以下三个方法完成对线程中断的支持。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean isInterrupted()</span><br><span class="line"></span><br><span class="line">public void interrupt()</span><br><span class="line"></span><br><span class="line">public static boolean interrupted()</span><br></pre></td></tr></table></figure></p>
<p>每个线程都一个状态位用于标识当前线程对象是否是中断状态。isInterrupted是一个实例方法，主要用于判断当前线程对象的中断标志位是否被标记了，如果被标记了则返回true表示当前已经被中断，否则返回false。我们也可以看看它的实现源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean isInterrupted() &#123;</span><br><span class="line">        return isInterrupted(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private native boolean isInterrupted(boolean ClearInterrupted);</span><br></pre></td></tr></table></figure>
<p>底层调用的本地方法isInterrupted，传入一个boolean类型的参数，用于指定调用该方法之后是否需要清除该线程对象的中断标识位。从这里我们也可以看出来，调用isInterrupted并不会清除线程对象的中断标识位。</p>
<p>interrupt也是一个实例方法，该方法用于设置线程对象的中断标识位，只要能获取到实例对象，就能调用该方法。</p>
<p>interrupted是一个静态的方法，用于返回当前线程是否被中断，并清空标志位。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static boolean interrupted() &#123;</span><br><span class="line">    return currentThread().isInterrupted(true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private native boolean isInterrupted(boolean ClearInterrupted);</span><br></pre></td></tr></table></figure>
<p>该方法用于判断当前线程是否被中断，并且该方法调用结束的时候会清空中断标识位。下面我们看看线程所处不同状态下对于中断操作的反应。</p>
<h3 id="2-线程在不同状态下对于中断所产生的反应"><a href="#2-线程在不同状态下对于中断所产生的反应" class="headerlink" title="2. 线程在不同状态下对于中断所产生的反应"></a>2. 线程在不同状态下对于中断所产生的反应</h3><p>线程一共6种状态，分别是NEW，RUNNABLE，BLOCKED，WAITING，TIMED_WAITING，TERMINATED（Thread类中有一个State枚举类型列举了线程的所有状态）。下面我们就将把线程分别置于上述的不同种状态，然后看看我们的中断操作对它们的影响。</p>
<h4 id="2-1-NEW和TERMINATED"><a href="#2-1-NEW和TERMINATED" class="headerlink" title="2.1 NEW和TERMINATED"></a>2.1 NEW和TERMINATED</h4><p>线程的new状态表示还未调用start方法，还未真正启动。线程的terminated状态表示线程已经运行终止。这两个状态下调用中断方法来中断线程的时候，Java认为毫无意义，所以并不会设置线程的中断标识位，什么事也不会发生。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    Thread thread = new MyThread();</span><br><span class="line">    System.out.println(thread.getState());</span><br><span class="line">    thread.interrupt();</span><br><span class="line">    System.out.println(thread.isInterrupted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NEW</span><br><span class="line">fales</span><br></pre></td></tr></table></figure></p>
<p>terminated状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    Thread thread = new MyThread();</span><br><span class="line">    thread.start();</span><br><span class="line">    thread.join();</span><br><span class="line">    System.out.println(thread.getState());</span><br><span class="line">    thread.interrupt();</span><br><span class="line">    System.out.println(thread.isInterrupted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TERMINATED</span><br><span class="line">false</span><br></pre></td></tr></table></figure></p>
<p>从上述的两个例子来看，对于处于new和terminated状态的线程对于中断是屏蔽的，也就是说中断操作对这两种状态下的线程是无效的。</p>
<h4 id="2-2-RUNNABLE"><a href="#2-2-RUNNABLE" class="headerlink" title="2.2 RUNNABLE"></a>2.2 RUNNABLE</h4><p>如果线程处于运行状态，那么该线程的状态就是RUNNABLE，但是不一定所有处于RUNNABLE状态的线程都能获得CPU运行，在某个时间段，只能由一个线程占用CPU，那么其余的线程虽然状态是RUNNABLE，但是都没有处于运行状态。而我们处于RUNNABLE状态的线程在遭遇中断操作的时候只会设置该线程的中断标志位，并不会让线程实际中断，想要发现本线程已经被要求中断了则需要用程序去判断。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends Thread&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    Thread thread = new MyThread();</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(thread.getState());</span><br><span class="line"></span><br><span class="line">    thread.interrupt();</span><br><span class="line">    Thread.sleep(1000);//等到thread线程被中断之后</span><br><span class="line">    System.out.println(thread.isInterrupted());</span><br><span class="line">    System.out.println(thread.getState());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义的线程始终循环做一些事情，主线程启动该线程并输出该线程的状态，然后调用中断方法中断该线程并再次输出该线程的状态。总的输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUNNABLE</span><br><span class="line">ture</span><br><span class="line">RUNNABLE</span><br></pre></td></tr></table></figure>
<p>可以看到在我们启动线程之后，线程状态变为RUNNABLE，中断之后输出中断标志，显然中断位已经被标记，但是当我们再次输出线程状态的时候发现，线程仍然处于RUNNABLE状态。很显然，处于RUNNBALE状态下的线程即便遇到中断操作，也只会设置中断标志位并不会实际中断线程运行。那么问题是，既然不能直接中断线程，我要中断标志有何用处？<br>这里其实Java将这种权力交给了我们的程序，Java给我们提供了一个中断标志位，我们的程序可以通过if判断中断标志位是否被设置来中断我们的程序而不是系统强制的中断。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void run()&#123;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        if (Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">            System.out.println(&quot;exit MyThread&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程一旦发现自己的中断标志为被设置了，立马跳出死循环。这样的设计好处就在于给了我们程序更大的灵活性。</p>
<h4 id="2-3-BLOCKED"><a href="#2-3-BLOCKED" class="headerlink" title="2.3 BLOCKED"></a>2.3 BLOCKED</h4><p>当线程处于BLOCKED状态说明该线程由于竞争某个对象的锁失败而被挂在了该对象的阻塞队列上了。那么此时发起中断操作不会对该线程产生任何影响，依然只是设置中断标志位。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends Thread&#123;</span><br><span class="line">    public synchronized static void doSomething()&#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            //do something</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们自定义了一个线程类，run方法中主要就做一件事情，调用一个有锁的静态方法，该方法内部是一个死循环（占用该锁让其他线程阻塞）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    Thread thread1 = new MyThread();</span><br><span class="line">    thread1.start();</span><br><span class="line"></span><br><span class="line">    Thread thread2 = new MyThread();</span><br><span class="line">    thread2.start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(1000);</span><br><span class="line">    System.out.println(thread1.getState());</span><br><span class="line">    System.out.println(thread2.getState());</span><br><span class="line"></span><br><span class="line">    thread2.interrupt();</span><br><span class="line">    System.out.println(thread2.isInterrupted());</span><br><span class="line">    System.out.println(thread2.getState());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在我们的主线程中，我们定义了两个线程并按照定义顺序启动他们，显然thread1启动后便占用MyThread类锁，此后thread2在获取锁的时候一定失败，自然被阻塞在阻塞队列上，而我们对thread2进行中断，输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RUNNABLE</span><br><span class="line">BLOCKED</span><br><span class="line">true</span><br><span class="line">BLOCKED</span><br></pre></td></tr></table></figure></p>
<p>从输出结果看来，thread2处于BLOCKED状态，执行中断操作之后，该线程仍然处于BLOCKED状态，但是中断标志位却已被修改。这种状态下的线程和处于RUNNABLE状态下的线程是类似的，给了我们程序更大的灵活性去判断和处理中断。</p>
<h4 id="2-4-WAITING-TIMED-WAITING"><a href="#2-4-WAITING-TIMED-WAITING" class="headerlink" title="2.4 WAITING/TIMED_WAITING"></a>2.4 WAITING/TIMED_WAITING</h4><p>这两种状态本质上是同一种状态，只不过TIMED_WAITING在等待一段时间后会自动释放自己，而WAITING则是无限期等待，需要其他线程调用notify方法释放自己。但是他们都是线程在运行的过程中由于缺少某些条件而被挂起在某个对象的等待队列上。当这些线程遇到中断操作的时候，会抛出一个InterruptedException异常，并清空中断标志位。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends Thread&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        synchronized (this)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(&quot;i am waiting but facing interruptexception now&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们定义了一个线程类，其中run方法让当前线程阻塞到条件队列上，并且针对InterruptedException 进行捕获，如果遇到InterruptedException 异常则输出一行信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    Thread thread = new MyThread();</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(500);</span><br><span class="line">    System.out.println(thread.getState());</span><br><span class="line">    thread.interrupt();</span><br><span class="line">    Thread.sleep(1000);</span><br><span class="line">    System.out.println(thread.isInterrupted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在main线程中我们启动一个MyThread线程，然后对其进行中断操作。运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WAITING</span><br><span class="line">i am waiting but facing interruptexception now</span><br><span class="line">false</span><br></pre></td></tr></table></figure></p>
<p>从运行结果看，当前程thread启动之后就被挂起到该线程对象的条件队列上，然后我们调用interrupt方法对该线程进行中断，输出了我们在catch中的输出语句，显然是捕获了InterruptedException异常，接着就看到该线程的中断标志位被清空。</p>
<p>综上所述，我们分别介绍了不同种线程的不同状态下对于中断请求的反应。NEW和TERMINATED对于中断操作几乎是屏蔽的，RUNNABLE和BLOCKED类似，对于中断操作只是设置中断标志位并没有强制终止线程，对于线程的终止权利依然在程序手中。WAITING/TIMED_WAITING状态下的线程对于中断操作是敏感的，他们会抛出异常并清空中断标志位。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/20/并发编程-线程中断/" data-id="cjw02os6k0014l2i72ytyno9d" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发编程/">并发编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-源码分析-SimpleDateFormat的用法以及线程安全" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/21/源码分析-SimpleDateFormat的用法以及线程安全/" class="article-date">
  <time datetime="2017-12-21T01:02:32.000Z" itemprop="datePublished">2017-12-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/21/源码分析-SimpleDateFormat的用法以及线程安全/">源码分析-SimpleDateFormat的用法以及线程安全</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>开发中我们经常会用到时间相关类，我们有很多办法在Java代码中获取时间。但是不同的方法获取到的时间的格式都不尽相同，这时候就需要一种格式化工具，把时间显示成我们需要的格式。最常用的方法就是使用SimpleDateFormat类。这是一个看上去功能比较简单的类，但是，一旦使用不当也有可能导致很大的问题。</p>
<p>在阿里巴巴Java开发手册中，有如下明确规定：<br><img src="http://wx2.sinaimg.cn/mw690/87c9e458gy1g2df391sgsj20u002qmy9.jpg" alt="image"><br>本文就围绕SimpleDateFormat的用法、原理等来深入分析下如何以正确使用它。</p>
<h3 id="1-SimpleDateFormat用法"><a href="#1-SimpleDateFormat用法" class="headerlink" title="1. SimpleDateFormat用法"></a>1. SimpleDateFormat用法</h3><h4 id="1-1-基本用法"><a href="#1-1-基本用法" class="headerlink" title="1.1 基本用法"></a>1.1 基本用法</h4><p>SimpleDateFormat是java提供的能对时间格式化及解析的工具类。  </p>
<ul>
<li><p>格式化：将规范日期格式化成日期文本（时间字符串）  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">String dateStr = sdf.format(new Date());</span><br></pre></td></tr></table></figure>
</li>
<li><p>解析： 将文本日期解析成规范化的时间格式  </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date d = sdf.parse(dataStr);</span><br></pre></td></tr></table></figure>
<p>用户可以自定义文本日期的格式，通过字母来描述时间元素，并组装成想要的日期和时间格式。常用的时间元素和字母的对应表如下：<br><img src="http://wx4.sinaimg.cn/mw690/87c9e458gy1g2dfj3v4y8j20u00le7ci.jpg" alt="模板定义"><br>模式字母通常是重复的，其数量确定其精确表示。如下表是常用的输出格式的表示方法。<br><img src="http://wx4.sinaimg.cn/mw690/87c9e458gy1g2dfklzoizj20tq0bgwko.jpg" alt="image">  </p>
<h4 id="1-2-时区"><a href="#1-2-时区" class="headerlink" title="1.2 时区"></a>1.2 时区</h4><p>如何在Java代码中获取不同时区的时间呢？SimpleDateFormat可以实现这个功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        System.out.println(sdf.format(Calendar.getInstance().getTime()));</span><br><span class="line">        sdf.setTimeZone(TimeZone.getTimeZone(&quot;America/Los_Angeles&quot;));</span><br><span class="line">        System.out.println(sdf.format(Calendar.getInstance().getTime()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码，输出的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-04-24 09:26:38</span><br><span class="line">2019-04-23 18:26:38</span><br></pre></td></tr></table></figure>
<p>中国的时间第一行，而美国洛杉矶时间比中国北京时间慢了17个小时（这还和冬夏令时有关系）。<br>当然，这不是显示其他时区的唯一方法</p>
<h3 id="2-SimpleDateFormat线程安全性"><a href="#2-SimpleDateFormat线程安全性" class="headerlink" title="2. SimpleDateFormat线程安全性"></a>2. SimpleDateFormat线程安全性</h3><p>由于SimpleDateFormat比较常用，而且在一般情况下，一个应用中的时间显示模式都是一样的，所以很多人愿意使用如下方式定义SimpleDateFormat：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">   private static SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">        sdf.setTimeZone(TimeZone.getTimeZone(&quot;America/New_York&quot;));</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种定义方式，存在很大的线程安全隐患。  </p>
<h4 id="2-1-问题重现"><a href="#2-1-问题重现" class="headerlink" title="2.1 问题重现"></a>2.1 问题重现</h4><p>以下代码使用线程池来执行时间输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 定义一个全局的SimpleDateFormat</span><br><span class="line">    */</span><br><span class="line">   private static SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 使用ThreadFactoryBuilder定义一个线程池</span><br><span class="line">    */</span><br><span class="line">   private static ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()</span><br><span class="line">       .setNameFormat(&quot;demo-pool-%d&quot;).build();</span><br><span class="line"></span><br><span class="line">   private static ExecutorService pool = new ThreadPoolExecutor(5, 200,</span><br><span class="line">       0L, TimeUnit.MILLISECONDS,</span><br><span class="line">       new LinkedBlockingQueue&lt;Runnable&gt;(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 定义一个CountDownLatch，保证所有子线程执行完之后主线程再执行</span><br><span class="line">    */</span><br><span class="line">   private static CountDownLatch countDownLatch = new CountDownLatch(100);</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       //定义一个线程安全的HashSet</span><br><span class="line">       Set&lt;String&gt; dates = Collections.synchronizedSet(new HashSet&lt;String&gt;());</span><br><span class="line">       for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">           //获取当前时间</span><br><span class="line">           Calendar calendar = Calendar.getInstance();</span><br><span class="line">           int finalI = i;</span><br><span class="line">           pool.execute(() -&gt; &#123;</span><br><span class="line">                   //时间增加</span><br><span class="line">                   calendar.add(Calendar.DATE, finalI);</span><br><span class="line">                   //通过simpleDateFormat把时间转换成字符串</span><br><span class="line">                   String dateString = sdf.format(calendar.getTime());</span><br><span class="line">                   //把字符串放入Set中</span><br><span class="line">                   dates.add(dateString);</span><br><span class="line">                   //countDown</span><br><span class="line">                   countDownLatch.countDown();</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">       //阻塞，直到countDown数量为0</span><br><span class="line">       countDownLatch.await();</span><br><span class="line">       //输出去重后的时间个数</span><br><span class="line">       System.out.println(dates.size());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码，其实比较容易理解。就是循环一百次，每次循环的时候都在当前时间基础上增加一个天数（这个天数随着循环次数而变化），然后把所有日期放入一个线程安全的、带有去重功能的Set中，然后输出Set中元素个数。 </p>
<p>正常情况下，以上代码输出结果应该是100。但是实际执行结果是一个小于100的数字。</p>
<p>原因就是因为SimpleDateFormat作为一个非线程安全的类，被当做了共享变量在多个线程中进行使用，这就出现了线程安全问题。</p>
<h4 id="2-2-线程不安全原因"><a href="#2-2-线程不安全原因" class="headerlink" title="2.2 线程不安全原因"></a>2.2 线程不安全原因</h4><p>其实，JDK文档中已经明确表明了SimpleDateFormat不应该用在多线程场景中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Date formats are not synchronized.</span><br><span class="line">It is recommended to create separate format instances for each thread.</span><br><span class="line">If multiple threads access a format concurrently, it must be synchronized externally.</span><br></pre></td></tr></table></figure></p>
<p>那么为什么会出现这种问题，SimpleDateFormat底层到底是怎么实现的？<br>跟踪一下SimpleDateFormat类中format方法的实现其实就能发现端倪。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public StringBuffer format(Date date, StringBuffer toAppendTo,</span><br><span class="line">                               FieldPosition pos)</span><br><span class="line">    &#123;</span><br><span class="line">        pos.beginIndex = pos.endIndex = 0;</span><br><span class="line">        return format(date, toAppendTo, pos.getFieldDelegate());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Called from Format after creating a FieldDelegate</span><br><span class="line">    private StringBuffer format(Date date, StringBuffer toAppendTo,</span><br><span class="line">                                FieldDelegate delegate) &#123;</span><br><span class="line">        // Convert input date to time field list</span><br><span class="line">        calendar.setTime(date);</span><br><span class="line"></span><br><span class="line">        boolean useDateFormatSymbols = useDateFormatSymbols();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; compiledPattern.length; ) &#123;</span><br><span class="line">            int tag = compiledPattern[i] &gt;&gt;&gt; 8;</span><br><span class="line">            int count = compiledPattern[i++] &amp; 0xff;</span><br><span class="line">            if (count == 255) &#123;</span><br><span class="line">                count = compiledPattern[i++] &lt;&lt; 16;</span><br><span class="line">                count |= compiledPattern[i++];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            switch (tag) &#123;</span><br><span class="line">            case TAG_QUOTE_ASCII_CHAR:</span><br><span class="line">                toAppendTo.append((char)count);</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case TAG_QUOTE_CHARS:</span><br><span class="line">                toAppendTo.append(compiledPattern, i, count);</span><br><span class="line">                i += count;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            default:</span><br><span class="line">                subFormat(tag, count, delegate, toAppendTo, useDateFormatSymbols);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return toAppendTo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>SimpleDateFormat中的format方法在执行过程中，会使用一个成员变量calendar来保存时间。这其实就是问题的关键。</p>
<p>由于我们在声明SimpleDateFormat的时候，使用的是static定义的。那么这个SimpleDateFormat就是一个共享变量，随之，SimpleDateFormat中的calendar也就可以被多个线程访问到。</p>
<p>假设线程1刚刚执行完calendar.setTime把时间设置成2018-11-11，还没等执行完，线程2又执行了calendar.setTime把时间改成了2018-12-12。这时候线程1继续往下执行，拿到的calendar.getTime得到的时间就是线程2改过之后的。</p>
<p>除了format方法以外，SimpleDateFormat的parse方法也有同样的问题。</p>
<h3 id="3-如何解决"><a href="#3-如何解决" class="headerlink" title="3. 如何解决"></a>3. 如何解决</h3><p>解决方法有很多，先介绍三个比较常用的方法。</p>
<h4 id="3-1-使用局部变量"><a href="#3-1-使用局部变量" class="headerlink" title="3.1 使用局部变量"></a>3.1 使用局部变量</h4><p>SimpleDateFormat变成了局部变量，就不会被多个线程同时访问到了，就避免了线程安全问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">   //获取当前时间</span><br><span class="line">   Calendar calendar = Calendar.getInstance();</span><br><span class="line">   int finalI = i;</span><br><span class="line">   pool.execute(() -&gt; &#123;</span><br><span class="line">       // SimpleDateFormat声明成局部变量</span><br><span class="line">   SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">       //时间增加</span><br><span class="line">       calendar.add(Calendar.DATE, finalI);</span><br><span class="line">       //通过simpleDateFormat把时间转换成字符串</span><br><span class="line">       String dateString = simpleDateFormat.format(calendar.getTime());</span><br><span class="line">       //把字符串放入Set中</span><br><span class="line">       dates.add(dateString);</span><br><span class="line">       //countDown</span><br><span class="line">       countDownLatch.countDown();</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-2-加同步锁"><a href="#3-2-加同步锁" class="headerlink" title="3.2 加同步锁"></a>3.2 加同步锁</h4><p>除了改成局部变量以外，还有一种方法大家可能比较熟悉的，就是对于共享变量进行加锁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">   //获取当前时间</span><br><span class="line">   Calendar calendar = Calendar.getInstance();</span><br><span class="line">   int finalI = i;</span><br><span class="line">   pool.execute(() -&gt; &#123;</span><br><span class="line">       //时间增加</span><br><span class="line">        calendar.add(Calendar.DATE, finalI);</span><br><span class="line">       //通过simpleDateFormat把时间转换成字符串</span><br><span class="line">       //加锁</span><br><span class="line">        synchronized (simpleDateFormat) &#123;</span><br><span class="line">            String dateString = simpleDateFormat.format(calendar.getTime());</span><br><span class="line">        &#125;</span><br><span class="line">       //把字符串放入Set中</span><br><span class="line">        dates.add(dateString);</span><br><span class="line">       //countDown</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    </span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过加锁，使多个线程排队顺序执行。避免了并发导致的线程安全问题。</p>
<h4 id="3-3-使用ThreadLocal"><a href="#3-3-使用ThreadLocal" class="headerlink" title="3.3 使用ThreadLocal"></a>3.3 使用ThreadLocal</h4><p>第三种方式，就是使用 ThreadLocal。 ThreadLocal 可以确保每个线程都可以得到单独的一个 SimpleDateFormat 的对象，那么自然也就不存在竞争问题了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 使用ThreadLocal定义一个全局的SimpleDateFormat</span><br><span class="line">*/</span><br><span class="line">private static ThreadLocal&lt;SimpleDateFormat&gt; simpleDateFormatThreadLocal = new ThreadLocal&lt;SimpleDateFormat&gt;() &#123;</span><br><span class="line">   @Override</span><br><span class="line">   protected SimpleDateFormat initialValue() &#123;</span><br><span class="line">       return new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//用法</span><br><span class="line">String dateString = simpleDateFormatThreadLocal.get().format(calendar.getTime());</span><br></pre></td></tr></table></figure></p>
<p>当然，以上代码也有改进空间，就是，其实SimpleDateFormat的创建过程可以改为延迟加载。这里就不详细介绍了。</p>
<h3 id="4-使用DateTimeFormatter"><a href="#4-使用DateTimeFormatter" class="headerlink" title="4. 使用DateTimeFormatter"></a>4. 使用DateTimeFormatter</h3><p>如果是Java8应用，可以使用DateTimeFormatter代替SimpleDateFormat，这是一个线程安全的格式化工具类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//解析日期</span><br><span class="line">String dateStr= &quot;2016年10月25日&quot;;</span><br><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日&quot;);</span><br><span class="line">LocalDate date= LocalDate.parse(dateStr, formatter);</span><br><span class="line"></span><br><span class="line">//日期转换为字符串</span><br><span class="line">LocalDateTime now = LocalDateTime.now();</span><br><span class="line">DateTimeFormatter format = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日 hh:mm a&quot;);</span><br><span class="line">String nowStr = now .format(format);</span><br><span class="line">System.out.println(nowStr);</span><br></pre></td></tr></table></figure></p>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p>本文介绍了SimpleDateFormat的用法，SimpleDateFormat主要可以在String和Date之间做转换，还可以将时间转换成不同时区输出。同时提到在并发场景中SimpleDateFormat是不能保证线程安全的，需要开发者自己来保证其安全性。</p>
<p>主要的几个手段有改为局部变量、使用synchronized加锁、使用Threadlocal为每一个线程单独创建一个和使用Java8中的DateTimeFormatter类代替等。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/21/源码分析-SimpleDateFormat的用法以及线程安全/" data-id="cjw02os6l0016l2i78rrto48i" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码分析/">源码分析</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/java编程/">java编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux命令/">linux命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并发编程/">并发编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码分析/">源码分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/转载/">转载</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/java编程/" style="font-size: 10px;">java编程</a> <a href="/tags/linux命令/" style="font-size: 13.33px;">linux命令</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/并发编程/" style="font-size: 20px;">并发编程</a> <a href="/tags/数据库/" style="font-size: 13.33px;">数据库</a> <a href="/tags/源码分析/" style="font-size: 13.33px;">源码分析</a> <a href="/tags/设计模式/" style="font-size: 16.67px;">设计模式</a> <a href="/tags/转载/" style="font-size: 10px;">转载</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/07/21/源码分析-会用HashMap/">源码分析-会用HashMap</a>
          </li>
        
          <li>
            <a href="/2018/05/15/并发编程-线程池源码详解/">并发编程-线程池源码详解</a>
          </li>
        
          <li>
            <a href="/2018/05/03/并发编程-ThreadLocal原理/">并发编程-ThreadLocal原理</a>
          </li>
        
          <li>
            <a href="/2018/04/27/并发编程-并发工具类/">并发编程-并发工具类</a>
          </li>
        
          <li>
            <a href="/2018/04/25/并发编程-共享式AQS源码详解/">并发编程-共享式AQS源码详解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>